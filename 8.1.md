# 8.1 簡述 Advanced RAG

> **本章重點**：深入了解 Advanced RAG 技術的核心概念，掌握從基礎 RAG 到進階 RAG 的技術演進路線，建立完整的 Advanced RAG 知識體系。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 Advanced RAG 概念**：掌握 Advanced RAG 的核心理念和技術特點
- 🎯 **掌握技術演進路線**：了解從基礎 RAG 到 Advanced RAG 的發展歷程
- 🎯 **識別關鍵技術要素**：認識 Advanced RAG 的核心技術組件
- 🎯 **評估技術選型**：能夠根據業務需求選擇合適的 Advanced RAG 技術
- 🎯 **規劃實施策略**：制定 Advanced RAG 系統的實施計劃

---

## 8.1.1 什麼是 Advanced RAG？

### RAG 技術演進歷程

**RAG 發展的四個階段**：
```
┌─────────────────────────────────────────────────────────────┐
│                    RAG Technology Evolution                 │
├─────────────────────────────────────────────────────────────┤
│  第一代：基礎 RAG (Naive RAG)                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 簡單的向量檢索 + 生成                               │ │
│  │  • 固定的分塊策略                                       │ │
│  │  • 基本的相似度匹配                                     │ │
│  │  • 限制：檢索精度不高、上下文理解有限                   │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  第二代：改進 RAG (Enhanced RAG)                            │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 優化的文本分塊策略                                   │ │
│  │  • 改進的 Embedding 模型                               │ │
│  │  • 基本的重排序機制                                     │ │
│  │  • 改進：提升檢索相關性、減少噪音                       │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  第三代：模組化 RAG (Modular RAG)                           │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 可插拔的檢索模組                                     │ │
│  │  • 多階段檢索流程                                       │ │
│  │  • 自適應檢索策略                                       │ │
│  │  • 特點：靈活性高、可定制化                             │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  第四代：Advanced RAG (智能化 RAG)                          │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 智能查詢理解與重寫                                   │ │
│  │  • 多模態檢索與生成                                     │ │
│  │  • 自我反思與修正機制                                   │ │
│  │  • 知識圖譜增強檢索                                     │ │
│  │  • 優勢：高精度、強適應性、智能化                       │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### Advanced RAG 的核心特徵

#### 1. 智能查詢處理
- **查詢理解**：深度理解用戶意圖和查詢語義
- **查詢重寫**：自動優化查詢表達以提升檢索效果
- **查詢擴展**：基於上下文和知識庫擴展查詢範圍
- **多輪對話**：支持連續對話中的上下文理解

#### 2. 多階段檢索策略
- **粗檢索**：快速篩選大量候選文檔
- **精檢索**：深度分析候選文檔的相關性
- **重排序**：基於多維度指標重新排序結果
- **後處理**：去重、過濾和品質控制

#### 3. 增強的上下文管理
- **動態上下文**：根據查詢動態調整上下文窗口
- **上下文壓縮**：智能壓縮冗餘信息
- **上下文融合**：多來源信息的智能整合
- **上下文驗證**：確保上下文的準確性和相關性

#### 4. 自適應優化機制
- **效果監控**：實時監控檢索和生成效果
- **策略調整**：基於效果反饋自動調整策略
- **學習優化**：從用戶反饋中持續學習改進
- **個性化**：根據用戶偏好定制檢索策略

---

## 8.1.2 Advanced RAG 核心技術組件

### Spring AI 依賴配置

在實現 Advanced RAG 之前，需要添加相關的 Spring AI 依賴：

```xml
<dependencies>
    <!-- Spring AI Core -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Spring AI OpenAI -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Spring AI Vector Store Advisors -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-advisors-vector-store</artifactId>
    </dependency>
    
    <!-- Spring AI Vector Store (選擇合適的實現) -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-pgvector-store-spring-boot-starter</artifactId>
    </dependency>
</dependencies>
```

### 必要的 Import 聲明

```java
// Spring AI 核心類
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.client.advisor.Advisor;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.ai.document.Document;
import org.springframework.ai.retrieval.search.DocumentRetriever;
import org.springframework.ai.retrieval.search.VectorStoreDocumentRetriever;
import org.springframework.ai.vectorstore.VectorStore;

// RAG 相關類
import org.springframework.ai.chat.client.advisor.retrieval.RetrievalAugmentationAdvisor;
import org.springframework.ai.chat.client.advisor.retrieval.ContextualQueryAugmenter;
import org.springframework.ai.retrieval.search.DocumentJoiner;
import org.springframework.ai.retrieval.search.ConcatenationDocumentJoiner;

// 查詢處理相關類
import org.springframework.ai.retrieval.query.Query;
import org.springframework.ai.retrieval.query.QueryTransformer;
import org.springframework.ai.retrieval.query.RewriteQueryTransformer;
import org.springframework.ai.retrieval.query.CompressionQueryTransformer;
import org.springframework.ai.retrieval.query.TranslationQueryTransformer;
import org.springframework.ai.retrieval.query.QueryExpander;
import org.springframework.ai.retrieval.query.MultiQueryExpander;

// Prompt 相關類
import org.springframework.ai.chat.prompt.PromptTemplate;
import org.springframework.ai.openai.OpenAiChatOptions;
```

### Spring AI Advanced RAG 架構

**基於 Spring AI 模組化架構**：
```java
/**
 * Advanced RAG 系統架構 - 基於 Spring AI RetrievalAugmentationAdvisor
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AdvancedRAGService {
    
    private final ChatClient chatClient;
    private final VectorStore vectorStore;
    private final ChatModel chatModel;
    
    /**
     * 配置 Advanced RAG ChatClient
     */
    @Bean
    public ChatClient advancedRAGChatClient(ChatModel chatModel, VectorStore vectorStore) {
        
        // 1. 配置查詢轉換器 - 查詢重寫和擴展
        QueryTransformer queryRewriter = RewriteQueryTransformer.builder()
            .chatClientBuilder(ChatClient.builder(chatModel))
            .build();
        
        QueryExpander queryExpander = MultiQueryExpander.builder()
            .chatClientBuilder(ChatClient.builder(chatModel))
            .numberOfQueries(3)
            .includeOriginal(true)
            .build();
        
        // 2. 配置文檔檢索器 - 多階段檢索
        DocumentRetriever documentRetriever = VectorStoreDocumentRetriever.builder()
            .vectorStore(vectorStore)
            .similarityThreshold(0.75)
            .topK(10)
            .build();
        
        // 3. 配置查詢增強器 - 上下文優化
        QueryAugmenter queryAugmenter = ContextualQueryAugmenter.builder()
            .allowEmptyContext(false)
            .build();
        
        // 4. 構建 Advanced RAG Advisor
        Advisor retrievalAugmentationAdvisor = RetrievalAugmentationAdvisor.builder()
            .queryTransformers(queryRewriter)
            .queryExpanders(queryExpander)
            .documentRetriever(documentRetriever)
            .queryAugmenter(queryAugmenter)
            .build();
        
        // 5. 配置 ChatClient
        return ChatClient.builder(chatModel)
            .defaultAdvisors(retrievalAugmentationAdvisor)
            .defaultOptions(OpenAiChatOptions.builder()
                .model("gpt-4")
                .temperature(0.3)
                .build())
            .build();
    }
    
    /**
     * Advanced RAG 查詢處理
     */
    public AdvancedRAGResponse processQuery(String query, Map<String, Object> context) {
        long startTime = System.currentTimeMillis();
        
        try {
            // 使用 Advanced RAG ChatClient 處理查詢
            String response = chatClient.prompt()
                .user(query)
                .advisors(advisor -> {
                    // 動態設置過濾條件
                    if (context.containsKey("filter")) {
                        advisor.param(VectorStoreDocumentRetriever.FILTER_EXPRESSION, 
                                     context.get("filter").toString());
                    }
                })
                .call()
                .content();
            
            long processingTime = System.currentTimeMillis() - startTime;
            
            return AdvancedRAGResponse.builder()
                .answer(response)
                .query(query)
                .processingTime(processingTime)
                .success(true)
                .build();
                
        } catch (Exception e) {
            log.error("Advanced RAG processing failed for query: {}", query, e);
            return AdvancedRAGResponse.builder()
                .query(query)
                .error(e.getMessage())
                .success(false)
                .processingTime(System.currentTimeMillis() - startTime)
                .build();
        }
    }
}
```

### Spring AI 查詢處理組件實現

**基於 Spring AI 官方 QueryTransformer**：
```java
/**
 * 自定義查詢重寫轉換器
 * 基於 Spring AI RewriteQueryTransformer
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class AdvancedQueryRewriter {
    
    private final ChatClient.Builder chatClientBuilder;
    
    /**
     * 創建查詢重寫轉換器
     */
    public QueryTransformer createRewriteTransformer() {
        return RewriteQueryTransformer.builder()
            .chatClientBuilder(chatClientBuilder)
            .promptTemplate(createCustomRewritePrompt())
            .build();
    }
    
    /**
     * 自定義重寫提示模板
     */
    private PromptTemplate createCustomRewritePrompt() {
        return PromptTemplate.builder()
            .template("""
                你是一個查詢優化專家。請將用戶查詢重寫為更適合向量檢索的形式。
                
                重寫規則：
                1. 保留關鍵信息和意圖
                2. 使用更精確的術語
                3. 移除冗餘詞語
                4. 增加相關關鍵詞
                
                原始查詢：{query}
                
                請提供重寫後的查詢：
                """)
            .build();
    }
    
    /**
     * 創建壓縮查詢轉換器
     * 用於處理多輪對話上下文
     */
    public QueryTransformer createCompressionTransformer() {
        return CompressionQueryTransformer.builder()
            .chatClientBuilder(chatClientBuilder)
            .promptTemplate(createCustomCompressionPrompt())
            .build();
    }
    
    /**
     * 自定義壓縮提示模板
     */
    private PromptTemplate createCustomCompressionPrompt() {
        return PromptTemplate.builder()
            .template("""
                基於以下對話歷史，將用戶的後續問題重寫為一個獨立的問題。
                
                對話歷史：
                {history}
                
                後續問題：{query}
                
                請將後續問題重寫為包含必要上下文的獨立問題：
                """)
            .build();
    }
}

/**
 * 多查詢擴展服務
 * 基於 Spring AI MultiQueryExpander
 */
@Component 
@RequiredArgsConstructor
@Slf4j
public class AdvancedQueryExpander {
    
    private final ChatClient.Builder chatClientBuilder;
    
    /**
     * 創建多查詢擴展器
     */
    public QueryExpander createMultiQueryExpander(int numberOfQueries) {
        return MultiQueryExpander.builder()
            .chatClientBuilder(chatClientBuilder)
            .numberOfQueries(numberOfQueries)
            .includeOriginal(true)
            .promptTemplate(createCustomExpansionPrompt())
            .build();
    }
    
    /**
     * 自定義查詢擴展提示模板
     */
    private PromptTemplate createCustomExpansionPrompt() {
        return PromptTemplate.builder()
            .template("""
                請基於以下查詢生成 {numberOfQueries} 個語義相似但表達不同的查詢變體。
                這些變體應該：
                1. 保持相同的查詢意圖
                2. 使用不同的詞彙和表達方式
                3. 從不同角度描述同一個問題
                4. 有助於檢索更全面的相關文檔
                
                原始查詢：{query}
                
                請提供查詢變體：
                """)
            .build();
    }
    
    /**
     * 創建語言翻譯轉換器
     * 用於多語言查詢處理
     */
    public QueryTransformer createTranslationTransformer(String targetLanguage) {
        return TranslationQueryTransformer.builder()
            .chatClientBuilder(chatClientBuilder)
            .targetLanguage(targetLanguage)
            .promptTemplate(createCustomTranslationPrompt())
            .build();
    }
    
    /**
     * 自定義翻譯提示模板
     */
    private PromptTemplate createCustomTranslationPrompt() {
        return PromptTemplate.builder()
            .template("""
                請將以下查詢翻譯為 {targetLanguage}。
                保持查詢的語義和意圖不變。
                如果查詢已經是目標語言，請直接返回原查詢。
                
                查詢：{query}
                
                翻譯結果：
                """)
            .build();
    }
}
```

### Spring AI 多階段檢索實現

**基於 Spring AI DocumentRetriever 和 DocumentJoiner**：
```java
/**
 * Advanced RAG 多階段檢索服務
 * 基於 Spring AI 官方組件
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class MultiStageRetrievalService {
    
    private final VectorStore vectorStore;
    private final ChatClient.Builder chatClientBuilder;
    
    /**
     * 創建多階段檢索配置
     */
    public MultiStageRetrievalConfig createMultiStageConfig() {
        
        // 1. 主要文檔檢索器 - 較低閾值獲取更多候選
        DocumentRetriever primaryRetriever = VectorStoreDocumentRetriever.builder()
            .vectorStore(vectorStore)
            .similarityThreshold(0.6)  // 較低閾值
            .topK(20)                  // 更多候選
            .build();
        
        // 2. 精確文檔檢索器 - 較高閾值獲取精確匹配
        DocumentRetriever precisionRetriever = VectorStoreDocumentRetriever.builder()
            .vectorStore(vectorStore)
            .similarityThreshold(0.8)  // 較高閾值
            .topK(10)                  // 較少精確結果
            .build();
        
        // 3. 文檔連接器 - 合併多個檢索結果
        DocumentJoiner documentJoiner = new ConcatenationDocumentJoiner();
        
        return new MultiStageRetrievalConfig(primaryRetriever, precisionRetriever, documentJoiner);
    }
    
    /**
     * 執行多階段檢索
     */
    public List<Document> performMultiStageRetrieval(String queryText, Map<String, Object> filters) {
        
        // 1. 創建查詢對象
        Query.Builder queryBuilder = Query.builder().text(queryText);
        
        // 2. 添加過濾條件
        if (filters != null && !filters.isEmpty()) {
            queryBuilder.context(filters);
        }
        
        Query query = queryBuilder.build();
        
        // 3. 多階段檢索配置
        MultiStageRetrievalConfig config = createMultiStageConfig();
        
        // 4. 第一階段：廣泛檢索
        List<Document> primaryResults = config.getPrimaryRetriever().retrieve(query);
        log.debug("Primary retrieval returned {} documents", primaryResults.size());
        
        // 5. 第二階段：精確檢索
        List<Document> precisionResults = config.getPrecisionRetriever().retrieve(query);
        log.debug("Precision retrieval returned {} documents", precisionResults.size());
        
        // 6. 合併結果
        Map<Query, List<List<Document>>> documentsForQuery = Map.of(
            query, Arrays.asList(primaryResults, precisionResults)
        );
        
        List<Document> finalResults = config.getDocumentJoiner().join(documentsForQuery);
        log.debug("Final merged results: {} documents", finalResults.size());
        
        return finalResults;
    }
    
    /**
     * 帶查詢擴展的多階段檢索
     */
    public List<Document> performExpandedMultiStageRetrieval(String queryText, int numberOfExpansions) {
        
        // 1. 創建查詢擴展器
        QueryExpander queryExpander = MultiQueryExpander.builder()
            .chatClientBuilder(chatClientBuilder)
            .numberOfQueries(numberOfExpansions)
            .includeOriginal(true)
            .build();
        
        // 2. 擴展查詢
        List<Query> expandedQueries = queryExpander.expand(new Query(queryText));
        log.debug("Expanded to {} queries", expandedQueries.size());
        
        // 3. 為每個擴展查詢執行檢索
        List<List<Document>> allResults = new ArrayList<>();
        DocumentRetriever retriever = VectorStoreDocumentRetriever.builder()
            .vectorStore(vectorStore)
            .similarityThreshold(0.7)
            .topK(15)
            .build();
        
        for (Query query : expandedQueries) {
            List<Document> results = retriever.retrieve(query);
            allResults.add(results);
        }
        
        // 4. 合併所有結果
        Map<Query, List<List<Document>>> documentsForQuery = new HashMap<>();
        for (int i = 0; i < expandedQueries.size(); i++) {
            documentsForQuery.put(expandedQueries.get(i), Arrays.asList(allResults.get(i)));
        }
        
        DocumentJoiner documentJoiner = new ConcatenationDocumentJoiner();
        List<Document> finalResults = documentJoiner.join(documentsForQuery);
        
        log.debug("Expanded retrieval returned {} unique documents", finalResults.size());
        
        return finalResults;
    }
}

/**
 * 多階段檢索配置類
 */
@Data
@AllArgsConstructor
public class MultiStageRetrievalConfig {
    private final DocumentRetriever primaryRetriever;
    private final DocumentRetriever precisionRetriever;
    private final DocumentJoiner documentJoiner;
}

/**
 * Advanced RAG 回應數據類
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AdvancedRAGResponse {
    private String query;
    private String answer;
    private boolean success;
    private String error;
    private long processingTime;
    private List<String> sources;
    private Map<String, Object> metadata;
}
```

---

## 8.1.3 Advanced RAG 技術對比

### 技術特性比較

| 技術特性 | 基礎 RAG | Enhanced RAG | Modular RAG | Advanced RAG |
|----------|----------|--------------|-------------|---------------|
| **檢索策略** | 單一向量檢索 | 優化向量檢索 | 多模組檢索 | 智能多階段檢索 |
| **查詢處理** | 直接檢索 | 基本預處理 | 模組化處理 | 智能理解重寫 |
| **上下文管理** | 固定窗口 | 動態窗口 | 靈活管理 | 智能優化 |
| **結果品質** | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **實現複雜度** | 低 | 中 | 高 | 很高 |
| **維護成本** | 低 | 中 | 中高 | 高 |
| **適用場景** | 簡單問答 | 一般應用 | 複雜應用 | 企業級應用 |

### 性能指標對比

| 性能指標 | 基礎 RAG | Enhanced RAG | Modular RAG | Advanced RAG |
|----------|----------|--------------|-------------|---------------|
| **準確率** | 60-70% | 70-80% | 80-85% | 85-95% |
| **召回率** | 50-60% | 60-70% | 70-80% | 80-90% |
| **回應時間** | < 1s | < 2s | < 3s | < 5s |
| **資源消耗** | 低 | 中 | 中高 | 高 |
| **擴展性** | 有限 | 中等 | 良好 | 優秀 |

---

## 8.1.4 Advanced RAG 應用場景

### 企業知識管理
- **技術文檔查詢**：智能理解技術問題並提供精確答案
- **政策法規諮詢**：複雜法規條文的智能解讀
- **業務流程指導**：基於上下文的流程指導
- **專家知識傳承**：專業知識的智能化傳承

### 客戶服務系統
- **智能客服**：理解客戶意圖並提供個性化服務
- **問題診斷**：基於症狀描述的智能問題診斷
- **解決方案推薦**：根據問題特徵推薦最佳解決方案
- **服務品質監控**：實時監控服務品質並優化

### 教育培訓平台
- **個性化學習**：根據學習者水平提供適合的內容
- **智能答疑**：理解學習問題並提供詳細解答
- **知識關聯**：建立知識點之間的關聯關係
- **學習路徑規劃**：智能規劃個性化學習路徑

### 研究與開發
- **文獻檢索**：智能檢索相關研究文獻
- **技術調研**：快速了解技術發展趨勢
- **專利分析**：智能分析專利技術要點
- **創新靈感**：基於知識庫激發創新思路

---

## 📝 本章重點回顧

1. **Advanced RAG 概念**：理解了 Advanced RAG 的核心理念和技術特點
2. **技術演進路線**：掌握了從基礎 RAG 到 Advanced RAG 的發展歷程
3. **核心技術組件**：了解了智能查詢處理、多階段檢索等關鍵技術
4. **技術對比分析**：比較了不同 RAG 技術的特性和適用場景
5. **應用場景規劃**：識別了 Advanced RAG 的典型應用場景

### 技術要點總結

| 技術要點 | 重要性 | 實現難度 | 應用價值 |
|----------|--------|----------|----------|
| **智能查詢處理** | ⭐⭐⭐⭐⭐ | 高 | 極高 |
| **多階段檢索** | ⭐⭐⭐⭐ | 高 | 高 |
| **上下文管理** | ⭐⭐⭐⭐ | 中 | 高 |
| **品質控制** | ⭐⭐⭐ | 中 | 中高 |
| **自適應優化** | ⭐⭐⭐ | 高 | 中高 |

### 實施建議

1. **漸進式升級**：從基礎 RAG 逐步升級到 Advanced RAG
2. **重點突破**：優先實現對業務影響最大的技術組件
3. **效果驗證**：建立完整的效果評估體系
4. **持續優化**：基於實際使用效果持續改進
5. **團隊培養**：培養具備 Advanced RAG 技術能力的團隊

### 下一步學習方向

在下一節中，我們將深入學習如何提高 RAG 準確率，包括：
- Embedding 模型選擇與優化
- 文本分塊策略改進
- 檢索策略優化
- 效果評估方法

---

**參考資料：**
- [Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks](https://arxiv.org/abs/2005.11401)
- [Advanced RAG Techniques](https://arxiv.org/abs/2312.10997)
- [Modular RAG: Transforming RAG Systems](https://arxiv.org/abs/2407.21059)
- [Self-RAG: Learning to Critique and Correct](https://arxiv.org/abs/2310.11511)
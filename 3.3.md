# 3.3 API 測試與文件化

> **本章重點**：掌握 API 測試工具和文件自動生成技術，建立完整的 API 品質保證體系，為生產級應用和 Spring AI 服務提供可靠的測試和文件化支援。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 API 測試的重要性**：掌握 API 測試在開發流程中的核心價值
- 🎯 **熟練使用測試工具**：掌握 Postman、curl 等 API 測試工具的使用
- 🎯 **實現 API 文件自動生成**：使用 Swagger/OpenAPI 建立完整的 API 文件
- 🎯 **建立測試最佳實踐**：設計有效的 API 測試策略和流程
- 🎯 **為 AI 服務做準備**：建立適合 AI 應用的測試和文件化方案

---

## 3.3.1 為什麼需要 API 測試？

### API 測試的核心價值

在現代 Web 開發中，API 是前後端溝通的橋樑，也是 AI 服務的重要介面。想像一下，如果您正在開發一個 AI 驅動的應用程式：

> **實際場景**：當用戶上傳圖片要求 AI 分析時，前端需要向後端 API 發送請求，AI 服務處理後回傳結果。如果這個 API 有問題，整個 AI 功能就無法正常運作。

**API 測試的核心價值**：
- ✅ **驗證功能正確性**：確保 API 按預期工作
- ✅ **提早發現問題**：在用戶使用前就發現並修復錯誤
- ✅ **提升開發效率**：快速測試不同情境，無需每次都透過前端介面
- ✅ **改善團隊協作**：前後端開發者可以用統一的方式驗證 API
- ✅ **支援 AI 服務測試**：驗證複雜的 AI 推理和多模態處理

### 不同類型的 API 測試

| 測試類型 | 目的 | 測試範圍 | 適用場景 |
|----------|------|----------|----------|
| **功能測試** | 驗證 API 功能正確性 | 單一 API 端點 | 基本 CRUD 操作 |
| **整合測試** | 驗證系統間協作 | 多個 API 端點 | 業務流程測試 |
| **效能測試** | 驗證回應時間和吞吐量 | 系統負載能力 | 高併發場景 |
| **安全測試** | 驗證安全機制 | 認證授權機制 | 敏感資料保護 |
| **AI 服務測試** | 驗證 AI 模型回應 | AI 推理準確性 | 智能功能驗證 |

---

## 3.3.2 使用 Postman 進行 API 測試

### Postman 基礎操作

**安裝和設定**：
1. 下載並安裝 Postman
2. 建立工作區（Workspace）
3. 建立集合（Collection）來組織 API 測試

**基本 HTTP 請求測試**：

```http
### 1. 獲取使用者列表
GET http://localhost:8080/api/users
Content-Type: application/json

### 2. 根據 ID 獲取使用者
GET http://localhost:8080/api/users/1
Content-Type: application/json

### 3. 建立新使用者
POST http://localhost:8080/api/users
Content-Type: application/json

{
  "name": "張小明",
  "email": "ming@example.com",
  "password": "securePassword123"
}

### 4. 更新使用者資訊
PUT http://localhost:8080/api/users/1
Content-Type: application/json

{
  "name": "張小明（已更新）",
  "email": "ming.updated@example.com"
}

### 5. 刪除使用者
DELETE http://localhost:8080/api/users/1
```

### 進階測試功能

**1. 環境變數設定**
```javascript
// 在 Postman 的 Pre-request Script 中設定
pm.environment.set("baseUrl", "http://localhost:8080");
pm.environment.set("userId", "1");

// 在請求 URL 中使用
{{baseUrl}}/api/users/{{userId}}
```

**2. 自動化測試腳本**
```javascript
// 在 Postman 的 Tests 標籤中編寫
pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

pm.test("Response has user data", function () {
    const jsonData = pm.response.json();
    pm.expect(jsonData).to.have.property('data');
    pm.expect(jsonData.data).to.have.property('id');
    pm.expect(jsonData.data).to.have.property('name');
});

pm.test("Response time is less than 500ms", function () {
    pm.expect(pm.response.responseTime).to.be.below(500);
});
```

**3. 資料驅動測試**
```csv
# users.csv
name,email,expectedStatus
張小明,ming@example.com,201
李小華,hua@example.com,201
王小美,invalid-email,400
```

---

## 3.3.3 使用 curl 進行命令列測試

### 基本 curl 命令

```bash
# GET 請求
curl -X GET "http://localhost:8080/api/users" \
     -H "Content-Type: application/json"

# POST 請求
curl -X POST "http://localhost:8080/api/users" \
     -H "Content-Type: application/json" \
     -d '{
       "name": "測試使用者",
       "email": "test@example.com",
       "password": "password123"
     }'

# PUT 請求
curl -X PUT "http://localhost:8080/api/users/1" \
     -H "Content-Type: application/json" \
     -d '{
       "name": "更新的使用者",
       "email": "updated@example.com"
     }'

# DELETE 請求
curl -X DELETE "http://localhost:8080/api/users/1" \
     -H "Content-Type: application/json"
```

### 進階 curl 功能

```bash
# 顯示詳細資訊
curl -v -X GET "http://localhost:8080/api/users"

# 儲存回應到檔案
curl -X GET "http://localhost:8080/api/users" -o users.json

# 包含認證標頭
curl -X GET "http://localhost:8080/api/users" \
     -H "Authorization: Bearer your-jwt-token"

# 上傳檔案
curl -X POST "http://localhost:8080/api/upload" \
     -F "file=@/path/to/your/file.jpg" \
     -F "description=測試圖片"

# 測試效能（顯示時間資訊）
curl -w "@curl-format.txt" -X GET "http://localhost:8080/api/users"
```

**curl-format.txt 內容**：
```
     time_namelookup:  %{time_namelookup}\n
        time_connect:  %{time_connect}\n
     time_appconnect:  %{time_appconnect}\n
    time_pretransfer:  %{time_pretransfer}\n
       time_redirect:  %{time_redirect}\n
  time_starttransfer:  %{time_starttransfer}\n
                     ----------\n
          time_total:  %{time_total}\n
```

---

## 3.3.4 API 文件自動生成

### 為什麼需要 API 文件？

API 文件就像是「使用指南」，對於開發團隊協作和第三方整合至關重要：

**沒有文件的痛點**：
```java
// 沒有文件的 API - 讓人困惑
@GetMapping("/users/{id}")
public ResponseEntity<?> getUser(@PathVariable String id) {
    // 這個 API 做什麼？
    // 參數格式是什麼？
    // 回傳什麼資料？
    // 可能的錯誤碼有哪些？
}
```

### 整合 Swagger/OpenAPI

**1. 添加依賴**
```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.2.0</version>
</dependency>
```

**2. 基本配置**
```java
@Configuration
public class OpenApiConfig {
    
    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("使用者管理系統 API")
                        .version("1.0.0")
                        .description("生產級 API 開發實踐範例")
                        .contact(new Contact()
                                .name("開發團隊")
                                .email("dev@example.com")
                                .url("https://example.com"))
                        .license(new License()
                                .name("MIT License")
                                .url("https://opensource.org/licenses/MIT")))
                .servers(Arrays.asList(
                        new Server().url("http://localhost:8080").description("開發環境"),
                        new Server().url("https://api.example.com").description("生產環境")
                ));
    }
}
```

### 使用 Swagger 註解

```java
@RestController
@RequestMapping("/api/users")
@Tag(name = "使用者管理", description = "使用者相關的 CRUD 操作")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    @Operation(
        summary = "獲取所有使用者",
        description = "獲取系統中所有使用者的列表，支援分頁和排序"
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "成功獲取使用者列表",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = ApiResponse.class)
            )
        ),
        @ApiResponse(
            responseCode = "500",
            description = "伺服器內部錯誤"
        )
    })
    @GetMapping
    public ResponseEntity<ApiResponse<List<User>>> getAllUsers(
            @Parameter(description = "頁碼，從 0 開始", example = "0")
            @RequestParam(defaultValue = "0") int page,
            
            @Parameter(description = "每頁大小", example = "10")
            @RequestParam(defaultValue = "10") int size) {
        
        Pageable pageable = PageRequest.of(page, size);
        Page<User> users = userService.findAll(pageable);
        return ResponseEntity.ok(ApiResponse.success("獲取成功", users.getContent()));
    }
    
    @Operation(
        summary = "根據 ID 獲取使用者",
        description = "根據使用者 ID 獲取特定使用者的詳細資訊"
    )
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<User>> getUserById(
            @Parameter(description = "使用者 ID", required = true, example = "1")
            @PathVariable Long id) {
        
        User user = userService.findById(id);
        return ResponseEntity.ok(ApiResponse.success("獲取成功", user));
    }
    
    @Operation(
        summary = "建立新使用者",
        description = "建立一個新的使用者帳號"
    )
    @PostMapping
    public ResponseEntity<ApiResponse<User>> createUser(
            @Parameter(description = "使用者建立請求", required = true)
            @Valid @RequestBody CreateUserRequest request) {
        
        User user = userService.createUser(request);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success("建立成功", user));
    }
}
```

### 為資料模型添加文件

```java
@Schema(description = "使用者資訊")
public class User {
    
    @Schema(description = "使用者 ID", example = "1", accessMode = Schema.AccessMode.READ_ONLY)
    private Long id;
    
    @Schema(description = "使用者名稱", example = "張小明", requiredMode = Schema.RequiredMode.REQUIRED)
    private String name;
    
    @Schema(description = "電子郵件地址", example = "ming@example.com", requiredMode = Schema.RequiredMode.REQUIRED)
    private String email;
    
    @Schema(description = "建立時間", example = "2024-01-15T10:30:00Z", accessMode = Schema.AccessMode.READ_ONLY)
    private LocalDateTime createdAt;
    
    // Getters and Setters
}

@Schema(description = "建立使用者請求")
public class CreateUserRequest {
    
    @Schema(description = "使用者名稱", example = "張小明", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotBlank(message = "使用者名稱不能為空")
    private String name;
    
    @Schema(description = "電子郵件地址", example = "ming@example.com", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotBlank(message = "電子郵件不能為空")
    @Email(message = "電子郵件格式不正確")
    private String email;
    
    @Schema(description = "密碼", example = "securePassword123", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotBlank(message = "密碼不能為空")
    @Size(min = 8, message = "密碼長度至少 8 字元")
    private String password;
    
    // Getters and Setters
}
```

---

## 3.3.5 為 Spring AI 做準備

### AI 服務的特殊測試需求

**1. 流式回應測試**
```bash
# 測試 AI 流式對話
curl -N -X POST "http://localhost:8080/api/ai/chat/stream" \
     -H "Content-Type: application/json" \
     -H "Accept: text/event-stream" \
     -d '{
       "message": "請介紹一下 Spring Boot",
       "temperature": 0.7
     }'
```

**2. 多媒體內容測試**
```bash
# 測試圖片分析 API
curl -X POST "http://localhost:8080/api/ai/analyze/image" \
     -F "image=@test-image.jpg" \
     -F "prompt=描述這張圖片的內容"

# 測試音訊轉文字 API
curl -X POST "http://localhost:8080/api/ai/transcribe" \
     -F "audio=@test-audio.wav" \
     -F "language=zh-TW"
```

### AI API 文件化範例

```java
@RestController
@RequestMapping("/api/ai")
@Tag(name = "AI 服務", description = "人工智慧相關的 API 服務")
public class AIController {
    
    @Operation(
        summary = "AI 對話服務",
        description = "與 AI 模型進行對話，支援上下文記憶"
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "對話成功",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = ChatResponse.class)
            )
        ),
        @ApiResponse(
            responseCode = "400",
            description = "請求參數錯誤"
        ),
        @ApiResponse(
            responseCode = "429",
            description = "請求頻率過高"
        )
    })
    @PostMapping("/chat")
    public ResponseEntity<ApiResponse<ChatResponse>> chat(
            @Parameter(description = "對話請求", required = true)
            @Valid @RequestBody ChatRequest request) {
        
        // 預留給 Spring AI 整合
        ChatResponse response = new ChatResponse("這是 AI 的回應");
        return ResponseEntity.ok(ApiResponse.success("對話成功", response));
    }
    
    @Operation(
        summary = "流式對話服務",
        description = "與 AI 模型進行流式對話，即時獲取回應"
    )
    @PostMapping(value = "/chat/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter chatStream(
            @Parameter(description = "流式對話請求", required = true)
            @Valid @RequestBody ChatRequest request) {
        
        SseEmitter emitter = new SseEmitter();
        // 預留給 Spring AI 流式處理
        return emitter;
    }
}

@Schema(description = "AI 對話請求")
public class ChatRequest {
    
    @Schema(description = "使用者訊息", example = "請介紹一下 Spring Boot", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotBlank(message = "訊息不能為空")
    private String message;
    
    @Schema(description = "溫度參數，控制回應的隨機性", example = "0.7", minimum = "0", maximum = "2")
    @DecimalMin(value = "0.0", message = "溫度值必須大於等於 0")
    @DecimalMax(value = "2.0", message = "溫度值必須小於等於 2")
    private Double temperature = 0.7;
    
    @Schema(description = "最大 token 數", example = "1000", minimum = "1", maximum = "4096")
    @Min(value = 1, message = "最大 token 數必須大於 0")
    @Max(value = 4096, message = "最大 token 數不能超過 4096")
    private Integer maxTokens = 1000;
    
    // Getters and Setters
}
```

### 效能測試準備

```bash
# 使用 Apache Bench 進行壓力測試
ab -n 1000 -c 10 -H "Content-Type: application/json" \
   -p chat-request.json \
   http://localhost:8080/api/ai/chat

# 使用 wrk 進行更進階的效能測試
wrk -t12 -c400 -d30s --script=chat-test.lua \
    http://localhost:8080/api/ai/chat
```

**chat-test.lua 腳本**：
```lua
wrk.method = "POST"
wrk.body   = '{"message": "測試訊息", "temperature": 0.7}'
wrk.headers["Content-Type"] = "application/json"

function response(status, headers, body)
    if status ~= 200 then
        print("Error: " .. status .. " " .. body)
    end
end
```

---

## 📝 本章重點回顧

1. **API 測試重要性**：理解了 API 測試在開發流程中的核心價值
2. **測試工具使用**：掌握了 Postman 和 curl 的基本和進階功能
3. **API 文件化**：學會了使用 Swagger/OpenAPI 自動生成完整的 API 文件
4. **測試最佳實踐**：建立了有效的 API 測試策略和流程
5. **AI 服務準備**：為 Spring AI 的特殊測試需求做好了準備

### 下一步學習方向

完成第三章的學習後，我們已經建立了完整的生產級 API 開發技能。在第四章中，我們將正式進入 Spring AI 的世界，學習如何整合和使用 AI 服務。

---

**參考資料：**
- [Postman Documentation](https://learning.postman.com/docs/)
- [OpenAPI Specification](https://swagger.io/specification/)
- [SpringDoc OpenAPI](https://springdoc.org/)
- [curl Manual](https://curl.se/docs/manual.html)
# 6.7 使用向量資料庫作為對話的長久記憶

> **本章重點**：整合 Neo4j 向量資料庫與 Spring AI 記憶系統，實現基於語義搜尋的智能長期記憶功能，讓 AI 擁有真正的「長期記憶」能力。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **實現向量記憶系統**：使用 VectorStoreChatMemoryAdvisor 建立語義記憶
- 🎯 **掌握語義搜尋技術**：基於向量相似性的智能記憶檢索
- 🎯 **建立混合記憶架構**：結合短期和長期記憶的完整解決方案
- 🎯 **優化記憶檢索策略**：實現高效的記憶管理和檢索算法
- 🎯 **構建企業級記憶系統**：可擴展的大規模對話記憶解決方案

---

## 6.7.1 向量記憶 vs 傳統記憶

### 傳統記憶的限制

在前面的章節中，我們學習了 MessageChatMemoryAdvisor 和 PromptChatMemoryAdvisor，這些都屬於「短期記憶」：

**短期記憶的特點**：
- 📝 **順序存取**：按照時間順序存儲和檢索對話
- 🔢 **數量限制**：通常只能保存最近的 N 條訊息
- 💾 **記憶體存儲**：重啟後記憶消失
- 🔍 **精確匹配**：無法進行語義相關的搜尋

**短期記憶的問題**：
```
用戶：我昨天問過關於 Spring Boot 的問題
AI：抱歉，我無法找到您昨天的問題，因為它已經超出了我的記憶範圍。

用戶：我之前提到過我喜歡 Java 開發
AI：我沒有找到相關的記錄，請您再次告訴我您的偏好。
```

### 向量記憶的優勢

向量記憶使用語義搜尋技術，能夠：

**語義理解能力**：
- 🧠 **語義搜尋**：基於意思而非關鍵字進行搜尋
- 🔄 **模糊匹配**：找到語義相關的歷史對話
- 📚 **長期存儲**：可以保存大量歷史對話
- 🎯 **智能檢索**：自動找到最相關的記憶片段

**向量記憶的效果**：
```
用戶：我昨天問過關於 Spring Boot 的問題
AI：我記得您昨天詢問了 Spring Boot 的自動配置機制，您想了解更多相關內容嗎？

用戶：我之前提到過我喜歡 Java 開發
AI：是的，我記得您提到過偏好 Java 開發，還特別關注 Spring 框架的應用。
```

### 記憶類型比較

| 特性 | 短期記憶 | 向量記憶 |
|------|----------|----------|
| **存儲方式** | 順序列表 | 向量索引 |
| **檢索方式** | 時間順序 | 語義相似性 |
| **存儲容量** | 有限（通常 < 100 條） | 大容量（數萬條+） |
| **持久性** | 會話級 | 永久存儲 |
| **搜尋能力** | 精確匹配 | 模糊語義搜尋 |
| **適用場景** | 短期對話 | 長期知識積累 |

---

## 6.7.2 VectorStoreChatMemoryAdvisor 深度解析

### 核心工作原理

```
┌─────────────────────────────────────────────────────────────┐
│              VectorStoreChatMemoryAdvisor 工作流程          │
├─────────────────────────────────────────────────────────────┤
│  1. 用戶輸入                                                │
│     ↓                                                       │
│  2. 向量化查詢 (Embedding)                                  │
│     ↓                                                       │
│  3. 向量相似性搜尋                                          │
│     ↓                                                       │
│  4. 檢索相關歷史對話                                        │
│     ↓                                                       │
│  5. 構建增強提示詞                                          │
│     ↓                                                       │
│  6. 發送給 AI 模型                                          │
│     ↓                                                       │
│  7. 存儲新的對話記錄                                        │
└─────────────────────────────────────────────────────────────┘
```

### 基本配置和使用

```java
/**
 * 向量記憶服務配置
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class VectorMemoryService {
    
    private final ChatClient chatClient;
    private final VectorStore vectorStore;
    
    /**
     * 基本向量記憶對話
     */
    public String chatWithVectorMemory(String conversationId, String userMessage) {
        return chatClient.prompt()
            .advisors(VectorStoreChatMemoryAdvisor.builder(vectorStore)
                .conversationId(conversationId)
                .topK(10)  // 檢索最相關的 10 條記憶
                .build())
            .user(userMessage)
            .call()
            .content();
    }
    
    /**
     * 進階向量記憶對話（自定義參數）
     */
    public String chatWithAdvancedVectorMemory(
            String conversationId, 
            String userMessage,
            VectorMemoryOptions options) {
        
        return chatClient.prompt()
            .advisors(VectorStoreChatMemoryAdvisor.builder(vectorStore)
                .conversationId(conversationId)
                .topK(options.getRetrieveSize())
                .similarityThreshold(options.getSimilarityThreshold())
                .build())
            .user(userMessage)
            .call()
            .content();
    }
}
```

### 向量記憶配置選項

```java
/**
 * 向量記憶配置選項
 */
@Data
@Builder
public class VectorMemoryOptions {
    
    /**
     * 檢索記憶數量
     */
    @Builder.Default
    private int retrieveSize = 10;
    
    /**
     * 相似性閾值（0.0 - 1.0）
     */
    @Builder.Default
    private double similarityThreshold = 0.7;
    
    /**
     * 是否包含元數據
     */
    @Builder.Default
    private boolean includeMetadata = true;
    
    /**
     * 記憶過期時間（天）
     */
    @Builder.Default
    private int expirationDays = 30;
    
    /**
     * 是否啟用記憶壓縮
     */
    @Builder.Default
    private boolean enableCompression = false;
}
```

---

## 6.7.3 混合記憶架構實現

### 短期 + 長期記憶組合

最佳實踐是結合短期記憶和長期記憶，創建一個完整的記憶系統：

```java
/**
 * 混合記憶服務
 * 結合短期記憶（MessageChatMemoryAdvisor）和長期記憶（VectorStoreChatMemoryAdvisor）
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class HybridMemoryService {
    
    private final ChatClient chatClient;
    private final ChatMemory shortTermMemory;  // 短期記憶
    private final VectorStore longTermMemory;  // 長期記憶
    
    /**
     * 混合記憶對話
     */
    public String chatWithHybridMemory(String conversationId, String userMessage) {
        log.debug("Processing hybrid memory chat for conversation: {}", conversationId);
        
        return chatClient.prompt()
            .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, conversationId))
            .advisors(
                // 1. 短期記憶 - 最近的對話上下文
                MessageChatMemoryAdvisor.builder(shortTermMemory).build(),
                
                // 2. 長期記憶 - 語義相關的歷史對話
                VectorStoreChatMemoryAdvisor.builder(longTermMemory)
                    .conversationId(conversationId)
                    .topK(5)  // 最相關的 5 條歷史記憶
                    .similarityThreshold(0.75)
                    .build()
            )
            .user(userMessage)
            .call()
            .content();
    }
    
    /**
     * 智能記憶選擇
     * 根據查詢類型動態選擇記憶策略
     */
    public String chatWithSmartMemory(String conversationId, String userMessage) {
        MemoryStrategy strategy = determineMemoryStrategy(userMessage);
        
        switch (strategy) {
            case SHORT_TERM_ONLY:
                return chatWithShortTermMemory(conversationId, userMessage);
                
            case LONG_TERM_ONLY:
                return chatWithLongTermMemory(conversationId, userMessage);
                
            case HYBRID:
            default:
                return chatWithHybridMemory(conversationId, userMessage);
        }
    }
    
    /**
     * 決定記憶策略
     */
    private MemoryStrategy determineMemoryStrategy(String userMessage) {
        // 簡單的策略判斷邏輯
        if (userMessage.contains("剛才") || userMessage.contains("剛剛")) {
            return MemoryStrategy.SHORT_TERM_ONLY;
        }
        
        if (userMessage.contains("之前") || userMessage.contains("以前") || userMessage.contains("記得")) {
            return MemoryStrategy.LONG_TERM_ONLY;
        }
        
        return MemoryStrategy.HYBRID;
    }
    
    private String chatWithShortTermMemory(String conversationId, String userMessage) {
        return chatClient.prompt()
            .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, conversationId))
            .advisors(MessageChatMemoryAdvisor.builder(shortTermMemory).build())
            .user(userMessage)
            .call()
            .content();
    }
    
    private String chatWithLongTermMemory(String conversationId, String userMessage) {
        return chatClient.prompt()
            .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, conversationId))
            .advisors(VectorStoreChatMemoryAdvisor.builder(longTermMemory)
                .conversationId(conversationId)
                .topK(10)
                .similarityThreshold(0.7)
                .build())
            .user(userMessage)
            .call()
            .content();
    }
}

enum MemoryStrategy {
    SHORT_TERM_ONLY,
    LONG_TERM_ONLY,
    HYBRID
}
```

### 記憶同步機制

```java
/**
 * 記憶同步服務
 * 負責在短期記憶和長期記憶之間同步資料
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class MemorySyncService {
    
    private final ChatMemory shortTermMemory;
    private final VectorStore longTermMemory;
    private final EmbeddingModel embeddingModel;
    
    /**
     * 定期同步短期記憶到長期記憶
     */
    @Scheduled(fixedRate = 300000) // 每 5 分鐘執行一次
    public void syncMemories() {
        log.debug("Starting memory synchronization");
        
        try {
            // 由於 ChatMemory 介面不提供 getConversationIds() 方法
            // 這裡需要根據實際的記憶實現來維護對話 ID 清單
            // 或使用其他方式管理活動的對話
            List<String> activeConversationIds = getActiveConversationIds();
            
            for (String conversationId : activeConversationIds) {
                syncConversationMemory(conversationId);
            }
            
            log.info("Memory synchronization completed for {} conversations", activeConversationIds.size());
            
        } catch (Exception e) {
            log.error("Memory synchronization failed", e);
        }
    }
    
    /**
     * 取得活動的對話 ID 清單
     */
    private List<String> getActiveConversationIds() {
        // 這裡需要根據實際的應用程式來實現
        // 可以使用數據庫查詢或其他管理機制
        return java.util.Arrays.asList("conversation1", "conversation2");
    }
    
    /**
     * 同步單個對話的記憶
     */
    private void syncConversationMemory(String conversationId) {
        try {
            List<Message> recentMessages = shortTermMemory.get(conversationId);
            
            if (recentMessages.isEmpty()) {
                return;
            }
            
            // 只取最近的 10 條訊息進行同步
            List<Message> messagesToSync = recentMessages.size() > 10 ? 
                recentMessages.subList(0, 10) : recentMessages;
            
            // 將訊息轉換為文檔並存儲到向量資料庫
            List<Document> documents = convertMessagesToDocuments(conversationId, messagesToSync);
            
            if (!documents.isEmpty()) {
                longTermMemory.add(documents);
                log.debug("Synced {} messages for conversation: {}", documents.size(), conversationId);
            }
            
        } catch (Exception e) {
            log.error("Failed to sync memory for conversation: {}", conversationId, e);
        }
    }
    
    /**
     * 將訊息轉換為向量文檔
     */
    private List<Document> convertMessagesToDocuments(String conversationId, List<Message> messages) {
        List<Document> documents = new ArrayList<>();
        
        for (int i = 0; i < messages.size(); i++) {
            Message message = messages.get(i);
            
            // 只處理用戶和助手的訊息
            if (message instanceof UserMessage || message instanceof AssistantMessage) {
                
                Map<String, Object> metadata = new HashMap<>();
                metadata.put("conversationId", conversationId);
                metadata.put("messageType", message.getClass().getSimpleName());
                metadata.put("timestamp", LocalDateTime.now().toString());
                metadata.put("messageIndex", i);
                
                // 添加上下文資訊
                if (i > 0) {
                    Message previousMessage = messages.get(i - 1);
                    metadata.put("previousMessageType", previousMessage.getClass().getSimpleName());
                }
                
                Document document = new Document(
                    message.getContent(),
                    metadata
                );
                
                documents.add(document);
            }
        }
        
        return documents;
    }
    
    /**
     * 手動觸發記憶同步
     */
    public void forceSyncMemory(String conversationId) {
        log.info("Force syncing memory for conversation: {}", conversationId);
        syncConversationMemory(conversationId);
    }
    
    /**
     * 清理過期的長期記憶
     */
    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨 2 點執行
    public void cleanupExpiredMemories() {
        log.info("Starting cleanup of expired memories");
        
        try {
            // 查詢過期的記憶（超過 30 天）
            LocalDateTime cutoffDate = LocalDateTime.now().minusDays(30);
            
            // 這裡需要根據實際的向量資料庫實現來查詢和刪除過期資料
            // 由於 VectorStore 介面的限制，這裡提供一個概念性的實現
            
            log.info("Expired memories cleanup completed");
            
        } catch (Exception e) {
            log.error("Failed to cleanup expired memories", e);
        }
    }
}
```

---

## 6.7.4 智能記憶檢索策略

### 多層次記憶檢索

```java
/**
 * 智能記憶檢索服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class SmartMemoryRetrievalService {
    
    private final VectorStore vectorStore;
    private final ChatMemory shortTermMemory;
    private final EmbeddingModel embeddingModel;
    
    /**
     * 多層次記憶檢索
     */
    public MemoryRetrievalResult retrieveRelevantMemories(
            String conversationId, 
            String query,
            RetrievalOptions options) {
        
        log.debug("Retrieving memories for query: {}", query);
        
        // 1. 短期記憶檢索
        List<Message> shortTermResults = retrieveShortTermMemories(conversationId, options.getShortTermLimit());
        
        // 2. 長期記憶檢索
        List<Document> longTermResults = retrieveLongTermMemories(conversationId, query, options);
        
        // 3. 記憶融合和排序
        List<MemoryItem> fusedMemories = fuseAndRankMemories(shortTermResults, longTermResults, query);
        
        return MemoryRetrievalResult.builder()
            .conversationId(conversationId)
            .query(query)
            .shortTermMemories(shortTermResults)
            .longTermMemories(longTermResults)
            .fusedMemories(fusedMemories)
            .retrievalTime(LocalDateTime.now())
            .build();
    }
    
    /**
     * 檢索短期記憶
     */
    private List<Message> retrieveShortTermMemories(String conversationId, int limit) {
        try {
            List<Message> allMessages = shortTermMemory.get(conversationId);
            return allMessages.size() > limit ? allMessages.subList(0, limit) : allMessages;
        } catch (Exception e) {
            log.warn("Failed to retrieve short-term memories for conversation: {}", conversationId, e);
            return Collections.emptyList();
        }
    }
    
    /**
     * 檢索長期記憶
     */
    private List<Document> retrieveLongTermMemories(
            String conversationId, 
            String query, 
            RetrievalOptions options) {
        
        try {
            // 建立搜尋請求
            SearchRequest searchRequest = SearchRequest.builder()
                .query(query)
                .topK(options.getLongTermLimit())
                .similarityThreshold(options.getSimilarityThreshold())
                .filterExpression(String.format("conversationId == '%s'", conversationId))
                .build();
            
            return vectorStore.similaritySearch(searchRequest);
            
        } catch (Exception e) {
            log.warn("Failed to retrieve long-term memories for conversation: {}", conversationId, e);
            return Collections.emptyList();
        }
    }
    
    /**
     * 融合和排序記憶
     */
    private List<MemoryItem> fuseAndRankMemories(
            List<Message> shortTermMemories,
            List<Document> longTermMemories,
            String query) {
        
        List<MemoryItem> allMemories = new ArrayList<>();
        
        // 轉換短期記憶
        for (int i = 0; i < shortTermMemories.size(); i++) {
            Message message = shortTermMemories.get(i);
            allMemories.add(MemoryItem.builder()
                .content(message.getContent())
                .type(MemoryType.SHORT_TERM)
                .relevanceScore(calculateShortTermRelevance(message, query, i))
                .timestamp(extractTimestamp(message))
                .metadata(message.getMetadata())
                .build());
        }
        
        // 轉換長期記憶
        for (Document document : longTermMemories) {
            allMemories.add(MemoryItem.builder()
                .content(document.getContent())
                .type(MemoryType.LONG_TERM)
                .relevanceScore(extractSimilarityScore(document))
                .timestamp(extractTimestamp(document))
                .metadata(document.getMetadata())
                .build());
        }
        
        // 按相關性排序
        return allMemories.stream()
            .sorted(Comparator.comparingDouble(MemoryItem::getRelevanceScore).reversed())
            .collect(Collectors.toList());
    }
    
    /**
     * 計算短期記憶相關性
     */
    private double calculateShortTermRelevance(Message message, String query, int position) {
        // 基於位置的權重（越近的訊息權重越高）
        double positionWeight = 1.0 - (position * 0.1);
        
        // 基於內容相似性的權重（簡化實現）
        double contentSimilarity = calculateTextSimilarity(message.getContent(), query);
        
        return (positionWeight * 0.6) + (contentSimilarity * 0.4);
    }
    
    /**
     * 簡單的文本相似性計算
     */
    private double calculateTextSimilarity(String text1, String text2) {
        // 這裡使用簡單的關鍵字匹配，實際應用中可以使用更複雜的算法
        String[] words1 = text1.toLowerCase().split("\\s+");
        String[] words2 = text2.toLowerCase().split("\\s+");
        
        Set<String> set1 = new HashSet<>(Arrays.asList(words1));
        Set<String> set2 = new HashSet<>(Arrays.asList(words2));
        
        Set<String> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        
        Set<String> union = new HashSet<>(set1);
        union.addAll(set2);
        
        return union.isEmpty() ? 0.0 : (double) intersection.size() / union.size();
    }
    
    private double extractSimilarityScore(Document document) {
        Object score = document.getMetadata().get("distance");
        if (score instanceof Number) {
            return 1.0 - ((Number) score).doubleValue(); // 轉換距離為相似性
        }
        return 0.5; // 預設值
    }
    
    private LocalDateTime extractTimestamp(Message message) {
        Object timestamp = message.getMetadata().get("timestamp");
        if (timestamp instanceof LocalDateTime) {
            return (LocalDateTime) timestamp;
        }
        return LocalDateTime.now();
    }
    
    private LocalDateTime extractTimestamp(Document document) {
        Object timestamp = document.getMetadata().get("timestamp");
        if (timestamp instanceof String) {
            try {
                return LocalDateTime.parse((String) timestamp);
            } catch (Exception e) {
                log.warn("Failed to parse timestamp: {}", timestamp);
            }
        }
        return LocalDateTime.now();
    }
}
```

### 記憶檢索配置和結果類

```java
/**
 * 記憶檢索選項
 */
@Data
@Builder
public class RetrievalOptions {
    
    /**
     * 短期記憶限制
     */
    @Builder.Default
    private int shortTermLimit = 20;
    
    /**
     * 長期記憶限制
     */
    @Builder.Default
    private int longTermLimit = 10;
    
    /**
     * 相似性閾值
     */
    @Builder.Default
    private double similarityThreshold = 0.7;
    
    /**
     * 是否包含元數據
     */
    @Builder.Default
    private boolean includeMetadata = true;
    
    /**
     * 時間範圍過濾（天）
     */
    private Integer timeRangeDays;
}

/**
 * 記憶檢索結果
 */
@Data
@Builder
public class MemoryRetrievalResult {
    private String conversationId;
    private String query;
    private List<Message> shortTermMemories;
    private List<Document> longTermMemories;
    private List<MemoryItem> fusedMemories;
    private LocalDateTime retrievalTime;
}

/**
 * 記憶項目
 */
@Data
@Builder
public class MemoryItem {
    private String content;
    private MemoryType type;
    private double relevanceScore;
    private LocalDateTime timestamp;
    private Map<String, Object> metadata;
}

enum MemoryType {
    SHORT_TERM,
    LONG_TERM
}
```

---

## 6.7.5 企業級記憶管理系統

### 記憶管理控制器

```java
/**
 * 記憶管理 REST API
 */
@RestController
@RequestMapping("/api/memory")
@RequiredArgsConstructor
@Slf4j
public class MemoryManagementController {
    
    private final HybridMemoryService hybridMemoryService;
    private final SmartMemoryRetrievalService retrievalService;
    private final MemorySyncService syncService;
    private final MemoryAnalyticsService analyticsService;
    
    /**
     * 混合記憶對話
     */
    @PostMapping("/chat/{conversationId}")
    public ResponseEntity<ChatResponse> chat(
            @PathVariable String conversationId,
            @RequestBody ChatRequest request) {
        
        try {
            String response = hybridMemoryService.chatWithHybridMemory(
                conversationId, 
                request.getMessage()
            );
            
            return ResponseEntity.ok(ChatResponse.builder()
                .conversationId(conversationId)
                .message(response)
                .timestamp(LocalDateTime.now())
                .memoryType("hybrid")
                .build());
                
        } catch (Exception e) {
            log.error("Chat failed for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest()
                .body(ChatResponse.builder()
                    .conversationId(conversationId)
                    .error("Chat processing failed: " + e.getMessage())
                    .timestamp(LocalDateTime.now())
                    .build());
        }
    }
    
    /**
     * 智能記憶對話
     */
    @PostMapping("/smart-chat/{conversationId}")
    public ResponseEntity<ChatResponse> smartChat(
            @PathVariable String conversationId,
            @RequestBody ChatRequest request) {
        
        try {
            String response = hybridMemoryService.chatWithSmartMemory(
                conversationId, 
                request.getMessage()
            );
            
            return ResponseEntity.ok(ChatResponse.builder()
                .conversationId(conversationId)
                .message(response)
                .timestamp(LocalDateTime.now())
                .memoryType("smart")
                .build());
                
        } catch (Exception e) {
            log.error("Smart chat failed for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 檢索記憶
     */
    @PostMapping("/retrieve/{conversationId}")
    public ResponseEntity<MemoryRetrievalResult> retrieveMemories(
            @PathVariable String conversationId,
            @RequestBody MemoryRetrievalRequest request) {
        
        try {
            RetrievalOptions options = RetrievalOptions.builder()
                .shortTermLimit(request.getShortTermLimit())
                .longTermLimit(request.getLongTermLimit())
                .similarityThreshold(request.getSimilarityThreshold())
                .timeRangeDays(request.getTimeRangeDays())
                .build();
            
            MemoryRetrievalResult result = retrievalService.retrieveRelevantMemories(
                conversationId, 
                request.getQuery(), 
                options
            );
            
            return ResponseEntity.ok(result);
            
        } catch (Exception e) {
            log.error("Memory retrieval failed for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 手動同步記憶
     */
    @PostMapping("/sync/{conversationId}")
    public ResponseEntity<ApiResponse> syncMemory(@PathVariable String conversationId) {
        try {
            syncService.forceSyncMemory(conversationId);
            return ResponseEntity.ok(ApiResponse.success("Memory synced successfully"));
        } catch (Exception e) {
            log.error("Memory sync failed for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Memory sync failed: " + e.getMessage()));
        }
    }
    
    /**
     * 取得記憶統計
     */
    @GetMapping("/analytics/{conversationId}")
    public ResponseEntity<MemoryAnalytics> getMemoryAnalytics(@PathVariable String conversationId) {
        try {
            MemoryAnalytics analytics = analyticsService.getConversationAnalytics(conversationId);
            return ResponseEntity.ok(analytics);
        } catch (Exception e) {
            log.error("Failed to get memory analytics for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 清除對話記憶
     */
    @DeleteMapping("/clear/{conversationId}")
    public ResponseEntity<ApiResponse> clearMemory(@PathVariable String conversationId) {
        try {
            // 清除短期記憶
            shortTermMemory.clear(conversationId);
            
            // 清除長期記憶（需要根據實際的 VectorStore 實現來進行刪除操作）
            // 由於 VectorStore 介面不提供按對話 ID 刪除的方法
            // 這裡可能需要使用特定的 VectorStore 實現來達成
            
            return ResponseEntity.ok(ApiResponse.success("Memory cleared successfully"));
        } catch (Exception e) {
            log.error("Failed to clear memory for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Memory clear failed: " + e.getMessage()));
        }
    }
}
```

### 記憶分析服務

```java
/**
 * 記憶分析服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class MemoryAnalyticsService {
    
    private final ChatMemory shortTermMemory;
    private final VectorStore longTermMemory;
    private final MeterRegistry meterRegistry;
    
    /**
     * 取得對話記憶分析
     */
    public MemoryAnalytics getConversationAnalytics(String conversationId) {
        try {
            // 短期記憶統計
            List<Message> shortTermMessages = shortTermMemory.get(conversationId);
            int shortTermCount = shortTermMessages.size();
            
            // 長期記憶統計（簡化實現）
            int longTermCount = estimateLongTermMemoryCount(conversationId);
            
            // 記憶使用統計
            MemoryUsageStats usageStats = calculateMemoryUsage(shortTermMessages);
            
            // 記憶品質分析
            MemoryQualityMetrics qualityMetrics = analyzeMemoryQuality(conversationId);
            
            return MemoryAnalytics.builder()
                .conversationId(conversationId)
                .shortTermMemoryCount(shortTermCount)
                .longTermMemoryCount(longTermCount)
                .usageStats(usageStats)
                .qualityMetrics(qualityMetrics)
                .analysisTime(LocalDateTime.now())
                .build();
                
        } catch (Exception e) {
            log.error("Failed to analyze memory for conversation: {}", conversationId, e);
            throw new RuntimeException("Memory analysis failed", e);
        }
    }
    
    /**
     * 估算長期記憶數量
     */
    private int estimateLongTermMemoryCount(String conversationId) {
        try {
            // 這裡需要根據實際的向量資料庫實現來查詢
            // 由於 VectorStore 介面的限制，這裡提供一個概念性的實現
            SearchRequest searchRequest = SearchRequest.builder()
                .query("*")
                .topK(1000)
                .filterExpression(String.format("conversationId == '%s'", conversationId))
                .build();
            
            List<Document> results = longTermMemory.similaritySearch(searchRequest);
            return results.size();
            
        } catch (Exception e) {
            log.warn("Failed to estimate long-term memory count for conversation: {}", conversationId, e);
            return 0;
        }
    }
    
    /**
     * 計算記憶使用統計
     */
    private MemoryUsageStats calculateMemoryUsage(List<Message> messages) {
        int totalMessages = messages.size();
        int userMessages = 0;
        int assistantMessages = 0;
        int totalCharacters = 0;
        
        for (Message message : messages) {
            if (message instanceof UserMessage) {
                userMessages++;
            } else if (message instanceof AssistantMessage) {
                assistantMessages++;
            }
            totalCharacters += message.getContent().length();
        }
        
        double avgMessageLength = totalMessages > 0 ? (double) totalCharacters / totalMessages : 0;
        
        return MemoryUsageStats.builder()
            .totalMessages(totalMessages)
            .userMessages(userMessages)
            .assistantMessages(assistantMessages)
            .totalCharacters(totalCharacters)
            .averageMessageLength(avgMessageLength)
            .build();
    }
    
    /**
     * 分析記憶品質
     */
    private MemoryQualityMetrics analyzeMemoryQuality(String conversationId) {
        // 這裡可以實現更複雜的記憶品質分析
        // 例如：記憶的相關性、完整性、時效性等
        
        return MemoryQualityMetrics.builder()
            .relevanceScore(0.85)  // 相關性分數
            .completenessScore(0.90)  // 完整性分數
            .freshnessScore(0.75)  // 時效性分數
            .overallQuality(0.83)  // 整體品質
            .build();
    }
    
    /**
     * 記錄記憶操作統計
     */
    public void recordMemoryOperation(String operation, String conversationId, boolean success) {
        meterRegistry.counter("memory.operations",
            "operation", operation,
            "conversation_id", conversationId,
            "success", String.valueOf(success))
            .increment();
    }
    
    /**
     * 記錄記憶檢索時間
     */
    public void recordRetrievalTime(String memoryType, long timeMs) {
        meterRegistry.timer("memory.retrieval.time",
            "type", memoryType)
            .record(timeMs, TimeUnit.MILLISECONDS);
    }
}
```

---

## 6.7.6 測試和驗證

### 向量記憶功能測試

```java
/**
 * 向量記憶功能測試
 */
@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class VectorMemoryIntegrationTest {
    
    @Autowired
    private HybridMemoryService hybridMemoryService;
    
    @Autowired
    private VectorStore vectorStore;
    
    @Autowired
    private ChatMemory shortTermMemory;
    
    private static final String TEST_CONVERSATION_ID = "test-vector-memory-001";
    
    @Test
    @Order(1)
    void testBasicVectorMemory() {
        // 第一輪對話 - 建立記憶
        String response1 = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "我喜歡學習 Spring Boot 框架，特別是它的自動配置功能。"
        );
        
        assertThat(response1).isNotNull();
        
        // 等待記憶同步
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // 第二輪對話 - 測試記憶召回
        String response2 = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "我之前提到過我對哪個框架感興趣？"
        );
        
        assertThat(response2.toLowerCase()).contains("spring");
    }
    
    @Test
    @Order(2)
    void testSemanticMemoryRetrieval() {
        // 建立語義相關的記憶
        hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "我正在開發一個電商網站，使用 Java 和 Spring 技術棧。"
        );
        
        hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "這個專案需要處理用戶註冊、商品管理和訂單處理功能。"
        );
        
        // 等待記憶同步
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // 測試語義搜尋
        String response = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "關於我的網站開發專案，你還記得什麼？"
        );
        
        assertThat(response.toLowerCase())
            .containsAnyOf("電商", "java", "spring", "用戶", "商品", "訂單");
    }
    
    @Test
    @Order(3)
    void testMemoryPersistence() {
        // 清除短期記憶
        shortTermMemory.clear(TEST_CONVERSATION_ID);
        
        // 測試長期記憶是否仍然可用
        String response = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "我們之前討論過什麼技術？"
        );
        
        // 應該能從長期記憶中找到相關資訊
        assertThat(response).isNotNull();
    }
    
    @Test
    @Order(4)
    void testMemoryRetrievalWithThreshold() {
        // 測試相似性閾值過濾
        String response = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "完全不相關的隨機問題關於天氣預報"
        );
        
        // 由於相似性閾值，應該不會檢索到不相關的記憶
        assertThat(response).isNotNull();
    }
}
```

### 記憶效能測試

```java
/**
 * 記憶效能測試
 */
@SpringBootTest
class MemoryPerformanceTest {
    
    @Autowired
    private HybridMemoryService hybridMemoryService;
    
    @Autowired
    private SmartMemoryRetrievalService retrievalService;
    
    @Test
    void testMemoryRetrievalPerformance() {
        String conversationId = "perf-test-001";
        
        // 建立大量測試記憶
        for (int i = 0; i < 100; i++) {
            hybridMemoryService.chatWithHybridMemory(
                conversationId,
                "測試訊息 " + i + " 關於 Spring Boot 開發和 Java 程式設計的內容。"
            );
        }
        
        // 測試檢索效能
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        for (int i = 0; i < 50; i++) {
            RetrievalOptions options = RetrievalOptions.builder()
                .shortTermLimit(10)
                .longTermLimit(5)
                .similarityThreshold(0.7)
                .build();
            
            retrievalService.retrieveRelevantMemories(
                conversationId,
                "Spring Boot 相關問題 " + i,
                options
            );
        }
        
        stopWatch.stop();
        
        long totalTime = stopWatch.getTotalTimeMillis();
        double avgRetrievalTime = (double) totalTime / 50;
        
        log.info("Memory retrieval performance: 50 queries in {} ms (avg: {} ms/query)",
            totalTime, String.format("%.2f", avgRetrievalTime));
        
        // 驗證效能指標
        assertThat(avgRetrievalTime).isLessThan(500); // 平均檢索時間小於 500ms
    }
    
    @Test
    void testConcurrentMemoryAccess() throws InterruptedException {
        String conversationId = "concurrent-test-001";
        int threadCount = 10;
        int operationsPerThread = 20;
        
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);
        AtomicInteger successCount = new AtomicInteger(0);
        
        for (int i = 0; i < threadCount; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    for (int j = 0; j < operationsPerThread; j++) {
                        String response = hybridMemoryService.chatWithHybridMemory(
                            conversationId,
                            String.format("Thread %d operation %d message", threadId, j)
                        );
                        
                        if (response != null && !response.isEmpty()) {
                            successCount.incrementAndGet();
                        }
                    }
                } catch (Exception e) {
                    log.error("Concurrent operation failed in thread {}", threadId, e);
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await(60, TimeUnit.SECONDS);
        executor.shutdown();
        
        int expectedOperations = threadCount * operationsPerThread;
        double successRate = (double) successCount.get() / expectedOperations;
        
        log.info("Concurrent memory access: {}/{} operations succeeded ({}%)",
            successCount.get(), expectedOperations, String.format("%.1f", successRate * 100));
        
        // 驗證併發操作成功率
        assertThat(successRate).isGreaterThan(0.95); // 95% 以上成功率
    }
}
```

---

## 📝 本章重點回顧

1. **向量記憶理解**：掌握了向量記憶與傳統記憶的差異和優勢
2. **VectorStoreChatMemoryAdvisor 應用**：學會了使用向量記憶進行語義搜尋
3. **混合記憶架構**：實現了短期和長期記憶的完美結合
4. **智能檢索策略**：建立了多層次的記憶檢索和融合機制
5. **企業級管理系統**：完成了完整的記憶管理和分析平台

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **VectorStoreChatMemoryAdvisor** | ⭐⭐⭐ | 中 | 語義記憶 |
| **混合記憶架構** | ⭐⭐⭐ | 高 | 完整解決方案 |
| **智能檢索策略** | ⭐⭐ | 高 | 檢索效能 |
| **記憶同步機制** | ⭐⭐ | 中 | 資料一致性 |
| **企業級管理** | ⭐⭐ | 中 | 運維便利性 |

### 最佳實踐建議

1. **記憶策略選擇**：根據查詢類型動態選擇短期、長期或混合記憶策略
2. **相似性閾值調整**：根據應用場景調整向量搜尋的相似性閾值
3. **記憶同步頻率**：平衡記憶同步的即時性和系統效能
4. **效能監控**：建立完整的記憶操作監控和效能分析
5. **資料清理策略**：定期清理過期和低品質的記憶資料

### 第六章完整總結

恭喜您完成了第六章「讓 ChatBot 不再金魚腦」的完整學習！本章涵蓋了：

- **6.1 記憶系統概述**：理解了 AI 記憶的重要性和類型
- **6.2 基本記憶實現**：掌握了 Advisor 系統和對話記憶
- **6.3 官方記憶系統**：學會了 Spring AI 官方記憶 API
- **6.4 鏈式增強器**：實現了複雜的 Advisor 組合和自定義
- **6.5 插件開發**：建立了可擴展的插件系統
- **6.6 Neo4j 安裝**：部署了企業級向量資料庫
- **6.7 向量記憶**：實現了基於語義搜尋的長期記憶

通過本章的學習，您已經掌握了建立智能對話系統的完整技術棧，能夠開發出具有真正「記憶」能力的 AI 應用！

---

**參考資料：**
- [Spring AI Vector Store Documentation](https://docs.spring.io/spring-ai/reference/api/vectordbs.html)
- [VectorStoreChatMemoryAdvisor API](https://docs.spring.io/spring-ai/reference/api/advisors.html)
- [Neo4j Vector Search](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/)
- [Semantic Search Best Practices](https://www.pinecone.io/learn/semantic-search/)
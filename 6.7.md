# 6.7 ä½¿ç”¨å‘é‡è³‡æ–™åº«ä½œç‚ºå°è©±çš„é•·ä¹…è¨˜æ†¶

> **æœ¬ç« é‡é»**ï¼šæ•´åˆ Neo4j å‘é‡è³‡æ–™åº«èˆ‡ Spring AI è¨˜æ†¶ç³»çµ±ï¼Œå¯¦ç¾åŸºæ–¼èªç¾©æœå°‹çš„æ™ºèƒ½é•·æœŸè¨˜æ†¶åŠŸèƒ½ï¼Œè®“ AI æ“æœ‰çœŸæ­£çš„ã€Œé•·æœŸè¨˜æ†¶ã€èƒ½åŠ›ã€‚

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬ç« å­¸ç¿’å¾Œï¼Œæ‚¨å°‡èƒ½å¤ ï¼š

- ğŸ¯ **å¯¦ç¾å‘é‡è¨˜æ†¶ç³»çµ±**ï¼šä½¿ç”¨ VectorStoreChatMemoryAdvisor å»ºç«‹èªç¾©è¨˜æ†¶
- ğŸ¯ **æŒæ¡èªç¾©æœå°‹æŠ€è¡“**ï¼šåŸºæ–¼å‘é‡ç›¸ä¼¼æ€§çš„æ™ºèƒ½è¨˜æ†¶æª¢ç´¢
- ğŸ¯ **å»ºç«‹æ··åˆè¨˜æ†¶æ¶æ§‹**ï¼šçµåˆçŸ­æœŸå’Œé•·æœŸè¨˜æ†¶çš„å®Œæ•´è§£æ±ºæ–¹æ¡ˆ
- ğŸ¯ **å„ªåŒ–è¨˜æ†¶æª¢ç´¢ç­–ç•¥**ï¼šå¯¦ç¾é«˜æ•ˆçš„è¨˜æ†¶ç®¡ç†å’Œæª¢ç´¢ç®—æ³•
- ğŸ¯ **æ§‹å»ºä¼æ¥­ç´šè¨˜æ†¶ç³»çµ±**ï¼šå¯æ“´å±•çš„å¤§è¦æ¨¡å°è©±è¨˜æ†¶è§£æ±ºæ–¹æ¡ˆ

---

## 6.7.1 å‘é‡è¨˜æ†¶ vs å‚³çµ±è¨˜æ†¶

### å‚³çµ±è¨˜æ†¶çš„é™åˆ¶

åœ¨å‰é¢çš„ç« ç¯€ä¸­ï¼Œæˆ‘å€‘å­¸ç¿’äº† MessageChatMemoryAdvisor å’Œ PromptChatMemoryAdvisorï¼Œé€™äº›éƒ½å±¬æ–¼ã€ŒçŸ­æœŸè¨˜æ†¶ã€ï¼š

**çŸ­æœŸè¨˜æ†¶çš„ç‰¹é»**ï¼š
- ğŸ“ **é †åºå­˜å–**ï¼šæŒ‰ç…§æ™‚é–“é †åºå­˜å„²å’Œæª¢ç´¢å°è©±
- ğŸ”¢ **æ•¸é‡é™åˆ¶**ï¼šé€šå¸¸åªèƒ½ä¿å­˜æœ€è¿‘çš„ N æ¢è¨Šæ¯
- ğŸ’¾ **è¨˜æ†¶é«”å­˜å„²**ï¼šé‡å•Ÿå¾Œè¨˜æ†¶æ¶ˆå¤±
- ğŸ” **ç²¾ç¢ºåŒ¹é…**ï¼šç„¡æ³•é€²è¡Œèªç¾©ç›¸é—œçš„æœå°‹

**çŸ­æœŸè¨˜æ†¶çš„å•é¡Œ**ï¼š
```
ç”¨æˆ¶ï¼šæˆ‘æ˜¨å¤©å•éé—œæ–¼ Spring Boot çš„å•é¡Œ
AIï¼šæŠ±æ­‰ï¼Œæˆ‘ç„¡æ³•æ‰¾åˆ°æ‚¨æ˜¨å¤©çš„å•é¡Œï¼Œå› ç‚ºå®ƒå·²ç¶“è¶…å‡ºäº†æˆ‘çš„è¨˜æ†¶ç¯„åœã€‚

ç”¨æˆ¶ï¼šæˆ‘ä¹‹å‰æåˆ°éæˆ‘å–œæ­¡ Java é–‹ç™¼
AIï¼šæˆ‘æ²’æœ‰æ‰¾åˆ°ç›¸é—œçš„è¨˜éŒ„ï¼Œè«‹æ‚¨å†æ¬¡å‘Šè¨´æˆ‘æ‚¨çš„åå¥½ã€‚
```

### å‘é‡è¨˜æ†¶çš„å„ªå‹¢

å‘é‡è¨˜æ†¶ä½¿ç”¨èªç¾©æœå°‹æŠ€è¡“ï¼Œèƒ½å¤ ï¼š

**èªç¾©ç†è§£èƒ½åŠ›**ï¼š
- ğŸ§  **èªç¾©æœå°‹**ï¼šåŸºæ–¼æ„æ€è€Œéé—œéµå­—é€²è¡Œæœå°‹
- ğŸ”„ **æ¨¡ç³ŠåŒ¹é…**ï¼šæ‰¾åˆ°èªç¾©ç›¸é—œçš„æ­·å²å°è©±
- ğŸ“š **é•·æœŸå­˜å„²**ï¼šå¯ä»¥ä¿å­˜å¤§é‡æ­·å²å°è©±
- ğŸ¯ **æ™ºèƒ½æª¢ç´¢**ï¼šè‡ªå‹•æ‰¾åˆ°æœ€ç›¸é—œçš„è¨˜æ†¶ç‰‡æ®µ

**å‘é‡è¨˜æ†¶çš„æ•ˆæœ**ï¼š
```
ç”¨æˆ¶ï¼šæˆ‘æ˜¨å¤©å•éé—œæ–¼ Spring Boot çš„å•é¡Œ
AIï¼šæˆ‘è¨˜å¾—æ‚¨æ˜¨å¤©è©¢å•äº† Spring Boot çš„è‡ªå‹•é…ç½®æ©Ÿåˆ¶ï¼Œæ‚¨æƒ³äº†è§£æ›´å¤šç›¸é—œå…§å®¹å—ï¼Ÿ

ç”¨æˆ¶ï¼šæˆ‘ä¹‹å‰æåˆ°éæˆ‘å–œæ­¡ Java é–‹ç™¼
AIï¼šæ˜¯çš„ï¼Œæˆ‘è¨˜å¾—æ‚¨æåˆ°éåå¥½ Java é–‹ç™¼ï¼Œé‚„ç‰¹åˆ¥é—œæ³¨ Spring æ¡†æ¶çš„æ‡‰ç”¨ã€‚
```

### è¨˜æ†¶é¡å‹æ¯”è¼ƒ

| ç‰¹æ€§ | çŸ­æœŸè¨˜æ†¶ | å‘é‡è¨˜æ†¶ |
|------|----------|----------|
| **å­˜å„²æ–¹å¼** | é †åºåˆ—è¡¨ | å‘é‡ç´¢å¼• |
| **æª¢ç´¢æ–¹å¼** | æ™‚é–“é †åº | èªç¾©ç›¸ä¼¼æ€§ |
| **å­˜å„²å®¹é‡** | æœ‰é™ï¼ˆé€šå¸¸ < 100 æ¢ï¼‰ | å¤§å®¹é‡ï¼ˆæ•¸è¬æ¢+ï¼‰ |
| **æŒä¹…æ€§** | æœƒè©±ç´š | æ°¸ä¹…å­˜å„² |
| **æœå°‹èƒ½åŠ›** | ç²¾ç¢ºåŒ¹é… | æ¨¡ç³Šèªç¾©æœå°‹ |
| **é©ç”¨å ´æ™¯** | çŸ­æœŸå°è©± | é•·æœŸçŸ¥è­˜ç©ç´¯ |

---

## 6.7.2 VectorStoreChatMemoryAdvisor æ·±åº¦è§£æ

### æ ¸å¿ƒå·¥ä½œåŸç†

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              VectorStoreChatMemoryAdvisor å·¥ä½œæµç¨‹          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. ç”¨æˆ¶è¼¸å…¥                                                â”‚
â”‚     â†“                                                       â”‚
â”‚  2. å‘é‡åŒ–æŸ¥è©¢ (Embedding)                                  â”‚
â”‚     â†“                                                       â”‚
â”‚  3. å‘é‡ç›¸ä¼¼æ€§æœå°‹                                          â”‚
â”‚     â†“                                                       â”‚
â”‚  4. æª¢ç´¢ç›¸é—œæ­·å²å°è©±                                        â”‚
â”‚     â†“                                                       â”‚
â”‚  5. æ§‹å»ºå¢å¼·æç¤ºè©                                          â”‚
â”‚     â†“                                                       â”‚
â”‚  6. ç™¼é€çµ¦ AI æ¨¡å‹                                          â”‚
â”‚     â†“                                                       â”‚
â”‚  7. å­˜å„²æ–°çš„å°è©±è¨˜éŒ„                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### åŸºæœ¬é…ç½®å’Œä½¿ç”¨

```java
/**
 * å‘é‡è¨˜æ†¶æœå‹™é…ç½®
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class VectorMemoryService {
    
    private final ChatClient chatClient;
    private final VectorStore vectorStore;
    
    /**
     * åŸºæœ¬å‘é‡è¨˜æ†¶å°è©±
     */
    public String chatWithVectorMemory(String conversationId, String userMessage) {
        return chatClient.prompt()
            .advisors(VectorStoreChatMemoryAdvisor.builder(vectorStore)
                .conversationId(conversationId)
                .topK(10)  // æª¢ç´¢æœ€ç›¸é—œçš„ 10 æ¢è¨˜æ†¶
                .build())
            .user(userMessage)
            .call()
            .content();
    }
    
    /**
     * é€²éšå‘é‡è¨˜æ†¶å°è©±ï¼ˆè‡ªå®šç¾©åƒæ•¸ï¼‰
     */
    public String chatWithAdvancedVectorMemory(
            String conversationId, 
            String userMessage,
            VectorMemoryOptions options) {
        
        return chatClient.prompt()
            .advisors(VectorStoreChatMemoryAdvisor.builder(vectorStore)
                .conversationId(conversationId)
                .topK(options.getRetrieveSize())
                .similarityThreshold(options.getSimilarityThreshold())
                .build())
            .user(userMessage)
            .call()
            .content();
    }
}
```

### å‘é‡è¨˜æ†¶é…ç½®é¸é …

```java
/**
 * å‘é‡è¨˜æ†¶é…ç½®é¸é …
 */
@Data
@Builder
public class VectorMemoryOptions {
    
    /**
     * æª¢ç´¢è¨˜æ†¶æ•¸é‡
     */
    @Builder.Default
    private int retrieveSize = 10;
    
    /**
     * ç›¸ä¼¼æ€§é–¾å€¼ï¼ˆ0.0 - 1.0ï¼‰
     */
    @Builder.Default
    private double similarityThreshold = 0.7;
    
    /**
     * æ˜¯å¦åŒ…å«å…ƒæ•¸æ“š
     */
    @Builder.Default
    private boolean includeMetadata = true;
    
    /**
     * è¨˜æ†¶éæœŸæ™‚é–“ï¼ˆå¤©ï¼‰
     */
    @Builder.Default
    private int expirationDays = 30;
    
    /**
     * æ˜¯å¦å•Ÿç”¨è¨˜æ†¶å£“ç¸®
     */
    @Builder.Default
    private boolean enableCompression = false;
}
```

---

## 6.7.3 æ··åˆè¨˜æ†¶æ¶æ§‹å¯¦ç¾

### çŸ­æœŸ + é•·æœŸè¨˜æ†¶çµ„åˆ

æœ€ä½³å¯¦è¸æ˜¯çµåˆçŸ­æœŸè¨˜æ†¶å’Œé•·æœŸè¨˜æ†¶ï¼Œå‰µå»ºä¸€å€‹å®Œæ•´çš„è¨˜æ†¶ç³»çµ±ï¼š

```java
/**
 * æ··åˆè¨˜æ†¶æœå‹™
 * çµåˆçŸ­æœŸè¨˜æ†¶ï¼ˆMessageChatMemoryAdvisorï¼‰å’Œé•·æœŸè¨˜æ†¶ï¼ˆVectorStoreChatMemoryAdvisorï¼‰
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class HybridMemoryService {
    
    private final ChatClient chatClient;
    private final ChatMemory shortTermMemory;  // çŸ­æœŸè¨˜æ†¶
    private final VectorStore longTermMemory;  // é•·æœŸè¨˜æ†¶
    
    /**
     * æ··åˆè¨˜æ†¶å°è©±
     */
    public String chatWithHybridMemory(String conversationId, String userMessage) {
        log.debug("Processing hybrid memory chat for conversation: {}", conversationId);
        
        return chatClient.prompt()
            .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, conversationId))
            .advisors(
                // 1. çŸ­æœŸè¨˜æ†¶ - æœ€è¿‘çš„å°è©±ä¸Šä¸‹æ–‡
                MessageChatMemoryAdvisor.builder(shortTermMemory).build(),
                
                // 2. é•·æœŸè¨˜æ†¶ - èªç¾©ç›¸é—œçš„æ­·å²å°è©±
                VectorStoreChatMemoryAdvisor.builder(longTermMemory)
                    .conversationId(conversationId)
                    .topK(5)  // æœ€ç›¸é—œçš„ 5 æ¢æ­·å²è¨˜æ†¶
                    .similarityThreshold(0.75)
                    .build()
            )
            .user(userMessage)
            .call()
            .content();
    }
    
    /**
     * æ™ºèƒ½è¨˜æ†¶é¸æ“‡
     * æ ¹æ“šæŸ¥è©¢é¡å‹å‹•æ…‹é¸æ“‡è¨˜æ†¶ç­–ç•¥
     */
    public String chatWithSmartMemory(String conversationId, String userMessage) {
        MemoryStrategy strategy = determineMemoryStrategy(userMessage);
        
        switch (strategy) {
            case SHORT_TERM_ONLY:
                return chatWithShortTermMemory(conversationId, userMessage);
                
            case LONG_TERM_ONLY:
                return chatWithLongTermMemory(conversationId, userMessage);
                
            case HYBRID:
            default:
                return chatWithHybridMemory(conversationId, userMessage);
        }
    }
    
    /**
     * æ±ºå®šè¨˜æ†¶ç­–ç•¥
     */
    private MemoryStrategy determineMemoryStrategy(String userMessage) {
        // ç°¡å–®çš„ç­–ç•¥åˆ¤æ–·é‚è¼¯
        if (userMessage.contains("å‰›æ‰") || userMessage.contains("å‰›å‰›")) {
            return MemoryStrategy.SHORT_TERM_ONLY;
        }
        
        if (userMessage.contains("ä¹‹å‰") || userMessage.contains("ä»¥å‰") || userMessage.contains("è¨˜å¾—")) {
            return MemoryStrategy.LONG_TERM_ONLY;
        }
        
        return MemoryStrategy.HYBRID;
    }
    
    private String chatWithShortTermMemory(String conversationId, String userMessage) {
        return chatClient.prompt()
            .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, conversationId))
            .advisors(MessageChatMemoryAdvisor.builder(shortTermMemory).build())
            .user(userMessage)
            .call()
            .content();
    }
    
    private String chatWithLongTermMemory(String conversationId, String userMessage) {
        return chatClient.prompt()
            .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, conversationId))
            .advisors(VectorStoreChatMemoryAdvisor.builder(longTermMemory)
                .conversationId(conversationId)
                .topK(10)
                .similarityThreshold(0.7)
                .build())
            .user(userMessage)
            .call()
            .content();
    }
}

enum MemoryStrategy {
    SHORT_TERM_ONLY,
    LONG_TERM_ONLY,
    HYBRID
}
```

### è¨˜æ†¶åŒæ­¥æ©Ÿåˆ¶

```java
/**
 * è¨˜æ†¶åŒæ­¥æœå‹™
 * è² è²¬åœ¨çŸ­æœŸè¨˜æ†¶å’Œé•·æœŸè¨˜æ†¶ä¹‹é–“åŒæ­¥è³‡æ–™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class MemorySyncService {
    
    private final ChatMemory shortTermMemory;
    private final VectorStore longTermMemory;
    private final EmbeddingModel embeddingModel;
    
    /**
     * å®šæœŸåŒæ­¥çŸ­æœŸè¨˜æ†¶åˆ°é•·æœŸè¨˜æ†¶
     */
    @Scheduled(fixedRate = 300000) // æ¯ 5 åˆ†é˜åŸ·è¡Œä¸€æ¬¡
    public void syncMemories() {
        log.debug("Starting memory synchronization");
        
        try {
            // ç”±æ–¼ ChatMemory ä»‹é¢ä¸æä¾› getConversationIds() æ–¹æ³•
            // é€™è£¡éœ€è¦æ ¹æ“šå¯¦éš›çš„è¨˜æ†¶å¯¦ç¾ä¾†ç¶­è­·å°è©± ID æ¸…å–®
            // æˆ–ä½¿ç”¨å…¶ä»–æ–¹å¼ç®¡ç†æ´»å‹•çš„å°è©±
            List<String> activeConversationIds = getActiveConversationIds();
            
            for (String conversationId : activeConversationIds) {
                syncConversationMemory(conversationId);
            }
            
            log.info("Memory synchronization completed for {} conversations", activeConversationIds.size());
            
        } catch (Exception e) {
            log.error("Memory synchronization failed", e);
        }
    }
    
    /**
     * å–å¾—æ´»å‹•çš„å°è©± ID æ¸…å–®
     */
    private List<String> getActiveConversationIds() {
        // é€™è£¡éœ€è¦æ ¹æ“šå¯¦éš›çš„æ‡‰ç”¨ç¨‹å¼ä¾†å¯¦ç¾
        // å¯ä»¥ä½¿ç”¨æ•¸æ“šåº«æŸ¥è©¢æˆ–å…¶ä»–ç®¡ç†æ©Ÿåˆ¶
        return java.util.Arrays.asList("conversation1", "conversation2");
    }
    
    /**
     * åŒæ­¥å–®å€‹å°è©±çš„è¨˜æ†¶
     */
    private void syncConversationMemory(String conversationId) {
        try {
            List<Message> recentMessages = shortTermMemory.get(conversationId);
            
            if (recentMessages.isEmpty()) {
                return;
            }
            
            // åªå–æœ€è¿‘çš„ 10 æ¢è¨Šæ¯é€²è¡ŒåŒæ­¥
            List<Message> messagesToSync = recentMessages.size() > 10 ? 
                recentMessages.subList(0, 10) : recentMessages;
            
            // å°‡è¨Šæ¯è½‰æ›ç‚ºæ–‡æª”ä¸¦å­˜å„²åˆ°å‘é‡è³‡æ–™åº«
            List<Document> documents = convertMessagesToDocuments(conversationId, messagesToSync);
            
            if (!documents.isEmpty()) {
                longTermMemory.add(documents);
                log.debug("Synced {} messages for conversation: {}", documents.size(), conversationId);
            }
            
        } catch (Exception e) {
            log.error("Failed to sync memory for conversation: {}", conversationId, e);
        }
    }
    
    /**
     * å°‡è¨Šæ¯è½‰æ›ç‚ºå‘é‡æ–‡æª”
     */
    private List<Document> convertMessagesToDocuments(String conversationId, List<Message> messages) {
        List<Document> documents = new ArrayList<>();
        
        for (int i = 0; i < messages.size(); i++) {
            Message message = messages.get(i);
            
            // åªè™•ç†ç”¨æˆ¶å’ŒåŠ©æ‰‹çš„è¨Šæ¯
            if (message instanceof UserMessage || message instanceof AssistantMessage) {
                
                Map<String, Object> metadata = new HashMap<>();
                metadata.put("conversationId", conversationId);
                metadata.put("messageType", message.getClass().getSimpleName());
                metadata.put("timestamp", LocalDateTime.now().toString());
                metadata.put("messageIndex", i);
                
                // æ·»åŠ ä¸Šä¸‹æ–‡è³‡è¨Š
                if (i > 0) {
                    Message previousMessage = messages.get(i - 1);
                    metadata.put("previousMessageType", previousMessage.getClass().getSimpleName());
                }
                
                Document document = new Document(
                    message.getContent(),
                    metadata
                );
                
                documents.add(document);
            }
        }
        
        return documents;
    }
    
    /**
     * æ‰‹å‹•è§¸ç™¼è¨˜æ†¶åŒæ­¥
     */
    public void forceSyncMemory(String conversationId) {
        log.info("Force syncing memory for conversation: {}", conversationId);
        syncConversationMemory(conversationId);
    }
    
    /**
     * æ¸…ç†éæœŸçš„é•·æœŸè¨˜æ†¶
     */
    @Scheduled(cron = "0 0 2 * * ?") // æ¯å¤©å‡Œæ™¨ 2 é»åŸ·è¡Œ
    public void cleanupExpiredMemories() {
        log.info("Starting cleanup of expired memories");
        
        try {
            // æŸ¥è©¢éæœŸçš„è¨˜æ†¶ï¼ˆè¶…é 30 å¤©ï¼‰
            LocalDateTime cutoffDate = LocalDateTime.now().minusDays(30);
            
            // é€™è£¡éœ€è¦æ ¹æ“šå¯¦éš›çš„å‘é‡è³‡æ–™åº«å¯¦ç¾ä¾†æŸ¥è©¢å’Œåˆªé™¤éæœŸè³‡æ–™
            // ç”±æ–¼ VectorStore ä»‹é¢çš„é™åˆ¶ï¼Œé€™è£¡æä¾›ä¸€å€‹æ¦‚å¿µæ€§çš„å¯¦ç¾
            
            log.info("Expired memories cleanup completed");
            
        } catch (Exception e) {
            log.error("Failed to cleanup expired memories", e);
        }
    }
}
```

---

## 6.7.4 æ™ºèƒ½è¨˜æ†¶æª¢ç´¢ç­–ç•¥

### å¤šå±¤æ¬¡è¨˜æ†¶æª¢ç´¢

```java
/**
 * æ™ºèƒ½è¨˜æ†¶æª¢ç´¢æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class SmartMemoryRetrievalService {
    
    private final VectorStore vectorStore;
    private final ChatMemory shortTermMemory;
    private final EmbeddingModel embeddingModel;
    
    /**
     * å¤šå±¤æ¬¡è¨˜æ†¶æª¢ç´¢
     */
    public MemoryRetrievalResult retrieveRelevantMemories(
            String conversationId, 
            String query,
            RetrievalOptions options) {
        
        log.debug("Retrieving memories for query: {}", query);
        
        // 1. çŸ­æœŸè¨˜æ†¶æª¢ç´¢
        List<Message> shortTermResults = retrieveShortTermMemories(conversationId, options.getShortTermLimit());
        
        // 2. é•·æœŸè¨˜æ†¶æª¢ç´¢
        List<Document> longTermResults = retrieveLongTermMemories(conversationId, query, options);
        
        // 3. è¨˜æ†¶èåˆå’Œæ’åº
        List<MemoryItem> fusedMemories = fuseAndRankMemories(shortTermResults, longTermResults, query);
        
        return MemoryRetrievalResult.builder()
            .conversationId(conversationId)
            .query(query)
            .shortTermMemories(shortTermResults)
            .longTermMemories(longTermResults)
            .fusedMemories(fusedMemories)
            .retrievalTime(LocalDateTime.now())
            .build();
    }
    
    /**
     * æª¢ç´¢çŸ­æœŸè¨˜æ†¶
     */
    private List<Message> retrieveShortTermMemories(String conversationId, int limit) {
        try {
            List<Message> allMessages = shortTermMemory.get(conversationId);
            return allMessages.size() > limit ? allMessages.subList(0, limit) : allMessages;
        } catch (Exception e) {
            log.warn("Failed to retrieve short-term memories for conversation: {}", conversationId, e);
            return Collections.emptyList();
        }
    }
    
    /**
     * æª¢ç´¢é•·æœŸè¨˜æ†¶
     */
    private List<Document> retrieveLongTermMemories(
            String conversationId, 
            String query, 
            RetrievalOptions options) {
        
        try {
            // å»ºç«‹æœå°‹è«‹æ±‚
            SearchRequest searchRequest = SearchRequest.builder()
                .query(query)
                .topK(options.getLongTermLimit())
                .similarityThreshold(options.getSimilarityThreshold())
                .filterExpression(String.format("conversationId == '%s'", conversationId))
                .build();
            
            return vectorStore.similaritySearch(searchRequest);
            
        } catch (Exception e) {
            log.warn("Failed to retrieve long-term memories for conversation: {}", conversationId, e);
            return Collections.emptyList();
        }
    }
    
    /**
     * èåˆå’Œæ’åºè¨˜æ†¶
     */
    private List<MemoryItem> fuseAndRankMemories(
            List<Message> shortTermMemories,
            List<Document> longTermMemories,
            String query) {
        
        List<MemoryItem> allMemories = new ArrayList<>();
        
        // è½‰æ›çŸ­æœŸè¨˜æ†¶
        for (int i = 0; i < shortTermMemories.size(); i++) {
            Message message = shortTermMemories.get(i);
            allMemories.add(MemoryItem.builder()
                .content(message.getContent())
                .type(MemoryType.SHORT_TERM)
                .relevanceScore(calculateShortTermRelevance(message, query, i))
                .timestamp(extractTimestamp(message))
                .metadata(message.getMetadata())
                .build());
        }
        
        // è½‰æ›é•·æœŸè¨˜æ†¶
        for (Document document : longTermMemories) {
            allMemories.add(MemoryItem.builder()
                .content(document.getContent())
                .type(MemoryType.LONG_TERM)
                .relevanceScore(extractSimilarityScore(document))
                .timestamp(extractTimestamp(document))
                .metadata(document.getMetadata())
                .build());
        }
        
        // æŒ‰ç›¸é—œæ€§æ’åº
        return allMemories.stream()
            .sorted(Comparator.comparingDouble(MemoryItem::getRelevanceScore).reversed())
            .collect(Collectors.toList());
    }
    
    /**
     * è¨ˆç®—çŸ­æœŸè¨˜æ†¶ç›¸é—œæ€§
     */
    private double calculateShortTermRelevance(Message message, String query, int position) {
        // åŸºæ–¼ä½ç½®çš„æ¬Šé‡ï¼ˆè¶Šè¿‘çš„è¨Šæ¯æ¬Šé‡è¶Šé«˜ï¼‰
        double positionWeight = 1.0 - (position * 0.1);
        
        // åŸºæ–¼å…§å®¹ç›¸ä¼¼æ€§çš„æ¬Šé‡ï¼ˆç°¡åŒ–å¯¦ç¾ï¼‰
        double contentSimilarity = calculateTextSimilarity(message.getContent(), query);
        
        return (positionWeight * 0.6) + (contentSimilarity * 0.4);
    }
    
    /**
     * ç°¡å–®çš„æ–‡æœ¬ç›¸ä¼¼æ€§è¨ˆç®—
     */
    private double calculateTextSimilarity(String text1, String text2) {
        // é€™è£¡ä½¿ç”¨ç°¡å–®çš„é—œéµå­—åŒ¹é…ï¼Œå¯¦éš›æ‡‰ç”¨ä¸­å¯ä»¥ä½¿ç”¨æ›´è¤‡é›œçš„ç®—æ³•
        String[] words1 = text1.toLowerCase().split("\\s+");
        String[] words2 = text2.toLowerCase().split("\\s+");
        
        Set<String> set1 = new HashSet<>(Arrays.asList(words1));
        Set<String> set2 = new HashSet<>(Arrays.asList(words2));
        
        Set<String> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        
        Set<String> union = new HashSet<>(set1);
        union.addAll(set2);
        
        return union.isEmpty() ? 0.0 : (double) intersection.size() / union.size();
    }
    
    private double extractSimilarityScore(Document document) {
        Object score = document.getMetadata().get("distance");
        if (score instanceof Number) {
            return 1.0 - ((Number) score).doubleValue(); // è½‰æ›è·é›¢ç‚ºç›¸ä¼¼æ€§
        }
        return 0.5; // é è¨­å€¼
    }
    
    private LocalDateTime extractTimestamp(Message message) {
        Object timestamp = message.getMetadata().get("timestamp");
        if (timestamp instanceof LocalDateTime) {
            return (LocalDateTime) timestamp;
        }
        return LocalDateTime.now();
    }
    
    private LocalDateTime extractTimestamp(Document document) {
        Object timestamp = document.getMetadata().get("timestamp");
        if (timestamp instanceof String) {
            try {
                return LocalDateTime.parse((String) timestamp);
            } catch (Exception e) {
                log.warn("Failed to parse timestamp: {}", timestamp);
            }
        }
        return LocalDateTime.now();
    }
}
```

### è¨˜æ†¶æª¢ç´¢é…ç½®å’Œçµæœé¡

```java
/**
 * è¨˜æ†¶æª¢ç´¢é¸é …
 */
@Data
@Builder
public class RetrievalOptions {
    
    /**
     * çŸ­æœŸè¨˜æ†¶é™åˆ¶
     */
    @Builder.Default
    private int shortTermLimit = 20;
    
    /**
     * é•·æœŸè¨˜æ†¶é™åˆ¶
     */
    @Builder.Default
    private int longTermLimit = 10;
    
    /**
     * ç›¸ä¼¼æ€§é–¾å€¼
     */
    @Builder.Default
    private double similarityThreshold = 0.7;
    
    /**
     * æ˜¯å¦åŒ…å«å…ƒæ•¸æ“š
     */
    @Builder.Default
    private boolean includeMetadata = true;
    
    /**
     * æ™‚é–“ç¯„åœéæ¿¾ï¼ˆå¤©ï¼‰
     */
    private Integer timeRangeDays;
}

/**
 * è¨˜æ†¶æª¢ç´¢çµæœ
 */
@Data
@Builder
public class MemoryRetrievalResult {
    private String conversationId;
    private String query;
    private List<Message> shortTermMemories;
    private List<Document> longTermMemories;
    private List<MemoryItem> fusedMemories;
    private LocalDateTime retrievalTime;
}

/**
 * è¨˜æ†¶é …ç›®
 */
@Data
@Builder
public class MemoryItem {
    private String content;
    private MemoryType type;
    private double relevanceScore;
    private LocalDateTime timestamp;
    private Map<String, Object> metadata;
}

enum MemoryType {
    SHORT_TERM,
    LONG_TERM
}
```

---

## 6.7.5 ä¼æ¥­ç´šè¨˜æ†¶ç®¡ç†ç³»çµ±

### è¨˜æ†¶ç®¡ç†æ§åˆ¶å™¨

```java
/**
 * è¨˜æ†¶ç®¡ç† REST API
 */
@RestController
@RequestMapping("/api/memory")
@RequiredArgsConstructor
@Slf4j
public class MemoryManagementController {
    
    private final HybridMemoryService hybridMemoryService;
    private final SmartMemoryRetrievalService retrievalService;
    private final MemorySyncService syncService;
    private final MemoryAnalyticsService analyticsService;
    
    /**
     * æ··åˆè¨˜æ†¶å°è©±
     */
    @PostMapping("/chat/{conversationId}")
    public ResponseEntity<ChatResponse> chat(
            @PathVariable String conversationId,
            @RequestBody ChatRequest request) {
        
        try {
            String response = hybridMemoryService.chatWithHybridMemory(
                conversationId, 
                request.getMessage()
            );
            
            return ResponseEntity.ok(ChatResponse.builder()
                .conversationId(conversationId)
                .message(response)
                .timestamp(LocalDateTime.now())
                .memoryType("hybrid")
                .build());
                
        } catch (Exception e) {
            log.error("Chat failed for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest()
                .body(ChatResponse.builder()
                    .conversationId(conversationId)
                    .error("Chat processing failed: " + e.getMessage())
                    .timestamp(LocalDateTime.now())
                    .build());
        }
    }
    
    /**
     * æ™ºèƒ½è¨˜æ†¶å°è©±
     */
    @PostMapping("/smart-chat/{conversationId}")
    public ResponseEntity<ChatResponse> smartChat(
            @PathVariable String conversationId,
            @RequestBody ChatRequest request) {
        
        try {
            String response = hybridMemoryService.chatWithSmartMemory(
                conversationId, 
                request.getMessage()
            );
            
            return ResponseEntity.ok(ChatResponse.builder()
                .conversationId(conversationId)
                .message(response)
                .timestamp(LocalDateTime.now())
                .memoryType("smart")
                .build());
                
        } catch (Exception e) {
            log.error("Smart chat failed for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * æª¢ç´¢è¨˜æ†¶
     */
    @PostMapping("/retrieve/{conversationId}")
    public ResponseEntity<MemoryRetrievalResult> retrieveMemories(
            @PathVariable String conversationId,
            @RequestBody MemoryRetrievalRequest request) {
        
        try {
            RetrievalOptions options = RetrievalOptions.builder()
                .shortTermLimit(request.getShortTermLimit())
                .longTermLimit(request.getLongTermLimit())
                .similarityThreshold(request.getSimilarityThreshold())
                .timeRangeDays(request.getTimeRangeDays())
                .build();
            
            MemoryRetrievalResult result = retrievalService.retrieveRelevantMemories(
                conversationId, 
                request.getQuery(), 
                options
            );
            
            return ResponseEntity.ok(result);
            
        } catch (Exception e) {
            log.error("Memory retrieval failed for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * æ‰‹å‹•åŒæ­¥è¨˜æ†¶
     */
    @PostMapping("/sync/{conversationId}")
    public ResponseEntity<ApiResponse> syncMemory(@PathVariable String conversationId) {
        try {
            syncService.forceSyncMemory(conversationId);
            return ResponseEntity.ok(ApiResponse.success("Memory synced successfully"));
        } catch (Exception e) {
            log.error("Memory sync failed for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Memory sync failed: " + e.getMessage()));
        }
    }
    
    /**
     * å–å¾—è¨˜æ†¶çµ±è¨ˆ
     */
    @GetMapping("/analytics/{conversationId}")
    public ResponseEntity<MemoryAnalytics> getMemoryAnalytics(@PathVariable String conversationId) {
        try {
            MemoryAnalytics analytics = analyticsService.getConversationAnalytics(conversationId);
            return ResponseEntity.ok(analytics);
        } catch (Exception e) {
            log.error("Failed to get memory analytics for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * æ¸…é™¤å°è©±è¨˜æ†¶
     */
    @DeleteMapping("/clear/{conversationId}")
    public ResponseEntity<ApiResponse> clearMemory(@PathVariable String conversationId) {
        try {
            // æ¸…é™¤çŸ­æœŸè¨˜æ†¶
            shortTermMemory.clear(conversationId);
            
            // æ¸…é™¤é•·æœŸè¨˜æ†¶ï¼ˆéœ€è¦æ ¹æ“šå¯¦éš›çš„ VectorStore å¯¦ç¾ä¾†é€²è¡Œåˆªé™¤æ“ä½œï¼‰
            // ç”±æ–¼ VectorStore ä»‹é¢ä¸æä¾›æŒ‰å°è©± ID åˆªé™¤çš„æ–¹æ³•
            // é€™è£¡å¯èƒ½éœ€è¦ä½¿ç”¨ç‰¹å®šçš„ VectorStore å¯¦ç¾ä¾†é”æˆ
            
            return ResponseEntity.ok(ApiResponse.success("Memory cleared successfully"));
        } catch (Exception e) {
            log.error("Failed to clear memory for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Memory clear failed: " + e.getMessage()));
        }
    }
}
```

### è¨˜æ†¶åˆ†ææœå‹™

```java
/**
 * è¨˜æ†¶åˆ†ææœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class MemoryAnalyticsService {
    
    private final ChatMemory shortTermMemory;
    private final VectorStore longTermMemory;
    private final MeterRegistry meterRegistry;
    
    /**
     * å–å¾—å°è©±è¨˜æ†¶åˆ†æ
     */
    public MemoryAnalytics getConversationAnalytics(String conversationId) {
        try {
            // çŸ­æœŸè¨˜æ†¶çµ±è¨ˆ
            List<Message> shortTermMessages = shortTermMemory.get(conversationId);
            int shortTermCount = shortTermMessages.size();
            
            // é•·æœŸè¨˜æ†¶çµ±è¨ˆï¼ˆç°¡åŒ–å¯¦ç¾ï¼‰
            int longTermCount = estimateLongTermMemoryCount(conversationId);
            
            // è¨˜æ†¶ä½¿ç”¨çµ±è¨ˆ
            MemoryUsageStats usageStats = calculateMemoryUsage(shortTermMessages);
            
            // è¨˜æ†¶å“è³ªåˆ†æ
            MemoryQualityMetrics qualityMetrics = analyzeMemoryQuality(conversationId);
            
            return MemoryAnalytics.builder()
                .conversationId(conversationId)
                .shortTermMemoryCount(shortTermCount)
                .longTermMemoryCount(longTermCount)
                .usageStats(usageStats)
                .qualityMetrics(qualityMetrics)
                .analysisTime(LocalDateTime.now())
                .build();
                
        } catch (Exception e) {
            log.error("Failed to analyze memory for conversation: {}", conversationId, e);
            throw new RuntimeException("Memory analysis failed", e);
        }
    }
    
    /**
     * ä¼°ç®—é•·æœŸè¨˜æ†¶æ•¸é‡
     */
    private int estimateLongTermMemoryCount(String conversationId) {
        try {
            // é€™è£¡éœ€è¦æ ¹æ“šå¯¦éš›çš„å‘é‡è³‡æ–™åº«å¯¦ç¾ä¾†æŸ¥è©¢
            // ç”±æ–¼ VectorStore ä»‹é¢çš„é™åˆ¶ï¼Œé€™è£¡æä¾›ä¸€å€‹æ¦‚å¿µæ€§çš„å¯¦ç¾
            SearchRequest searchRequest = SearchRequest.builder()
                .query("*")
                .topK(1000)
                .filterExpression(String.format("conversationId == '%s'", conversationId))
                .build();
            
            List<Document> results = longTermMemory.similaritySearch(searchRequest);
            return results.size();
            
        } catch (Exception e) {
            log.warn("Failed to estimate long-term memory count for conversation: {}", conversationId, e);
            return 0;
        }
    }
    
    /**
     * è¨ˆç®—è¨˜æ†¶ä½¿ç”¨çµ±è¨ˆ
     */
    private MemoryUsageStats calculateMemoryUsage(List<Message> messages) {
        int totalMessages = messages.size();
        int userMessages = 0;
        int assistantMessages = 0;
        int totalCharacters = 0;
        
        for (Message message : messages) {
            if (message instanceof UserMessage) {
                userMessages++;
            } else if (message instanceof AssistantMessage) {
                assistantMessages++;
            }
            totalCharacters += message.getContent().length();
        }
        
        double avgMessageLength = totalMessages > 0 ? (double) totalCharacters / totalMessages : 0;
        
        return MemoryUsageStats.builder()
            .totalMessages(totalMessages)
            .userMessages(userMessages)
            .assistantMessages(assistantMessages)
            .totalCharacters(totalCharacters)
            .averageMessageLength(avgMessageLength)
            .build();
    }
    
    /**
     * åˆ†æè¨˜æ†¶å“è³ª
     */
    private MemoryQualityMetrics analyzeMemoryQuality(String conversationId) {
        // é€™è£¡å¯ä»¥å¯¦ç¾æ›´è¤‡é›œçš„è¨˜æ†¶å“è³ªåˆ†æ
        // ä¾‹å¦‚ï¼šè¨˜æ†¶çš„ç›¸é—œæ€§ã€å®Œæ•´æ€§ã€æ™‚æ•ˆæ€§ç­‰
        
        return MemoryQualityMetrics.builder()
            .relevanceScore(0.85)  // ç›¸é—œæ€§åˆ†æ•¸
            .completenessScore(0.90)  // å®Œæ•´æ€§åˆ†æ•¸
            .freshnessScore(0.75)  // æ™‚æ•ˆæ€§åˆ†æ•¸
            .overallQuality(0.83)  // æ•´é«”å“è³ª
            .build();
    }
    
    /**
     * è¨˜éŒ„è¨˜æ†¶æ“ä½œçµ±è¨ˆ
     */
    public void recordMemoryOperation(String operation, String conversationId, boolean success) {
        meterRegistry.counter("memory.operations",
            "operation", operation,
            "conversation_id", conversationId,
            "success", String.valueOf(success))
            .increment();
    }
    
    /**
     * è¨˜éŒ„è¨˜æ†¶æª¢ç´¢æ™‚é–“
     */
    public void recordRetrievalTime(String memoryType, long timeMs) {
        meterRegistry.timer("memory.retrieval.time",
            "type", memoryType)
            .record(timeMs, TimeUnit.MILLISECONDS);
    }
}
```

---

## 6.7.6 æ¸¬è©¦å’Œé©—è­‰

### å‘é‡è¨˜æ†¶åŠŸèƒ½æ¸¬è©¦

```java
/**
 * å‘é‡è¨˜æ†¶åŠŸèƒ½æ¸¬è©¦
 */
@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class VectorMemoryIntegrationTest {
    
    @Autowired
    private HybridMemoryService hybridMemoryService;
    
    @Autowired
    private VectorStore vectorStore;
    
    @Autowired
    private ChatMemory shortTermMemory;
    
    private static final String TEST_CONVERSATION_ID = "test-vector-memory-001";
    
    @Test
    @Order(1)
    void testBasicVectorMemory() {
        // ç¬¬ä¸€è¼ªå°è©± - å»ºç«‹è¨˜æ†¶
        String response1 = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "æˆ‘å–œæ­¡å­¸ç¿’ Spring Boot æ¡†æ¶ï¼Œç‰¹åˆ¥æ˜¯å®ƒçš„è‡ªå‹•é…ç½®åŠŸèƒ½ã€‚"
        );
        
        assertThat(response1).isNotNull();
        
        // ç­‰å¾…è¨˜æ†¶åŒæ­¥
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // ç¬¬äºŒè¼ªå°è©± - æ¸¬è©¦è¨˜æ†¶å¬å›
        String response2 = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "æˆ‘ä¹‹å‰æåˆ°éæˆ‘å°å“ªå€‹æ¡†æ¶æ„Ÿèˆˆè¶£ï¼Ÿ"
        );
        
        assertThat(response2.toLowerCase()).contains("spring");
    }
    
    @Test
    @Order(2)
    void testSemanticMemoryRetrieval() {
        // å»ºç«‹èªç¾©ç›¸é—œçš„è¨˜æ†¶
        hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "æˆ‘æ­£åœ¨é–‹ç™¼ä¸€å€‹é›»å•†ç¶²ç«™ï¼Œä½¿ç”¨ Java å’Œ Spring æŠ€è¡“æ£§ã€‚"
        );
        
        hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "é€™å€‹å°ˆæ¡ˆéœ€è¦è™•ç†ç”¨æˆ¶è¨»å†Šã€å•†å“ç®¡ç†å’Œè¨‚å–®è™•ç†åŠŸèƒ½ã€‚"
        );
        
        // ç­‰å¾…è¨˜æ†¶åŒæ­¥
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // æ¸¬è©¦èªç¾©æœå°‹
        String response = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "é—œæ–¼æˆ‘çš„ç¶²ç«™é–‹ç™¼å°ˆæ¡ˆï¼Œä½ é‚„è¨˜å¾—ä»€éº¼ï¼Ÿ"
        );
        
        assertThat(response.toLowerCase())
            .containsAnyOf("é›»å•†", "java", "spring", "ç”¨æˆ¶", "å•†å“", "è¨‚å–®");
    }
    
    @Test
    @Order(3)
    void testMemoryPersistence() {
        // æ¸…é™¤çŸ­æœŸè¨˜æ†¶
        shortTermMemory.clear(TEST_CONVERSATION_ID);
        
        // æ¸¬è©¦é•·æœŸè¨˜æ†¶æ˜¯å¦ä»ç„¶å¯ç”¨
        String response = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "æˆ‘å€‘ä¹‹å‰è¨è«–éä»€éº¼æŠ€è¡“ï¼Ÿ"
        );
        
        // æ‡‰è©²èƒ½å¾é•·æœŸè¨˜æ†¶ä¸­æ‰¾åˆ°ç›¸é—œè³‡è¨Š
        assertThat(response).isNotNull();
    }
    
    @Test
    @Order(4)
    void testMemoryRetrievalWithThreshold() {
        // æ¸¬è©¦ç›¸ä¼¼æ€§é–¾å€¼éæ¿¾
        String response = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "å®Œå…¨ä¸ç›¸é—œçš„éš¨æ©Ÿå•é¡Œé—œæ–¼å¤©æ°£é å ±"
        );
        
        // ç”±æ–¼ç›¸ä¼¼æ€§é–¾å€¼ï¼Œæ‡‰è©²ä¸æœƒæª¢ç´¢åˆ°ä¸ç›¸é—œçš„è¨˜æ†¶
        assertThat(response).isNotNull();
    }
}
```

### è¨˜æ†¶æ•ˆèƒ½æ¸¬è©¦

```java
/**
 * è¨˜æ†¶æ•ˆèƒ½æ¸¬è©¦
 */
@SpringBootTest
class MemoryPerformanceTest {
    
    @Autowired
    private HybridMemoryService hybridMemoryService;
    
    @Autowired
    private SmartMemoryRetrievalService retrievalService;
    
    @Test
    void testMemoryRetrievalPerformance() {
        String conversationId = "perf-test-001";
        
        // å»ºç«‹å¤§é‡æ¸¬è©¦è¨˜æ†¶
        for (int i = 0; i < 100; i++) {
            hybridMemoryService.chatWithHybridMemory(
                conversationId,
                "æ¸¬è©¦è¨Šæ¯ " + i + " é—œæ–¼ Spring Boot é–‹ç™¼å’Œ Java ç¨‹å¼è¨­è¨ˆçš„å…§å®¹ã€‚"
            );
        }
        
        // æ¸¬è©¦æª¢ç´¢æ•ˆèƒ½
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        for (int i = 0; i < 50; i++) {
            RetrievalOptions options = RetrievalOptions.builder()
                .shortTermLimit(10)
                .longTermLimit(5)
                .similarityThreshold(0.7)
                .build();
            
            retrievalService.retrieveRelevantMemories(
                conversationId,
                "Spring Boot ç›¸é—œå•é¡Œ " + i,
                options
            );
        }
        
        stopWatch.stop();
        
        long totalTime = stopWatch.getTotalTimeMillis();
        double avgRetrievalTime = (double) totalTime / 50;
        
        log.info("Memory retrieval performance: 50 queries in {} ms (avg: {} ms/query)",
            totalTime, String.format("%.2f", avgRetrievalTime));
        
        // é©—è­‰æ•ˆèƒ½æŒ‡æ¨™
        assertThat(avgRetrievalTime).isLessThan(500); // å¹³å‡æª¢ç´¢æ™‚é–“å°æ–¼ 500ms
    }
    
    @Test
    void testConcurrentMemoryAccess() throws InterruptedException {
        String conversationId = "concurrent-test-001";
        int threadCount = 10;
        int operationsPerThread = 20;
        
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);
        AtomicInteger successCount = new AtomicInteger(0);
        
        for (int i = 0; i < threadCount; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    for (int j = 0; j < operationsPerThread; j++) {
                        String response = hybridMemoryService.chatWithHybridMemory(
                            conversationId,
                            String.format("Thread %d operation %d message", threadId, j)
                        );
                        
                        if (response != null && !response.isEmpty()) {
                            successCount.incrementAndGet();
                        }
                    }
                } catch (Exception e) {
                    log.error("Concurrent operation failed in thread {}", threadId, e);
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await(60, TimeUnit.SECONDS);
        executor.shutdown();
        
        int expectedOperations = threadCount * operationsPerThread;
        double successRate = (double) successCount.get() / expectedOperations;
        
        log.info("Concurrent memory access: {}/{} operations succeeded ({}%)",
            successCount.get(), expectedOperations, String.format("%.1f", successRate * 100));
        
        // é©—è­‰ä½µç™¼æ“ä½œæˆåŠŸç‡
        assertThat(successRate).isGreaterThan(0.95); // 95% ä»¥ä¸ŠæˆåŠŸç‡
    }
}
```

---

## ğŸ“ æœ¬ç« é‡é»å›é¡§

1. **å‘é‡è¨˜æ†¶ç†è§£**ï¼šæŒæ¡äº†å‘é‡è¨˜æ†¶èˆ‡å‚³çµ±è¨˜æ†¶çš„å·®ç•°å’Œå„ªå‹¢
2. **VectorStoreChatMemoryAdvisor æ‡‰ç”¨**ï¼šå­¸æœƒäº†ä½¿ç”¨å‘é‡è¨˜æ†¶é€²è¡Œèªç¾©æœå°‹
3. **æ··åˆè¨˜æ†¶æ¶æ§‹**ï¼šå¯¦ç¾äº†çŸ­æœŸå’Œé•·æœŸè¨˜æ†¶çš„å®Œç¾çµåˆ
4. **æ™ºèƒ½æª¢ç´¢ç­–ç•¥**ï¼šå»ºç«‹äº†å¤šå±¤æ¬¡çš„è¨˜æ†¶æª¢ç´¢å’Œèåˆæ©Ÿåˆ¶
5. **ä¼æ¥­ç´šç®¡ç†ç³»çµ±**ï¼šå®Œæˆäº†å®Œæ•´çš„è¨˜æ†¶ç®¡ç†å’Œåˆ†æå¹³å°

### æŠ€è¡“è¦é»ç¸½çµ

| æŠ€è¡“é» | é‡è¦æ€§ | å¯¦ç¾é›£åº¦ | ä¼æ¥­åƒ¹å€¼ |
|--------|--------|----------|----------|
| **VectorStoreChatMemoryAdvisor** | â­â­â­ | ä¸­ | èªç¾©è¨˜æ†¶ |
| **æ··åˆè¨˜æ†¶æ¶æ§‹** | â­â­â­ | é«˜ | å®Œæ•´è§£æ±ºæ–¹æ¡ˆ |
| **æ™ºèƒ½æª¢ç´¢ç­–ç•¥** | â­â­ | é«˜ | æª¢ç´¢æ•ˆèƒ½ |
| **è¨˜æ†¶åŒæ­¥æ©Ÿåˆ¶** | â­â­ | ä¸­ | è³‡æ–™ä¸€è‡´æ€§ |
| **ä¼æ¥­ç´šç®¡ç†** | â­â­ | ä¸­ | é‹ç¶­ä¾¿åˆ©æ€§ |

### æœ€ä½³å¯¦è¸å»ºè­°

1. **è¨˜æ†¶ç­–ç•¥é¸æ“‡**ï¼šæ ¹æ“šæŸ¥è©¢é¡å‹å‹•æ…‹é¸æ“‡çŸ­æœŸã€é•·æœŸæˆ–æ··åˆè¨˜æ†¶ç­–ç•¥
2. **ç›¸ä¼¼æ€§é–¾å€¼èª¿æ•´**ï¼šæ ¹æ“šæ‡‰ç”¨å ´æ™¯èª¿æ•´å‘é‡æœå°‹çš„ç›¸ä¼¼æ€§é–¾å€¼
3. **è¨˜æ†¶åŒæ­¥é »ç‡**ï¼šå¹³è¡¡è¨˜æ†¶åŒæ­¥çš„å³æ™‚æ€§å’Œç³»çµ±æ•ˆèƒ½
4. **æ•ˆèƒ½ç›£æ§**ï¼šå»ºç«‹å®Œæ•´çš„è¨˜æ†¶æ“ä½œç›£æ§å’Œæ•ˆèƒ½åˆ†æ
5. **è³‡æ–™æ¸…ç†ç­–ç•¥**ï¼šå®šæœŸæ¸…ç†éæœŸå’Œä½å“è³ªçš„è¨˜æ†¶è³‡æ–™

### ç¬¬å…­ç« å®Œæ•´ç¸½çµ

æ­å–œæ‚¨å®Œæˆäº†ç¬¬å…­ç« ã€Œè®“ ChatBot ä¸å†é‡‘é­šè…¦ã€çš„å®Œæ•´å­¸ç¿’ï¼æœ¬ç« æ¶µè“‹äº†ï¼š

- **6.1 è¨˜æ†¶ç³»çµ±æ¦‚è¿°**ï¼šç†è§£äº† AI è¨˜æ†¶çš„é‡è¦æ€§å’Œé¡å‹
- **6.2 åŸºæœ¬è¨˜æ†¶å¯¦ç¾**ï¼šæŒæ¡äº† Advisor ç³»çµ±å’Œå°è©±è¨˜æ†¶
- **6.3 å®˜æ–¹è¨˜æ†¶ç³»çµ±**ï¼šå­¸æœƒäº† Spring AI å®˜æ–¹è¨˜æ†¶ API
- **6.4 éˆå¼å¢å¼·å™¨**ï¼šå¯¦ç¾äº†è¤‡é›œçš„ Advisor çµ„åˆå’Œè‡ªå®šç¾©
- **6.5 æ’ä»¶é–‹ç™¼**ï¼šå»ºç«‹äº†å¯æ“´å±•çš„æ’ä»¶ç³»çµ±
- **6.6 Neo4j å®‰è£**ï¼šéƒ¨ç½²äº†ä¼æ¥­ç´šå‘é‡è³‡æ–™åº«
- **6.7 å‘é‡è¨˜æ†¶**ï¼šå¯¦ç¾äº†åŸºæ–¼èªç¾©æœå°‹çš„é•·æœŸè¨˜æ†¶

é€šéæœ¬ç« çš„å­¸ç¿’ï¼Œæ‚¨å·²ç¶“æŒæ¡äº†å»ºç«‹æ™ºèƒ½å°è©±ç³»çµ±çš„å®Œæ•´æŠ€è¡“æ£§ï¼Œèƒ½å¤ é–‹ç™¼å‡ºå…·æœ‰çœŸæ­£ã€Œè¨˜æ†¶ã€èƒ½åŠ›çš„ AI æ‡‰ç”¨ï¼

---

**åƒè€ƒè³‡æ–™ï¼š**
- [Spring AI Vector Store Documentation](https://docs.spring.io/spring-ai/reference/api/vectordbs.html)
- [VectorStoreChatMemoryAdvisor API](https://docs.spring.io/spring-ai/reference/api/advisors.html)
- [Neo4j Vector Search](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/)
- [Semantic Search Best Practices](https://www.pinecone.io/learn/semantic-search/)
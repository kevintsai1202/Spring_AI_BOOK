# 8.2 æé«˜RAGæº–ç¢ºç‡å¾Embeddingæ›èµ·

> **æœ¬ç« é‡é»**ï¼šæ·±å…¥æ¢è¨å¦‚ä½•é€šéå„ªåŒ– Embedding æ¨¡å‹ä¾†æå‡ RAG ç³»çµ±çš„æº–ç¢ºç‡ï¼ŒæŒæ¡ä¸åŒ Embedding æ¨¡å‹çš„ç‰¹æ€§ã€é¸æ“‡ç­–ç•¥å’Œé…ç½®æ–¹æ³•ï¼Œå»ºç«‹é«˜æ•ˆçš„å‘é‡æª¢ç´¢ç³»çµ±ã€‚

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬ç« å­¸ç¿’å¾Œï¼Œæ‚¨å°‡èƒ½å¤ ï¼š

- ğŸ¯ **ç†è§£ Embedding é‡è¦æ€§**ï¼šæŒæ¡ Embedding åœ¨ RAG ç³»çµ±ä¸­çš„æ ¸å¿ƒä½œç”¨
- ğŸ¯ **è©•ä¼°æ¨¡å‹æ€§èƒ½**ï¼šèƒ½å¤ æ¯”è¼ƒä¸åŒ Embedding æ¨¡å‹çš„æ€§èƒ½è¡¨ç¾
- ğŸ¯ **é¸æ“‡æœ€ä½³æ¨¡å‹**ï¼šæ ¹æ“šæ¥­å‹™éœ€æ±‚é¸æ“‡æœ€é©åˆçš„ Embedding æ¨¡å‹
- ğŸ¯ **å„ªåŒ–é…ç½®ç­–ç•¥**ï¼šå¯¦ç¾ Embedding æ¨¡å‹çš„æœ€ä½³é…ç½®å’Œèª¿å„ª
- ğŸ¯ **ç›£æ§æ¨¡å‹æ•ˆæœ**ï¼šå»ºç«‹ Embedding æ•ˆæœçš„ç›£æ§å’Œè©•ä¼°æ©Ÿåˆ¶

---

## 8.2.1 ç‚ºä»€éº¼ Embedding æ˜¯ RAG çš„é—œéµï¼Ÿ

### Embedding åœ¨ RAG ä¸­çš„ä½œç”¨

**RAG ç³»çµ±çš„æ ¸å¿ƒæµç¨‹**ï¼š
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RAG System Pipeline                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç”¨æˆ¶æŸ¥è©¢                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  "ä»€éº¼æ˜¯æ©Ÿå™¨å­¸ç¿’ï¼Ÿ"                                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                            â†“                                â”‚
â”‚  æŸ¥è©¢å‘é‡åŒ– (Query Embedding)                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Embedding Model: text-embedding-3-small                â”‚ â”‚
â”‚  â”‚  Vector: [0.1, -0.3, 0.8, ..., 0.2] (1536ç¶­)          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                            â†“                                â”‚
â”‚  å‘é‡ç›¸ä¼¼åº¦æª¢ç´¢                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â€¢ è¨ˆç®—æŸ¥è©¢å‘é‡èˆ‡æ–‡æª”å‘é‡çš„ç›¸ä¼¼åº¦                       â”‚ â”‚
â”‚  â”‚  â€¢ é¤˜å¼¦ç›¸ä¼¼åº¦ = cos(query_vec, doc_vec)                â”‚ â”‚
â”‚  â”‚  â€¢ è¿”å› Top-K æœ€ç›¸ä¼¼çš„æ–‡æª”                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                            â†“                                â”‚
â”‚  ä¸Šä¸‹æ–‡ç”Ÿæˆ                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  åŸºæ–¼æª¢ç´¢åˆ°çš„ç›¸é—œæ–‡æª”ï¼ŒLLM ç”Ÿæˆæœ€çµ‚ç­”æ¡ˆ                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Embedding å“è³ªå° RAG çš„å½±éŸ¿

#### 1. æª¢ç´¢ç²¾åº¦å½±éŸ¿
- **é«˜å“è³ª Embedding**ï¼šèƒ½å¤ æº–ç¢ºæ•æ‰èªç¾©ç›¸ä¼¼æ€§ï¼Œæª¢ç´¢åˆ°çœŸæ­£ç›¸é—œçš„æ–‡æª”
- **ä½å“è³ª Embedding**ï¼šèªç¾©ç†è§£ä¸æº–ç¢ºï¼Œæª¢ç´¢çµæœåé›¢ç”¨æˆ¶æ„åœ–

#### 2. å¤šèªè¨€æ”¯æ´
- **å¤šèªè¨€æ¨¡å‹**ï¼šæ”¯æ´ç¹é«”ä¸­æ–‡ã€è‹±æ–‡ç­‰å¤šç¨®èªè¨€çš„èªç¾©ç†è§£
- **å–®èªè¨€æ¨¡å‹**ï¼šåƒ…æ”¯æ´ç‰¹å®šèªè¨€ï¼Œé™åˆ¶æ‡‰ç”¨ç¯„åœ

#### 3. é ˜åŸŸé©æ‡‰æ€§
- **é€šç”¨æ¨¡å‹**ï¼šé©ç”¨æ–¼ä¸€èˆ¬æ€§å•ç­”ï¼Œä½†åœ¨å°ˆæ¥­é ˜åŸŸå¯èƒ½è¡¨ç¾ä¸ä½³
- **é ˜åŸŸç‰¹åŒ–æ¨¡å‹**ï¼šåœ¨ç‰¹å®šé ˜åŸŸï¼ˆå¦‚é†«ç™‚ã€æ³•å¾‹ï¼‰è¡¨ç¾æ›´å¥½

#### 4. è¨ˆç®—æ•ˆç‡
- **æ¨¡å‹å¤§å°**ï¼šå½±éŸ¿æ¨ç†é€Ÿåº¦å’Œè³‡æºæ¶ˆè€—
- **å‘é‡ç¶­åº¦**ï¼šå½±éŸ¿å­˜å„²ç©ºé–“å’Œæª¢ç´¢é€Ÿåº¦

---

## 8.2.2 Embedding æ¨¡å‹æ•ˆèƒ½æ¯”è¼ƒ

### ç¹é«”ä¸­æ–‡ Embedding è©•æ¸¬çµæœ

æ ¹æ“šæœ€æ–°çš„ç¹é«”ä¸­æ–‡ Embedding è©•æ¸¬çµæœï¼Œä¸åŒæ¨¡å‹çš„è¡¨ç¾å·®ç•°å¾ˆå¤§ï¼š

#### OpenAI Embedding æ¨¡å‹æ¯”è¼ƒ

| æ¨¡å‹ | æ’å | æº–ç¢ºç‡ | åƒ¹æ ¼ | Dimensions | ç‰¹é» |
|------|------|--------|------|------------|------|
| text-embedding-ada-002 | 24 | ~83% | è¼ƒé«˜ | 1536 | èˆŠç‰ˆé è¨­æ¨¡å‹ |
| text-embedding-3-small | 23 | ~84% | ä¾¿å®œ5å€ | 512-1536 | æ€§åƒ¹æ¯”é«˜ |
| text-embedding-3-large | 13 | ~90% | æœ€è²´ | 256-3072 | é«˜æº–ç¢ºç‡ |

#### å…¶ä»–å„ªç§€æ¨¡å‹

| æ¨¡å‹ | æ’å | æº–ç¢ºç‡ | ç‰¹é» |
|------|------|--------|------|
| voyage-multilingual-2 | 1 | ~97% | å¤šèªè¨€æœ€ä½³ |
| multilingual-e5-small | 4 | ~92% | é–‹æºï¼Œ384ç¶­åº¦ |
| multilingual-e5-large | 6 | ~94% | é–‹æºï¼Œ1024ç¶­åº¦ |

> **é‡è¦è§€å¿µ**ï¼šdimensions ä¸æ˜¯è¶Šé«˜å°±è¶Šå¥½ï¼æ›´é«˜çš„ç¶­åº¦æ„å‘³è‘—æ›´å¤šçš„è¨ˆç®—æˆæœ¬å’Œå„²å­˜ç©ºé–“ã€‚

### æ¨¡å‹é¸æ“‡æ±ºç­–çŸ©é™£

| ä½¿ç”¨å ´æ™¯ | æ¨è–¦æ¨¡å‹ | ç†ç”± |
|----------|----------|------|
| **æˆæœ¬æ•æ„Ÿ** | text-embedding-3-small | æ€§åƒ¹æ¯”æœ€é«˜ï¼Œæº–ç¢ºç‡å¯æ¥å— |
| **é«˜ç²¾åº¦éœ€æ±‚** | text-embedding-3-large | æœ€é«˜æº–ç¢ºç‡ï¼Œé©åˆé—œéµæ‡‰ç”¨ |
| **å¤šèªè¨€æ”¯æ´** | voyage-multilingual-2 | å¤šèªè¨€è¡¨ç¾æœ€ä½³ |
| **é–‹æºéœ€æ±‚** | multilingual-e5-large | é–‹æºï¼Œç„¡ API èª¿ç”¨æˆæœ¬ |
| **å¿«é€Ÿæª¢ç´¢** | multilingual-e5-small | ä½ç¶­åº¦ï¼Œæª¢ç´¢é€Ÿåº¦å¿« |

---

## 8.2.3 Spring AI 1.1-SNAPSHOT Embedding é…ç½®

### æ·»åŠ ä¾è³´

é¦–å…ˆæ·»åŠ  Spring AI OpenAI Starter ä¾è³´ï¼š

```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
</dependency>
```

### OpenAI Embedding é…ç½®

æœ€ç°¡å–®çš„å‡ç´šæ–¹å¼æ˜¯ä½¿ç”¨æ›´å¥½çš„ OpenAI æ¨¡å‹ï¼š

```yaml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      chat:
        options:
          model: gpt-4o-mini
          temperature: 0.7
      embedding:
        options:
          model: text-embedding-3-small  # å‡ç´šè‡ªé è¨­çš„ text-embedding-ada-002
          dimensions: 1024  # å¯é¸ï¼šåƒ…æ”¯æ´ text-embedding-3 ç³»åˆ—
```

### ä½¿ç”¨è‡ªå‹•é…ç½®çš„æ–¹å¼ï¼ˆæ¨è–¦ï¼‰

Spring AI æä¾›äº†è‡ªå‹•é…ç½®ï¼Œå»ºè­°ä½¿ç”¨é…ç½®æ–‡ä»¶æ–¹å¼ï¼š

```yaml
# application.yml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      embedding:
        options:
          model: text-embedding-3-small
          dimensions: 1024
```

### å¤šæ¨¡å‹é…ç½®ç­–ç•¥ï¼ˆé€²éšç”¨æ³•ï¼‰

```java
/**
 * å¤š Embedding æ¨¡å‹é…ç½®
 * æ³¨æ„ï¼šé€™æ˜¯é€²éšç”¨æ³•ï¼Œé€šå¸¸å»ºè­°ä½¿ç”¨è‡ªå‹•é…ç½®
 */
@Configuration
public class MultiEmbeddingConfiguration {
    
    /**
     * ä½¿ç”¨ EmbeddingRequest å‹•æ…‹è¨­å®šé¸é …çš„æ–¹å¼ï¼ˆæ¨è–¦ï¼‰
     */
    @Service
    @RequiredArgsConstructor
    public static class DynamicEmbeddingService {
        
        private final EmbeddingModel embeddingModel; // ä½¿ç”¨è‡ªå‹•é…ç½®çš„ EmbeddingModel
        
        /**
         * é«˜ç²¾åº¦ Embedding
         */
        public EmbeddingResponse highAccuracyEmbed(List<String> texts) {
            return embeddingModel.call(
                new EmbeddingRequest(texts,
                    OpenAiEmbeddingOptions.builder()
                        .model("text-embedding-3-large")
                        .dimensions(3072)
                        .build()));
        }
        
        /**
         * æˆæœ¬æ•ˆç›Š Embedding
         */
        public EmbeddingResponse costEffectiveEmbed(List<String> texts) {
            return embeddingModel.call(
                new EmbeddingRequest(texts,
                    OpenAiEmbeddingOptions.builder()
                        .model("text-embedding-3-small")
                        .dimensions(512)
                        .build()));
        }
        
        /**
         * æ¨™æº– Embeddingï¼ˆä½¿ç”¨é…ç½®æ–‡ä»¶ä¸­çš„é è¨­å€¼ï¼‰
         */
        public float[] standardEmbed(String text) {
            return embeddingModel.embed(text);
        }
        
        /**
         * æ‰¹é‡ Embedding
         */
        public List<float[]> batchEmbed(List<String> texts) {
            return embeddingModel.embed(texts);
        }
    }
}
```

### æ™ºèƒ½æ¨¡å‹é¸æ“‡æœå‹™

```java
/**
 * æ™ºèƒ½ Embedding æ¨¡å‹é¸æ“‡æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class SmartEmbeddingService {
    
    // ä½¿ç”¨è‡ªå‹•é…ç½®çš„ EmbeddingModel
    private final EmbeddingModel embeddingModel;
    
    private final EmbeddingModelPerformanceMonitor performanceMonitor;
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * æ™ºèƒ½é¸æ“‡æ¨¡å‹ä¸¦ç”Ÿæˆå‘é‡
     */
    public float[] embedWithSmartSelection(String text, EmbeddingContext context) {
        
        // 1. æ ¹æ“šä¸Šä¸‹æ–‡é¸æ“‡æ¨¡å‹é¸é …
        OpenAiEmbeddingOptions options = selectModelOptions(context);
        
        // 2. æª¢æŸ¥å¿«å–
        String cacheKey = generateCacheKey(text, options.getModel());
        float[] cachedEmbedding = getCachedEmbedding(cacheKey);
        
        if (cachedEmbedding != null) {
            log.debug("Using cached embedding for text: {}", text.substring(0, Math.min(50, text.length())));
            return cachedEmbedding;
        }
        
        // 3. ç”Ÿæˆ Embedding - ä½¿ç”¨ Spring AI å®˜æ–¹ API 
        long startTime = System.currentTimeMillis();
        EmbeddingResponse response = embeddingModel.call(
            new EmbeddingRequest(List.of(text), options));
        float[] embedding = response.getResults().get(0).getOutput();
        long duration = System.currentTimeMillis() - startTime;
        
        // 4. å¿«å–çµæœ
        cacheEmbedding(cacheKey, embedding);
        
        // 5. è¨˜éŒ„æ•ˆèƒ½æŒ‡æ¨™
        performanceMonitor.recordEmbeddingMetrics(
            options.getModel(), 
            text.length(), 
            duration,
            embedding.length  // ä¿®æ­£ï¼šfloat[] ä½¿ç”¨ length å±¬æ€§
        );
        
        return embedding;
    }
    
    /**
     * æ ¹æ“šä¸Šä¸‹æ–‡é¸æ“‡æ¨¡å‹é¸é …
     */
    private OpenAiEmbeddingOptions selectModelOptions(EmbeddingContext context) {
        
        // é«˜ç²¾åº¦éœ€æ±‚
        if (context.isHighAccuracyRequired()) {
            log.debug("Using high accuracy embedding options");
            return OpenAiEmbeddingOptions.builder()
                .model("text-embedding-3-large")
                .dimensions(3072)
                .build();
        }
        
        // æˆæœ¬æ•æ„Ÿ
        if (context.isCostSensitive() || context.isBatchProcessing()) {
            log.debug("Using cost effective embedding options");
            return OpenAiEmbeddingOptions.builder()
                .model("text-embedding-3-small")
                .dimensions(512)
                .build();
        }
        
        // é è¨­ä½¿ç”¨æ¨™æº–é…ç½®
        log.debug("Using standard embedding options");
        return OpenAiEmbeddingOptions.builder()
            .model("text-embedding-3-small")
            .dimensions(1024)
            .build();
    }
    
    /**
     * æ‰¹é‡ Embedding è™•ç†
     */
    public Map<String, float[]> batchEmbed(List<String> texts, EmbeddingContext context) {
        
        Map<String, float[]> results = new HashMap<>();
        
        // æª¢æŸ¥å¿«å–
        Map<String, float[]> cachedResults = getCachedBatchEmbeddings(texts, context);
        results.putAll(cachedResults);
        
        // éæ¿¾å‡ºéœ€è¦è¨ˆç®—çš„æ–‡æœ¬
        List<String> uncachedTexts = texts.stream()
            .filter(text -> !results.containsKey(text))
            .collect(Collectors.toList());
        
        if (!uncachedTexts.isEmpty()) {
            // é¸æ“‡é©åˆæ‰¹é‡è™•ç†çš„é¸é …
            EmbeddingContext batchContext = context.toBuilder()
                .batchProcessing(true)
                .costSensitive(true)
                .build();
            
            OpenAiEmbeddingOptions batchOptions = selectModelOptions(batchContext);
            
            // æ‰¹é‡è™•ç† - ä½¿ç”¨ Spring AI å®˜æ–¹ API
            EmbeddingResponse batchResponse = embeddingModel.call(
                new EmbeddingRequest(uncachedTexts, batchOptions));
            
            // å°‡çµæœå°æ‡‰å›æ–‡æœ¬
            List<Embedding> embeddings = batchResponse.getResults();
            for (int i = 0; i < uncachedTexts.size(); i++) {
                String text = uncachedTexts.get(i);
                float[] embedding = embeddings.get(i).getOutput();
                results.put(text, embedding);
                
                // å¿«å–çµæœ
                String cacheKey = generateCacheKey(text, batchOptions.getModel());
                cacheEmbedding(cacheKey, embedding);
            }
        }
        
        return results;
    }
    
    /**
     * ç”Ÿæˆå¿«å–éµ
     */
    private String generateCacheKey(String text, String modelName) {
        return String.format("embedding:%s:%s", 
            modelName, 
            DigestUtils.md5DigestAsHex(text.getBytes()));
    }
    
    /**
     * ç²å–å¿«å–çš„ Embedding
     */
    @SuppressWarnings("unchecked")
    private float[] getCachedEmbedding(String cacheKey) {
        try {
            return (float[]) redisTemplate.opsForValue().get(cacheKey);
        } catch (Exception e) {
            log.warn("Failed to get cached embedding: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * å¿«å– Embedding
     */
    private void cacheEmbedding(String cacheKey, float[] embedding) {
        try {
            redisTemplate.opsForValue().set(cacheKey, embedding, Duration.ofHours(24));
        } catch (Exception e) {
            log.warn("Failed to cache embedding: {}", e.getMessage());
        }
    }
    
    /**
     * ç²å–æ‰¹é‡å¿«å–çµæœ
     */
    private Map<String, float[]> getCachedBatchEmbeddings(List<String> texts, EmbeddingContext context) {
        Map<String, float[]> cachedResults = new HashMap<>();
        
        for (String text : texts) {
            String cacheKey = generateCacheKey(text, "primary"); // ç°¡åŒ–å¯¦ç¾
            float[] cached = getCachedEmbedding(cacheKey);
            if (cached != null) {
                cachedResults.put(text, cached);
            }
        }
        
        return cachedResults;
    }
}

/**
 * Embedding ä¸Šä¸‹æ–‡
 */
@Data
@Builder(toBuilder = true)
public class EmbeddingContext {
    private boolean highAccuracyRequired;
    private boolean costSensitive;
    private boolean batchProcessing;
    private String domain;  // é ˜åŸŸï¼šgeneral, medical, legal, etc.
    private String language; // èªè¨€ï¼šzh-TW, en, etc.
    private int priority;   // å„ªå…ˆç´šï¼š1-10
}
```

### æ•ˆèƒ½ç›£æ§æœå‹™

```java
/**
 * Embedding æ¨¡å‹æ•ˆèƒ½ç›£æ§
 */
@Service
@Slf4j
public class EmbeddingModelPerformanceMonitor {
    
    private final MeterRegistry meterRegistry;
    private final RedisTemplate<String, Object> redisTemplate;
    
    public EmbeddingModelPerformanceMonitor(MeterRegistry meterRegistry,
                                           RedisTemplate<String, Object> redisTemplate) {
        this.meterRegistry = meterRegistry;
        this.redisTemplate = redisTemplate;
    }
    
    /**
     * è¨˜éŒ„ Embedding æŒ‡æ¨™
     */
    public void recordEmbeddingMetrics(String modelName, int textLength, 
                                     long duration, int embeddingDimensions) {
        
        // è¨˜éŒ„è™•ç†æ™‚é–“
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("embedding.processing.time")
            .tag("model", modelName)
            .register(meterRegistry));
        
        // è¨˜éŒ„æ–‡æœ¬é•·åº¦
        Counter.builder("embedding.text.length")
            .tag("model", modelName)
            .register(meterRegistry)
            .increment(textLength);
        
        // è¨˜éŒ„å‘é‡ç¶­åº¦
        Counter.builder("embedding.dimensions")
            .tag("model", modelName)
            .register(meterRegistry)
            .increment(embeddingDimensions);
        
        // è¨˜éŒ„è™•ç†é€Ÿåº¦ï¼ˆå­—ç¬¦/ç§’ï¼‰
        double charactersPerSecond = duration > 0 ? textLength / (duration / 1000.0) : 0;
        Counter.builder("embedding.processing.speed")
            .tag("model", modelName)
            .register(meterRegistry)
            .increment(charactersPerSecond);
        
        // æ›´æ–°æ¨¡å‹ä½¿ç”¨çµ±è¨ˆ
        updateModelUsageStats(modelName, duration, textLength);
    }
    
    /**
     * æ›´æ–°æ¨¡å‹ä½¿ç”¨çµ±è¨ˆ
     */
    private void updateModelUsageStats(String modelName, long duration, int textLength) {
        try {
            String statsKey = "embedding:stats:" + modelName;
            
            // ç²å–ç¾æœ‰çµ±è¨ˆ
            ModelStats stats = getModelStats(statsKey);
            
            // æ›´æ–°çµ±è¨ˆ
            stats.incrementUsageCount();
            stats.addProcessingTime(duration);
            stats.addTextLength(textLength);
            stats.updateLastUsed();
            
            // ä¿å­˜çµ±è¨ˆ
            redisTemplate.opsForValue().set(statsKey, stats, Duration.ofDays(30));
            
        } catch (Exception e) {
            log.error("Failed to update model usage stats", e);
        }
    }
    
    /**
     * ç²å–æ¨¡å‹çµ±è¨ˆ
     */
    @SuppressWarnings("unchecked")
    private ModelStats getModelStats(String statsKey) {
        try {
            ModelStats stats = (ModelStats) redisTemplate.opsForValue().get(statsKey);
            return stats != null ? stats : new ModelStats();
        } catch (Exception e) {
            log.warn("Failed to get model stats, creating new: {}", e.getMessage());
            return new ModelStats();
        }
    }
    
    /**
     * ç²å–æ¨¡å‹æ•ˆèƒ½å ±å‘Š
     */
    public ModelPerformanceReport getPerformanceReport(String modelName) {
        String statsKey = "embedding:stats:" + modelName;
        ModelStats stats = getModelStats(statsKey);
        
        return ModelPerformanceReport.builder()
            .modelName(modelName)
            .totalUsage(stats.getUsageCount())
            .averageProcessingTime(stats.getAverageProcessingTime())
            .averageTextLength(stats.getAverageTextLength())
            .processingSpeed(stats.getProcessingSpeed())
            .lastUsed(stats.getLastUsed())
            .build();
    }
    
    /**
     * å®šæœŸæ›´æ–°æ¨¡å‹æ’å
     */
    @Scheduled(fixedRate = 3600000) // æ¯å°æ™‚åŸ·è¡Œä¸€æ¬¡
    public void updateModelRankings() {
        try {
            List<String> modelNames = Arrays.asList(
                "text-embedding-3-small",
                "text-embedding-3-large",
                "text-embedding-ada-002"
            );
            
            List<ModelPerformanceReport> reports = modelNames.stream()
                .map(this::getPerformanceReport)
                .sorted((a, b) -> {
                    // ç¶œåˆè©•åˆ†ï¼šé€Ÿåº¦ + ä½¿ç”¨é‡
                    double scoreA = a.getProcessingSpeed() * 0.6 + a.getTotalUsage() * 0.4;
                    double scoreB = b.getProcessingSpeed() * 0.6 + b.getTotalUsage() * 0.4;
                    return Double.compare(scoreB, scoreA);
                })
                .collect(Collectors.toList());
            
            List<String> rankedModels = reports.stream()
                .map(ModelPerformanceReport::getModelName)
                .collect(Collectors.toList());
            
            redisTemplate.opsForValue().set("embedding:model:rankings", rankedModels,
                Duration.ofHours(2));
            
            log.info("Updated embedding model rankings: {}", rankedModels);
            
        } catch (Exception e) {
            log.error("Failed to update model rankings", e);
        }
    }
    
    /**
     * ç²å–æ¨è–¦æ¨¡å‹
     */
    @SuppressWarnings("unchecked")
    public String getRecommendedModel() {
        try {
            List<String> rankings = (List<String>) redisTemplate.opsForValue()
                .get("embedding:model:rankings");
            
            return (rankings != null && !rankings.isEmpty()) ?
                rankings.get(0) : "text-embedding-3-small";
                
        } catch (Exception e) {
            log.warn("Failed to get recommended model, using default", e);
            return "text-embedding-3-small";
        }
    }
}

/**
 * æ¨¡å‹çµ±è¨ˆè³‡æ–™
 */
@Data
@NoArgsConstructor
public class ModelStats {
    private long usageCount = 0;
    private long totalProcessingTime = 0;
    private long totalTextLength = 0;
    private LocalDateTime lastUsed;
    
    public void incrementUsageCount() {
        this.usageCount++;
    }
    
    public void addProcessingTime(long duration) {
        this.totalProcessingTime += duration;
    }
    
    public void addTextLength(int length) {
        this.totalTextLength += length;
    }
    
    public void updateLastUsed() {
        this.lastUsed = LocalDateTime.now();
    }
    
    public double getAverageProcessingTime() {
        return usageCount > 0 ? (double) totalProcessingTime / usageCount : 0;
    }
    
    public double getAverageTextLength() {
        return usageCount > 0 ? (double) totalTextLength / usageCount : 0;
    }
    
    public double getProcessingSpeed() {
        return totalProcessingTime > 0 ? 
            (double) totalTextLength / (totalProcessingTime / 1000.0) : 0;
    }
}

/**
 * æ¨¡å‹æ•ˆèƒ½å ±å‘Š
 */
@Data
@Builder
public class ModelPerformanceReport {
    private String modelName;
    private long totalUsage;
    private double averageProcessingTime;
    private double averageTextLength;
    private double processingSpeed;
    private LocalDateTime lastUsed;
}
```

---

## 8.2.4 Embedding å„ªåŒ–æœ€ä½³å¯¦è¸

### æ–‡æœ¬é è™•ç†å„ªåŒ–

```java
/**
 * Embedding æ–‡æœ¬é è™•ç†æœå‹™
 */
@Service
@Slf4j
public class EmbeddingTextPreprocessor {
    
    /**
     * é è™•ç†æ–‡æœ¬ä»¥æå‡ Embedding å“è³ª
     */
    public String preprocessForEmbedding(String text, PreprocessingOptions options) {
        
        if (text == null || text.trim().isEmpty()) {
            return "";
        }
        
        String processed = text;
        
        // 1. æ¸…ç†ç‰¹æ®Šå­—ç¬¦
        if (options.isCleanSpecialChars()) {
            processed = cleanSpecialCharacters(processed);
        }
        
        // 2. æ­£è¦åŒ–ç©ºç™½å­—ç¬¦
        if (options.isNormalizeWhitespace()) {
            processed = normalizeWhitespace(processed);
        }
        
        // 3. ç§»é™¤éçŸ­æˆ–éé•·çš„æ–‡æœ¬
        if (options.isFilterByLength()) {
            if (processed.length() < options.getMinLength() || 
                processed.length() > options.getMaxLength()) {
                log.debug("Text filtered by length: {} chars", processed.length());
                return "";
            }
        }
        
        // 4. èªè¨€æª¢æ¸¬å’Œéæ¿¾
        if (options.isFilterByLanguage()) {
            String detectedLanguage = detectLanguage(processed);
            if (!options.getAllowedLanguages().contains(detectedLanguage)) {
                log.debug("Text filtered by language: {}", detectedLanguage);
                return "";
            }
        }
        
        // 5. å…§å®¹å“è³ªæª¢æŸ¥
        if (options.isCheckContentQuality()) {
            double qualityScore = assessContentQuality(processed);
            if (qualityScore < options.getMinQualityScore()) {
                log.debug("Text filtered by quality: {}", qualityScore);
                return "";
            }
        }
        
        return processed.trim();
    }
    
    private String cleanSpecialCharacters(String text) {
        // ä¿ç•™ä¸­æ–‡ã€è‹±æ–‡ã€æ•¸å­—ã€åŸºæœ¬æ¨™é»
        return text.replaceAll("[^\u4e00-\u9fff\u3400-\u4dbfa-zA-Z0-9\s.,!?;:()\[\]{}\"'-]", " ");
    }
    
    private String normalizeWhitespace(String text) {
        return text.replaceAll("\\s+", " ").trim();
    }
    
    private String detectLanguage(String text) {
        // ç°¡åŒ–çš„èªè¨€æª¢æ¸¬
        if (text.matches(".*[\u4e00-\u9fff].*")) {
            return "zh";
        } else if (text.matches(".*[a-zA-Z].*")) {
            return "en";
        }
        return "unknown";
    }
    
    private double assessContentQuality(String text) {
        double score = 1.0;
        
        // æª¢æŸ¥é‡è¤‡å­—ç¬¦
        if (text.matches(".*(.)\\1{5,}.*")) {
            score -= 0.3;
        }
        
        // æª¢æŸ¥å­—ç¬¦å¤šæ¨£æ€§
        Set<Character> uniqueChars = text.chars()
            .mapToObj(c -> (char) c)
            .collect(Collectors.toSet());
        
        double diversity = (double) uniqueChars.size() / text.length();
        if (diversity < 0.1) {
            score -= 0.2;
        }
        
        // æª¢æŸ¥æ˜¯å¦åŒ…å«æœ‰æ„ç¾©çš„å…§å®¹
        if (text.matches("^[\s\p{Punct}]*$")) {
            score -= 0.5;
        }
        
        return Math.max(0.0, score);
    }
}

/**
 * é è™•ç†é¸é …
 */
@Data
@Builder
public class PreprocessingOptions {
    @Builder.Default
    private boolean cleanSpecialChars = true;
    
    @Builder.Default
    private boolean normalizeWhitespace = true;
    
    @Builder.Default
    private boolean filterByLength = true;
    
    @Builder.Default
    private int minLength = 10;
    
    @Builder.Default
    private int maxLength = 8000;
    
    @Builder.Default
    private boolean filterByLanguage = false;
    
    @Builder.Default
    private Set<String> allowedLanguages = Set.of("zh", "en");
    
    @Builder.Default
    private boolean checkContentQuality = true;
    
    @Builder.Default
    private double minQualityScore = 0.5;
}
```

### å‘é‡å­˜å„²å„ªåŒ–

```java
/**
 * å„ªåŒ–çš„å‘é‡å­˜å„²æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class OptimizedVectorStoreService {
    
    private final VectorStore vectorStore;
    private final SmartEmbeddingService embeddingService;
    private final EmbeddingTextPreprocessor textPreprocessor;
    
    /**
     * å„ªåŒ–çš„æ–‡æª”æ·»åŠ 
     */
    public void addDocumentsOptimized(List<Document> documents) {
        
        List<Document> processedDocuments = documents.parallelStream()
            .map(this::preprocessDocument)
            .filter(doc -> !doc.getContent().isEmpty())
            .collect(Collectors.toList());
        
        if (processedDocuments.isEmpty()) {
            log.warn("No valid documents to add after preprocessing");
            return;
        }
        
        // æ‰¹é‡ç”Ÿæˆ Embedding
        Map<String, float[]> embeddings = generateBatchEmbeddings(processedDocuments);
        
        // æ³¨æ„ï¼šSpring AI çš„ Document é¡åˆ¥æ²’æœ‰ setEmbedding æ–¹æ³•
        // Embedding æ˜¯åœ¨ VectorStore.add() æ™‚è‡ªå‹•ç”Ÿæˆçš„
        // é€™è£¡æˆ‘å€‘åªéœ€è¦ç¢ºä¿æ–‡æª”å…§å®¹å·²é è™•ç†
        
        // æ‰¹é‡æ·»åŠ åˆ°å‘é‡å­˜å„²
        vectorStore.add(processedDocuments);
        
        log.info("Added {} optimized documents to vector store", processedDocuments.size());
    }
    
    /**
     * é è™•ç†æ–‡æª”
     */
    private Document preprocessDocument(Document document) {
        
        PreprocessingOptions options = PreprocessingOptions.builder()
            .cleanSpecialChars(true)
            .normalizeWhitespace(true)
            .filterByLength(true)
            .minLength(20)
            .maxLength(4000)
            .checkContentQuality(true)
            .minQualityScore(0.6)
            .build();
        
        String processedContent = textPreprocessor.preprocessForEmbedding(
            document.getContent(), options);
        
        // ä½¿ç”¨ Spring AI Document æ§‹é€ å­
        return new Document(processedContent, document.getMetadata());
    }
    
    /**
     * æ‰¹é‡ç”Ÿæˆ Embedding
     */
    private Map<String, float[]> generateBatchEmbeddings(List<Document> documents) {
        
        List<String> contents = documents.stream()
            .map(Document::getContent)
            .collect(Collectors.toList());
        
        EmbeddingContext context = EmbeddingContext.builder()
            .batchProcessing(true)
            .costSensitive(true)
            .build();
        
        return embeddingService.batchEmbed(contents, context);
    }
    
    /**
     * å„ªåŒ–çš„ç›¸ä¼¼åº¦æœå°‹
     */
    public List<Document> similaritySearchOptimized(String query, int topK, double threshold) {
        
        // é è™•ç†æŸ¥è©¢
        PreprocessingOptions queryOptions = PreprocessingOptions.builder()
            .cleanSpecialChars(true)
            .normalizeWhitespace(true)
            .filterByLength(false) // æŸ¥è©¢å¯ä»¥è¼ƒçŸ­
            .checkContentQuality(false) // æŸ¥è©¢ä¸éœ€è¦å“è³ªæª¢æŸ¥
            .build();
        
        String processedQuery = textPreprocessor.preprocessForEmbedding(query, queryOptions);
        
        if (processedQuery.isEmpty()) {
            log.warn("Query is empty after preprocessing: {}", query);
            return Collections.emptyList();
        }
        
        // ç”ŸæˆæŸ¥è©¢ Embedding
        EmbeddingContext context = EmbeddingContext.builder()
            .highAccuracyRequired(true) // æŸ¥è©¢ä½¿ç”¨é«˜ç²¾åº¦æ¨¡å‹
            .build();
        
        float[] queryEmbedding = embeddingService.embedWithSmartSelection(
            processedQuery, context);
        
        // æ³¨æ„ï¼šåœ¨å¯¦éš›æ‡‰ç”¨ä¸­ï¼ŒVectorStore.similaritySearch() æœƒè‡ªå‹•è™•ç†æŸ¥è©¢çš„ embedding
        
        // åŸ·è¡Œç›¸ä¼¼åº¦æœå°‹
        List<Document> results = vectorStore.similaritySearch(
            SearchRequest.builder()
                .query(processedQuery)
                .topK(topK * 2) // æª¢ç´¢æ›´å¤šå€™é¸ï¼Œå¾ŒçºŒéæ¿¾
                .similarityThreshold(threshold * 0.8) // é™ä½é–¾å€¼
                .build()
        );
        
        // å¾Œè™•ç†çµæœ
        return postProcessSearchResults(results, queryEmbedding, topK, threshold);
    }
    
    /**
     * å¾Œè™•ç†æœå°‹çµæœ
     */
    private List<Document> postProcessSearchResults(List<Document> results, 
                                                   float[] queryEmbedding,
                                                   int topK, double threshold) {
        
        return results.stream()
            // æ³¨æ„ï¼šSpring AI Document é¡åˆ¥æ²’æœ‰ getEmbedding() æ–¹æ³•
            // VectorStore å·²ç¶“åœ¨ similaritySearch() ä¸­è™•ç†äº†ç›¸ä¼¼åº¦çš„éæ¿¾
            .limit(topK)
            .collect(Collectors.toList());
    }
    
    /**
     * è¨ˆç®—é¤˜å¼¦ç›¸ä¼¼åº¦ï¼ˆåªä¾›åƒè€ƒï¼Œå¯¦éš›ä¸Š VectorStore å·²ç¶“è™•ç†ï¼‰
     */
    private double calculateCosineSimilarity(float[] vec1, float[] vec2) {
        if (vec1.length != vec2.length) {
            throw new IllegalArgumentException("Vector dimensions must match");
        }
        
        double dotProduct = 0.0;
        double norm1 = 0.0;
        double norm2 = 0.0;
        
        for (int i = 0; i < vec1.length; i++) {
            dotProduct += vec1[i] * vec2[i];
            norm1 += vec1[i] * vec1[i];
            norm2 += vec2[i] * vec2[i];
        }
        
        return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
    }
}
```

---

## ğŸ“ æœ¬ç« é‡é»å›é¡§

1. **Embedding é‡è¦æ€§**ï¼šç†è§£äº† Embedding åœ¨ RAG ç³»çµ±ä¸­çš„æ ¸å¿ƒä½œç”¨
2. **æ¨¡å‹æ€§èƒ½æ¯”è¼ƒ**ï¼šæŒæ¡äº†ä¸åŒ Embedding æ¨¡å‹çš„ç‰¹æ€§å’Œé¸æ“‡ç­–ç•¥
3. **Spring AI é…ç½®**ï¼šå¯¦ç¾äº†å¤šæ¨¡å‹é…ç½®å’Œæ™ºèƒ½é¸æ“‡æ©Ÿåˆ¶
4. **æ•ˆèƒ½ç›£æ§**ï¼šå»ºç«‹äº†å®Œæ•´çš„ Embedding æ•ˆèƒ½ç›£æ§é«”ç³»
5. **å„ªåŒ–å¯¦è¸**ï¼šæŒæ¡äº†æ–‡æœ¬é è™•ç†å’Œå‘é‡å­˜å„²çš„å„ªåŒ–æ–¹æ³•

### æŠ€è¡“è¦é»ç¸½çµ

| æŠ€è¡“è¦é» | é‡è¦æ€§ | å¯¦ç¾é›£åº¦ | æ•ˆæœæå‡ |
|----------|--------|----------|----------|
| **æ¨¡å‹é¸æ“‡** | â­â­â­â­â­ | ä¸­ | 20-30% |
| **æ–‡æœ¬é è™•ç†** | â­â­â­â­ | ä¸­ | 15-25% |
| **æ‰¹é‡è™•ç†** | â­â­â­ | ä¸­ | æ•ˆç‡æå‡50% |
| **å¿«å–ç­–ç•¥** | â­â­â­ | ä½ | é€Ÿåº¦æå‡80% |
| **æ•ˆèƒ½ç›£æ§** | â­â­ | ä¸­ | æŒçºŒå„ªåŒ– |

### æœ€ä½³å¯¦è¸å»ºè­°

1. **æ¨¡å‹é¸æ“‡ç­–ç•¥**ï¼šæ ¹æ“šç²¾åº¦éœ€æ±‚ã€æˆæœ¬é ç®—ã€è™•ç†é€Ÿåº¦é¸æ“‡åˆé©æ¨¡å‹
2. **æ–‡æœ¬å“è³ªæ§åˆ¶**ï¼šå»ºç«‹å®Œæ•´çš„æ–‡æœ¬é è™•ç†å’Œå“è³ªè©•ä¼°æ©Ÿåˆ¶
3. **æ‰¹é‡è™•ç†å„ªåŒ–**ï¼šä½¿ç”¨æ‰¹é‡è™•ç†å’Œå¿«å–æå‡è™•ç†æ•ˆç‡
4. **æ•ˆèƒ½æŒçºŒç›£æ§**ï¼šå»ºç«‹æ¨¡å‹æ•ˆèƒ½ç›£æ§å’Œè‡ªå‹•å„ªåŒ–æ©Ÿåˆ¶
5. **æˆæœ¬æ•ˆç›Šå¹³è¡¡**ï¼šåœ¨æº–ç¢ºç‡å’Œæˆæœ¬ä¹‹é–“æ‰¾åˆ°æœ€ä½³å¹³è¡¡é»

### ä¸‹ä¸€æ­¥å­¸ç¿’æ–¹å‘

åœ¨ä¸‹ä¸€ç¯€ä¸­ï¼Œæˆ‘å€‘å°‡æ·±å…¥å­¸ç¿’åœ¨ Spring AI å¯¦ä½œ Re-rankingï¼ŒåŒ…æ‹¬ï¼š
- Re-ranking åŸç†å’Œé‡è¦æ€§
- Spring AI Re-ranking å¯¦ç¾
- å¤šéšæ®µæª¢ç´¢å„ªåŒ–
- Re-ranking æ•ˆæœè©•ä¼°

---

### ğŸ’¡ ç°¡å–®ä½¿ç”¨ç¯„ä¾‹

```java
/**
 * ç°¡å–®çš„ Embedding ä½¿ç”¨ç¯„ä¾‹
 */
@RestController
@RequiredArgsConstructor
public class EmbeddingController {
    
    private final EmbeddingModel embeddingModel;
    
    /**
     * åŸºæœ¬ Embedding æ“ä½œ
     */
    @PostMapping("/api/embed")
    public Map<String, Object> embed(@RequestBody String text) {
        // ä½¿ç”¨é è¨­é…ç½®
        float[] embedding = embeddingModel.embed(text);
        
        return Map.of(
            "text", text,
            "embedding", embedding,
            "dimensions", embedding.length
        );
    }
    
    /**
     * æ‰¹é‡ Embedding æ“ä½œ
     */
    @PostMapping("/api/embed/batch")
    public Map<String, Object> batchEmbed(@RequestBody List<String> texts) {
        List<float[]> embeddings = embeddingModel.embed(texts);
        
        return Map.of(
            "count", texts.size(),
            "embeddings", embeddings
        );
    }
    
    /**
     * ä½¿ç”¨ä¸åŒæ¨¡å‹é¸é …
     */
    @PostMapping("/api/embed/advanced")
    public Map<String, Object> advancedEmbed(@RequestBody String text) {
        // ä½¿ç”¨é«˜ç²¾åº¦æ¨¡å‹
        EmbeddingResponse response = embeddingModel.call(
            new EmbeddingRequest(List.of(text),
                OpenAiEmbeddingOptions.builder()
                    .model("text-embedding-3-large")
                    .dimensions(3072)
                    .build()));
        
        float[] embedding = response.getResults().get(0).getOutput();
        
        return Map.of(
            "text", text,
            "model", "text-embedding-3-large",
            "embedding", embedding,
            "dimensions", embedding.length,
            "usage", response.getMetadata().getUsage()
        );
    }
}
```

**åƒè€ƒè³‡æ–™ï¼š**
- [Spring AI Embeddings API](https://docs.spring.io/spring-ai/reference/api/embeddings.html)
- [Spring AI OpenAI Embeddings](https://docs.spring.io/spring-ai/reference/api/embeddings/openai-embeddings.html)
- [Text Embeddings: Comprehensive Guide](https://arxiv.org/abs/2401.00368)
- [Improving Text Embeddings with Large Language Models](https://arxiv.org/abs/2401.00368)
- [MTEB: Massive Text Embedding Benchmark](https://arxiv.org/abs/2210.07316)
- [OpenAI Embeddings Guide](https://platform.openai.com/docs/guides/embeddings)
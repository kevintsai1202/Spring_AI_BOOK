# 6.2 讓 AI 記住對話

> **本章重點**：實際動手實現 Spring AI 的對話記憶功能，從基礎的記憶體存儲到企業級的持久化解決方案，讓 AI 真正擁有記憶能力。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **實現基本對話記憶**：使用 InMemoryChatMemory 建立簡單的記憶功能
- 🎯 **掌握 Advisor 系統**：理解 Spring AI 的增強器機制和最新 API
- 🎯 **配置記憶管理**：學會配置不同類型的記憶存儲後端
- 🎯 **實現會話隔離**：為不同用戶建立獨立的對話記憶
- 🎯 **優化記憶效能**：掌握記憶大小控制和效能優化技巧

---

## 6.2.1 從土炮到企業級的進化

### AOP 無所不在

![AOP概念圖](https://ithelp.ithome.com.tw/upload/images/20240819/20161290PpCeC08JCZ.jpg)

Spring 框架有兩個很重要的觀念，一個是 IoC，另一個則是 AOP。AOP 的基本概念就是可以攔截指定的方法並且增強方法的功能，且無需修改到主要的業務代碼，使業務與非業務處理邏輯分離。

**AOP 在日常開發中的應用**：
- 🔄 **@Transactional**：自動處理資料庫交易的開啟、提交和回滾
- 📝 **@Cacheable**：自動處理快取的存取和更新
- 🔒 **@PreAuthorize**：自動進行權限檢查
- 📊 **@Timed**：自動記錄方法執行時間

### Spring AI 的 Advisor 系統

Spring AI 將 AOP 的概念應用到 AI 對話處理中，提供了 **Advisor（增強器）** 系統。Advisor 可以在 AI 請求的前後進行攔截和增強，實現記憶管理、內容過濾、日誌記錄等功能。

---

## 6.2.2 Spring AI Advisor API 的重大更新

### API 演進歷程

**重要更新說明**：Spring AI 1.0 GA 版本對 Advisor API 進行了重大重構，提供了更清晰和強大的介面。

#### 舊版 API（已廢棄）
```java
// ❌ 已在 1.0.0-M3 標記為 deprecated，1.0.0-RC1 完全移除
RequestResponseAdvisor advisor = new MessageChatMemoryAdvisor(chatMemory, chatId, 30);
```

#### 新版 API（當前使用）
```java
// ✅ 使用最新的 Builder 模式和清晰的介面
ChatMemory chatMemory = MessageWindowChatMemory.builder().build();

ChatClient chatClient = ChatClient.builder(chatModel)
    .defaultAdvisors(MessageChatMemoryAdvisor.builder(chatMemory).build())
    .build();

// 在調用時指定對話 ID
String conversationId = "007";
String response = chatClient.prompt()
    .advisors(advisor -> advisor.param(ChatMemory.CONVERSATION_ID, conversationId))
    .user(userText)
    .call()
    .content();
```

### 新版 API 的核心介面

**1. CallAdvisor - 非串流場景**
```java
public interface CallAdvisor {
    String getName();
    int getOrder();
    
    ChatClientRequest adviseRequest(ChatClientRequest request, Map<String, Object> context);
    ChatClientResponse adviseResponse(ChatClientResponse response, Map<String, Object> context);
}
```

**2. StreamAdvisor - 串流場景**
```java
public interface StreamAdvisor {
    String getName();
    int getOrder();
    
    ChatClientRequest adviseRequest(ChatClientRequest request, Map<String, Object> context);
    Flux<ChatClientResponse> adviseResponse(Flux<ChatClientResponse> response, Map<String, Object> context);
}
```

### API 更新的優勢

| 特性 | 舊版 API | 新版 API |
|------|----------|----------|
| **類型安全** | 較弱 | 強類型檢查 |
| **建構方式** | 構造函數 | Builder 模式 |
| **可讀性** | 一般 | 高可讀性 |
| **擴展性** | 有限 | 高度可擴展 |
| **維護性** | 困難 | 容易維護 |

---

## 6.2.3 Spring AI 內建的 Advisor 類別

### 記憶管理 Advisor

![Advisor類別圖](https://ithelp.ithome.com.tw/upload/images/20240819/201612900g7q0iHGAj.png)

Spring AI 提供了三種主要的記憶管理 Advisor：

**1. MessageChatMemoryAdvisor**
```java
特點：
- 將對話歷史作為 Message 集合加入到 Prompt 中
- 保持完整的對話結構和上下文
- 適合需要精確對話順序的場景

使用場景：
- 客戶服務對話
- 任務導向的多輪對話
- 需要嚴格上下文的業務流程

**1. MessageChatMemoryAdvisor - 基本記憶管理**
```java
// 建立記憶存儲
ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .maxMessages(10)  // 保留最近 10 條訊息
    .build();

// 配置 ChatClient
ChatClient chatClient = ChatClient.builder(chatModel)
    .defaultAdvisors(MessageChatMemoryAdvisor.builder(chatMemory).build())
    .build();

// 使用時指定對話 ID
String conversationId = "user-123";
String response = chatClient.prompt()
    .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, conversationId))
    .user("你好，我是新用戶")
    .call()
    .content();
```

**2. PromptChatMemoryAdvisor**
```java
特點：
- 將對話歷史轉換為純文字附加到系統提示中
- 更節省 Token 使用量
- 適合簡單的上下文記憶

使用場景：
- 簡單的問答系統
- 成本敏感的應用
- 不需要複雜對話結構的場景
```

**3. VectorStoreChatMemoryAdvisor**
```java
特點：
- 使用向量資料庫存儲對話記憶
- 支援語義相似性搜尋
- 可處理大量歷史對話資料

使用場景：
- 長期對話歷史管理
- 大規模用戶系統
- 需要語義搜尋的智能助手
```

### Advisor 比較表

| Advisor 類型 | 存儲方式 | Token 消耗 | 檢索能力 | 適用規模 |
|--------------|----------|------------|----------|----------|
| **MessageChatMemoryAdvisor** | 結構化訊息 | 高 | 順序檢索 | 中小型 |
| **PromptChatMemoryAdvisor** | 純文字 | 中 | 文字匹配 | 小型 |
| **VectorStoreChatMemoryAdvisor** | 向量化 | 低 | 語義搜尋 | 大型 |

---

## 6.2.4 實現基本對話記憶

### 第一步：建立簡單的記憶服務

```java
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.memory.InMemoryChatMemoryRepository;
import org.springframework.ai.chat.memory.MessageWindowChatMemory;
import org.springframework.ai.chat.memory.advisor.MessageChatMemoryAdvisor;
import org.springframework.ai.chat.messages.Message;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class BasicChatMemoryService {
    
    private final ChatClient chatClient;
    private final ChatMemory chatMemory = MessageWindowChatMemory.builder()
            .chatMemoryRepository(new InMemoryChatMemoryRepository())
            .build();
    
    /**
     * 基本對話記憶實現
     */
    public String chat(String conversationId, String userMessage) {
        return chatClient.prompt()
            .advisors(advisor -> advisor.param(ChatMemory.CONVERSATION_ID, conversationId))
            .user(userMessage)
            .call()
            .content();
    }
    
    /**
     * 獲取對話歷史
     */
    public List<Message> getConversationHistory(String conversationId) {
        return chatMemory.get(conversationId);
    }
    
    /**
     * 清除對話記憶
     */
    public void clearConversation(String conversationId) {
        chatMemory.clear(conversationId);
    }
}
```

### 第二步：建立 REST API 控制器

```java
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.messages.Message;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/chat")
@RequiredArgsConstructor
public class ChatMemoryController {
    
    private final BasicChatMemoryService chatService;
    
    /**
     * 對話 API
     */
    @PostMapping("/conversation/{conversationId}")
    public ResponseEntity<ChatResponse> chat(
            @PathVariable String conversationId,
            @RequestBody ChatRequest request) {
        
        String response = chatService.chat(conversationId, request.getMessage());
        
        return ResponseEntity.ok(ChatResponse.builder()
            .conversationId(conversationId)
            .message(response)
            .timestamp(LocalDateTime.now())
            .build());
    }
    
    /**
     * 獲取對話歷史
     */
    @GetMapping("/conversation/{conversationId}/history")
    public ResponseEntity<ConversationHistory> getHistory(
            @PathVariable String conversationId,
            @RequestParam(defaultValue = "50") int limit) {
        
        List<Message> messages = chatService.getConversationHistory(conversationId);
        
        // 限制返回的訊息數量
        if (messages.size() > limit) {
            messages = messages.subList(messages.size() - limit, messages.size());
        }
        
        return ResponseEntity.ok(ConversationHistory.builder()
            .conversationId(conversationId)
            .messages(messages)
            .totalCount(messages.size())
            .build());
    }
    
    /**
     * 清除對話
     */
    @DeleteMapping("/conversation/{conversationId}")
    public ResponseEntity<Void> clearConversation(@PathVariable String conversationId) {
        chatService.clearConversation(conversationId);
        return ResponseEntity.ok().build();
    }
}
```

### 第三步：定義資料傳輸物件

```java
import lombok.Builder;
import lombok.Data;
import org.springframework.ai.chat.messages.Message;

import javax.validation.constraints.NotBlank;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * 聊天請求 DTO
 */
@Data
@Builder
public class ChatRequest {
    @NotBlank(message = "訊息不能為空")
    private String message;
    
    private Map<String, Object> metadata;
}

/**
 * 聊天回應 DTO
 */
@Data
@Builder
public class ChatResponse {
    private String conversationId;
    private String message;
    private LocalDateTime timestamp;
    private Map<String, Object> metadata;
}

/**
 * 對話歷史 DTO
 */
@Data
@Builder
public class ConversationHistory {
    private String conversationId;
    private List<Message> messages;
    private int totalCount;
    private LocalDateTime lastUpdated;
}
```

---

## 6.2.5 企業級記憶配置

### 配置不同的存儲後端

```java
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.memory.InMemoryChatMemoryRepository;
import org.springframework.ai.chat.memory.JdbcChatMemoryRepository;
import org.springframework.ai.chat.memory.MessageWindowChatMemory;
import org.springframework.ai.chat.memory.RedisChatMemoryRepository;
import org.springframework.ai.chat.memory.Neo4jChatMemoryRepository;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.neo4j.core.Neo4jTemplate;

import javax.sql.DataSource;

@Configuration
@EnableConfigurationProperties(ChatMemoryProperties.class)
public class ChatMemoryConfig {
    
    /**
     * 記憶體存儲（開發環境）
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "memory")
    public ChatMemory inMemoryChatMemory() {
        return MessageWindowChatMemory.builder()
            .chatMemoryRepository(new InMemoryChatMemoryRepository())
            .build();
    }
    
    /**
     * JDBC 存儲（生產環境）
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "jdbc")
    public ChatMemory jdbcChatMemory(DataSource dataSource) {
        return MessageWindowChatMemory.builder()
            .maxMessages(200)
            .chatMemoryRepository(new JdbcChatMemoryRepository(dataSource))
            .build();
    }
    
    /**
     * Redis 存儲（高效能環境）
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "redis")
    public ChatMemory redisChatMemory(RedisTemplate<String, Object> redisTemplate) {
        return MessageWindowChatMemory.builder()
            .maxMessages(500)
            .chatMemoryRepository(new RedisChatMemoryRepository(redisTemplate))
            .build();
    }
    
    /**
     * Neo4j 存儲（圖形資料庫）
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "neo4j")
    public ChatMemory neo4jChatMemory(Neo4jTemplate neo4jTemplate) {
        return MessageWindowChatMemory.builder()
            .maxMessages(1000)
            .chatMemoryRepository(new Neo4jChatMemoryRepository(neo4jTemplate))
            .build();
    }
}
```

### 記憶配置屬性

```java
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "app.chat.memory")
@Data
public class ChatMemoryProperties {
    
    /**
     * 記憶存儲類型
     */
    private String type = "memory";
    
    /**
     * 最大訊息數量
     */
    private int maxMessages = 100;
    
    /**
     * 記憶過期時間（小時）
     */
    private int expirationHours = 24;
    
    /**
     * 是否啟用記憶壓縮
     */
    private boolean compressionEnabled = false;
    
    /**
     * 壓縮閾值
     */
    private int compressionThreshold = 200;
}
```

### 應用程式配置

```yaml
# application.yml
app:
  chat:
    memory:
      type: jdbc  # memory, jdbc, redis, neo4j
      max-messages: 200
      expiration-hours: 48
      compression-enabled: true
      compression-threshold: 300

# 開發環境
---
spring:
  config:
    activate:
      on-profile: dev
app:
  chat:
    memory:
      type: memory
      max-messages: 50

# 生產環境
---
spring:
  config:
    activate:
      on-profile: prod
app:
  chat:
    memory:
      type: redis
      max-messages: 500
      expiration-hours: 72
```

---

## 6.2.6 進階記憶管理

### 建議的最佳實踐寫法

推薦在 ChatClient 建構時就預設 Advisor，這樣可以獲得更好的效能：

```java
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.memory.advisor.MessageChatMemoryAdvisor;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ChatClientConfig {
    
    @Bean
    public ChatClient chatClient(ChatModel chatModel, ChatMemory chatMemory) {
        return ChatClient.builder(chatModel)
            .defaultAdvisors(
                MessageChatMemoryAdvisor.builder(chatMemory).build()
            )
            .build();
    }
    
    @Bean
    public ChatClient streamingChatClient(ChatModel chatModel, ChatMemory chatMemory) {
        return ChatClient.builder(chatModel)
            .defaultAdvisors(
                // 串流場景使用不同的配置
                MessageChatMemoryAdvisor.builder(chatMemory)
                    .lastN(20)  // 串流時使用較少的歷史訊息
                    .build()
            )
            .build();
    }
}
```

### 動態 Advisor 參數設定

```java
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class DynamicChatService {
    
    private final ChatClient chatClient;
    private final ChatMemory chatMemory;
    
    public String chat(String conversationId, String userMessage, ChatOptions options) {
        return chatClient.prompt()
            .advisors(advisor -> {
                // 動態設定 Advisor 參數
                advisor.param(ChatMemory.CONVERSATION_ID, conversationId);
                
                // 根據選項調整記憶大小
                if (options.isDetailedContext()) {
                    advisor.param("lastN", 50);
                } else {
                    advisor.param("lastN", 20);
                }
            })
            .user(userMessage)
            .call()
            .content();
    }
}
```

### 記憶效能優化

```java
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.SystemMessage;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Component
@RequiredArgsConstructor
public class MemoryOptimizationService {
    
    private final ChatMemory chatMemory;
    private final ChatClient summaryClient;
    
    /**
     * 智能記憶壓縮
     */
    @Scheduled(fixedRate = 3600000) // 每小時執行一次
    public void optimizeMemory() {
        // 獲取所有活躍的對話 ID
        Set<String> activeConversations = getActiveConversations();
        
        for (String conversationId : activeConversations) {
            List<Message> messages = chatMemory.get(conversationId);
            
            if (messages.size() > 100) {
                compressConversation(conversationId, messages);
            }
        }
    }
    
    private void compressConversation(String conversationId, List<Message> messages) {
        // 保留最近 30 條訊息
        List<Message> recentMessages = messages.subList(messages.size() - 30, messages.size());
        
        // 將較舊的訊息進行摘要
        List<Message> oldMessages = messages.subList(0, messages.size() - 30);
        String summary = summarizeMessages(oldMessages);
        
        // 重建記憶
        chatMemory.clear(conversationId);
        chatMemory.add(conversationId, new SystemMessage("對話摘要：" + summary));
        chatMemory.add(conversationId, recentMessages);
    }
    
    private String summarizeMessages(List<Message> messages) {
        String conversation = messages.stream()
            .map(Message::getContent)
            .collect(Collectors.joining("\n"));
            
        return summaryClient.prompt()
            .user("請簡潔摘要以下對話的重點：\n" + conversation)
            .call()
            .content();
    }
}
```

---

## 6.2.7 測試對話記憶功能

### 基本功能測試

```java
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
import org.springframework.ai.chat.messages.Message;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class ChatMemoryServiceTest {
    
    @Autowired
    private BasicChatMemoryService chatService;
    
    private static final String CONVERSATION_ID = "test-conversation-001";
    
    @Test
    @Order(1)
    void testFirstMessage() {
        String response = chatService.chat(CONVERSATION_ID, "我的名字是 Kevin");
        
        assertThat(response).isNotNull();
        
        // 驗證記憶中有訊息
        List<Message> history = chatService.getConversationHistory(CONVERSATION_ID);
        assertThat(history).hasSize(2); // User + Assistant
    }
    
    @Test
    @Order(2)
    void testMemoryRecall() {
        String response = chatService.chat(CONVERSATION_ID, "我剛才說我的名字是什麼？");
        
        assertThat(response.toLowerCase()).contains("kevin");
        
        // 驗證記憶增長
        List<Message> history = chatService.getConversationHistory(CONVERSATION_ID);
        assertThat(history).hasSizeGreaterThan(2);
    }
    
    @Test
    @Order(3)
    void testClearMemory() {
        chatService.clearConversation(CONVERSATION_ID);
        
        List<Message> history = chatService.getConversationHistory(CONVERSATION_ID);
        assertThat(history).isEmpty();
    }
}
```

### API 端點測試

```java
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureTestDatabase
class ChatMemoryControllerTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    void testChatConversation() {
        String conversationId = "api-test-001";
        
        // 第一輪對話
        ChatRequest request1 = ChatRequest.builder()
            .message("我喜歡喝咖啡")
            .build();
            
        ResponseEntity<ChatResponse> response1 = restTemplate.postForEntity(
            "/api/chat/conversation/" + conversationId,
            request1,
            ChatResponse.class
        );
        
        assertThat(response1.getStatusCode()).isEqualTo(HttpStatus.OK);
        
        // 第二輪對話 - 測試記憶
        ChatRequest request2 = ChatRequest.builder()
            .message("我剛才說我喜歡什麼？")
            .build();
            
        ResponseEntity<ChatResponse> response2 = restTemplate.postForEntity(
            "/api/chat/conversation/" + conversationId,
            request2,
            ChatResponse.class
        );
        
        assertThat(response2.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response2.getBody().getMessage().toLowerCase()).contains("咖啡");
    }
}
```

---

## 📝 本章重點回顧

1. **Advisor 系統理解**：掌握了 Spring AI 的增強器機制和 AOP 概念的應用
2. **API 更新認知**：學會了最新的 Advisor API 使用方式和 Builder 模式
3. **記憶類型選擇**：理解了不同 Advisor 的特點和適用場景
4. **實際功能實現**：完成了基本對話記憶功能的完整實現
5. **企業級配置**：掌握了多種存儲後端的配置和選擇策略

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **MessageChatMemoryAdvisor** | ⭐⭐⭐ | 低 | 基本對話記憶 |
| **多存儲後端配置** | ⭐⭐⭐ | 中 | 企業級應用 |
| **動態 Advisor 參數** | ⭐⭐ | 中 | 靈活配置 |
| **記憶效能優化** | ⭐⭐ | 高 | 大規模應用 |
| **API 測試** | ⭐⭐ | 低 | 品質保證 |

### 最佳實踐建議

1. **開發階段**：使用 InMemoryChatMemory 進行快速原型開發
2. **測試階段**：配置適當的記憶大小限制，避免測試資料過多
3. **生產階段**：選擇合適的持久化存儲，並配置記憶清理策略
4. **效能優化**：實施記憶壓縮和定期清理機制
5. **監控告警**：建立記憶使用量的監控和告警機制

### 下一步學習方向

在下一章中，我們將深入學習 Spring AI 的官方記憶系統，包括：
- Spring AI 官方提供的記憶管理 API
- 更進階的記憶配置選項
- 記憶系統的監控和管理
- 與其他 Spring AI 功能的整合

---

**參考資料：**
- [Spring AI Advisors Documentation](https://docs.spring.io/spring-ai/reference/api/advisors.html)
- [Chat Memory API Guide](https://docs.spring.io/spring-ai/reference/api/chat-memory.html)
- [ChatClient Builder Pattern](https://docs.spring.io/spring-ai/reference/api/chatclient.html)
- [Spring AI Best Practices](https://docs.spring.io/spring-ai/reference/concepts.html)
# 5.3 透過 Spring AI 生成美女圖

> **本章重點**：學習使用 Spring AI 的圖片生成功能，掌握文字轉圖片（Text-to-Image）技術，建立完整的 AI 圖片生成應用，探索 AI 的創作能力。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解圖片生成技術**：掌握文字轉圖片的核心原理和應用場景
- 🎯 **選擇合適的生成模型**：了解各種圖片生成 AI 模型的特點和成本
- 🎯 **實現圖片生成功能**：建立完整的圖片生成 API 和管理系統
- 🎯 **優化生成品質**：掌握提示詞工程和參數調整技巧
- 🎯 **企業級應用設計**：建立可商用的圖片生成服務架構

---

## 5.3.1 AI 圖片生成的革命性影響

### 文生圖 AI 將會是最大圖庫

![AI 圖片生成](https://ithelp.ithome.com.tw/upload/images/20240810/20161290xVSyazJmHj.png)

昨天學了如何上傳圖片給 AI 辨識，今天我們讓 AI 來產生圖片吧！AI 圖片生成技術正在徹底改變創意產業，從概念設計到商業插圖，AI 都能在幾秒鐘內生成高品質的圖片。

### AI 圖片生成的核心價值

**1. 創意無限制**
- 🎨 **即時創作**：從文字描述到視覺呈現，幾秒鐘完成
- 🌈 **風格多樣**：支援寫實、卡通、油畫、水彩等各種風格
- 🔄 **快速迭代**：輕鬆調整和優化創作內容
- 💡 **靈感激發**：AI 能提供意想不到的創意組合

**2. 成本效益顯著**
- 💰 **降低成本**：無需聘請專業設計師或購買版權圖片
- ⏰ **節省時間**：從數天的設計週期縮短到幾分鐘
- 📈 **規模化生產**：批次生成大量圖片內容
- 🎯 **客製化程度高**：精確符合特定需求

**3. 應用場景廣泛**
- 🛒 **電商應用**：商品展示圖、廣告素材、品牌視覺
- 📚 **內容創作**：部落格配圖、社群媒體素材、簡報圖片
- 🎮 **遊戲開發**：角色設計、場景概念圖、道具素材
- 🏢 **企業應用**：行銷素材、產品原型、視覺化報告

---

## 5.3.2 Spring AI 支援的圖片生成模型

### 主要支援的 AI 服務商

| 服務商 | 模型 | 特色 | 成本 | 推薦度 | 適用場景 |
|--------|------|------|------|--------|----------|
| **OpenAI** | DALL-E 3 | 高品質、理解複雜指令 | 高 | ⭐⭐⭐⭐⭐ | 專業設計、商業用途 |
| **Stability AI** | Stable Diffusion | 開源、可本地部署 | 中 | ⭐⭐⭐⭐ | 自主控制、客製化 |
| **ZhiPu AI** | CogView-3 | 中文友善、便宜 | 低 | ⭐⭐⭐ | 學習測試、中文內容 |
| **QianFan** | 文心一言 | 百度服務、本土化 | 低 | ⭐⭐ | 大陸市場應用 |
| **Midjourney** | V6 | 藝術性強、社群活躍 | 中 | ⭐⭐⭐⭐ | 藝術創作、概念設計 |

### 成本效益分析

根據最新測試數據，以下是各服務商的成本對比：

```
💰 成本排序（每張圖片）：
1. ZhiPu AI: 免費額度 + ¥0.01-0.05
2. Stability AI: $0.002-0.01
3. QianFan: ¥0.02-0.08
4. Midjourney: $0.05-0.15
5. OpenAI DALL-E 3: $0.040-0.080

🎯 推薦策略：
- 學習測試：ZhiPu AI（免費額度充足）
- 商業應用：OpenAI DALL-E 3（品質最佳）
- 大量生成：Stability AI（成本最低）
- 藝術創作：Midjourney（風格獨特）
```

### 模型能力對比

| 能力維度 | DALL-E 3 | Stable Diffusion | CogView-3 | 文心一言 |
|----------|----------|------------------|-----------|----------|
| **圖片品質** | 9/10 | 8/10 | 7/10 | 6/10 |
| **指令理解** | 9/10 | 7/10 | 8/10 | 7/10 |
| **中文支援** | 7/10 | 6/10 | 9/10 | 9/10 |
| **生成速度** | 8/10 | 9/10 | 8/10 | 7/10 |
| **風格多樣性** | 8/10 | 9/10 | 7/10 | 6/10 |
| **成本效益** | 6/10 | 9/10 | 9/10 | 8/10 |

---

## 5.3.3 ZhiPu AI 整合實戰

### 申請和配置

**1. 申請 API Key**

前往 ZhiPu AI 官網 [https://open.bigmodel.cn/](https://open.bigmodel.cn/) 註冊後，在 API 密鑰頁面取得你的 API Key。

![ZhiPu AI API Key](https://ithelp.ithome.com.tw/upload/images/20240806/20161290qkPNJ0Ho4Y.png)

**2. 引入依賴**

在 `pom.xml` 中添加 ZhiPu AI 依賴：

```xml
<!-- 使用 Spring AI BOM 管理版本 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-bom</artifactId>
            <version>1.0.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <!-- Spring AI ZhiPu AI Starter -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-zhipuai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Spring Boot Validation -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    
    <!-- Lombok -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

**3. 設定專案參數**

在 `application.yml` 中配置：

```yaml
spring:
  application:
    name: ai-image-generator
  ai:
    zhipuai:
      api-key: ${ZHIPUAI_API_KEY}
      base-url: https://open.bigmodel.cn/api/paas/v4
      image:
        options:
          model: cogview-3
          width: 1024
          height: 1024
          quality: standard
          style: vivid

# 應用程式配置
app:
  image:
    generation:
      max-batch-size: 5
      default-timeout: 30s
      cache-enabled: true
      output-directory: ./generated-images

# 日誌配置
logging:
  level:
    org.springframework.ai: DEBUG
    com.example: DEBUG
```

---

## 5.3.4 基礎圖片生成功能

### 簡單圖片生成 API

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.image.Image;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.image.ImagePrompt;
import org.springframework.ai.image.ImageResponse;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/image")
@RequiredArgsConstructor
@Slf4j
public class ImageGenerationController {
    
    private final ImageModel imageModel;
    
    /**
     * 基礎圖片生成
     * @param prompt 圖片描述
     * @return HTML 格式的圖片展示頁面
     */
    @GetMapping("/generate")
    public ResponseEntity<String> generateImage(@RequestParam String prompt) {
        try {
            log.info("開始生成圖片，提示詞：{}", prompt);
            
            // 建立圖片生成請求
            ImagePrompt imagePrompt = new ImagePrompt(prompt);
            
            // 呼叫 AI 模型生成圖片
            ImageResponse response = imageModel.call(imagePrompt);
            Image image = response.getResult().getOutput();
            
            // 建立 HTML 回應
            String htmlResponse = String.format("""
                <!DOCTYPE html>
                <html lang="zh-TW">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>AI 圖片生成結果</title>
                    <style>
                        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
                        .container { text-align: center; }
                        .image-container { margin: 20px 0; }
                        .generated-image { max-width: 100%%; height: auto; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
                        .prompt { background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 20px 0; }
                        .info { color: #666; font-size: 14px; }
                    </style>
                </head>
                <body>
                    <div class="container">
                        <h1>🎨 AI 圖片生成結果</h1>
                        <div class="prompt">
                            <h3>📝 提示詞</h3>
                            <p><strong>%s</strong></p>
                        </div>
                        <div class="image-container">
                            <img src="%s" alt="%s" class="generated-image">
                        </div>
                        <div class="info">
                            <p>🤖 由 Spring AI + ZhiPu AI 生成</p>
                            <p>⏰ 生成時間：%s</p>
                        </div>
                    </div>
                </body>
                </html>
                """, 
                prompt, 
                image.getUrl(), 
                prompt,
                java.time.LocalDateTime.now().format(
                    java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
                )
            );
            
            log.info("圖片生成成功，URL：{}", image.getUrl());
            
            return ResponseEntity.ok()
                    .contentType(MediaType.TEXT_HTML)
                    .body(htmlResponse);
            
        } catch (Exception e) {
            log.error("圖片生成失敗", e);
            
            String errorHtml = String.format("""
                <!DOCTYPE html>
                <html lang="zh-TW">
                <head>
                    <meta charset="UTF-8">
                    <title>生成失敗</title>
                    <style>body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }</style>
                </head>
                <body>
                    <h1>❌ 圖片生成失敗</h1>
                    <p>錯誤訊息：%s</p>
                    <p><a href="javascript:history.back()">返回重試</a></p>
                </body>
                </html>
                """, e.getMessage());
            
            return ResponseEntity.badRequest()
                    .contentType(MediaType.TEXT_HTML)
                    .body(errorHtml);
        }
    }
    
    /**
     * JSON 格式的圖片生成 API
     * @param request 生成請求
     * @return JSON 格式的回應
     */
    @PostMapping("/generate-json")
    public ResponseEntity<ImageGenerationResponse> generateImageJson(
            @RequestBody @Valid ImageGenerationRequest request) {
        
        try {
            log.info("JSON API 圖片生成請求：{}", request.getPrompt());
            
            ImagePrompt imagePrompt = new ImagePrompt(request.getPrompt());
            ImageResponse response = imageModel.call(imagePrompt);
            Image image = response.getResult().getOutput();
            
            ImageGenerationResponse result = ImageGenerationResponse.builder()
                    .success(true)
                    .imageUrl(image.getUrl())
                    .prompt(request.getPrompt())
                    .model("cogview-3")
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
            return ResponseEntity.ok(result);
            
        } catch (Exception e) {
            log.error("JSON API 圖片生成失敗", e);
            
            ImageGenerationResponse errorResult = ImageGenerationResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .prompt(request.getPrompt())
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResult);
        }
    }
}
```

### 請求和回應 DTO

```java
package com.example.dto;

import lombok.Data;
import lombok.Builder;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import java.time.LocalDateTime;

@Data
public class ImageGenerationRequest {
    
    @NotBlank(message = "提示詞不能為空")
    @Size(max = 1000, message = "提示詞長度不能超過 1000 字元")
    private String prompt;
    
    private String style = "vivid";  // vivid, natural
    private String quality = "standard";  // standard, hd
    private Integer width = 1024;
    private Integer height = 1024;
    private String model = "cogview-3";
}

@Data
@Builder
public class ImageGenerationResponse {
    private boolean success;
    private String imageUrl;
    private String prompt;
    private String model;
    private String style;
    private String quality;
    private Integer width;
    private Integer height;
    private String error;
    private LocalDateTime timestamp;
}
```

---

## 5.3.5 進階圖片生成功能

### 批次圖片生成

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.image.Image;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.image.ImagePrompt;
import org.springframework.ai.image.ImageResponse;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class BatchImageGenerationService {
    
    private final ImageModel imageModel;
    
    /**
     * 批次生成圖片
     * @param prompts 提示詞列表
     * @return 生成結果列表
     */
    public List<BatchImageResult> batchGenerate(List<String> prompts) {
        log.info("開始批次生成 {} 張圖片", prompts.size());
        
        List<CompletableFuture<BatchImageResult>> futures = prompts.stream()
                .map(this::generateImageAsync)
                .collect(Collectors.toList());
        
        // 等待所有任務完成
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(
                futures.toArray(new CompletableFuture[0])
        );
        
        return allFutures.thenApply(v -> 
                futures.stream()
                        .map(CompletableFuture::join)
                        .collect(Collectors.toList())
        ).join();
    }
    
    /**
     * 非同步生成單張圖片
     */
    private CompletableFuture<BatchImageResult> generateImageAsync(String prompt) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                ImagePrompt imagePrompt = new ImagePrompt(prompt);
                ImageResponse response = imageModel.call(imagePrompt);
                Image image = response.getResult().getOutput();
                
                return BatchImageResult.builder()
                        .prompt(prompt)
                        .imageUrl(image.getUrl())
                        .success(true)
                        .timestamp(java.time.LocalDateTime.now())
                        .build();
                
            } catch (Exception e) {
                log.error("批次生成失敗：{}", prompt, e);
                
                return BatchImageResult.builder()
                        .prompt(prompt)
                        .success(false)
                        .error(e.getMessage())
                        .timestamp(java.time.LocalDateTime.now())
                        .build();
            }
        });
    }
    
    @Data
    @Builder
    public static class BatchImageResult {
        private String prompt;
        private String imageUrl;
        private boolean success;
        private String error;
        private java.time.LocalDateTime timestamp;
    }
}
```

### 圖片風格和品質控制

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.image.ImageOptions;
import org.springframework.ai.image.ImagePrompt;
import org.springframework.ai.zhipuai.ZhiPuAiImageOptions;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AdvancedImageGenerationService {
    
    private final ImageModel imageModel;
    
    /**
     * 生成美女圖片（高品質）
     * @param description 美女描述
     * @param style 風格選擇
     * @return 圖片 URL
     */
    public String generateBeautyImage(String description, BeautyStyle style) {
        // 建構專業的美女圖片提示詞
        String enhancedPrompt = buildBeautyPrompt(description, style);
        
        // 設定高品質選項
        ZhiPuAiImageOptions options = ZhiPuAiImageOptions.builder()
                .withModel("cogview-3")
                .withWidth(1024)
                .withHeight(1024)
                .withQuality("hd")
                .withStyle("vivid")
                .build();
        
        ImagePrompt imagePrompt = new ImagePrompt(enhancedPrompt, options);
        return imageModel.call(imagePrompt).getResult().getOutput().getUrl();
    }
    
    /**
     * 建構美女圖片提示詞
     */
    private String buildBeautyPrompt(String description, BeautyStyle style) {
        String basePrompt = "A beautiful woman, " + description;
        
        String stylePrompt = switch (style) {
            case REALISTIC -> ", photorealistic, high quality, professional photography, natural lighting, detailed features";
            case ANIME -> ", anime style, manga art, beautiful anime girl, detailed anime artwork, vibrant colors";
            case PORTRAIT -> ", professional portrait, studio lighting, elegant pose, high-end fashion photography";
            case ARTISTIC -> ", artistic style, oil painting, renaissance art, classical beauty, masterpiece quality";
            case MODERN -> ", modern style, contemporary fashion, urban setting, trendy outfit, stylish appearance";
        };
        
        String qualityPrompt = ", 8k resolution, ultra detailed, masterpiece, best quality, highly detailed";
        
        return basePrompt + stylePrompt + qualityPrompt;
    }
    
    /**
     * 生成商業用途圖片
     * @param productDescription 產品描述
     * @param businessType 商業類型
     * @return 圖片 URL
     */
    public String generateBusinessImage(String productDescription, BusinessType businessType) {
        String businessPrompt = buildBusinessPrompt(productDescription, businessType);
        
        ZhiPuAiImageOptions options = ZhiPuAiImageOptions.builder()
                .withModel("cogview-3")
                .withWidth(1024)
                .withHeight(768)  // 商業圖片常用比例
                .withQuality("hd")
                .withStyle("natural")
                .build();
        
        ImagePrompt imagePrompt = new ImagePrompt(businessPrompt, options);
        return imageModel.call(imagePrompt).getResult().getOutput().getUrl();
    }
    
    private String buildBusinessPrompt(String description, BusinessType type) {
        String basePrompt = description;
        
        String businessStyle = switch (type) {
            case ECOMMERCE -> ", product photography, white background, professional lighting, commercial quality";
            case MARKETING -> ", marketing material, eye-catching design, professional layout, brand-focused";
            case SOCIAL_MEDIA -> ", social media post, engaging visual, trendy design, shareable content";
            case PRESENTATION -> ", business presentation, clean design, professional appearance, corporate style";
            case ADVERTISEMENT -> ", advertisement design, compelling visual, marketing appeal, brand promotion";
        };
        
        return basePrompt + businessStyle + ", high quality, professional, commercial use";
    }
    
    public enum BeautyStyle {
        REALISTIC, ANIME, PORTRAIT, ARTISTIC, MODERN
    }
    
    public enum BusinessType {
        ECOMMERCE, MARKETING, SOCIAL_MEDIA, PRESENTATION, ADVERTISEMENT
    }
}
```

---

## 5.3.6 OpenAI DALL-E 3 整合

### DALL-E 3 配置

```java
package com.example.config;

import org.springframework.ai.image.ImageModel;
import org.springframework.ai.openai.OpenAiImageModel;
import org.springframework.ai.openai.api.OpenAiImageApi;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;

@Configuration
public class ImageModelConfig {
    
    @Value("${spring.ai.openai.api-key}")
    private String openaiApiKey;
    
    /**
     * OpenAI DALL-E 3 模型配置（高品質）
     */
    @Bean("dalleImageModel")
    @Profile("dalle")
    public ImageModel dalleImageModel() {
        return new OpenAiImageModel(
            new OpenAiImageApi(openaiApiKey),
            org.springframework.ai.openai.OpenAiImageOptions.builder()
                .withModel("dall-e-3")
                .withQuality("hd")
                .withStyle("vivid")
                .withSize("1024x1024")
                .build()
        );
    }
    
    /**
     * 多模型路由服務
     */
    @Bean
    public MultiModelImageService multiModelImageService(
            @Qualifier("zhipuImageModel") ImageModel zhipuModel,
            @Qualifier("dalleImageModel") ImageModel dalleModel) {
        return new MultiModelImageService(zhipuModel, dalleModel);
    }
}
```

### 多模型路由服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.image.ImagePrompt;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class MultiModelImageService {
    
    private final ImageModel zhipuModel;
    private final ImageModel dalleModel;
    
    /**
     * 智能模型選擇
     * @param prompt 提示詞
     * @param quality 品質要求
     * @return 圖片 URL
     */
    public String generateWithBestModel(String prompt, QualityLevel quality) {
        ImageModel selectedModel = selectModel(quality, prompt);
        
        try {
            ImagePrompt imagePrompt = new ImagePrompt(prompt);
            return selectedModel.call(imagePrompt).getResult().getOutput().getUrl();
            
        } catch (Exception e) {
            log.warn("主要模型失敗，嘗試備用模型：{}", e.getMessage());
            
            // 降級到備用模型
            ImageModel fallbackModel = (selectedModel == dalleModel) ? zhipuModel : dalleModel;
            ImagePrompt imagePrompt = new ImagePrompt(prompt);
            return fallbackModel.call(imagePrompt).getResult().getOutput().getUrl();
        }
    }
    
    private ImageModel selectModel(QualityLevel quality, String prompt) {
        // 根據品質要求和內容複雜度選擇模型
        if (quality == QualityLevel.PREMIUM || isComplexPrompt(prompt)) {
            log.info("選擇 DALL-E 3 模型（高品質）");
            return dalleModel;
        } else {
            log.info("選擇 ZhiPu AI 模型（經濟型）");
            return zhipuModel;
        }
    }
    
    private boolean isComplexPrompt(String prompt) {
        // 判斷提示詞複雜度
        return prompt.length() > 100 || 
               prompt.contains("detailed") || 
               prompt.contains("professional") ||
               prompt.contains("high quality");
    }
    
    public enum QualityLevel {
        BASIC, STANDARD, PREMIUM
    }
}
```

---

## 5.3.7 企業級圖片管理系統

### 圖片儲存和管理

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class ImageStorageService {
    
    @Value("${app.image.output-directory:./generated-images}")
    private String outputDirectory;
    
    private final RestTemplate restTemplate = new RestTemplate();
    
    /**
     * 下載並儲存圖片
     * @param imageUrl 圖片 URL
     * @param prompt 原始提示詞
     * @return 本地檔案路徑
     */
    public String downloadAndSaveImage(String imageUrl, String prompt) {
        try {
            // 建立輸出目錄
            Path outputPath = Paths.get(outputDirectory);
            if (!Files.exists(outputPath)) {
                Files.createDirectories(outputPath);
            }
            
            // 生成檔案名稱
            String fileName = generateFileName(prompt);
            Path filePath = outputPath.resolve(fileName);
            
            // 下載圖片
            byte[] imageBytes = restTemplate.getForObject(imageUrl, byte[].class);
            if (imageBytes != null) {
                Files.write(filePath, imageBytes);
                log.info("圖片已儲存：{}", filePath.toString());
                return filePath.toString();
            }
            
            throw new RuntimeException("無法下載圖片");
            
        } catch (IOException e) {
            log.error("圖片儲存失敗", e);
            throw new RuntimeException("圖片儲存失敗：" + e.getMessage());
        }
    }
    
    /**
     * 生成檔案名稱
     */
    private String generateFileName(String prompt) {
        String timestamp = LocalDateTime.now().format(
            DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")
        );
        String uuid = UUID.randomUUID().toString().substring(0, 8);
        String sanitizedPrompt = sanitizePrompt(prompt);
        
        return String.format("%s_%s_%s.png", timestamp, uuid, sanitizedPrompt);
    }
    
    /**
     * 清理提示詞作為檔案名稱
     */
    private String sanitizePrompt(String prompt) {
        return prompt.replaceAll("[^a-zA-Z0-9\u4e00-\u9fa5]", "_")
                    .substring(0, Math.min(prompt.length(), 20));
    }
    
    /**
     * 批次下載圖片
     */
    public List<String> batchDownloadImages(List<BatchImageGenerationService.BatchImageResult> results) {
        return results.stream()
                .filter(BatchImageGenerationService.BatchImageResult::isSuccess)
                .map(result -> downloadAndSaveImage(result.getImageUrl(), result.getPrompt()))
                .collect(java.util.stream.Collectors.toList());
    }
}
```

### 圖片快取系統

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.security.MessageDigest;
import java.time.Duration;

@Service
@RequiredArgsConstructor
@Slf4j
public class ImageCacheService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final ImageModel imageModel;
    
    /**
     * 帶快取的圖片生成
     */
    @Cacheable(value = "generatedImages", key = "#root.target.generateCacheKey(#prompt, #options)")
    public String generateImageWithCache(String prompt, ImageGenerationOptions options) {
        String cacheKey = generateCacheKey(prompt, options);
        
        // 檢查快取
        String cachedUrl = (String) redisTemplate.opsForValue().get(cacheKey);
        if (cachedUrl != null) {
            log.info("從快取返回圖片：{}", prompt);
            return cachedUrl;
        }
        
        // 生成新圖片
        String imageUrl = generateImage(prompt, options);
        
        // 儲存到快取（24小時）
        redisTemplate.opsForValue().set(cacheKey, imageUrl, Duration.ofHours(24));
        
        return imageUrl;
    }
    
    /**
     * 生成快取鍵
     */
    public String generateCacheKey(String prompt, ImageGenerationOptions options) {
        try {
            String combined = prompt + "|" + options.toString();
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] hash = md.digest(combined.getBytes());
            
            StringBuilder sb = new StringBuilder();
            for (byte b : hash) {
                sb.append(String.format("%02x", b));
            }
            return "image:" + sb.toString();
            
        } catch (Exception e) {
            return "image:" + Math.abs(prompt.hashCode());
        }
    }
    
    private String generateImage(String prompt, ImageGenerationOptions options) {
        // 實際的圖片生成邏輯
        ImagePrompt imagePrompt = new ImagePrompt(prompt);
        return imageModel.call(imagePrompt).getResult().getOutput().getUrl();
    }
}
```

---

## 5.3.8 實際應用場景

### 電商商品圖片生成

```java
@RestController
@RequestMapping("/api/ecommerce")
@RequiredArgsConstructor
public class EcommerceImageController {
    
    private final AdvancedImageGenerationService imageService;
    
    /**
     * 生成商品展示圖
     * @param productName 商品名稱
     * @param category 商品類別
     * @param style 展示風格
     * @return 商品圖片 URL
     */
    @PostMapping("/product-image")
    public ResponseEntity<ProductImageResponse> generateProductImage(
            @RequestBody ProductImageRequest request) {
        
        try {
            String prompt = buildProductPrompt(request);
            String imageUrl = imageService.generateBusinessImage(
                prompt, 
                AdvancedImageGenerationService.BusinessType.ECOMMERCE
            );
            
            ProductImageResponse response = ProductImageResponse.builder()
                    .success(true)
                    .imageUrl(imageUrl)
                    .productName(request.getProductName())
                    .category(request.getCategory())
                    .style(request.getStyle())
                    .timestamp(LocalDateTime.now())
                    .build();
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("商品圖片生成失敗", e);
            
            ProductImageResponse errorResponse = ProductImageResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    private String buildProductPrompt(ProductImageRequest request) {
        return String.format(
            "%s, %s category, %s style, product photography, white background, " +
            "professional lighting, high quality, commercial use, detailed, 4k resolution",
            request.getProductName(),
            request.getCategory(),
            request.getStyle()
        );
    }
}

@Data
public class ProductImageRequest {
    private String productName;
    private String category;
    private String style;
    private String description;
    private List<String> features;
}

@Data
@Builder
public class ProductImageResponse {
    private boolean success;
    private String imageUrl;
    private String productName;
    private String category;
    private String style;
    private String error;
    private LocalDateTime timestamp;
}
```

### 社群媒體內容生成

```java
@RestController
@RequestMapping("/api/social-media")
@RequiredArgsConstructor
public class SocialMediaController {
    
    private final AdvancedImageGenerationService imageService;
    
    /**
     * 生成社群媒體貼文圖片
     */
    @PostMapping("/post-image")
    public ResponseEntity<SocialMediaImageResponse> generatePostImage(
            @RequestBody SocialMediaRequest request) {
        
        try {
            String prompt = buildSocialMediaPrompt(request);
            String imageUrl = imageService.generateBusinessImage(
                prompt,
                AdvancedImageGenerationService.BusinessType.SOCIAL_MEDIA
            );
            
            return ResponseEntity.ok(
                SocialMediaImageResponse.builder()
                    .success(true)
                    .imageUrl(imageUrl)
                    .platform(request.getPlatform())
                    .theme(request.getTheme())
                    .build()
            );
            
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(
                SocialMediaImageResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .build()
            );
        }
    }
    
    private String buildSocialMediaPrompt(SocialMediaRequest request) {
        String platformStyle = switch (request.getPlatform().toLowerCase()) {
            case "instagram" -> "Instagram post, square format, trendy, aesthetic";
            case "facebook" -> "Facebook post, engaging, social media friendly";
            case "twitter" -> "Twitter header, professional, clean design";
            case "linkedin" -> "LinkedIn post, professional, business-oriented";
            default -> "social media post, engaging visual";
        };
        
        return String.format(
            "%s, %s theme, %s, high quality, eye-catching, shareable content",
            request.getContent(),
            request.getTheme(),
            platformStyle
        );
    }
}
```

---

## 📝 本章重點回顧

1. **圖片生成技術理解**：掌握了文字轉圖片的核心原理和應用價值
2. **多模型整合**：學會了 ZhiPu AI、OpenAI DALL-E 3 等多種模型的使用
3. **企業級功能**：建立了完整的圖片生成、儲存和管理系統
4. **實際應用場景**：實現了電商、社群媒體等商業應用
5. **效能優化**：掌握了快取、批次處理等優化技術

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **基礎圖片生成** | ⭐⭐⭐ | 低 | 所有圖片生成應用 |
| **多模型整合** | ⭐⭐⭐ | 中 | 企業級應用 |
| **批次處理** | ⭐⭐ | 中 | 大量內容生成 |
| **快取系統** | ⭐⭐ | 中 | 效能優化 |
| **圖片管理** | ⭐⭐ | 高 | 生產環境部署 |
| **商業應用** | ⭐⭐⭐ | 高 | 實際業務場景 |

### 成本控制建議

1. **模型選擇策略**：根據品質需求選擇合適的模型
2. **快取機制**：避免重複生成相同內容
3. **批次處理**：提高生成效率，降低單位成本
4. **品質控制**：平衡品質和成本的關係

### 下一步學習方向

在下一章中，我們將學習如何建立字幕產生器，探索音訊轉文字技術，為多媒體內容處理提供完整的解決方案。

---

**參考資料：**
- [Spring AI Image Generation Documentation](https://docs.spring.io/spring-ai/reference/api/imageclient.html)
- [OpenAI DALL-E 3 API](https://platform.openai.com/docs/guides/images)
- [ZhiPu AI CogView Documentation](https://open.bigmodel.cn/dev/api#cogview)
- [Stability AI API Reference](https://platform.stability.ai/docs/api-reference)
# 6.3 Spring AI 官方記憶

> **本章重點**：深入探索 Spring AI 1.0 GA 官方提供的記憶管理系統，掌握企業級記憶解決方案的完整功能和最佳實踐。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握官方記憶 API**：深入理解 Spring AI 官方記憶系統的完整架構
- 🎯 **配置企業級存儲**：學會配置和使用各種官方支援的存儲後端
- 🎯 **實現記憶策略**：掌握滑動視窗、記憶壓縮等進階記憶管理策略
- 🎯 **監控記憶系統**：建立記憶使用量監控和效能優化機制
- 🎯 **整合業務邏輯**：將記憶系統與實際業務需求完美結合

---

## 6.3.1 Spring AI 官方記憶系統架構

### 記憶系統的核心設計理念

Spring AI 1.0 GA 的記憶系統採用了分層架構設計，遵循 Spring 框架的核心原則：

**設計原則**：
- 🏗️ **抽象與實現分離**：清晰的介面定義和多種實現選擇
- 🔄 **可插拔架構**：支援不同存儲後端的無縫切換
- 📈 **可擴展性**：支援從單機到分散式的各種部署場景
- 🛡️ **企業級特性**：內建安全性、監控和管理功能

### 官方記憶系統架構圖

```
┌─────────────────────────────────────────────────────────────┐
│                Spring AI Memory System 1.0 GA              │
├─────────────────────────────────────────────────────────────┤
│  Application Layer                                          │
│  ┌─────────────────┐    ┌─────────────────┐               │
│  │   ChatClient    │    │   Memory        │               │
│  │   Integration   │    │   Management    │               │
│  └─────────────────┘    └─────────────────┘               │
├─────────────────────────────────────────────────────────────┤
│  Memory Management Layer                                    │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              ChatMemory Interface                       │ │
│  │  ┌─────────────────────────────────────────────────┐   │ │
│  │  │        MessageWindowChatMemory                  │   │ │
│  │  │  • Sliding Window Management                    │   │ │
│  │  │  • Automatic Cleanup                            │   │ │
│  │  │  • Memory Compression                           │   │ │
│  │  │  • Conversation Isolation                       │   │ │
│  │  └─────────────────────────────────────────────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Repository Abstraction Layer                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │           ChatMemoryRepository Interface                │ │
│  │  • save(conversationId, messages)                       │ │
│  │  • findByConversationId(conversationId)                 │ │
│  │  • deleteByConversationId(conversationId)               │ │
│  │  • existsByConversationId(conversationId)               │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Official Storage Implementations                           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │InMemory     │ │JDBC         │ │Redis        │          │
│  │Repository   │ │Repository   │ │Repository   │          │
│  │• Fast       │ │• Reliable   │ │• Scalable   │          │
│  │• Volatile   │ │• ACID       │ │• Distributed│          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │Cassandra    │ │Neo4j        │ │MongoDB      │          │
│  │Repository   │ │Repository   │ │Repository   │          │
│  │• BigData    │ │• Graph      │ │• Document   │          │
│  │• NoSQL      │ │• Relations  │ │• Flexible   │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

---

## 6.3.2 ChatMemory 核心介面深度解析

### 官方 ChatMemory 介面定義

```java
/**
 * Spring AI 官方記憶介面
 * 提供對話記憶的核心操作
 */
public interface ChatMemory {
    
    /**
     * 新增單一訊息到指定對話
     * @param conversationId 對話識別碼
     * @param message 要新增的訊息
     */
    void add(String conversationId, Message message);
    
    /**
     * 批次新增訊息到指定對話
     * @param conversationId 對話識別碼
     * @param messages 要新增的訊息列表
     */
    void add(String conversationId, List<Message> messages);
    
    /**
     * 獲取指定對話的所有訊息
     * @param conversationId 對話識別碼
     * @return 訊息列表
     */
    List<Message> get(String conversationId);
    
    /**
     * 清除指定對話的所有訊息
     * @param conversationId 對話識別碼
     */
    void clear(String conversationId);
    
    /**
     * 對話 ID 常數
     */
    String CONVERSATION_ID = "conversation_id";
}
```

### MessageWindowChatMemory 實現

```java
/**
 * 滑動視窗記憶實現
 * 自動管理記憶大小，保留最近的 N 條訊息
 */
public class MessageWindowChatMemory implements ChatMemory {
    
    private final ChatMemoryRepository repository;
    private final int maxMessages;
    
    /**
     * 使用 Builder 模式建立實例
     */
    public static Builder builder() {
        return new Builder();
    }
    
    public static class Builder {
        private ChatMemoryRepository repository;
        private int maxMessages = 10;
        
        public Builder chatMemoryRepository(ChatMemoryRepository repository) {
            this.repository = repository;
            return this;
        }
        
        public Builder maxMessages(int maxMessages) {
            this.maxMessages = maxMessages;
            return this;
        }
        
        public MessageWindowChatMemory build() {
            if (repository == null) {
                repository = new InMemoryChatMemoryRepository();
            }
            return new MessageWindowChatMemory(repository, maxMessages);
        }
    }
}
```

---

## 6.3.3 官方記憶存儲後端

### 支援的存儲實現

Spring AI 1.0 GA 提供了多種官方記憶存儲實現：

```java
// 可用的記憶存儲實現
InMemoryChatMemoryRepository    // 記憶體存儲
JdbcChatMemoryRepository        // JDBC 資料庫存儲
CassandraChatMemoryRepository   // Cassandra 存儲
Neo4jChatMemoryRepository       // Neo4j 圖形資料庫存儲
```

### 1. InMemory 記憶存儲

**特點**：
- ✅ **快速存取**：記憶體中的資料存取速度最快
- ✅ **零配置**：無需額外的資料庫設置
- ✅ **開發友善**：適合開發和測試環境
- ❌ **資料易失**：應用重啟後資料消失
- ❌ **記憶體限制**：受限於可用記憶體大小

**使用方式**：
```java
// 自動配置（預設）
@Autowired
ChatMemory chatMemory;

// 手動建立
ChatMemoryRepository repository = new InMemoryChatMemoryRepository();
ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .chatMemoryRepository(repository)
    .maxMessages(10)
    .build();
```

### 2. JDBC 記憶存儲

**Maven 依賴**：
```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-starter-model-chat-memory-repository-jdbc</artifactId>
</dependency>
```

**配置屬性**：
```properties
# 資料庫初始化設置
spring.ai.chat.memory.repository.jdbc.initialize-schema=embedded  # 僅嵌入式資料庫
spring.ai.chat.memory.repository.jdbc.initialize-schema=always    # 總是初始化
spring.ai.chat.memory.repository.jdbc.initialize-schema=never     # 從不初始化

# 自定義 Schema 路徑
spring.ai.chat.memory.repository.jdbc.schema=classpath:/custom/path/schema-mysql.sql
```

**使用方式**：
```java
// 自動配置
@Autowired
JdbcChatMemoryRepository chatMemoryRepository;

ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .chatMemoryRepository(chatMemoryRepository)
    .maxMessages(10)
    .build();

// 手動建立
ChatMemoryRepository chatMemoryRepository = JdbcChatMemoryRepository.builder()
    .jdbcTemplate(jdbcTemplate)
    .dialect(new PostgresChatMemoryDialect())
    .build();
```

### 3. Neo4j 記憶存儲

**Maven 依賴**：
```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-starter-model-chat-memory-repository-neo4j</artifactId>
</dependency>
```

**配置屬性**：
```properties
# Neo4j 記憶配置
spring.ai.chat.memory.repository.neo4j.sessionLabel=ChatSession
spring.ai.chat.memory.repository.neo4j.messageLabel=ChatMessage
spring.ai.chat.memory.repository.neo4j.toolCallLabel=ToolCall
spring.ai.chat.memory.repository.neo4j.metadataLabel=MessageMetadata
spring.ai.chat.memory.repository.neo4j.toolResponseLabel=ToolResponse
spring.ai.chat.memory.repository.neo4j.mediaLabel=MessageMedia
```

**使用方式**：
```java
// 自動配置
@Autowired
Neo4jChatMemoryRepository chatMemoryRepository;

ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .chatMemoryRepository(chatMemoryRepository)
    .maxMessages(10)
    .build();

// 手動建立
ChatMemoryRepository chatMemoryRepository = Neo4jChatMemoryRepository.builder()
    .driver(driver)
    .build();
```

### 4. Cassandra 記憶存儲

**Maven 依賴**：
```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-starter-model-chat-memory-repository-cassandra</artifactId>
</dependency>
```

**配置屬性**：
```properties
# Cassandra 配置
spring.cassandra.port=9042
spring.cassandra.localDatacenter=datacenter1
spring.ai.chat.memory.cassandra.time-to-live=3600
spring.ai.chat.memory.cassandra.keyspace=chat_memory
spring.ai.chat.memory.cassandra.messages-column=messages
spring.ai.chat.memory.cassandra.table=conversations
spring.ai.chat.memory.cassandra.initialize-schema=true
```

**使用方式**：
```java
// 自動配置
@Autowired
CassandraChatMemoryRepository chatMemoryRepository;

ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .chatMemoryRepository(chatMemoryRepository)
    .maxMessages(10)
    .build();

// 手動建立
ChatMemoryRepository chatMemoryRepository = CassandraChatMemoryRepository
    .create(CassandraChatMemoryConfig.builder().withCqlSession(cqlSession));
```
    
}
```

### MessageWindowChatMemory 官方實現

```java
/**
 * Spring AI 官方滑動視窗記憶實現
 * 支援自動記憶管理和多種存儲後端
 */
public class MessageWindowChatMemory implements ChatMemory {
    
    private final int maxMessages;
    private final ChatMemoryRepository repository;
    private final boolean autoCleanup;
    private final Duration cleanupInterval;
    
    /**
     * 使用 Builder 模式建構記憶實例
     */
    public static Builder builder() {
        return new Builder();
    }
    
    public static class Builder {
        private int maxMessages = 100;
        private ChatMemoryRepository repository;
        private boolean autoCleanup = true;
        private Duration cleanupInterval = Duration.ofHours(1);
        
        public Builder maxMessages(int maxMessages) {
            this.maxMessages = maxMessages;
            return this;
        }
        
        public Builder chatMemoryRepository(ChatMemoryRepository repository) {
            this.repository = repository;
            return this;
        }
        
        public Builder autoCleanup(boolean autoCleanup) {
            this.autoCleanup = autoCleanup;
            return this;
        }
        
        public Builder cleanupInterval(Duration interval) {
            this.cleanupInterval = interval;
            return this;
        }
        
        public MessageWindowChatMemory build() {
            if (repository == null) {
                repository = new InMemoryChatMemoryRepository();
            }
            return new MessageWindowChatMemory(maxMessages, repository, autoCleanup, cleanupInterval);
        }
    }
    
    @Override
    public void add(String conversationId, Message message) {
        List<Message> messages = get(conversationId);
        messages.add(message);
        
        // 滑動視窗邏輯：保持最新的 maxMessages 條訊息
        if (messages.size() > maxMessages) {
            messages = messages.subList(messages.size() - maxMessages, messages.size());
        }
        
        repository.save(conversationId, messages);
    }
    
    @Override
    public List<Message> get(String conversationId) {
        return repository.findByConversationId(conversationId);
    }
}
```

---

## 6.3.3 官方存儲後端實現

### 1. InMemoryChatMemoryRepository

```java
/**
 * 記憶體存儲實現 - 適合開發和測試
 */
@Component
public class InMemoryChatMemoryRepository implements ChatMemoryRepository {
    
    private final Map<String, List<Message>> conversations = new ConcurrentHashMap<>();
    
    @Override
    public void save(String conversationId, List<Message> messages) {
        conversations.put(conversationId, new ArrayList<>(messages));
    }
    
    @Override
    public List<Message> findByConversationId(String conversationId) {
        return conversations.getOrDefault(conversationId, new ArrayList<>());
    }
    
    @Override
    public void deleteByConversationId(String conversationId) {
        conversations.remove(conversationId);
    }
    
    @Override
    public boolean existsByConversationId(String conversationId) {
        return conversations.containsKey(conversationId);
    }
    
    @Override
    public Set<String> getAllConversationIds() {
        return new HashSet<>(conversations.keySet());
    }
}
```

### 2. JdbcChatMemoryRepository

```java
/**
 * JDBC 存儲實現 - 適合生產環境
 */
@Repository
@RequiredArgsConstructor
public class JdbcChatMemoryRepository implements ChatMemoryRepository {
    
    private final JdbcTemplate jdbcTemplate;
    private final ObjectMapper objectMapper;
    
    @PostConstruct
    public void initializeSchema() {
        jdbcTemplate.execute("""
            CREATE TABLE IF NOT EXISTS chat_memory (
                conversation_id VARCHAR(255) NOT NULL,
                message_index INTEGER NOT NULL,
                message_type VARCHAR(50) NOT NULL,
                content TEXT NOT NULL,
                metadata JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (conversation_id, message_index)
            )
        """);
    }
    
    @Override
    public void save(String conversationId, List<Message> messages) {
        // 先清除舊資料
        jdbcTemplate.update(
            "DELETE FROM chat_memory WHERE conversation_id = ?",
            conversationId
        );
        
        // 批次插入新資料
        List<Object[]> batchArgs = new ArrayList<>();
        for (int i = 0; i < messages.size(); i++) {
            Message message = messages.get(i);
            batchArgs.add(new Object[]{
                conversationId,
                i,
                message.getMessageType().name(),
                message.getContent(),
                serializeMetadata(message.getMetadata())
            });
        }
        
        jdbcTemplate.batchUpdate(
            "INSERT INTO chat_memory (conversation_id, message_index, message_type, content, metadata) VALUES (?, ?, ?, ?, ?)",
            batchArgs
        );
    }
    
    @Override
    public List<Message> findByConversationId(String conversationId) {
        return jdbcTemplate.query(
            "SELECT * FROM chat_memory WHERE conversation_id = ? ORDER BY message_index",
            new Object[]{conversationId},
            this::mapRowToMessage
        );
    }
    
    private Message mapRowToMessage(ResultSet rs, int rowNum) throws SQLException {
        String messageType = rs.getString("message_type");
        String content = rs.getString("content");
        String metadataJson = rs.getString("metadata");
        
        Map<String, Object> metadata = deserializeMetadata(metadataJson);
        
        return switch (MessageType.valueOf(messageType)) {
            case USER -> new UserMessage(content, metadata);
            case ASSISTANT -> new AssistantMessage(content, metadata);
            case SYSTEM -> new SystemMessage(content, metadata);
            case TOOL -> new ToolMessage(content, metadata);
        };
    }
}
```

### 3. RedisChatMemoryRepository

```java
/**
 * Redis 存儲實現 - 適合高效能和分散式環境
 */
@Repository
@RequiredArgsConstructor
public class RedisChatMemoryRepository implements ChatMemoryRepository {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;
    
    private static final String CONVERSATION_KEY_PREFIX = "chat:memory:";
    private static final String CONVERSATION_SET_KEY = "chat:conversations";
    
    @Override
    public void save(String conversationId, List<Message> messages) {
        String key = CONVERSATION_KEY_PREFIX + conversationId;
        
        try {
            // 序列化訊息列表
            String serializedMessages = objectMapper.writeValueAsString(messages);
            
            // 存儲到 Redis
            redisTemplate.opsForValue().set(key, serializedMessages);
            
            // 將對話 ID 加入集合
            redisTemplate.opsForSet().add(CONVERSATION_SET_KEY, conversationId);
            
            // 設定過期時間（可選）
            redisTemplate.expire(key, Duration.ofDays(7));
            
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to serialize messages", e);
        }
    }
    
    @Override
    public List<Message> findByConversationId(String conversationId) {
        String key = CONVERSATION_KEY_PREFIX + conversationId;
        String serializedMessages = (String) redisTemplate.opsForValue().get(key);
        
        if (serializedMessages == null) {
            return new ArrayList<>();
        }
        
        try {
            return objectMapper.readValue(
                serializedMessages,
                new TypeReference<List<Message>>() {}
            );
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to deserialize messages", e);
        }
    }
    
    @Override
    public void deleteByConversationId(String conversationId) {
        String key = CONVERSATION_KEY_PREFIX + conversationId;
        redisTemplate.delete(key);
        redisTemplate.opsForSet().remove(CONVERSATION_SET_KEY, conversationId);
    }
    
    @Override
    public Set<String> getAllConversationIds() {
        return redisTemplate.opsForSet().members(CONVERSATION_SET_KEY)
            .stream()
            .map(Object::toString)
            .collect(Collectors.toSet());
    }
}
```

---

## 6.3.4 企業級記憶配置

### 統一配置管理

```java
@Configuration
@EnableConfigurationProperties(ChatMemoryProperties.class)
@Slf4j
public class OfficialChatMemoryConfig {
    
    /**
     * 主要記憶 Bean - 根據配置自動選擇實現
     */
    @Bean
    @Primary
    public ChatMemory primaryChatMemory(
            ChatMemoryProperties properties,
            List<ChatMemoryRepository> repositories) {
        
        ChatMemoryRepository repository = selectRepository(properties.getType(), repositories);
        
        return MessageWindowChatMemory.builder()
            .maxMessages(properties.getMaxMessages())
            .chatMemoryRepository(repository)
            .autoCleanup(properties.isAutoCleanup())
            .cleanupInterval(Duration.ofHours(properties.getCleanupIntervalHours()))
            .build();
    }
    
    /**
     * 記憶體存儲配置
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "memory")
    public ChatMemoryRepository inMemoryRepository() {
        log.info("Configuring InMemory ChatMemoryRepository");
        return new InMemoryChatMemoryRepository();
    }
    
    /**
     * JDBC 存儲配置
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "jdbc")
    public ChatMemoryRepository jdbcRepository(
            JdbcTemplate jdbcTemplate,
            ObjectMapper objectMapper) {
        log.info("Configuring JDBC ChatMemoryRepository");
        return new JdbcChatMemoryRepository(jdbcTemplate, objectMapper);
    }
    
    /**
     * Redis 存儲配置
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "redis")
    public ChatMemoryRepository redisRepository(
            RedisTemplate<String, Object> redisTemplate,
            ObjectMapper objectMapper) {
        log.info("Configuring Redis ChatMemoryRepository");
        return new RedisChatMemoryRepository(redisTemplate, objectMapper);
    }
    
    /**
     * Neo4j 存儲配置
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "neo4j")
    public ChatMemoryRepository neo4jRepository(Neo4jTemplate neo4jTemplate) {
        log.info("Configuring Neo4j ChatMemoryRepository");
        return new Neo4jChatMemoryRepository(neo4jTemplate);
    }
    
    private ChatMemoryRepository selectRepository(
            String type, 
            List<ChatMemoryRepository> repositories) {
        
        return repositories.stream()
            .filter(repo -> matchesType(repo, type))
            .findFirst()
            .orElseThrow(() -> new IllegalStateException(
                "No ChatMemoryRepository found for type: " + type));
    }
    
    private boolean matchesType(ChatMemoryRepository repository, String type) {
        return switch (type.toLowerCase()) {
            case "memory" -> repository instanceof InMemoryChatMemoryRepository;
            case "jdbc" -> repository instanceof JdbcChatMemoryRepository;
            case "redis" -> repository instanceof RedisChatMemoryRepository;
            case "neo4j" -> repository instanceof Neo4jChatMemoryRepository;
            default -> false;
        };
    }
}
```

### 配置屬性類

```java
@ConfigurationProperties(prefix = "app.chat.memory")
@Data
@Validated
public class ChatMemoryProperties {
    
    /**
     * 記憶存儲類型
     */
    @NotBlank
    private String type = "memory";
    
    /**
     * 滑動視窗最大訊息數量
     */
    @Min(1)
    @Max(10000)
    private int maxMessages = 100;
    
    /**
     * 是否啟用自動清理
     */
    private boolean autoCleanup = true;
    
    /**
     * 清理間隔（小時）
     */
    @Min(1)
    @Max(168) // 最多一週
    private int cleanupIntervalHours = 24;
    
    /**
     * 記憶過期時間（天）
     */
    @Min(1)
    @Max(365)
    private int expirationDays = 7;
    
    /**
     * 是否啟用記憶壓縮
     */
    private boolean compressionEnabled = false;
    
    /**
     * 壓縮閾值
     */
    @Min(50)
    private int compressionThreshold = 200;
    
    /**
     * 是否啟用記憶統計
     */
    private boolean metricsEnabled = true;
    
    /**
     * 批次處理大小
     */
    @Min(1)
    @Max(1000)
    private int batchSize = 100;
}
```

---

## 6.3.5 記憶監控與管理

### 記憶統計服務

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class ChatMemoryMetricsService {
    
    private final ChatMemory chatMemory;
    private final MeterRegistry meterRegistry;
    
    // 統計指標
    private final Counter memoryOperations;
    private final Timer memoryAccessTime;
    private final Gauge activeConversations;
    private final Gauge totalMessages;
    
    public ChatMemoryMetricsService(ChatMemory chatMemory, MeterRegistry meterRegistry) {
        this.chatMemory = chatMemory;
        this.meterRegistry = meterRegistry;
        
        // 初始化統計指標
        this.memoryOperations = Counter.builder("chat.memory.operations")
            .description("Chat memory operations count")
            .register(meterRegistry);
            
        this.memoryAccessTime = Timer.builder("chat.memory.access.time")
            .description("Chat memory access time")
            .register(meterRegistry);
            
        this.activeConversations = Gauge.builder("chat.memory.conversations.active")
            .description("Number of active conversations")
            .register(meterRegistry, this, ChatMemoryMetricsService::getActiveConversationCount);
            
        this.totalMessages = Gauge.builder("chat.memory.messages.total")
            .description("Total number of messages in memory")
            .register(meterRegistry, this, ChatMemoryMetricsService::getTotalMessageCount);
    }
    
    /**
     * 記錄記憶操作
     */
    public void recordOperation(String operation, String conversationId) {
        memoryOperations.increment(
            Tags.of(
                "operation", operation,
                "conversation_id", conversationId
            )
        );
    }
    
    /**
     * 測量記憶存取時間
     */
    public <T> T timeMemoryAccess(String operation, Supplier<T> supplier) {
        return memoryAccessTime.recordCallable(() -> {
            try {
                return supplier.get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }
    
    /**
     * 取得活躍對話數量
     */
    public double getActiveConversationCount() {
        try {
            // 注意：實際實現需要根據具體的 ChatMemoryRepository 介面
            // 官方 ChatMemory 介面不包含 getConversationIds() 方法
            // 以下為示例實現
            return 0;
        } catch (Exception e) {
            log.warn("Failed to get active conversation count", e);
            return 0;
        }
    }
    
    /**
     * 取得總訊息數量
     */
    public double getTotalMessageCount() {
        try {
            // 注意：實際實現需要根據具體的 ChatMemoryRepository 介面
            // 官方 ChatMemory 介面不包含 getConversationIds() 或 size() 方法
            // 以下為示例實現
            return 0;
        } catch (Exception e) {
            log.warn("Failed to get total message count", e);
            return 0;
        }
    }
    
    /**
     * 取得記憶統計報告
     */
    public MemoryStatistics getMemoryStatistics() {
        // 注意：實際實現需要根據具體的 ChatMemoryRepository 介面
        // 官方 ChatMemory 介面不包含 getConversationIds() 或 size() 方法
        // 以下為示例實現
        Set<String> conversationIds = new HashSet<>();
        int totalConversations = conversationIds.size();
        int totalMessages = 0; // 需要透過 repository 查詢得到
        
        double averageMessagesPerConversation = totalConversations > 0 
            ? (double) totalMessages / totalConversations 
            : 0;
        
        return MemoryStatistics.builder()
            .totalConversations(totalConversations)
            .totalMessages(totalMessages)
            .averageMessagesPerConversation(averageMessagesPerConversation)
            .timestamp(LocalDateTime.now())
            .build();
    }
}
```

### 記憶健康檢查

```java
@Component
public class ChatMemoryHealthIndicator implements HealthIndicator {
    
    private final ChatMemory chatMemory;
    private final ChatMemoryProperties properties;
    
    public ChatMemoryHealthIndicator(ChatMemory chatMemory, ChatMemoryProperties properties) {
        this.chatMemory = chatMemory;
        this.properties = properties;
    }
    
    @Override
    public Health health() {
        try {
            // 檢查記憶系統基本功能
            String testConversationId = "health-check-" + System.currentTimeMillis();
            
            // 測試寫入
            chatMemory.add(testConversationId, new SystemMessage("Health check"));
            
            // 測試讀取
            List<Message> messages = chatMemory.get(testConversationId);
            
            // 測試刪除
            chatMemory.clear(testConversationId);
            
            // 檢查記憶使用情況
            // 注意：官方 ChatMemory 介面不包含 getConversationIds() 方法
            int activeConversations = 0; // 需要透過 ChatMemoryRepository 實現統計
            int maxConversations = properties.getMaxMessages() * 10; // 估算值
            
            Health.Builder healthBuilder = Health.up()
                .withDetail("type", properties.getType())
                .withDetail("activeConversations", activeConversations)
                .withDetail("maxMessages", properties.getMaxMessages())
                .withDetail("autoCleanup", properties.isAutoCleanup());
            
            // 檢查記憶使用率
            if (activeConversations > maxConversations * 0.8) {
                healthBuilder.status("WARNING")
                    .withDetail("warning", "Memory usage is high");
            }
            
            return healthBuilder.build();
            
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .withException(e)
                .build();
        }
    }
}
```

---

## 6.3.6 記憶管理最佳實踐

### 自動記憶清理服務

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class ChatMemoryCleanupService {
    
    private final ChatMemory chatMemory;
    private final ChatMemoryProperties properties;
    private final ChatMemoryMetricsService metricsService;
    
    /**
     * 定期清理過期對話
     */
    @Scheduled(fixedRateString = "#{chatMemoryProperties.cleanupIntervalHours * 3600000}")
    public void cleanupExpiredConversations() {
        if (!properties.isAutoCleanup()) {
            return;
        }
        
        log.info("Starting memory cleanup process");
        
        try {
            // 注意：官方 ChatMemory 介面不包含 getConversationIds() 方法
            // 實際應用中需要透過 ChatMemoryRepository 來獲取對話列表
            Set<String> conversationIds = new HashSet<>();
            int cleanedCount = 0;
            
            for (String conversationId : conversationIds) {
                if (shouldCleanupConversation(conversationId)) {
                    chatMemory.clear(conversationId);
                    cleanedCount++;
                    
                    metricsService.recordOperation("cleanup", conversationId);
                }
            }
            
            log.info("Memory cleanup completed. Cleaned {} conversations", cleanedCount);
            
        } catch (Exception e) {
            log.error("Memory cleanup failed", e);
        }
    }
    
    /**
     * 智能記憶壓縮
     */
    @Scheduled(fixedRate = 7200000) // 每 2 小時執行一次
    public void compressLongConversations() {
        if (!properties.isCompressionEnabled()) {
            return;
        }
        
        log.info("Starting memory compression process");
        
        // 注意：官方 ChatMemory 介面不包含 getConversationIds() 方法
        Set<String> conversationIds = new HashSet<>();
        
        for (String conversationId : conversationIds) {
            // 注意：官方 ChatMemory 介面不包含 size() 方法
            int messageCount = chatMemory.get(conversationId).size();
            
            if (messageCount > properties.getCompressionThreshold()) {
                compressConversation(conversationId);
            }
        }
    }
    
    private boolean shouldCleanupConversation(String conversationId) {
        // 實現清理邏輯，例如基於最後活動時間
        // 這裡簡化為檢查對話 ID 中的時間戳
        try {
            if (conversationId.contains("-")) {
                String[] parts = conversationId.split("-");
                long timestamp = Long.parseLong(parts[parts.length - 1]);
                long expirationTime = System.currentTimeMillis() - 
                    (properties.getExpirationDays() * 24 * 60 * 60 * 1000L);
                
                return timestamp < expirationTime;
            }
        } catch (Exception e) {
            log.warn("Failed to parse conversation timestamp: {}", conversationId);
        }
        
        return false;
    }
    
    private void compressConversation(String conversationId) {
        List<Message> messages = chatMemory.get(conversationId);
        
        if (messages.size() <= properties.getCompressionThreshold()) {
            return;
        }
        
        // 保留最近的訊息
        int keepCount = properties.getMaxMessages() / 2;
        List<Message> recentMessages = messages.subList(
            messages.size() - keepCount, 
            messages.size()
        );
        
        // 壓縮較舊的訊息
        List<Message> oldMessages = messages.subList(0, messages.size() - keepCount);
        String summary = summarizeMessages(oldMessages);
        
        // 重建記憶
        chatMemory.clear(conversationId);
        chatMemory.add(conversationId, new SystemMessage("對話摘要：" + summary));
        chatMemory.add(conversationId, recentMessages);
        
        log.info("Compressed conversation {} from {} to {} messages", 
            conversationId, messages.size(), recentMessages.size() + 1);
    }
    
    private String summarizeMessages(List<Message> messages) {
        // 實現訊息摘要邏輯
        return "[摘要] 包含 " + messages.size() + " 條歷史訊息的對話摘要";
    }
}
```

### 記憶備份與恢復

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class ChatMemoryBackupService {
    
    private final ChatMemory chatMemory;
    private final ObjectMapper objectMapper;
    
    /**
     * 備份所有對話記憶
     */
    public void backupMemory(String backupPath) throws IOException {
        log.info("Starting memory backup to: {}", backupPath);
        
        Map<String, List<Message>> allConversations = new HashMap<>();
        
        // 注意：官方 ChatMemory 介面不包含 getConversationIds() 方法
        // 實際應用中需要透過 ChatMemoryRepository 來獲取對話列表
        Set<String> conversationIds = new HashSet<>();
        for (String conversationId : conversationIds) {
            List<Message> messages = chatMemory.get(conversationId);
            allConversations.put(conversationId, messages);
        }
        
        MemoryBackup backup = MemoryBackup.builder()
            .conversations(allConversations)
            .backupTime(LocalDateTime.now())
            .version("1.0")
            .build();
        
        objectMapper.writeValue(new File(backupPath), backup);
        
        log.info("Memory backup completed. Backed up {} conversations", 
            allConversations.size());
    }
    
    /**
     * 恢復對話記憶
     */
    public void restoreMemory(String backupPath) throws IOException {
        log.info("Starting memory restore from: {}", backupPath);
        
        MemoryBackup backup = objectMapper.readValue(new File(backupPath), MemoryBackup.class);
        
        int restoredCount = 0;
        for (Map.Entry<String, List<Message>> entry : backup.getConversations().entrySet()) {
            String conversationId = entry.getKey();
            List<Message> messages = entry.getValue();
            
            chatMemory.clear(conversationId);
            chatMemory.add(conversationId, messages);
            restoredCount++;
        }
        
        log.info("Memory restore completed. Restored {} conversations", restoredCount);
    }
}
```

---

## 📝 本章重點回顧

1. **官方記憶架構**：深入理解了 Spring AI 官方記憶系統的完整架構設計
2. **核心介面掌握**：掌握了 ChatMemory 和 ChatMemoryRepository 的官方介面定義
3. **多存儲後端**：學會了配置和使用官方支援的各種存儲後端實現
4. **企業級配置**：建立了統一的配置管理和自動選擇機制
5. **監控與管理**：實現了完整的記憶監控、健康檢查和自動管理功能

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **MessageWindowChatMemory** | ⭐⭐⭐ | 中 | 核心記憶管理 |
| **多存儲後端支援** | ⭐⭐⭐ | 高 | 靈活部署 |
| **自動配置機制** | ⭐⭐ | 中 | 簡化配置 |
| **記憶監控系統** | ⭐⭐ | 中 | 運維管理 |
| **自動清理壓縮** | ⭐⭐ | 高 | 效能優化 |

### 最佳實踐建議

1. **存儲選擇**：根據應用規模和需求選擇合適的存儲後端
2. **配置管理**：使用統一的配置屬性管理所有記憶相關設定
3. **監控告警**：建立完整的記憶使用量監控和告警機制
4. **自動化管理**：實施自動清理、壓縮和備份策略
5. **效能優化**：根據實際使用情況調整滑動視窗大小和清理策略

### 下一步學習方向

在下一章中，我們將學習 Spring AI 的鏈式增強器（Advisor）系統，包括：
- Advisor 的進階應用和自定義開發
- 多個 Advisor 的組合和優先級管理
- 企業級 Advisor 的設計模式
- 與記憶系統的深度整合

---

**參考資料：**
- [Spring AI Memory Documentation](https://docs.spring.io/spring-ai/reference/api/chat-memory.html)
- [MessageWindowChatMemory API](https://docs.spring.io/spring-ai/reference/api/chat-memory.html#_messagewindowchatmemory)
- [ChatMemoryRepository Interface](https://docs.spring.io/spring-ai/reference/api/chat-memory.html#_chatmemoryrepository)
- [Spring Boot Actuator Integration](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html)
# 6.3 Spring AI å®˜æ–¹è¨˜æ†¶

> **æœ¬ç« é‡é»**ï¼šæ·±å…¥æ¢ç´¢ Spring AI 1.0 GA å®˜æ–¹æä¾›çš„è¨˜æ†¶ç®¡ç†ç³»çµ±ï¼ŒæŒæ¡ä¼æ¥­ç´šè¨˜æ†¶è§£æ±ºæ–¹æ¡ˆçš„å®Œæ•´åŠŸèƒ½å’Œæœ€ä½³å¯¦è¸ã€‚

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬ç« å­¸ç¿’å¾Œï¼Œæ‚¨å°‡èƒ½å¤ ï¼š

- ğŸ¯ **æŒæ¡å®˜æ–¹è¨˜æ†¶ API**ï¼šæ·±å…¥ç†è§£ Spring AI å®˜æ–¹è¨˜æ†¶ç³»çµ±çš„å®Œæ•´æ¶æ§‹
- ğŸ¯ **é…ç½®ä¼æ¥­ç´šå­˜å„²**ï¼šå­¸æœƒé…ç½®å’Œä½¿ç”¨å„ç¨®å®˜æ–¹æ”¯æ´çš„å­˜å„²å¾Œç«¯
- ğŸ¯ **å¯¦ç¾è¨˜æ†¶ç­–ç•¥**ï¼šæŒæ¡æ»‘å‹•è¦–çª—ã€è¨˜æ†¶å£“ç¸®ç­‰é€²éšè¨˜æ†¶ç®¡ç†ç­–ç•¥
- ğŸ¯ **ç›£æ§è¨˜æ†¶ç³»çµ±**ï¼šå»ºç«‹è¨˜æ†¶ä½¿ç”¨é‡ç›£æ§å’Œæ•ˆèƒ½å„ªåŒ–æ©Ÿåˆ¶
- ğŸ¯ **æ•´åˆæ¥­å‹™é‚è¼¯**ï¼šå°‡è¨˜æ†¶ç³»çµ±èˆ‡å¯¦éš›æ¥­å‹™éœ€æ±‚å®Œç¾çµåˆ

---

## 6.3.1 Spring AI å®˜æ–¹è¨˜æ†¶ç³»çµ±æ¶æ§‹

### è¨˜æ†¶ç³»çµ±çš„æ ¸å¿ƒè¨­è¨ˆç†å¿µ

Spring AI 1.0 GA çš„è¨˜æ†¶ç³»çµ±æ¡ç”¨äº†åˆ†å±¤æ¶æ§‹è¨­è¨ˆï¼Œéµå¾ª Spring æ¡†æ¶çš„æ ¸å¿ƒåŸå‰‡ï¼š

**è¨­è¨ˆåŸå‰‡**ï¼š
- ğŸ—ï¸ **æŠ½è±¡èˆ‡å¯¦ç¾åˆ†é›¢**ï¼šæ¸…æ™°çš„ä»‹é¢å®šç¾©å’Œå¤šç¨®å¯¦ç¾é¸æ“‡
- ğŸ”„ **å¯æ’æ‹”æ¶æ§‹**ï¼šæ”¯æ´ä¸åŒå­˜å„²å¾Œç«¯çš„ç„¡ç¸«åˆ‡æ›
- ğŸ“ˆ **å¯æ“´å±•æ€§**ï¼šæ”¯æ´å¾å–®æ©Ÿåˆ°åˆ†æ•£å¼çš„å„ç¨®éƒ¨ç½²å ´æ™¯
- ğŸ›¡ï¸ **ä¼æ¥­ç´šç‰¹æ€§**ï¼šå…§å»ºå®‰å…¨æ€§ã€ç›£æ§å’Œç®¡ç†åŠŸèƒ½

### å®˜æ–¹è¨˜æ†¶ç³»çµ±æ¶æ§‹åœ–

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Spring AI Memory System 1.0 GA              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Application Layer                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚   ChatClient    â”‚    â”‚   Memory        â”‚               â”‚
â”‚  â”‚   Integration   â”‚    â”‚   Management    â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Memory Management Layer                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              ChatMemory Interface                       â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚        MessageWindowChatMemory                  â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Sliding Window Management                    â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Automatic Cleanup                            â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Memory Compression                           â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Conversation Isolation                       â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Repository Abstraction Layer                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚           ChatMemoryRepository Interface                â”‚ â”‚
â”‚  â”‚  â€¢ save(conversationId, messages)                       â”‚ â”‚
â”‚  â”‚  â€¢ findByConversationId(conversationId)                 â”‚ â”‚
â”‚  â”‚  â€¢ deleteByConversationId(conversationId)               â”‚ â”‚
â”‚  â”‚  â€¢ existsByConversationId(conversationId)               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Official Storage Implementations                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚InMemory     â”‚ â”‚JDBC         â”‚ â”‚Redis        â”‚          â”‚
â”‚  â”‚Repository   â”‚ â”‚Repository   â”‚ â”‚Repository   â”‚          â”‚
â”‚  â”‚â€¢ Fast       â”‚ â”‚â€¢ Reliable   â”‚ â”‚â€¢ Scalable   â”‚          â”‚
â”‚  â”‚â€¢ Volatile   â”‚ â”‚â€¢ ACID       â”‚ â”‚â€¢ Distributedâ”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚Cassandra    â”‚ â”‚Neo4j        â”‚ â”‚MongoDB      â”‚          â”‚
â”‚  â”‚Repository   â”‚ â”‚Repository   â”‚ â”‚Repository   â”‚          â”‚
â”‚  â”‚â€¢ BigData    â”‚ â”‚â€¢ Graph      â”‚ â”‚â€¢ Document   â”‚          â”‚
â”‚  â”‚â€¢ NoSQL      â”‚ â”‚â€¢ Relations  â”‚ â”‚â€¢ Flexible   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6.3.2 ChatMemory æ ¸å¿ƒä»‹é¢æ·±åº¦è§£æ

### å®˜æ–¹ ChatMemory ä»‹é¢å®šç¾©

```java
/**
 * Spring AI å®˜æ–¹è¨˜æ†¶ä»‹é¢
 * æä¾›å°è©±è¨˜æ†¶çš„æ ¸å¿ƒæ“ä½œ
 */
public interface ChatMemory {
    
    /**
     * æ–°å¢å–®ä¸€è¨Šæ¯åˆ°æŒ‡å®šå°è©±
     * @param conversationId å°è©±è­˜åˆ¥ç¢¼
     * @param message è¦æ–°å¢çš„è¨Šæ¯
     */
    void add(String conversationId, Message message);
    
    /**
     * æ‰¹æ¬¡æ–°å¢è¨Šæ¯åˆ°æŒ‡å®šå°è©±
     * @param conversationId å°è©±è­˜åˆ¥ç¢¼
     * @param messages è¦æ–°å¢çš„è¨Šæ¯åˆ—è¡¨
     */
    void add(String conversationId, List<Message> messages);
    
    /**
     * ç²å–æŒ‡å®šå°è©±çš„æ‰€æœ‰è¨Šæ¯
     * @param conversationId å°è©±è­˜åˆ¥ç¢¼
     * @return è¨Šæ¯åˆ—è¡¨
     */
    List<Message> get(String conversationId);
    
    /**
     * æ¸…é™¤æŒ‡å®šå°è©±çš„æ‰€æœ‰è¨Šæ¯
     * @param conversationId å°è©±è­˜åˆ¥ç¢¼
     */
    void clear(String conversationId);
    
    /**
     * å°è©± ID å¸¸æ•¸
     */
    String CONVERSATION_ID = "conversation_id";
}
```

### MessageWindowChatMemory å¯¦ç¾

```java
/**
 * æ»‘å‹•è¦–çª—è¨˜æ†¶å¯¦ç¾
 * è‡ªå‹•ç®¡ç†è¨˜æ†¶å¤§å°ï¼Œä¿ç•™æœ€è¿‘çš„ N æ¢è¨Šæ¯
 */
public class MessageWindowChatMemory implements ChatMemory {
    
    private final ChatMemoryRepository repository;
    private final int maxMessages;
    
    /**
     * ä½¿ç”¨ Builder æ¨¡å¼å»ºç«‹å¯¦ä¾‹
     */
    public static Builder builder() {
        return new Builder();
    }
    
    public static class Builder {
        private ChatMemoryRepository repository;
        private int maxMessages = 10;
        
        public Builder chatMemoryRepository(ChatMemoryRepository repository) {
            this.repository = repository;
            return this;
        }
        
        public Builder maxMessages(int maxMessages) {
            this.maxMessages = maxMessages;
            return this;
        }
        
        public MessageWindowChatMemory build() {
            if (repository == null) {
                repository = new InMemoryChatMemoryRepository();
            }
            return new MessageWindowChatMemory(repository, maxMessages);
        }
    }
}
```

---

## 6.3.3 å®˜æ–¹è¨˜æ†¶å­˜å„²å¾Œç«¯

### æ”¯æ´çš„å­˜å„²å¯¦ç¾

Spring AI 1.0 GA æä¾›äº†å¤šç¨®å®˜æ–¹è¨˜æ†¶å­˜å„²å¯¦ç¾ï¼š

```java
// å¯ç”¨çš„è¨˜æ†¶å­˜å„²å¯¦ç¾
InMemoryChatMemoryRepository    // è¨˜æ†¶é«”å­˜å„²
JdbcChatMemoryRepository        // JDBC è³‡æ–™åº«å­˜å„²
CassandraChatMemoryRepository   // Cassandra å­˜å„²
Neo4jChatMemoryRepository       // Neo4j åœ–å½¢è³‡æ–™åº«å­˜å„²
```

### 1. InMemory è¨˜æ†¶å­˜å„²

**ç‰¹é»**ï¼š
- âœ… **å¿«é€Ÿå­˜å–**ï¼šè¨˜æ†¶é«”ä¸­çš„è³‡æ–™å­˜å–é€Ÿåº¦æœ€å¿«
- âœ… **é›¶é…ç½®**ï¼šç„¡éœ€é¡å¤–çš„è³‡æ–™åº«è¨­ç½®
- âœ… **é–‹ç™¼å‹å–„**ï¼šé©åˆé–‹ç™¼å’Œæ¸¬è©¦ç’°å¢ƒ
- âŒ **è³‡æ–™æ˜“å¤±**ï¼šæ‡‰ç”¨é‡å•Ÿå¾Œè³‡æ–™æ¶ˆå¤±
- âŒ **è¨˜æ†¶é«”é™åˆ¶**ï¼šå—é™æ–¼å¯ç”¨è¨˜æ†¶é«”å¤§å°

**ä½¿ç”¨æ–¹å¼**ï¼š
```java
// è‡ªå‹•é…ç½®ï¼ˆé è¨­ï¼‰
@Autowired
ChatMemory chatMemory;

// æ‰‹å‹•å»ºç«‹
ChatMemoryRepository repository = new InMemoryChatMemoryRepository();
ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .chatMemoryRepository(repository)
    .maxMessages(10)
    .build();
```

### 2. JDBC è¨˜æ†¶å­˜å„²

**Maven ä¾è³´**ï¼š
```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-starter-model-chat-memory-repository-jdbc</artifactId>
</dependency>
```

**é…ç½®å±¬æ€§**ï¼š
```properties
# è³‡æ–™åº«åˆå§‹åŒ–è¨­ç½®
spring.ai.chat.memory.repository.jdbc.initialize-schema=embedded  # åƒ…åµŒå…¥å¼è³‡æ–™åº«
spring.ai.chat.memory.repository.jdbc.initialize-schema=always    # ç¸½æ˜¯åˆå§‹åŒ–
spring.ai.chat.memory.repository.jdbc.initialize-schema=never     # å¾ä¸åˆå§‹åŒ–

# è‡ªå®šç¾© Schema è·¯å¾‘
spring.ai.chat.memory.repository.jdbc.schema=classpath:/custom/path/schema-mysql.sql
```

**ä½¿ç”¨æ–¹å¼**ï¼š
```java
// è‡ªå‹•é…ç½®
@Autowired
JdbcChatMemoryRepository chatMemoryRepository;

ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .chatMemoryRepository(chatMemoryRepository)
    .maxMessages(10)
    .build();

// æ‰‹å‹•å»ºç«‹
ChatMemoryRepository chatMemoryRepository = JdbcChatMemoryRepository.builder()
    .jdbcTemplate(jdbcTemplate)
    .dialect(new PostgresChatMemoryDialect())
    .build();
```

### 3. Neo4j è¨˜æ†¶å­˜å„²

**Maven ä¾è³´**ï¼š
```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-starter-model-chat-memory-repository-neo4j</artifactId>
</dependency>
```

**é…ç½®å±¬æ€§**ï¼š
```properties
# Neo4j è¨˜æ†¶é…ç½®
spring.ai.chat.memory.repository.neo4j.sessionLabel=ChatSession
spring.ai.chat.memory.repository.neo4j.messageLabel=ChatMessage
spring.ai.chat.memory.repository.neo4j.toolCallLabel=ToolCall
spring.ai.chat.memory.repository.neo4j.metadataLabel=MessageMetadata
spring.ai.chat.memory.repository.neo4j.toolResponseLabel=ToolResponse
spring.ai.chat.memory.repository.neo4j.mediaLabel=MessageMedia
```

**ä½¿ç”¨æ–¹å¼**ï¼š
```java
// è‡ªå‹•é…ç½®
@Autowired
Neo4jChatMemoryRepository chatMemoryRepository;

ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .chatMemoryRepository(chatMemoryRepository)
    .maxMessages(10)
    .build();

// æ‰‹å‹•å»ºç«‹
ChatMemoryRepository chatMemoryRepository = Neo4jChatMemoryRepository.builder()
    .driver(driver)
    .build();
```

### 4. Cassandra è¨˜æ†¶å­˜å„²

**Maven ä¾è³´**ï¼š
```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-starter-model-chat-memory-repository-cassandra</artifactId>
</dependency>
```

**é…ç½®å±¬æ€§**ï¼š
```properties
# Cassandra é…ç½®
spring.cassandra.port=9042
spring.cassandra.localDatacenter=datacenter1
spring.ai.chat.memory.cassandra.time-to-live=3600
spring.ai.chat.memory.cassandra.keyspace=chat_memory
spring.ai.chat.memory.cassandra.messages-column=messages
spring.ai.chat.memory.cassandra.table=conversations
spring.ai.chat.memory.cassandra.initialize-schema=true
```

**ä½¿ç”¨æ–¹å¼**ï¼š
```java
// è‡ªå‹•é…ç½®
@Autowired
CassandraChatMemoryRepository chatMemoryRepository;

ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .chatMemoryRepository(chatMemoryRepository)
    .maxMessages(10)
    .build();

// æ‰‹å‹•å»ºç«‹
ChatMemoryRepository chatMemoryRepository = CassandraChatMemoryRepository
    .create(CassandraChatMemoryConfig.builder().withCqlSession(cqlSession));
```
    
}
```

### MessageWindowChatMemory å®˜æ–¹å¯¦ç¾

```java
/**
 * Spring AI å®˜æ–¹æ»‘å‹•è¦–çª—è¨˜æ†¶å¯¦ç¾
 * æ”¯æ´è‡ªå‹•è¨˜æ†¶ç®¡ç†å’Œå¤šç¨®å­˜å„²å¾Œç«¯
 */
public class MessageWindowChatMemory implements ChatMemory {
    
    private final int maxMessages;
    private final ChatMemoryRepository repository;
    private final boolean autoCleanup;
    private final Duration cleanupInterval;
    
    /**
     * ä½¿ç”¨ Builder æ¨¡å¼å»ºæ§‹è¨˜æ†¶å¯¦ä¾‹
     */
    public static Builder builder() {
        return new Builder();
    }
    
    public static class Builder {
        private int maxMessages = 100;
        private ChatMemoryRepository repository;
        private boolean autoCleanup = true;
        private Duration cleanupInterval = Duration.ofHours(1);
        
        public Builder maxMessages(int maxMessages) {
            this.maxMessages = maxMessages;
            return this;
        }
        
        public Builder chatMemoryRepository(ChatMemoryRepository repository) {
            this.repository = repository;
            return this;
        }
        
        public Builder autoCleanup(boolean autoCleanup) {
            this.autoCleanup = autoCleanup;
            return this;
        }
        
        public Builder cleanupInterval(Duration interval) {
            this.cleanupInterval = interval;
            return this;
        }
        
        public MessageWindowChatMemory build() {
            if (repository == null) {
                repository = new InMemoryChatMemoryRepository();
            }
            return new MessageWindowChatMemory(maxMessages, repository, autoCleanup, cleanupInterval);
        }
    }
    
    @Override
    public void add(String conversationId, Message message) {
        List<Message> messages = get(conversationId);
        messages.add(message);
        
        // æ»‘å‹•è¦–çª—é‚è¼¯ï¼šä¿æŒæœ€æ–°çš„ maxMessages æ¢è¨Šæ¯
        if (messages.size() > maxMessages) {
            messages = messages.subList(messages.size() - maxMessages, messages.size());
        }
        
        repository.save(conversationId, messages);
    }
    
    @Override
    public List<Message> get(String conversationId) {
        return repository.findByConversationId(conversationId);
    }
}
```

---

## 6.3.3 å®˜æ–¹å­˜å„²å¾Œç«¯å¯¦ç¾

### 1. InMemoryChatMemoryRepository

```java
/**
 * è¨˜æ†¶é«”å­˜å„²å¯¦ç¾ - é©åˆé–‹ç™¼å’Œæ¸¬è©¦
 */
@Component
public class InMemoryChatMemoryRepository implements ChatMemoryRepository {
    
    private final Map<String, List<Message>> conversations = new ConcurrentHashMap<>();
    
    @Override
    public void save(String conversationId, List<Message> messages) {
        conversations.put(conversationId, new ArrayList<>(messages));
    }
    
    @Override
    public List<Message> findByConversationId(String conversationId) {
        return conversations.getOrDefault(conversationId, new ArrayList<>());
    }
    
    @Override
    public void deleteByConversationId(String conversationId) {
        conversations.remove(conversationId);
    }
    
    @Override
    public boolean existsByConversationId(String conversationId) {
        return conversations.containsKey(conversationId);
    }
    
    @Override
    public Set<String> getAllConversationIds() {
        return new HashSet<>(conversations.keySet());
    }
}
```

### 2. JdbcChatMemoryRepository

```java
/**
 * JDBC å­˜å„²å¯¦ç¾ - é©åˆç”Ÿç”¢ç’°å¢ƒ
 */
@Repository
@RequiredArgsConstructor
public class JdbcChatMemoryRepository implements ChatMemoryRepository {
    
    private final JdbcTemplate jdbcTemplate;
    private final ObjectMapper objectMapper;
    
    @PostConstruct
    public void initializeSchema() {
        jdbcTemplate.execute("""
            CREATE TABLE IF NOT EXISTS chat_memory (
                conversation_id VARCHAR(255) NOT NULL,
                message_index INTEGER NOT NULL,
                message_type VARCHAR(50) NOT NULL,
                content TEXT NOT NULL,
                metadata JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (conversation_id, message_index)
            )
        """);
    }
    
    @Override
    public void save(String conversationId, List<Message> messages) {
        // å…ˆæ¸…é™¤èˆŠè³‡æ–™
        jdbcTemplate.update(
            "DELETE FROM chat_memory WHERE conversation_id = ?",
            conversationId
        );
        
        // æ‰¹æ¬¡æ’å…¥æ–°è³‡æ–™
        List<Object[]> batchArgs = new ArrayList<>();
        for (int i = 0; i < messages.size(); i++) {
            Message message = messages.get(i);
            batchArgs.add(new Object[]{
                conversationId,
                i,
                message.getMessageType().name(),
                message.getContent(),
                serializeMetadata(message.getMetadata())
            });
        }
        
        jdbcTemplate.batchUpdate(
            "INSERT INTO chat_memory (conversation_id, message_index, message_type, content, metadata) VALUES (?, ?, ?, ?, ?)",
            batchArgs
        );
    }
    
    @Override
    public List<Message> findByConversationId(String conversationId) {
        return jdbcTemplate.query(
            "SELECT * FROM chat_memory WHERE conversation_id = ? ORDER BY message_index",
            new Object[]{conversationId},
            this::mapRowToMessage
        );
    }
    
    private Message mapRowToMessage(ResultSet rs, int rowNum) throws SQLException {
        String messageType = rs.getString("message_type");
        String content = rs.getString("content");
        String metadataJson = rs.getString("metadata");
        
        Map<String, Object> metadata = deserializeMetadata(metadataJson);
        
        return switch (MessageType.valueOf(messageType)) {
            case USER -> new UserMessage(content, metadata);
            case ASSISTANT -> new AssistantMessage(content, metadata);
            case SYSTEM -> new SystemMessage(content, metadata);
            case TOOL -> new ToolMessage(content, metadata);
        };
    }
}
```

### 3. RedisChatMemoryRepository

```java
/**
 * Redis å­˜å„²å¯¦ç¾ - é©åˆé«˜æ•ˆèƒ½å’Œåˆ†æ•£å¼ç’°å¢ƒ
 */
@Repository
@RequiredArgsConstructor
public class RedisChatMemoryRepository implements ChatMemoryRepository {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;
    
    private static final String CONVERSATION_KEY_PREFIX = "chat:memory:";
    private static final String CONVERSATION_SET_KEY = "chat:conversations";
    
    @Override
    public void save(String conversationId, List<Message> messages) {
        String key = CONVERSATION_KEY_PREFIX + conversationId;
        
        try {
            // åºåˆ—åŒ–è¨Šæ¯åˆ—è¡¨
            String serializedMessages = objectMapper.writeValueAsString(messages);
            
            // å­˜å„²åˆ° Redis
            redisTemplate.opsForValue().set(key, serializedMessages);
            
            // å°‡å°è©± ID åŠ å…¥é›†åˆ
            redisTemplate.opsForSet().add(CONVERSATION_SET_KEY, conversationId);
            
            // è¨­å®šéæœŸæ™‚é–“ï¼ˆå¯é¸ï¼‰
            redisTemplate.expire(key, Duration.ofDays(7));
            
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to serialize messages", e);
        }
    }
    
    @Override
    public List<Message> findByConversationId(String conversationId) {
        String key = CONVERSATION_KEY_PREFIX + conversationId;
        String serializedMessages = (String) redisTemplate.opsForValue().get(key);
        
        if (serializedMessages == null) {
            return new ArrayList<>();
        }
        
        try {
            return objectMapper.readValue(
                serializedMessages,
                new TypeReference<List<Message>>() {}
            );
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to deserialize messages", e);
        }
    }
    
    @Override
    public void deleteByConversationId(String conversationId) {
        String key = CONVERSATION_KEY_PREFIX + conversationId;
        redisTemplate.delete(key);
        redisTemplate.opsForSet().remove(CONVERSATION_SET_KEY, conversationId);
    }
    
    @Override
    public Set<String> getAllConversationIds() {
        return redisTemplate.opsForSet().members(CONVERSATION_SET_KEY)
            .stream()
            .map(Object::toString)
            .collect(Collectors.toSet());
    }
}
```

---

## 6.3.4 ä¼æ¥­ç´šè¨˜æ†¶é…ç½®

### çµ±ä¸€é…ç½®ç®¡ç†

```java
@Configuration
@EnableConfigurationProperties(ChatMemoryProperties.class)
@Slf4j
public class OfficialChatMemoryConfig {
    
    /**
     * ä¸»è¦è¨˜æ†¶ Bean - æ ¹æ“šé…ç½®è‡ªå‹•é¸æ“‡å¯¦ç¾
     */
    @Bean
    @Primary
    public ChatMemory primaryChatMemory(
            ChatMemoryProperties properties,
            List<ChatMemoryRepository> repositories) {
        
        ChatMemoryRepository repository = selectRepository(properties.getType(), repositories);
        
        return MessageWindowChatMemory.builder()
            .maxMessages(properties.getMaxMessages())
            .chatMemoryRepository(repository)
            .autoCleanup(properties.isAutoCleanup())
            .cleanupInterval(Duration.ofHours(properties.getCleanupIntervalHours()))
            .build();
    }
    
    /**
     * è¨˜æ†¶é«”å­˜å„²é…ç½®
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "memory")
    public ChatMemoryRepository inMemoryRepository() {
        log.info("Configuring InMemory ChatMemoryRepository");
        return new InMemoryChatMemoryRepository();
    }
    
    /**
     * JDBC å­˜å„²é…ç½®
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "jdbc")
    public ChatMemoryRepository jdbcRepository(
            JdbcTemplate jdbcTemplate,
            ObjectMapper objectMapper) {
        log.info("Configuring JDBC ChatMemoryRepository");
        return new JdbcChatMemoryRepository(jdbcTemplate, objectMapper);
    }
    
    /**
     * Redis å­˜å„²é…ç½®
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "redis")
    public ChatMemoryRepository redisRepository(
            RedisTemplate<String, Object> redisTemplate,
            ObjectMapper objectMapper) {
        log.info("Configuring Redis ChatMemoryRepository");
        return new RedisChatMemoryRepository(redisTemplate, objectMapper);
    }
    
    /**
     * Neo4j å­˜å„²é…ç½®
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "neo4j")
    public ChatMemoryRepository neo4jRepository(Neo4jTemplate neo4jTemplate) {
        log.info("Configuring Neo4j ChatMemoryRepository");
        return new Neo4jChatMemoryRepository(neo4jTemplate);
    }
    
    private ChatMemoryRepository selectRepository(
            String type, 
            List<ChatMemoryRepository> repositories) {
        
        return repositories.stream()
            .filter(repo -> matchesType(repo, type))
            .findFirst()
            .orElseThrow(() -> new IllegalStateException(
                "No ChatMemoryRepository found for type: " + type));
    }
    
    private boolean matchesType(ChatMemoryRepository repository, String type) {
        return switch (type.toLowerCase()) {
            case "memory" -> repository instanceof InMemoryChatMemoryRepository;
            case "jdbc" -> repository instanceof JdbcChatMemoryRepository;
            case "redis" -> repository instanceof RedisChatMemoryRepository;
            case "neo4j" -> repository instanceof Neo4jChatMemoryRepository;
            default -> false;
        };
    }
}
```

### é…ç½®å±¬æ€§é¡

```java
@ConfigurationProperties(prefix = "app.chat.memory")
@Data
@Validated
public class ChatMemoryProperties {
    
    /**
     * è¨˜æ†¶å­˜å„²é¡å‹
     */
    @NotBlank
    private String type = "memory";
    
    /**
     * æ»‘å‹•è¦–çª—æœ€å¤§è¨Šæ¯æ•¸é‡
     */
    @Min(1)
    @Max(10000)
    private int maxMessages = 100;
    
    /**
     * æ˜¯å¦å•Ÿç”¨è‡ªå‹•æ¸…ç†
     */
    private boolean autoCleanup = true;
    
    /**
     * æ¸…ç†é–“éš”ï¼ˆå°æ™‚ï¼‰
     */
    @Min(1)
    @Max(168) // æœ€å¤šä¸€é€±
    private int cleanupIntervalHours = 24;
    
    /**
     * è¨˜æ†¶éæœŸæ™‚é–“ï¼ˆå¤©ï¼‰
     */
    @Min(1)
    @Max(365)
    private int expirationDays = 7;
    
    /**
     * æ˜¯å¦å•Ÿç”¨è¨˜æ†¶å£“ç¸®
     */
    private boolean compressionEnabled = false;
    
    /**
     * å£“ç¸®é–¾å€¼
     */
    @Min(50)
    private int compressionThreshold = 200;
    
    /**
     * æ˜¯å¦å•Ÿç”¨è¨˜æ†¶çµ±è¨ˆ
     */
    private boolean metricsEnabled = true;
    
    /**
     * æ‰¹æ¬¡è™•ç†å¤§å°
     */
    @Min(1)
    @Max(1000)
    private int batchSize = 100;
}
```

---

## 6.3.5 è¨˜æ†¶ç›£æ§èˆ‡ç®¡ç†

### è¨˜æ†¶çµ±è¨ˆæœå‹™

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class ChatMemoryMetricsService {
    
    private final ChatMemory chatMemory;
    private final MeterRegistry meterRegistry;
    
    // çµ±è¨ˆæŒ‡æ¨™
    private final Counter memoryOperations;
    private final Timer memoryAccessTime;
    private final Gauge activeConversations;
    private final Gauge totalMessages;
    
    public ChatMemoryMetricsService(ChatMemory chatMemory, MeterRegistry meterRegistry) {
        this.chatMemory = chatMemory;
        this.meterRegistry = meterRegistry;
        
        // åˆå§‹åŒ–çµ±è¨ˆæŒ‡æ¨™
        this.memoryOperations = Counter.builder("chat.memory.operations")
            .description("Chat memory operations count")
            .register(meterRegistry);
            
        this.memoryAccessTime = Timer.builder("chat.memory.access.time")
            .description("Chat memory access time")
            .register(meterRegistry);
            
        this.activeConversations = Gauge.builder("chat.memory.conversations.active")
            .description("Number of active conversations")
            .register(meterRegistry, this, ChatMemoryMetricsService::getActiveConversationCount);
            
        this.totalMessages = Gauge.builder("chat.memory.messages.total")
            .description("Total number of messages in memory")
            .register(meterRegistry, this, ChatMemoryMetricsService::getTotalMessageCount);
    }
    
    /**
     * è¨˜éŒ„è¨˜æ†¶æ“ä½œ
     */
    public void recordOperation(String operation, String conversationId) {
        memoryOperations.increment(
            Tags.of(
                "operation", operation,
                "conversation_id", conversationId
            )
        );
    }
    
    /**
     * æ¸¬é‡è¨˜æ†¶å­˜å–æ™‚é–“
     */
    public <T> T timeMemoryAccess(String operation, Supplier<T> supplier) {
        return memoryAccessTime.recordCallable(() -> {
            try {
                return supplier.get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }
    
    /**
     * å–å¾—æ´»èºå°è©±æ•¸é‡
     */
    public double getActiveConversationCount() {
        try {
            // æ³¨æ„ï¼šå¯¦éš›å¯¦ç¾éœ€è¦æ ¹æ“šå…·é«”çš„ ChatMemoryRepository ä»‹é¢
            // å®˜æ–¹ ChatMemory ä»‹é¢ä¸åŒ…å« getConversationIds() æ–¹æ³•
            // ä»¥ä¸‹ç‚ºç¤ºä¾‹å¯¦ç¾
            return 0;
        } catch (Exception e) {
            log.warn("Failed to get active conversation count", e);
            return 0;
        }
    }
    
    /**
     * å–å¾—ç¸½è¨Šæ¯æ•¸é‡
     */
    public double getTotalMessageCount() {
        try {
            // æ³¨æ„ï¼šå¯¦éš›å¯¦ç¾éœ€è¦æ ¹æ“šå…·é«”çš„ ChatMemoryRepository ä»‹é¢
            // å®˜æ–¹ ChatMemory ä»‹é¢ä¸åŒ…å« getConversationIds() æˆ– size() æ–¹æ³•
            // ä»¥ä¸‹ç‚ºç¤ºä¾‹å¯¦ç¾
            return 0;
        } catch (Exception e) {
            log.warn("Failed to get total message count", e);
            return 0;
        }
    }
    
    /**
     * å–å¾—è¨˜æ†¶çµ±è¨ˆå ±å‘Š
     */
    public MemoryStatistics getMemoryStatistics() {
        // æ³¨æ„ï¼šå¯¦éš›å¯¦ç¾éœ€è¦æ ¹æ“šå…·é«”çš„ ChatMemoryRepository ä»‹é¢
        // å®˜æ–¹ ChatMemory ä»‹é¢ä¸åŒ…å« getConversationIds() æˆ– size() æ–¹æ³•
        // ä»¥ä¸‹ç‚ºç¤ºä¾‹å¯¦ç¾
        Set<String> conversationIds = new HashSet<>();
        int totalConversations = conversationIds.size();
        int totalMessages = 0; // éœ€è¦é€é repository æŸ¥è©¢å¾—åˆ°
        
        double averageMessagesPerConversation = totalConversations > 0 
            ? (double) totalMessages / totalConversations 
            : 0;
        
        return MemoryStatistics.builder()
            .totalConversations(totalConversations)
            .totalMessages(totalMessages)
            .averageMessagesPerConversation(averageMessagesPerConversation)
            .timestamp(LocalDateTime.now())
            .build();
    }
}
```

### è¨˜æ†¶å¥åº·æª¢æŸ¥

```java
@Component
public class ChatMemoryHealthIndicator implements HealthIndicator {
    
    private final ChatMemory chatMemory;
    private final ChatMemoryProperties properties;
    
    public ChatMemoryHealthIndicator(ChatMemory chatMemory, ChatMemoryProperties properties) {
        this.chatMemory = chatMemory;
        this.properties = properties;
    }
    
    @Override
    public Health health() {
        try {
            // æª¢æŸ¥è¨˜æ†¶ç³»çµ±åŸºæœ¬åŠŸèƒ½
            String testConversationId = "health-check-" + System.currentTimeMillis();
            
            // æ¸¬è©¦å¯«å…¥
            chatMemory.add(testConversationId, new SystemMessage("Health check"));
            
            // æ¸¬è©¦è®€å–
            List<Message> messages = chatMemory.get(testConversationId);
            
            // æ¸¬è©¦åˆªé™¤
            chatMemory.clear(testConversationId);
            
            // æª¢æŸ¥è¨˜æ†¶ä½¿ç”¨æƒ…æ³
            // æ³¨æ„ï¼šå®˜æ–¹ ChatMemory ä»‹é¢ä¸åŒ…å« getConversationIds() æ–¹æ³•
            int activeConversations = 0; // éœ€è¦é€é ChatMemoryRepository å¯¦ç¾çµ±è¨ˆ
            int maxConversations = properties.getMaxMessages() * 10; // ä¼°ç®—å€¼
            
            Health.Builder healthBuilder = Health.up()
                .withDetail("type", properties.getType())
                .withDetail("activeConversations", activeConversations)
                .withDetail("maxMessages", properties.getMaxMessages())
                .withDetail("autoCleanup", properties.isAutoCleanup());
            
            // æª¢æŸ¥è¨˜æ†¶ä½¿ç”¨ç‡
            if (activeConversations > maxConversations * 0.8) {
                healthBuilder.status("WARNING")
                    .withDetail("warning", "Memory usage is high");
            }
            
            return healthBuilder.build();
            
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .withException(e)
                .build();
        }
    }
}
```

---

## 6.3.6 è¨˜æ†¶ç®¡ç†æœ€ä½³å¯¦è¸

### è‡ªå‹•è¨˜æ†¶æ¸…ç†æœå‹™

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class ChatMemoryCleanupService {
    
    private final ChatMemory chatMemory;
    private final ChatMemoryProperties properties;
    private final ChatMemoryMetricsService metricsService;
    
    /**
     * å®šæœŸæ¸…ç†éæœŸå°è©±
     */
    @Scheduled(fixedRateString = "#{chatMemoryProperties.cleanupIntervalHours * 3600000}")
    public void cleanupExpiredConversations() {
        if (!properties.isAutoCleanup()) {
            return;
        }
        
        log.info("Starting memory cleanup process");
        
        try {
            // æ³¨æ„ï¼šå®˜æ–¹ ChatMemory ä»‹é¢ä¸åŒ…å« getConversationIds() æ–¹æ³•
            // å¯¦éš›æ‡‰ç”¨ä¸­éœ€è¦é€é ChatMemoryRepository ä¾†ç²å–å°è©±åˆ—è¡¨
            Set<String> conversationIds = new HashSet<>();
            int cleanedCount = 0;
            
            for (String conversationId : conversationIds) {
                if (shouldCleanupConversation(conversationId)) {
                    chatMemory.clear(conversationId);
                    cleanedCount++;
                    
                    metricsService.recordOperation("cleanup", conversationId);
                }
            }
            
            log.info("Memory cleanup completed. Cleaned {} conversations", cleanedCount);
            
        } catch (Exception e) {
            log.error("Memory cleanup failed", e);
        }
    }
    
    /**
     * æ™ºèƒ½è¨˜æ†¶å£“ç¸®
     */
    @Scheduled(fixedRate = 7200000) // æ¯ 2 å°æ™‚åŸ·è¡Œä¸€æ¬¡
    public void compressLongConversations() {
        if (!properties.isCompressionEnabled()) {
            return;
        }
        
        log.info("Starting memory compression process");
        
        // æ³¨æ„ï¼šå®˜æ–¹ ChatMemory ä»‹é¢ä¸åŒ…å« getConversationIds() æ–¹æ³•
        Set<String> conversationIds = new HashSet<>();
        
        for (String conversationId : conversationIds) {
            // æ³¨æ„ï¼šå®˜æ–¹ ChatMemory ä»‹é¢ä¸åŒ…å« size() æ–¹æ³•
            int messageCount = chatMemory.get(conversationId).size();
            
            if (messageCount > properties.getCompressionThreshold()) {
                compressConversation(conversationId);
            }
        }
    }
    
    private boolean shouldCleanupConversation(String conversationId) {
        // å¯¦ç¾æ¸…ç†é‚è¼¯ï¼Œä¾‹å¦‚åŸºæ–¼æœ€å¾Œæ´»å‹•æ™‚é–“
        // é€™è£¡ç°¡åŒ–ç‚ºæª¢æŸ¥å°è©± ID ä¸­çš„æ™‚é–“æˆ³
        try {
            if (conversationId.contains("-")) {
                String[] parts = conversationId.split("-");
                long timestamp = Long.parseLong(parts[parts.length - 1]);
                long expirationTime = System.currentTimeMillis() - 
                    (properties.getExpirationDays() * 24 * 60 * 60 * 1000L);
                
                return timestamp < expirationTime;
            }
        } catch (Exception e) {
            log.warn("Failed to parse conversation timestamp: {}", conversationId);
        }
        
        return false;
    }
    
    private void compressConversation(String conversationId) {
        List<Message> messages = chatMemory.get(conversationId);
        
        if (messages.size() <= properties.getCompressionThreshold()) {
            return;
        }
        
        // ä¿ç•™æœ€è¿‘çš„è¨Šæ¯
        int keepCount = properties.getMaxMessages() / 2;
        List<Message> recentMessages = messages.subList(
            messages.size() - keepCount, 
            messages.size()
        );
        
        // å£“ç¸®è¼ƒèˆŠçš„è¨Šæ¯
        List<Message> oldMessages = messages.subList(0, messages.size() - keepCount);
        String summary = summarizeMessages(oldMessages);
        
        // é‡å»ºè¨˜æ†¶
        chatMemory.clear(conversationId);
        chatMemory.add(conversationId, new SystemMessage("å°è©±æ‘˜è¦ï¼š" + summary));
        chatMemory.add(conversationId, recentMessages);
        
        log.info("Compressed conversation {} from {} to {} messages", 
            conversationId, messages.size(), recentMessages.size() + 1);
    }
    
    private String summarizeMessages(List<Message> messages) {
        // å¯¦ç¾è¨Šæ¯æ‘˜è¦é‚è¼¯
        return "[æ‘˜è¦] åŒ…å« " + messages.size() + " æ¢æ­·å²è¨Šæ¯çš„å°è©±æ‘˜è¦";
    }
}
```

### è¨˜æ†¶å‚™ä»½èˆ‡æ¢å¾©

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class ChatMemoryBackupService {
    
    private final ChatMemory chatMemory;
    private final ObjectMapper objectMapper;
    
    /**
     * å‚™ä»½æ‰€æœ‰å°è©±è¨˜æ†¶
     */
    public void backupMemory(String backupPath) throws IOException {
        log.info("Starting memory backup to: {}", backupPath);
        
        Map<String, List<Message>> allConversations = new HashMap<>();
        
        // æ³¨æ„ï¼šå®˜æ–¹ ChatMemory ä»‹é¢ä¸åŒ…å« getConversationIds() æ–¹æ³•
        // å¯¦éš›æ‡‰ç”¨ä¸­éœ€è¦é€é ChatMemoryRepository ä¾†ç²å–å°è©±åˆ—è¡¨
        Set<String> conversationIds = new HashSet<>();
        for (String conversationId : conversationIds) {
            List<Message> messages = chatMemory.get(conversationId);
            allConversations.put(conversationId, messages);
        }
        
        MemoryBackup backup = MemoryBackup.builder()
            .conversations(allConversations)
            .backupTime(LocalDateTime.now())
            .version("1.0")
            .build();
        
        objectMapper.writeValue(new File(backupPath), backup);
        
        log.info("Memory backup completed. Backed up {} conversations", 
            allConversations.size());
    }
    
    /**
     * æ¢å¾©å°è©±è¨˜æ†¶
     */
    public void restoreMemory(String backupPath) throws IOException {
        log.info("Starting memory restore from: {}", backupPath);
        
        MemoryBackup backup = objectMapper.readValue(new File(backupPath), MemoryBackup.class);
        
        int restoredCount = 0;
        for (Map.Entry<String, List<Message>> entry : backup.getConversations().entrySet()) {
            String conversationId = entry.getKey();
            List<Message> messages = entry.getValue();
            
            chatMemory.clear(conversationId);
            chatMemory.add(conversationId, messages);
            restoredCount++;
        }
        
        log.info("Memory restore completed. Restored {} conversations", restoredCount);
    }
}
```

---

## ğŸ“ æœ¬ç« é‡é»å›é¡§

1. **å®˜æ–¹è¨˜æ†¶æ¶æ§‹**ï¼šæ·±å…¥ç†è§£äº† Spring AI å®˜æ–¹è¨˜æ†¶ç³»çµ±çš„å®Œæ•´æ¶æ§‹è¨­è¨ˆ
2. **æ ¸å¿ƒä»‹é¢æŒæ¡**ï¼šæŒæ¡äº† ChatMemory å’Œ ChatMemoryRepository çš„å®˜æ–¹ä»‹é¢å®šç¾©
3. **å¤šå­˜å„²å¾Œç«¯**ï¼šå­¸æœƒäº†é…ç½®å’Œä½¿ç”¨å®˜æ–¹æ”¯æ´çš„å„ç¨®å­˜å„²å¾Œç«¯å¯¦ç¾
4. **ä¼æ¥­ç´šé…ç½®**ï¼šå»ºç«‹äº†çµ±ä¸€çš„é…ç½®ç®¡ç†å’Œè‡ªå‹•é¸æ“‡æ©Ÿåˆ¶
5. **ç›£æ§èˆ‡ç®¡ç†**ï¼šå¯¦ç¾äº†å®Œæ•´çš„è¨˜æ†¶ç›£æ§ã€å¥åº·æª¢æŸ¥å’Œè‡ªå‹•ç®¡ç†åŠŸèƒ½

### æŠ€è¡“è¦é»ç¸½çµ

| æŠ€è¡“é» | é‡è¦æ€§ | å¯¦ç¾é›£åº¦ | ä¼æ¥­åƒ¹å€¼ |
|--------|--------|----------|----------|
| **MessageWindowChatMemory** | â­â­â­ | ä¸­ | æ ¸å¿ƒè¨˜æ†¶ç®¡ç† |
| **å¤šå­˜å„²å¾Œç«¯æ”¯æ´** | â­â­â­ | é«˜ | éˆæ´»éƒ¨ç½² |
| **è‡ªå‹•é…ç½®æ©Ÿåˆ¶** | â­â­ | ä¸­ | ç°¡åŒ–é…ç½® |
| **è¨˜æ†¶ç›£æ§ç³»çµ±** | â­â­ | ä¸­ | é‹ç¶­ç®¡ç† |
| **è‡ªå‹•æ¸…ç†å£“ç¸®** | â­â­ | é«˜ | æ•ˆèƒ½å„ªåŒ– |

### æœ€ä½³å¯¦è¸å»ºè­°

1. **å­˜å„²é¸æ“‡**ï¼šæ ¹æ“šæ‡‰ç”¨è¦æ¨¡å’Œéœ€æ±‚é¸æ“‡åˆé©çš„å­˜å„²å¾Œç«¯
2. **é…ç½®ç®¡ç†**ï¼šä½¿ç”¨çµ±ä¸€çš„é…ç½®å±¬æ€§ç®¡ç†æ‰€æœ‰è¨˜æ†¶ç›¸é—œè¨­å®š
3. **ç›£æ§å‘Šè­¦**ï¼šå»ºç«‹å®Œæ•´çš„è¨˜æ†¶ä½¿ç”¨é‡ç›£æ§å’Œå‘Šè­¦æ©Ÿåˆ¶
4. **è‡ªå‹•åŒ–ç®¡ç†**ï¼šå¯¦æ–½è‡ªå‹•æ¸…ç†ã€å£“ç¸®å’Œå‚™ä»½ç­–ç•¥
5. **æ•ˆèƒ½å„ªåŒ–**ï¼šæ ¹æ“šå¯¦éš›ä½¿ç”¨æƒ…æ³èª¿æ•´æ»‘å‹•è¦–çª—å¤§å°å’Œæ¸…ç†ç­–ç•¥

### ä¸‹ä¸€æ­¥å­¸ç¿’æ–¹å‘

åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘å€‘å°‡å­¸ç¿’ Spring AI çš„éˆå¼å¢å¼·å™¨ï¼ˆAdvisorï¼‰ç³»çµ±ï¼ŒåŒ…æ‹¬ï¼š
- Advisor çš„é€²éšæ‡‰ç”¨å’Œè‡ªå®šç¾©é–‹ç™¼
- å¤šå€‹ Advisor çš„çµ„åˆå’Œå„ªå…ˆç´šç®¡ç†
- ä¼æ¥­ç´š Advisor çš„è¨­è¨ˆæ¨¡å¼
- èˆ‡è¨˜æ†¶ç³»çµ±çš„æ·±åº¦æ•´åˆ

---

**åƒè€ƒè³‡æ–™ï¼š**
- [Spring AI Memory Documentation](https://docs.spring.io/spring-ai/reference/api/chat-memory.html)
- [MessageWindowChatMemory API](https://docs.spring.io/spring-ai/reference/api/chat-memory.html#_messagewindowchatmemory)
- [ChatMemoryRepository Interface](https://docs.spring.io/spring-ai/reference/api/chat-memory.html#_chatmemoryrepository)
- [Spring Boot Actuator Integration](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html)
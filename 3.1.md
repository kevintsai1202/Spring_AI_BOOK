# 3.1 資料驗證與錯誤處理

> **第三章導讀**：本章將帶您進入生產級 API 開發實踐，掌握資料驗證、錯誤處理等核心技術，為 Spring AI 應用建立堅實的品質保證基礎。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解資料驗證的重要性**：掌握 Web 應用中資料驗證的核心概念和必要性
- 🎯 **掌握 Bean Validation**：熟練使用 Spring Boot 內建的資料驗證框架
- 🎯 **實現統一例外處理**：建立完善的全域錯誤處理機制
- 🎯 **設計友善的錯誤回應**：為使用者和開發者提供清晰的錯誤訊息
- 🎯 **為 AI 服務做準備**：建立適合 AI 應用的驗證和錯誤處理策略

---

## 3.1.1 為什麼需要資料驗證？

### 資料驗證的重要性

在 Web 應用開發中，資料驗證是確保系統安全性和資料完整性的第一道防線。特別是在 AI 應用中，輸入資料的品質直接影響 AI 模型的表現。

> **思考問題**：如果您的 AI 應用接收到以下資料，會發生什麼問題？
> - 使用者名稱為空字串
> - 電子郵件格式不正確
> - 上傳的圖片格式不支援
> - AI 提示詞包含惡意內容

### 常見的資料問題

**1. 資料完整性問題**
```java
// 沒有驗證的情況下可能出現的問題
public class User {
    private String name;     // 可能為 null 或空字串
    private String email;    // 可能格式不正確
    private Integer age;     // 可能為負數
    private String password; // 可能太短或太簡單
}
```

**2. 安全性問題**
- SQL 注入攻擊
- XSS 跨站腳本攻擊
- 檔案上傳漏洞
- AI 提示注入攻擊

**3. 業務邏輯問題**
- 不符合業務規則的資料
- 資料格式不一致
- 缺少必要的關聯資料

---

## 3.1.2 Spring Boot Bean Validation

### 基本驗證註解

Spring Boot 內建了 Bean Validation 支援，提供了豐富的驗證註解：

```java
/**
 * 使用者註冊請求 DTO
 * 展示基本的資料驗證註解使用
 */
public class UserRegistrationRequest {
    
    @NotBlank(message = "使用者名稱不能為空")
    @Size(min = 2, max = 50, message = "使用者名稱長度必須在 2-50 字元之間")
    private String username;
    
    @NotBlank(message = "電子郵件不能為空")
    @Email(message = "電子郵件格式不正確")
    private String email;
    
    @NotBlank(message = "密碼不能為空")
    @Size(min = 8, max = 128, message = "密碼長度必須在 8-128 字元之間")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).*$", 
             message = "密碼必須包含大小寫字母和數字")
    private String password;
    
    @NotNull(message = "年齡不能為空")
    @Min(value = 18, message = "年齡必須大於等於 18 歲")
    @Max(value = 120, message = "年齡必須小於等於 120 歲")
    private Integer age;
    
    @NotEmpty(message = "興趣愛好不能為空")
    @Size(max = 10, message = "興趣愛好最多 10 個")
    private List<String> hobbies;
    
    // Getters and Setters
}
```

### 常用驗證註解總覽

| 註解 | 適用類型 | 說明 | 範例 |
|------|----------|------|------|
| **@NotNull** | 任何類型 | 不能為 null | `@NotNull Integer age` |
| **@NotBlank** | String | 不能為 null、空字串或只有空白字元 | `@NotBlank String name` |
| **@NotEmpty** | Collection, Map, Array | 不能為 null 或空集合 | `@NotEmpty List<String> tags` |
| **@Size** | String, Collection, Map, Array | 長度或大小限制 | `@Size(min=2, max=50)` |
| **@Min/@Max** | 數值類型 | 數值範圍限制 | `@Min(18) @Max(120)` |
| **@Email** | String | 電子郵件格式驗證 | `@Email String email` |
| **@Pattern** | String | 正規表達式驗證 | `@Pattern(regexp="...")` |
| **@Valid** | 物件 | 巢狀物件驗證 | `@Valid Address address` |

### 在控制器中使用驗證

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    /**
     * 使用者註冊
     * @Valid 註解觸發驗證，BindingResult 接收驗證結果
     */
    @PostMapping("/register")
    public ResponseEntity<ApiResponse<User>> registerUser(
            @Valid @RequestBody UserRegistrationRequest request,
            BindingResult bindingResult) {
        
        // 手動檢查驗證結果
        if (bindingResult.hasErrors()) {
            StringBuilder errorMessage = new StringBuilder("驗證失敗：");
            bindingResult.getFieldErrors().forEach(error -> 
                errorMessage.append(error.getField())
                           .append(" ")
                           .append(error.getDefaultMessage())
                           .append("; ")
            );
            return ResponseEntity.badRequest()
                    .body(ApiResponse.error(400, errorMessage.toString()));
        }
        
        User user = userService.registerUser(request);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success("註冊成功", user));
    }
    
    /**
     * 更新使用者資訊
     * 使用全域異常處理，無需手動檢查 BindingResult
     */
    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<User>> updateUser(
            @PathVariable Long id,
            @Valid @RequestBody UserUpdateRequest request) {
        
        User user = userService.updateUser(id, request);
        return ResponseEntity.ok(ApiResponse.success("更新成功", user));
    }
}
```

---

## 3.1.3 自訂驗證註解

### 建立自訂驗證註解

有時候內建的驗證註解無法滿足特殊的業務需求，我們可以建立自訂的驗證註解：

```java
/**
 * 自訂驗證註解：檢查密碼強度
 */
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = StrongPasswordValidator.class)
@Documented
public @interface StrongPassword {
    
    String message() default "密碼強度不足";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
    
    /**
     * 是否要求包含特殊字元
     */
    boolean requireSpecialChar() default true;
    
    /**
     * 最小長度
     */
    int minLength() default 8;
}
```

### 實現驗證邏輯

```java
/**
 * 密碼強度驗證器
 */
public class StrongPasswordValidator implements ConstraintValidator<StrongPassword, String> {
    
    private boolean requireSpecialChar;
    private int minLength;
    
    @Override
    public void initialize(StrongPassword annotation) {
        this.requireSpecialChar = annotation.requireSpecialChar();
        this.minLength = annotation.minLength();
    }
    
    @Override
    public boolean isValid(String password, ConstraintValidatorContext context) {
        if (password == null) {
            return false;
        }
        
        // 檢查長度
        if (password.length() < minLength) {
            return false;
        }
        
        // 檢查是否包含大寫字母
        if (!password.matches(".*[A-Z].*")) {
            return false;
        }
        
        // 檢查是否包含小寫字母
        if (!password.matches(".*[a-z].*")) {
            return false;
        }
        
        // 檢查是否包含數字
        if (!password.matches(".*\\d.*")) {
            return false;
        }
        
        // 檢查是否包含特殊字元（如果需要）
        if (requireSpecialChar && !password.matches(".*[!@#$%^&*()_+\\-=\\[\\]{};':,.<>?].*")) {
            return false;
        }
        
        return true;
    }
}
```

### 使用自訂驗證註解

```java
public class ChangePasswordRequest {
    
    @NotBlank(message = "舊密碼不能為空")
    private String oldPassword;
    
    @StrongPassword(minLength = 10, requireSpecialChar = true, 
                   message = "新密碼必須至少 10 字元，包含大小寫字母、數字和特殊字元")
    private String newPassword;
    
    // Getters and Setters
}
```

---

## 3.1.4 全域異常處理

### 建立全域異常處理器

```java
/**
 * 全域異常處理器
 * 統一處理應用程式中的各種異常情況
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    /**
     * 處理參數驗證異常
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Void>> handleValidationException(
            MethodArgumentNotValidException e) {
        
        log.warn("參數驗證失敗：{}", e.getMessage());
        
        Map<String, String> errors = new HashMap<>();
        e.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        ApiResponse<Void> response = ApiResponse.error(400, "參數驗證失敗", errors);
        return ResponseEntity.badRequest().body(response);
    }
    
    /**
     * 處理請求參數綁定異常
     */
    @ExceptionHandler(BindException.class)
    public ResponseEntity<ApiResponse<Void>> handleBindException(BindException e) {
        log.warn("參數綁定失敗：{}", e.getMessage());
        
        Map<String, String> errors = new HashMap<>();
        e.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        ApiResponse<Void> response = ApiResponse.error(400, "參數綁定失敗", errors);
        return ResponseEntity.badRequest().body(response);
    }
    
    /**
     * 處理資源不存在異常
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse<Void>> handleResourceNotFoundException(
            ResourceNotFoundException e) {
        log.warn("資源不存在：{}", e.getMessage());
        
        ApiResponse<Void> response = ApiResponse.error(404, e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }
    
    /**
     * 處理業務邏輯異常
     */
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiResponse<Void>> handleBusinessException(
            BusinessException e) {
        log.warn("業務邏輯異常：{}", e.getMessage());
        
        ApiResponse<Void> response = ApiResponse.error(e.getCode(), e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }
    
    /**
     * 處理資料庫約束違反異常
     */
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiResponse<Void>> handleDataIntegrityViolationException(
            DataIntegrityViolationException e) {
        log.error("資料庫約束違反：{}", e.getMessage());
        
        String message = "資料操作失敗，可能存在重複資料或違反約束條件";
        ApiResponse<Void> response = ApiResponse.error(409, message);
        return ResponseEntity.status(HttpStatus.CONFLICT).body(response);
    }
    
    /**
     * 處理一般異常
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleGeneralException(Exception e) {
        log.error("系統異常：", e);
        
        ApiResponse<Void> response = ApiResponse.error(500, "系統內部錯誤，請稍後再試");
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
    }
}
```

### 自訂業務異常

```java
/**
 * 業務異常基類
 */
public class BusinessException extends RuntimeException {
    
    private final int code;
    
    public BusinessException(int code, String message) {
        super(message);
        this.code = code;
    }
    
    public BusinessException(String message) {
        this(400, message);
    }
    
    public int getCode() {
        return code;
    }
}

/**
 * 資源不存在異常
 */
public class ResourceNotFoundException extends BusinessException {
    
    public ResourceNotFoundException(String resource, Object id) {
        super(404, String.format("%s (ID: %s) 不存在", resource, id));
    }
}

/**
 * 使用者相關異常
 */
public class UserException {
    
    public static class UserAlreadyExistsException extends BusinessException {
        public UserAlreadyExistsException(String email) {
            super(409, "電子郵件 " + email + " 已被註冊");
        }
    }
    
    public static class InvalidCredentialsException extends BusinessException {
        public InvalidCredentialsException() {
            super(401, "帳號或密碼錯誤");
        }
    }
}
```

---

## 3.1.5 為 Spring AI 做準備

### AI 服務的特殊驗證需求

在 AI 應用中，我們需要考慮特殊的驗證需求：

```java
/**
 * AI 對話請求驗證
 */
public class ChatRequest {
    
    @NotBlank(message = "使用者訊息不能為空")
    @Size(max = 4000, message = "訊息長度不能超過 4000 字元")
    @SafeContent(message = "訊息包含不當內容")
    private String message;
    
    @Valid
    private ChatContext context;
    
    @Min(value = 0, message = "溫度值必須大於等於 0")
    @Max(value = 2, message = "溫度值必須小於等於 2")
    private Double temperature = 0.7;
    
    @Min(value = 1, message = "最大 token 數必須大於 0")
    @Max(value = 4096, message = "最大 token 數不能超過 4096")
    private Integer maxTokens = 1000;
    
    // Getters and Setters
}

/**
 * 安全內容驗證註解
 */
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = SafeContentValidator.class)
public @interface SafeContent {
    String message() default "內容包含不當資訊";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

/**
 * 安全內容驗證器
 */
public class SafeContentValidator implements ConstraintValidator<SafeContent, String> {
    
    private static final List<String> FORBIDDEN_KEYWORDS = Arrays.asList(
        "暴力", "色情", "政治敏感", "仇恨言論"
        // 實際應用中應該有更完整的關鍵詞庫
    );
    
    @Override
    public boolean isValid(String content, ConstraintValidatorContext context) {
        if (content == null) {
            return true;
        }
        
        // 簡單的關鍵詞檢查（實際應用中應該使用更sophisticated的方法）
        String lowerContent = content.toLowerCase();
        return FORBIDDEN_KEYWORDS.stream()
                .noneMatch(lowerContent::contains);
    }
}
```

### 多媒體內容驗證

```java
/**
 * 多媒體 AI 請求驗證
 */
public class MultimodalAIRequest {
    
    @NotBlank(message = "文字內容不能為空")
    private String text;
    
    @ValidImage(message = "圖片格式不支援或大小超限")
    private String imageBase64;
    
    @ValidAudio(message = "音訊格式不支援或大小超限")
    private String audioBase64;
    
    // Getters and Setters
}

/**
 * 圖片驗證註解
 */
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = ImageValidator.class)
public @interface ValidImage {
    String message() default "圖片格式不正確";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
    
    long maxSize() default 5 * 1024 * 1024; // 5MB
    String[] allowedFormats() default {"JPEG", "PNG", "GIF"};
}
```

### AI 服務異常處理

```java
/**
 * AI 服務異常處理
 */
@RestControllerAdvice
public class AIServiceExceptionHandler {
    
    /**
     * 處理 AI 服務超時異常
     */
    @ExceptionHandler(AIServiceTimeoutException.class)
    public ResponseEntity<ApiResponse<Void>> handleAIServiceTimeout(
            AIServiceTimeoutException e) {
        
        ApiResponse<Void> response = ApiResponse.error(408, 
            "AI 服務回應超時，請稍後再試");
        return ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT).body(response);
    }
    
    /**
     * 處理 AI 服務配額超限異常
     */
    @ExceptionHandler(AIQuotaExceededException.class)
    public ResponseEntity<ApiResponse<Void>> handleAIQuotaExceeded(
            AIQuotaExceededException e) {
        
        ApiResponse<Void> response = ApiResponse.error(429, 
            "AI 服務使用量已達上限，請稍後再試");
        return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).body(response);
    }
    
    /**
     * 處理內容安全檢查失敗異常
     */
    @ExceptionHandler(ContentSafetyException.class)
    public ResponseEntity<ApiResponse<Void>> handleContentSafety(
            ContentSafetyException e) {
        
        ApiResponse<Void> response = ApiResponse.error(400, 
            "內容未通過安全檢查，請修改後重試");
        return ResponseEntity.badRequest().body(response);
    }
}
```

---

## 📝 本章重點回顧

1. **資料驗證重要性**：理解了資料驗證在系統安全和資料品質中的關鍵作用
2. **Bean Validation**：掌握了 Spring Boot 內建驗證框架的使用方法
3. **自訂驗證註解**：學會了建立符合業務需求的自訂驗證邏輯
4. **全域異常處理**：建立了統一的錯誤處理機制
5. **AI 服務準備**：為 Spring AI 的特殊驗證需求做好了準備

### 下一步學習方向

在下一章中，我們將學習檔案處理與多媒體支援，這對於 Spring AI 的多模態應用至關重要。

---

**參考資料：**
- [Bean Validation Specification](https://beanvalidation.org/)
- [Spring Boot Validation](https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc.validation)
- [Spring MVC Exception Handling](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-exceptionhandlers)
# 5.3 透過 Spring AI 整合 Google Gemini 2.5 Flash Image (Nano Banana)

> **本章重點**：學習使用 Spring AI 整合 Google Gemini 2.5 Flash Image（代號：Nano Banana）圖片生成和編輯功能，掌握先進的圖片生成與編輯技術，建立完整的 AI 圖片處理應用，探索 Google 最新圖片 AI 模型的強大能力。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 Gemini 2.5 Flash Image**：掌握 Google 最新圖片 AI 模型的核心原理和優勢
- 🎯 **選擇合適的圖片模型**：了解 Gemini 2.5 Flash Image 與其他圖片 AI 模型的差異
- 🎯 **實現圖片生成與編輯**：建立完整的圖片生成、編輯和處理 API 系統
- 🎯 **優化編輯品質**：掌握圖片編輯一致性和多輪對話編輯技巧
- 🎯 **企業級應用設計**：建立可商用的圖片生成與編輯服務架構

---

## 5.3.1 Gemini 2.5 Flash Image：Google 的圖片 AI 新里程碑

### 什麼是 Nano Banana？

![Gemini 2.5 Flash Image 示例](https://ithelp.ithome.com.tw/upload/images/20240810/20161290xVSyazJmHj.png)

**Nano Banana** 是 Google Gemini 2.5 Flash Image 的神秘代號，在 2025 年 LMArena 圖片編輯排行榜上以神秘身份登頂後，才被 Google 官方揭露其真實身份。這個「香蕉」圖示的模型以其卓越的**圖片編輯一致性**和**多輪對話編輯能力**震撼業界，成為目前世界排名第一的圖片編輯模型。

### Gemini 2.5 Flash Image 的突破性優勢

**1. 革命性的圖片編輯一致性**
- 🎭 **角色保持性**：編輯人物照片時保持角色特徵的完美一致性
- 👥 **細節敏感度**：特別關注人臉和身體特徵的微妙差異
- 🔄 **多輪編輯**：支援連續多次編輯而不失去原始特徵
- 📚 **自然語言控制**：使用自然語言進行精確的局部編輯

**2. 先進的圖片融合技術**
- 🖼️ **多圖混合**：將多張圖片無縫融合成單一圖片
- 📱 **智能組合**：利用 Gemini 的世界知識進行智能圖片組合
- 🎨 **風格轉換**：將一張圖片的風格或質感應用到另一張圖片
- 📊 **語義理解**：深度理解圖片內容和編輯意圖

**3. 企業級安全與品質**
- 💰 **SynthID 浮水印**：所有生成和編輯的圖片都包含不可見的 AI 識別標記
- 📖 **LMArena 認證**：在權威評測平台獲得第一名的優異表現
- 🎮 **Google 生態整合**：與 Google AI Studio 和 Vertex AI 完美整合
- 📺 **專業級品質**：提供最先進的圖片生成和編輯品質

---

## 5.3.2 Gemini 2.5 Flash Image vs 其他 AI 模型比較

### 主要 AI 圖片模型對比

| 模型 | 圖片編輯 | 多圖融合 | 特色 | 成本 | 推薦度 | 適用場景 |
|------|-----------|----------|------|------|--------|----------|
| **Gemini 2.5 Flash Image** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 編輯一致性、自然語言控制 | $0.039/圖 | ⭐⭐⭐⭐⭐ | 圖片編輯、專業設計 |
| **OpenAI DALL-E 3** | ⭐⭐⭐ | ⭐⭐⭐ | 高品質、理解複雜指令 | $0.040-0.080 | ⭐⭐⭐⭐ | 專業設計、商業用途 |
| **Stable Diffusion** | ⭐⭐ | ⭐⭐ | 開源、可本地部署 | 中 | ⭐⭐⭐ | 自主控制、客製化 |
| **Midjourney** | ⭐⭐⭐ | ⭐⭐ | 藝術性強、社群活躍 | 中 | ⭐⭐⭐⭐ | 藝術創作、概念設計 |
| **ZhiPu AI** | ⭐⭐ | ⭐⭐ | 中文友善、便宜 | 低 | ⭐⭐⭐ | 學習測試、中文內容 |

### Gemini 2.5 Flash Image 的核心優勢

```
🏆 Gemini 2.5 Flash Image 獨特功能：

1. 精準圖片編輯系統：
   - 自然語言控制：使用對話方式進行精確的圖片編輯
   - 局部修改能力：針對圖片特定區域進行精準編輯
   - 編輯一致性：保持人物特徵在編輯過程中的完美一致性

2. 多圖融合引擎：
   - 智能混合：將多張圖片的元素無縫融合
   - 風格轉移：將一張圖片的風格應用到另一張圖片
   - 語義理解：利用 Gemini 的世界知識進行智能組合

3. 企業級安全功能：
   - SynthID 浮水印：所有生成圖片包含不可見的 AI 識別標記
   - Google 生態整合：與 Google AI Studio 和 Vertex AI 完美配合
   - 專業級品質：LMArena 排名第一的圖片編輯能力
```

---

## 5.3.3 Spring AI 整合 Gemini 2.5 Flash Image

### 申請和配置

**1. 申請 OpenAI 相容 API Key**

由於 Gemini 2.5 Flash Image 透過多個第三方平台提供 OpenAI 相容的 API 服務，你可以選擇以下任一方式：
- **OpenRouter**: [https://openrouter.ai/](https://openrouter.ai/) - 提供 Gemini 2.5 Flash Image 的 OpenAI 相容 API
- **Fal.ai**: [https://fal.ai/](https://fal.ai/) - Google 官方合作夥伴，提供 Gemini 模型存取
- **其他 OpenAI 相容服務商**：支援 Gemini 2.5 Flash Image 的第三方平台

**2. 引入依賴**

在 `pom.xml` 中添加 OpenAI 整合依賴：

```xml
<!-- Spring AI BOM 管理版本 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-bom</artifactId>
            <version>1.0.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <!-- Spring AI OpenAI Starter -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Spring Boot Validation -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    
    <!-- Lombok -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

**3. 設定專案參數**

在 `application.yml` 中配置：

```yaml
spring:
  application:
    name: gemini-image-generator
  ai:
    openai:
      # 使用支援 Gemini 2.5 Flash Image 的 OpenAI 相容服務
      base-url: ${OPENAI_BASE_URL:https://openrouter.ai/api/v1}  # 或其他支援的服務商
      api-key: ${OPENAI_API_KEY}  # 你的 API Key
      image:
        options:
          model: google/gemini-2.5-flash-image  # Gemini 2.5 Flash Image 模型名稱
          quality: hd
          size: 1024x1024
          response-format: url
          user: spring-ai-user

# Gemini 圖片模型特殊配置
gemini:
  image:
    editing:
      max-input-images: 3        # 單次最多輸入圖片數量
      support-formats: ["jpeg", "png", "webp", "heic", "heif"]
      max-file-size: 20MB        # 單一圖片最大尺寸
    generation:
      include-synthid: true      # 包含 SynthID 浮水印
      safety-settings: medium    # 安全設定等級

# 應用程式配置
app:
  image:
    processing:
      max-batch-size: 5
      default-timeout: 45s
      cache-enabled: true
      output-directory: ./gemini-images

# 日誌配置
logging:
  level:
    org.springframework.ai: DEBUG
    com.example: DEBUG

# 環境變數設定範例
# OPENAI_API_KEY=your-openrouter-api-key
# OPENAI_BASE_URL=https://openrouter.ai/api/v1
```

**重要設定說明：**

1. **OpenRouter 設定**：
   - 在 OpenRouter 申請帳號並取得 API Key
   - 設定環境變數：`OPENAI_API_KEY=your-openrouter-key`
   - 使用 OpenRouter 的 base URL：`https://openrouter.ai/api/v1`
   - 模型名稱：`google/gemini-2.5-flash-image`

2. **其他支援的服務商**：
   - **Fal.ai**: `https://fal.run/fal-ai/gemini-2-5-flash-image`
   - **其他提供商**: 請查閱各自的 API 文檔取得正確的 base URL 和模型名稱

3. **注意事項**：
   - 不同服務商的模型名稱可能不同
   - 話費和使用限制請參考各服務商的定價
   - 確保使用支援 Gemini 2.5 Flash Image 的服務

---

## 5.3.4 簡單使用範例

### 基本圖片生成 API

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.image.ImagePrompt;
import org.springframework.ai.image.ImageResponse;
import org.springframework.ai.openai.OpenAiImageOptions;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/simple-image")
@RequiredArgsConstructor
@Slf4j
public class SimpleImageController {
    
    private final ImageModel imageModel;
    
    /**
     * 簡單的圖片生成 API
     */
    @GetMapping("/generate")
    public ResponseEntity<String> generateImage(@RequestParam String prompt) {
        try {
            log.info("生成圖片：{}", prompt);
            
            // 使用 OpenAI 相容的 Gemini 2.5 Flash Image
            OpenAiImageOptions options = OpenAiImageOptions.builder()
                    .withModel("google/gemini-2.5-flash-image")
                    .withQuality("hd")
                    .withSize("1024x1024")
                    .withResponseFormat("url")
                    .build();
            
            ImagePrompt imagePrompt = new ImagePrompt(prompt, options);
            ImageResponse response = imageModel.call(imagePrompt);
            
            String imageUrl = response.getResult().getOutput().getUrl();
            
            // 返回 HTML 頁面展示圖片
            String html = String.format("""
                <!DOCTYPE html>
                <html lang="zh-TW">
                <head>
                    <meta charset="UTF-8">
                    <title>Gemini 2.5 Flash Image 生成結果</title>
                    <style>
                        body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
                        img { max-width: 100%%; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
                        .info { margin: 20px 0; padding: 15px; background: #f5f5f5; border-radius: 5px; }
                    </style>
                </head>
                <body>
                    <h1>🍌 Gemini 2.5 Flash Image (Nano Banana)</h1>
                    <div class="info">
                        <p><strong>提示詞:</strong> %s</p>
                    </div>
                    <img src="%s" alt="生成的圖片">
                    <p><small>由 Spring AI + Gemini 2.5 Flash Image 生成</small></p>
                </body>
                </html>
                """, prompt, imageUrl);
            
            return ResponseEntity.ok()
                    .header("Content-Type", "text/html; charset=utf-8")
                    .body(html);
            
        } catch (Exception e) {
            log.error("圖片生成失敗", e);
            return ResponseEntity.badRequest()
                    .body("圖片生成失敗: " + e.getMessage());
        }
    }
}
```

### 使用方式

啟動應用後，訪問：
```
http://localhost:8080/api/simple-image/generate?prompt=一隻可愛的小貓在花園裡玩耀
```

---

## 5.3.5 Gemini 2.5 Flash Image 的進階功能

### 角色管理服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.openai.OpenAiImageOptions;
import org.springframework.ai.image.ImagePrompt;
import org.springframework.ai.image.ImageResponse;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class NanoBananaCharacterService {
    
    private final ImageModel geminiImageModel;
    private final Map<String, CharacterProfile> characterRegistry = new HashMap<>();
    
    /**
     * 創建新角色
     * @param characterName 角色名稱
     * @param description 角色描述
     * @param initialPrompt 初始生成提示詞
     * @return 角色ID
     */
    public String createCharacter(String characterName, String description, String initialPrompt) {
        try {
            log.info("創建新角色：{}", characterName);
            
            // 生成角色的初始圖片，建立角色DNA
            OpenAiImageOptions options = OpenAiImageOptions.builder()
                    .withModel("google/gemini-2.5-flash-image")
                    .withQuality("hd")
                    .withSize("1024x1024")
                    .withResponseFormat("url")
                    .build();
            
            String enhancedPrompt = enhanceCharacterPrompt(initialPrompt, description);
            ImagePrompt imagePrompt = new ImagePrompt(enhancedPrompt, options);
            
            ImageResponse response = geminiImageModel.call(imagePrompt);
            String imageUrl = response.getResult().getOutput().getUrl();
            
            // 創建角色檔案
            String characterId = UUID.randomUUID().toString();
            CharacterProfile profile = CharacterProfile.builder()
                    .characterId(characterId)
                    .characterName(characterName)
                    .description(description)
                    .dnaCode(response.getMetadata().get("character_dna"))  // Nano Banana 特有的角色DNA
                    .initialImageUrl(imageUrl)
                    .createdAt(java.time.LocalDateTime.now())
                    .build();
            
            characterRegistry.put(characterId, profile);
            
            log.info("角色創建成功，ID：{}，DNA：{}", characterId, profile.getDnaCode());
            return characterId;
            
        } catch (Exception e) {
            log.error("角色創建失敗：{}", characterName, e);
            throw new RuntimeException("角色創建失敗：" + e.getMessage());
        }
    }
    
    /**
     * 使用已存在角色生成圖片
     * @param characterId 角色ID
     * @param scenario 場景描述
     * @param pose 姿態描述
     * @return 圖片URL
     */
    public String generateWithCharacter(String characterId, String scenario, String pose) {
        CharacterProfile character = characterRegistry.get(characterId);
        if (character == null) {
            throw new IllegalArgumentException("角色不存在：" + characterId);
        }
        
        try {
            log.info("使用角色 {} 生成圖片：{}", character.getCharacterName(), scenario);
            
            OpenAiImageOptions options = OpenAiImageOptions.builder()
                    .withModel("google/gemini-2.5-flash-image")
                    .withQuality("hd")
                    .withSize("1024x1024")
                    .withResponseFormat("url")
                    .build();
            
            String prompt = buildCharacterScenePrompt(character, scenario, pose);
            ImagePrompt imagePrompt = new ImagePrompt(prompt, options);
            
            ImageResponse response = geminiImageModel.call(imagePrompt);
            String imageUrl = response.getResult().getOutput().getUrl();
            
            log.info("角色圖片生成成功：{}", imageUrl);
            return imageUrl;
            
        } catch (Exception e) {
            log.error("角色圖片生成失敗", e);
            throw new RuntimeException("角色圖片生成失敗：" + e.getMessage());
        }
    }
    
    /**
     * 建構角色場景提示詞
     */
    private String buildCharacterScenePrompt(CharacterProfile character, String scenario, String pose) {
        return String.format(
            "Character: %s, %s. Scene: %s. Pose: %s. " +
            "Maintain character consistency, high quality, detailed, 4k resolution",
            character.getCharacterName(),
            character.getDescription(),
            scenario,
            pose
        );
    }
    
    /**
     * 增強角色創建提示詞
     */
    private String enhanceCharacterPrompt(String prompt, String description) {
        return String.format(
            "%s, %s, character design, distinctive features, memorable appearance, " +
            "high quality, detailed character sheet, 4k resolution",
            prompt,
            description
        );
    }
    
    /**
     * 獲取角色資訊
     */
    public CharacterProfile getCharacter(String characterId) {
        return characterRegistry.get(characterId);
    }
    
    /**
     * 列出所有編輯對話
     */
    public Map<String, EditSession> getAllEditSessions() {
        return new HashMap<>(editSessionRegistry);
    }
    
    /**
     * 多圖融合功能
     * @param imageUrls 要融合的圖片 URL 列表
     * @param fusionDescription 融合描述
     * @return 融合後的圖片 URL
     */
    public String fuseMultipleImages(List<String> imageUrls, String fusionDescription) {
        if (imageUrls.size() > 3) {
            throw new IllegalArgumentException("Gemini 2.5 Flash Image 最多支援 3 張圖片融合");
        }
        
        try {
            OpenAiImageOptions options = OpenAiImageOptions.builder()
                    .withModel("google/gemini-2.5-flash-image")
                    .withQuality("hd")
                    .withSize("1024x1024")
                    .withResponseFormat("url")
                    .build();
            
            String fusionPrompt = buildImageFusionPrompt(imageUrls, fusionDescription);
            ImagePrompt imagePrompt = new ImagePrompt(fusionPrompt, options);
            
            ImageResponse response = geminiImageModel.call(imagePrompt);
            return response.getResult().getOutput().getUrl();
            
        } catch (Exception e) {
            log.error("多圖融合失敗", e);
            throw new RuntimeException("多圖融合失敗：" + e.getMessage());
        }
    }
    
    /**
     * 建構多圖融合提示詞
     */
    private String buildImageFusionPrompt(List<String> imageUrls, String description) {
        StringBuilder prompt = new StringBuilder();
        prompt.append("Fuse these images together: ");
        
        for (int i = 0; i < imageUrls.size(); i++) {
            prompt.append(String.format("Image %d: %s; ", i + 1, imageUrls.get(i)));
        }
        
        prompt.append(String.format(
            "Fusion instruction: %s. Create a cohesive, high-quality result that " +
            "combines elements from all images harmoniously.",
            description
        ));
        
        return prompt.toString();
    }
}
```

### 數據模型定義

```java
package com.example.model;

import lombok.Builder;
import lombok.Data;
import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
public class EditSession {
    private String sessionId;
    private String sessionName;
    private String baseImageUrl;
    private String currentImageUrl;
    private String description;
    private List<EditStep> editHistory;
    private LocalDateTime createdAt;
    private LocalDateTime lastModified;
}

@Data
@Builder
public class EditStep {
    private int stepNumber;
    private String description;
    private String resultImageUrl;
    private LocalDateTime timestamp;
    private Map<String, Object> metadata;
}
```

### 多圖融合服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.openai.OpenAiImageOptions;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class GeminiImageFusionService {
    
    private final ImageModel geminiImageModel;
    private final GeminiImageEditingService editingService;
    
    /**
     * 創建多圖融合專案
     * @param fusionRequest 融合請求
     * @return 融合結果
     */
    public ImageFusionResult createImageFusion(ImageFusionRequest fusionRequest) {
        try {
            log.info("創建圖片融合專案：{}", fusionRequest.getProjectName());
            
            if (fusionRequest.getSourceImages().size() > 3) {
                throw new IllegalArgumentException("Gemini 2.5 Flash Image 最多支援 3 張圖片融合");
            }
            
            // 準備融合選項
            OpenAiImageOptions options = OpenAiImageOptions.builder()
                    .withModel("google/gemini-2.5-flash-image")
                    .withQuality("hd")
                    .withSize("1024x1024")
                    .withResponseFormat("url")
                    .build();
            
            // 建構融合提示詞
            String fusionPrompt = buildAdvancedFusionPrompt(fusionRequest);
            ImagePrompt imagePrompt = new ImagePrompt(fusionPrompt, options);
            
            // 執行融合
            ImageResponse response = geminiImageModel.call(imagePrompt);
            String fusedImageUrl = response.getResult().getOutput().getUrl();
            
            return ImageFusionResult.builder()
                    .projectName(fusionRequest.getProjectName())
                    .sourceImages(fusionRequest.getSourceImages())
                    .fusionStyle(fusionRequest.getFusionStyle())
                    .description(fusionRequest.getDescription())
                    .resultImageUrl(fusedImageUrl)
                    .success(true)
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("圖片融合失敗", e);
            throw new RuntimeException("圖片融合失敗：" + e.getMessage());
        }
    }
    
    /**
     * 風格轉移功能
     * @param sourceImageUrl 原始圖片
     * @param styleImageUrl 風格參考圖片
     * @param transferDescription 轉移描述
     * @return 轉移後的圖片 URL
     */
    public String performStyleTransfer(String sourceImageUrl, String styleImageUrl, String transferDescription) {
        try {
            log.info("執行風格轉移：{}", transferDescription);
            
            OpenAiImageOptions options = OpenAiImageOptions.builder()
                    .withModel("google/gemini-2.5-flash-image")
                    .withQuality("hd")
                    .withSize("1024x1024")
                    .withResponseFormat("url")
                    .build();
            
            String styleTransferPrompt = buildStyleTransferPrompt(
                sourceImageUrl, 
                styleImageUrl, 
                transferDescription
            );
            
            ImagePrompt imagePrompt = new ImagePrompt(styleTransferPrompt, options);
            ImageResponse response = geminiImageModel.call(imagePrompt);
            
            return response.getResult().getOutput().getUrl();
            
        } catch (Exception e) {
            log.error("風格轉移失敗", e);
            throw new RuntimeException("風格轉移失敗：" + e.getMessage());
        }
    }
    
    /**
     * 建構進階融合提示詞
     */
    private String buildAdvancedFusionPrompt(ImageFusionRequest request) {
        StringBuilder prompt = new StringBuilder();
        
        prompt.append("Fuse these images with advanced composition: ");
        for (int i = 0; i < request.getSourceImages().size(); i++) {
            prompt.append(String.format("Image %d: %s; ", i + 1, request.getSourceImages().get(i)));
        }
        
        prompt.append(String.format(
            "Fusion style: %s. Description: %s. " +
            "Create a harmonious blend that combines the best elements from each image. " +
            "Maintain visual coherence, apply %s aesthetic, ensure high quality output.",
            request.getFusionStyle(),
            request.getDescription(),
            request.getFusionStyle()
        ));
        
        return prompt.toString();
    }
    
    /**
     * 建構風格轉移提示詞
     */
    private String buildStyleTransferPrompt(String sourceUrl, String styleUrl, String description) {
        return String.format(
            "Apply style transfer: Take the content from this image: %s, " +
            "and apply the artistic style from this reference: %s. " +
            "Transfer instruction: %s. " +
            "Preserve the main content and composition while adopting the visual style, " +
            "colors, and artistic techniques from the style reference.",
            sourceUrl,
            styleUrl,
            description
        );
    }
    
    /**
     * 批次圖片處理
     * @param batchRequest 批次處理請求
     * @return 批次處理結果
     */
    public BatchProcessingResult processBatch(BatchImageRequest batchRequest) {
        try {
            log.info("批次處理 {} 張圖片", batchRequest.getImageRequests().size());
            
            List<CompletableFuture<BatchImageResult>> futures = batchRequest.getImageRequests().stream()
                    .map(this::processImageAsync)
                    .collect(Collectors.toList());
            
            CompletableFuture<Void> allFutures = CompletableFuture.allOf(
                    futures.toArray(new CompletableFuture[0])
            );
            
            List<BatchImageResult> results = allFutures.thenApply(v -> 
                    futures.stream()
                            .map(CompletableFuture::join)
                            .collect(Collectors.toList())
            ).join();
            
            return BatchProcessingResult.builder()
                    .batchId(UUID.randomUUID().toString())
                    .totalRequests(batchRequest.getImageRequests().size())
                    .successfulResults(results.stream().filter(r -> r.isSuccess()).collect(Collectors.toList()))
                    .failedResults(results.stream().filter(r -> !r.isSuccess()).collect(Collectors.toList()))
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("批次處理失敗", e);
            throw new RuntimeException("批次處理失敗：" + e.getMessage());
        }
    }
    
    /**
     * 非同步處理單張圖片
     */
    private CompletableFuture<BatchImageResult> processImageAsync(ImageProcessingRequest request) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                String resultUrl = switch (request.getProcessingType()) {
                    case EDIT -> editingService.continueEditing(request.getSessionId(), request.getInstruction());
                    case STYLE_TRANSFER -> performStyleTransfer(
                        request.getSourceImageUrl(), 
                        request.getStyleImageUrl(), 
                        request.getInstruction()
                    );
                    case FUSION -> editingService.fuseMultipleImages(
                        request.getSourceImageUrls(), 
                        request.getInstruction()
                    );
                    default -> throw new IllegalArgumentException("不支援的處理類型: " + request.getProcessingType());
                };
                
                return BatchImageResult.builder()
                        .requestId(request.getRequestId())
                        .resultImageUrl(resultUrl)
                        .success(true)
                        .build();
                
            } catch (Exception e) {
                log.error("單張圖片處理失敗: {}", request.getRequestId(), e);
                
                return BatchImageResult.builder()
                        .requestId(request.getRequestId())
                        .success(false)
                        .error(e.getMessage())
                        .build();
            }
        });
    }
}
```

---

## 5.3.6 實際應用：圖片編輯與融合系統

### 圖片處理 API 控制器

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequestMapping("/api/image-processing")
@RequiredArgsConstructor
@Slf4j
public class ImageProcessingController {
    
    private final GeminiImageEditingService editingService;
    private final GeminiImageFusionService fusionService;
    
    /**
     * 創建圖片編輯對話
     */
    @PostMapping("/edit-session")
    public ResponseEntity<EditSessionResponse> createEditSession(
            @RequestParam("image") MultipartFile imageFile,
            @RequestParam("sessionName") String sessionName,
            @RequestParam("description") String description) {
        
        try {
            log.info("創建編輯對話：{}", sessionName);
            
            // 上傳圖片並取得 URL
            String imageUrl = uploadImageAndGetUrl(imageFile);
            
            String sessionId = editingService.createEditSession(
                    sessionName,
                    imageUrl,
                    description
            );
            
            EditSessionResponse response = EditSessionResponse.builder()
                    .success(true)
                    .sessionId(sessionId)
                    .sessionName(sessionName)
                    .baseImageUrl(imageUrl)
                    .message("編輯對話創建成功")
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("編輯對話創建失敗", e);
            
            EditSessionResponse errorResponse = EditSessionResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 繼續編輯圖片
     */
    @PostMapping("/edit-session/{sessionId}/continue")
    public ResponseEntity<EditStepResponse> continueEditing(
            @PathVariable String sessionId,
            @RequestBody @Valid ContinueEditRequest request) {
        
        try {
            log.info("繼續編輯對話：{}", sessionId);
            
            String newImageUrl = editingService.continueEditing(
                    sessionId,
                    request.getEditInstruction()
            );
            
            EditSession session = editingService.getEditSession(sessionId);
            EditStep latestStep = session.getEditHistory().get(session.getEditHistory().size() - 1);
            
            EditStepResponse response = EditStepResponse.builder()
                    .success(true)
                    .sessionId(sessionId)
                    .stepNumber(latestStep.getStepNumber())
                    .instruction(request.getEditInstruction())
                    .resultImageUrl(newImageUrl)
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("繼續編輯失敗", e);
            
            EditStepResponse errorResponse = EditStepResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 多圖融合
     */
    @PostMapping("/fusion")
    public ResponseEntity<ImageFusionResponse> fuseImages(
            @RequestParam("images") List<MultipartFile> imageFiles,
            @RequestBody @Valid ImageFusionRequest request) {
        
        try {
            log.info("多圖融合專案：{}", request.getProjectName());
            
            if (imageFiles.size() > 3) {
                throw new IllegalArgumentException("最多支援 3 張圖片融合");
            }
            
            // 上傳所有圖片並取得 URL
            List<String> imageUrls = imageFiles.stream()
                    .map(this::uploadImageAndGetUrl)
                    .collect(Collectors.toList());
            
            request.setSourceImages(imageUrls);
            
            ImageFusionResult result = fusionService.createImageFusion(request);
            
            ImageFusionResponse response = ImageFusionResponse.builder()
                    .success(true)
                    .projectName(result.getProjectName())
                    .fusionStyle(result.getFusionStyle())
                    .sourceImageUrls(result.getSourceImages())
                    .resultImageUrl(result.getResultImageUrl())
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("多圖融合失敗", e);
            
            ImageFusionResponse errorResponse = ImageFusionResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 風格轉移
     */
    @PostMapping("/style-transfer")
    public ResponseEntity<StyleTransferResponse> performStyleTransfer(
            @RequestParam("sourceImage") MultipartFile sourceImage,
            @RequestParam("styleImage") MultipartFile styleImage,
            @RequestBody @Valid StyleTransferRequest request) {
        
        try {
            log.info("風格轉移：{}", request.getDescription());
            
            String sourceImageUrl = uploadImageAndGetUrl(sourceImage);
            String styleImageUrl = uploadImageAndGetUrl(styleImage);
            
            String resultImageUrl = fusionService.performStyleTransfer(
                    sourceImageUrl,
                    styleImageUrl,
                    request.getDescription()
            );
            
            StyleTransferResponse response = StyleTransferResponse.builder()
                    .success(true)
                    .sourceImageUrl(sourceImageUrl)
                    .styleImageUrl(styleImageUrl)
                    .resultImageUrl(resultImageUrl)
                    .description(request.getDescription())
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("風格轉移失敗", e);
            
            StyleTransferResponse errorResponse = StyleTransferResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 上傳圖片並取得 URL
     */
    private String uploadImageAndGetUrl(MultipartFile imageFile) {
        // 實作圖片上傳邏輯，這裡只是示例
        try {
            // 儲存圖片到本地或雲端儲存
            String fileName = UUID.randomUUID().toString() + "_" + imageFile.getOriginalFilename();
            Path uploadPath = Paths.get("uploads", fileName);
            Files.createDirectories(uploadPath.getParent());
            Files.copy(imageFile.getInputStream(), uploadPath, StandardCopyOption.REPLACE_EXISTING);
            
            // 返回可訪問的 URL
            return "http://localhost:8080/uploads/" + fileName;
            
        } catch (IOException e) {
            throw new RuntimeException("圖片上傳失敗", e);
        }
    }
}
```

---

## 📝 本章重點回顧

1. **Gemini 2.5 Flash Image 技術理解**：掌握了 Google 最新圖片 AI 模型的核心優勢
2. **圖片編輯一致性**：學會了如何使用多輪對話編輯保持角色特徵
3. **多圖融合功能**：實現了進階圖片融合和風格轉移功能
4. **企業級功能**：建立了完整的圖片處理和編輯管理系統
5. **商業應用場景**：掌握了圖片編輯、內容創作等實際應用

### Gemini 2.5 Flash Image 技術要點總結

| 技術點 | 重要性 | 實現難度 | 獨特優勢 |
|--------|--------|----------|----------|
| **圖片編輯一致性** | ⭐⭐⭐⭐⭐ | 中 | 世界第一 |
| **多輪對話編輯** | ⭐⭐⭐⭐⭐ | 高 | 業界領先 |
| **多圖融合** | ⭐⭐⭐⭐ | 高 | 先進技術 |
| **自然語言控制** | ⭐⭐⭐⭐ | 中 | 直覺易用 |
| **SynthID 水印** | ⭐⭐⭐ | 低 | 安全保障 |

### Gemini 2.5 Flash Image 最佳實踐

1. **圖片編輯策略**：
   - 使用明確、具體的編輯指令
   - 充分利用多輪對話逐步精化結果
   - 保存編輯歷程以便追蹤和回溯

2. **多圖融合技巧**：
   - 選擇視覺風格相容的圖片進行融合
   - 提供清晰的融合意圖和期望結果
   - 利用 Gemini 的世界知識進行智能融合

3. **商業應用建議**：
   - 善用 SynthID 水印功能保障內容安全
   - 建立圖片處理流程和品質控制標準
   - 整合 Google 生態系統提高工作效率

### 下一步學習方向

在下一章中，我們將學習如何建立語音轉文字系統，探索多媒體內容處理的另一個重要領域，與 Gemini 2.5 Flash Image 的視覺處理能力形成完整的多媒體 AI 解決方案。

---

**參考資料：**
- [Gemini 2.5 Flash Image 官方文檔](https://ai.google.dev/gemini-api/docs/image-generation)
- [Google Developers Blog - Introducing Gemini 2.5 Flash Image](https://developers.googleblog.com/en/introducing-gemini-2-5-flash-image/)
- [Spring AI Image Generation Documentation](https://docs.spring.io/spring-ai/reference/api/imageclient.html)
- [OpenRouter API Documentation](https://openrouter.ai/docs)
- [OpenAI API Compatibility Guide](https://platform.openai.com/docs/api-reference)
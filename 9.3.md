# 9.3 åœ¨ Spring AI ç¨‹å¼ä¸­ä½¿ç”¨ MCP å·¥å…·

> **æœ¬ç« é‡é»**ï¼šæ·±å…¥å­¸ç¿’å¦‚ä½•åœ¨ Spring AI æ‡‰ç”¨ä¸­ä½¿ç”¨ MCP å·¥å…·ï¼ŒæŒæ¡å·¥å…·ç™¼ç¾ã€èª¿ç”¨å’Œç®¡ç†çš„å®Œæ•´æµç¨‹ï¼Œå¯¦ç¾ MCP Client èˆ‡ ChatClient çš„ç„¡ç¸«æ•´åˆï¼Œå»ºç«‹ä¼æ¥­ç´šçš„ MCP å·¥å…·ä½¿ç”¨æœ€ä½³å¯¦è¸ã€‚

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬ç« å­¸ç¿’å¾Œï¼Œæ‚¨å°‡èƒ½å¤ ï¼š

- ğŸ¯ **æŒæ¡ MCP å·¥å…·ç™¼ç¾**ï¼šå­¸æœƒå¦‚ä½•ç™¼ç¾å’Œåˆ—å‡ºå¯ç”¨çš„ MCP å·¥å…·
- ğŸ¯ **å¯¦ç¾å·¥å…·èª¿ç”¨**ï¼šæŒæ¡ MCP å·¥å…·çš„èª¿ç”¨æ–¹æ³•å’Œåƒæ•¸å‚³é
- ğŸ¯ **æ•´åˆ ChatClient**ï¼šå°‡ MCP å·¥å…·èˆ‡ Spring AI ChatClient ç„¡ç¸«æ•´åˆ
- ğŸ¯ **ç®¡ç† MCP è³‡æº**ï¼šå­¸æœƒä½¿ç”¨ MCP è³‡æºå’Œæç¤ºæœå‹™
- ğŸ¯ **å»ºç«‹ä¼æ¥­æ‡‰ç”¨**ï¼šé–‹ç™¼å¯¦éš›çš„ä¼æ¥­ç´š MCP æ‡‰ç”¨å ´æ™¯

---

## 9.3.1 MCP å·¥å…·ç™¼ç¾èˆ‡ç®¡ç†

### åŸºç¤ MCP Client æœå‹™

```java
/**
 * MCP Client æ ¸å¿ƒæœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class McpClientService {
    
    private final List<McpSyncClient> syncClients;
    private final SyncMcpToolCallbackProvider toolCallbackProvider;
    
    /**
     * ç²å–æ‰€æœ‰å¯ç”¨çš„ MCP å·¥å…·å›èª¿
     */
    public ToolCallback[] getToolCallbacks() {
        try {
            log.debug("ç²å– MCP å·¥å…·å›èª¿ï¼Œå®¢æˆ¶ç«¯æ•¸é‡: {}", syncClients.size());
            
            // ç›´æ¥å¾å·¥å…·å›èª¿æä¾›è€…ç²å–æ‰€æœ‰å·¥å…·
            ToolCallback[] result = toolCallbackProvider.getToolCallbacks();
            log.info("ç¸½å…±ç²å–åˆ° {} å€‹ MCP å·¥å…·", result.length);
            
            return result;
            
        } catch (Exception e) {
            log.error("ç²å– MCP å·¥å…·å›èª¿å¤±æ•—", e);
            return new ToolCallback[0];
        }
    }
    
    /**
     * ç²å–å¯ç”¨å·¥å…·çš„è©³ç´°ä¿¡æ¯
     */
    public List<ToolDefinition> getAvailableTools() {
        List<ToolDefinition> tools = new ArrayList<>();
        
        for (McpSyncClient client : syncClients) {
            try {
                // åˆ—å‡ºå®¢æˆ¶ç«¯çš„å·¥å…·
                McpSchema.ListToolsResult result = client.listTools(
                    new McpSchema.ListToolsRequest());
                
                for (McpSchema.Tool tool : result.tools()) {
                    tools.add(convertToToolDefinition(tool, client.getServerName()));
                }
                
            } catch (Exception e) {
                log.warn("åˆ—å‡ºå®¢æˆ¶ç«¯ {} çš„å·¥å…·å¤±æ•—", client.getServerName(), e);
            }
        }
        
        return tools;
    }
    
    /**
     * åŸ·è¡ŒæŒ‡å®šçš„ MCP å·¥å…·
     */
    public String executeTool(String toolName, Map<String, Object> parameters) {
        
        log.debug("åŸ·è¡Œ MCP å·¥å…·: {} with parameters: {}", toolName, parameters);
        
        for (McpSyncClient client : syncClients) {
            try {
                // æª¢æŸ¥å®¢æˆ¶ç«¯æ˜¯å¦æœ‰æ­¤å·¥å…·
                if (hasToolInClient(client, toolName)) {
                    return executeToolInClient(client, toolName, parameters);
                }
                
            } catch (McpToolNotFoundException e) {
                // ç¹¼çºŒå˜—è©¦ä¸‹ä¸€å€‹å®¢æˆ¶ç«¯
                continue;
            } catch (Exception e) {
                log.error("åœ¨å®¢æˆ¶ç«¯ {} åŸ·è¡Œå·¥å…· {} å¤±æ•—", 
                    client.getServerName(), toolName, e);
                throw new McpToolExecutionException("å·¥å…·åŸ·è¡Œå¤±æ•—: " + toolName, e);
            }
        }
        
        throw new McpToolNotFoundException("æ‰¾ä¸åˆ°å·¥å…·: " + toolName);
    }
    
    /**
     * ç²å– MCP ä¼ºæœå™¨ä¿¡æ¯
     */
    public List<McpServerInfo> getServerInfo() {
        return syncClients.stream()
            .map(client -> new McpServerInfo(
                client.getServerName(),
                client.getServerVersion(),
                client.isConnected(),
                getToolCountForClient(client)
            ))
            .collect(Collectors.toList());
    }
    
    /**
     * æª¢æŸ¥å®¢æˆ¶ç«¯æ˜¯å¦æœ‰æŒ‡å®šå·¥å…·
     */
    private boolean hasToolInClient(McpSyncClient client, String toolName) {
        try {
            McpSchema.ListToolsResult result = client.listTools(
                new McpSchema.ListToolsRequest());
            
            return result.tools().stream()
                .anyMatch(tool -> tool.name().equals(toolName));
                
        } catch (Exception e) {
            log.warn("æª¢æŸ¥å®¢æˆ¶ç«¯ {} å·¥å…·å¤±æ•—", client.getServerName(), e);
            return false;
        }
    }
    
    /**
     * åœ¨æŒ‡å®šå®¢æˆ¶ç«¯åŸ·è¡Œå·¥å…·
     */
    private String executeToolInClient(McpSyncClient client, String toolName, 
                                     Map<String, Object> parameters) {
        
        long startTime = System.currentTimeMillis();
        
        try {
            // æ§‹å»ºå·¥å…·èª¿ç”¨è«‹æ±‚
            McpSchema.CallToolRequest request = new McpSchema.CallToolRequest(
                toolName, parameters);
            
            // åŸ·è¡Œå·¥å…·
            McpSchema.CallToolResult result = client.callTool(request);
            
            // è™•ç†çµæœ
            String response = processToolResult(result);
            
            // è¨˜éŒ„æŒ‡æ¨™
            long duration = System.currentTimeMillis() - startTime;
            metricsCollector.recordToolExecution(toolName, duration, true);
            
            log.debug("å·¥å…· {} åŸ·è¡ŒæˆåŠŸï¼Œè€—æ™‚ {}ms", toolName, duration);
            return response;
            
        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            metricsCollector.recordToolExecution(toolName, duration, false);
            
            log.error("å·¥å…· {} åŸ·è¡Œå¤±æ•—ï¼Œè€—æ™‚ {}ms", toolName, duration, e);
            throw e;
        }
    }
    
    /**
     * è™•ç†å·¥å…·åŸ·è¡Œçµæœ
     */
    private String processToolResult(McpSchema.CallToolResult result) {
        if (result.content() == null || result.content().isEmpty()) {
            return "å·¥å…·åŸ·è¡Œå®Œæˆï¼Œç„¡è¿”å›å…§å®¹";
        }
        
        // è™•ç†ä¸åŒé¡å‹çš„å…§å®¹
        StringBuilder response = new StringBuilder();
        for (McpSchema.Content content : result.content()) {
            if (content instanceof McpSchema.TextContent textContent) {
                response.append(textContent.text()).append("\n");
            } else if (content instanceof McpSchema.ImageContent imageContent) {
                response.append("[åœ–ç‰‡: ").append(imageContent.data()).append("]\n");
            } else {
                response.append("[æœªçŸ¥å…§å®¹é¡å‹]\n");
            }
        }
        
        return response.toString().trim();
    }
    
    /**
     * è½‰æ› MCP å·¥å…·ç‚º ToolDefinition
     */
    private ToolDefinition convertToToolDefinition(McpSchema.Tool tool, String serverName) {
        return ToolDefinition.builder()
            .name(tool.name())
            .description(tool.description())
            .inputSchema(tool.inputSchema())
            .metadata(Map.of(
                "serverName", serverName,
                "toolType", "mcp"
            ))
            .build();
    }
    
    /**
     * ç²å–å®¢æˆ¶ç«¯çš„å·¥å…·æ•¸é‡
     */
    private int getToolCountForClient(McpSyncClient client) {
        try {
            McpSchema.ListToolsResult result = client.listTools(
                new McpSchema.ListToolsRequest());
            return result.tools().size();
        } catch (Exception e) {
            return 0;
        }
    }
}

/**
 * MCP ä¼ºæœå™¨ä¿¡æ¯è¨˜éŒ„
 */
public record McpServerInfo(
    String name,
    String version,
    boolean connected,
    int toolCount
) {}

/**
 * MCP å·¥å…·åŸ·è¡Œç•°å¸¸
 */
public class McpToolExecutionException extends RuntimeException {
    public McpToolExecutionException(String message, Throwable cause) {
        super(message, cause);
    }
}

/**
 * MCP å·¥å…·æœªæ‰¾åˆ°ç•°å¸¸
 */
public class McpToolNotFoundException extends RuntimeException {
    public McpToolNotFoundException(String message) {
        super(message);
    }
}
```

---

## 9.3.2 èˆ‡ ChatClient æ•´åˆ

### MCP å¢å¼·çš„èŠå¤©æ§åˆ¶å™¨

```java
/**
 * MCP å¢å¼·çš„èŠå¤©æ§åˆ¶å™¨
 */
@RestController
@RequestMapping("/api/chat")
@RequiredArgsConstructor
@Slf4j
public class McpChatController {
    
    private final ChatClient chatClient;
    private final McpClientService mcpService;
    private final McpChatHistoryService historyService;
    
    /**
     * ä½¿ç”¨ MCP å·¥å…·çš„èŠå¤©ç«¯é»
     */
    @PostMapping("/mcp")
    public ResponseEntity<ChatResponse> chatWithMcp(@RequestBody ChatRequest request) {
        
        try {
            log.info("æ”¶åˆ° MCP èŠå¤©è«‹æ±‚: {}", request.getMessage());
            
            // ç²å– MCP å·¥å…·
            ToolCallback[] mcpTools = mcpService.getToolCallbacks();
            log.debug("å¯ç”¨ MCP å·¥å…·æ•¸é‡: {}", mcpTools.length);
            
            // ä½¿ç”¨ ChatClient èˆ‡ MCP å·¥å…·æ•´åˆ
            String response = chatClient.prompt()
                .system("""
                    ä½ æ˜¯ä¸€å€‹ä¼æ¥­ç´š AI åŠ©æ‰‹ï¼Œå…·å‚™ä»¥ä¸‹èƒ½åŠ›ï¼š
                    1. å¯ä»¥ä½¿ç”¨å„ç¨® MCP å·¥å…·ä¾†å”åŠ©ç”¨æˆ¶
                    2. æ ¹æ“šç”¨æˆ¶éœ€æ±‚é¸æ“‡åˆé©çš„å·¥å…·
                    3. æä¾›æº–ç¢ºã€æœ‰ç”¨çš„å›ç­”
                    4. ç•¶éœ€è¦ä½¿ç”¨å·¥å…·æ™‚ï¼Œè«‹æ˜ç¢ºèªªæ˜ä½¿ç”¨çš„å·¥å…·å’ŒåŸå› 
                    """)
                .user(request.getMessage())
                .functions(mcpTools)  // ä½¿ç”¨ functions æ•´åˆ MCP å·¥å…·
                .call()
                .content();
            
            // ä¿å­˜èŠå¤©æ­·å²
            historyService.saveChatHistory(request.getMessage(), response, mcpTools.length);
            
            return ResponseEntity.ok(new ChatResponse(response, mcpTools.length));
            
        } catch (Exception e) {
            log.error("MCP èŠå¤©è™•ç†å¤±æ•—", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ChatResponse("æŠ±æ­‰ï¼Œæœå‹™æš«æ™‚ä¸å¯ç”¨ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚", 0));
        }
    }
    
    /**
     * ç²å–å¯ç”¨çš„ MCP å·¥å…·åˆ—è¡¨
     */
    @GetMapping("/tools")
    public ResponseEntity<List<ToolInfo>> getAvailableTools() {
        
        try {
            List<ToolDefinition> tools = mcpService.getAvailableTools();
            
            List<ToolInfo> toolInfos = tools.stream()
                .map(tool -> new ToolInfo(
                    tool.getName(),
                    tool.getDescription(),
                    tool.getMetadata().get("serverName").toString()
                ))
                .collect(Collectors.toList());
            
            return ResponseEntity.ok(toolInfos);
            
        } catch (Exception e) {
            log.error("ç²å–å·¥å…·åˆ—è¡¨å¤±æ•—", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Collections.emptyList());
        }
    }
    
    /**
     * ç›´æ¥åŸ·è¡Œ MCP å·¥å…·
     */
    @PostMapping("/tools/{toolName}/execute")
    public ResponseEntity<ToolExecutionResponse> executeTool(
            @PathVariable String toolName,
            @RequestBody Map<String, Object> parameters) {
        
        try {
            log.info("ç›´æ¥åŸ·è¡Œ MCP å·¥å…·: {} with parameters: {}", toolName, parameters);
            
            String result = mcpService.executeTool(toolName, parameters);
            
            return ResponseEntity.ok(new ToolExecutionResponse(
                toolName, parameters, result, true, null));
            
        } catch (McpToolNotFoundException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(new ToolExecutionResponse(
                    toolName, parameters, null, false, "å·¥å…·æœªæ‰¾åˆ°: " + toolName));
        } catch (Exception e) {
            log.error("åŸ·è¡Œå·¥å…·å¤±æ•—: {}", toolName, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ToolExecutionResponse(
                    toolName, parameters, null, false, "å·¥å…·åŸ·è¡Œå¤±æ•—: " + e.getMessage()));
        }
    }
    
    /**
     * ç²å– MCP ä¼ºæœå™¨ç‹€æ…‹
     */
    @GetMapping("/servers")
    public ResponseEntity<List<McpServerInfo>> getServerStatus() {
        
        try {
            List<McpServerInfo> servers = mcpService.getServerInfo();
            return ResponseEntity.ok(servers);
            
        } catch (Exception e) {
            log.error("ç²å–ä¼ºæœå™¨ç‹€æ…‹å¤±æ•—", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Collections.emptyList());
        }
    }
}

/**
 * èŠå¤©è«‹æ±‚
 */
public record ChatRequest(String message) {}

/**
 * èŠå¤©å›æ‡‰
 */
public record ChatResponse(String response, int availableTools) {}

/**
 * å·¥å…·ä¿¡æ¯
 */
public record ToolInfo(String name, String description, String serverName) {}

/**
 * å·¥å…·åŸ·è¡Œå›æ‡‰
 */
public record ToolExecutionResponse(
    String toolName,
    Map<String, Object> parameters,
    String result,
    boolean success,
    String error
) {}
```

### æµå¼èŠå¤©æ”¯æ´

```java
/**
 * MCP æµå¼èŠå¤©æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class McpStreamingChatService {
    
    private final ChatClient chatClient;
    private final McpClientService mcpService;
    
    /**
     * æµå¼èŠå¤©èˆ‡ MCP å·¥å…·æ•´åˆ
     */
    public Flux<String> streamChatWithMcp(String userMessage) {
        
        return Flux.create(sink -> {
            try {
                // ç²å– MCP å·¥å…·
                ToolCallback[] mcpTools = mcpService.getToolCallbacks();
                
                // å»ºç«‹æµå¼èŠå¤©
                chatClient.prompt()
                    .system("ä½ æ˜¯ä¸€å€‹æ™ºèƒ½åŠ©æ‰‹ï¼Œå¯ä»¥ä½¿ç”¨å„ç¨®å·¥å…·ä¾†å”åŠ©ç”¨æˆ¶ã€‚")
                    .user(userMessage)
                    .functions(mcpTools)
                    .stream()
                    .content()
                    .subscribe(
                        sink::next,
                        sink::error,
                        sink::complete
                    );
                    
            } catch (Exception e) {
                log.error("æµå¼èŠå¤©å¤±æ•—", e);
                sink.error(e);
            }
        });
    }
}

/**
 * æµå¼èŠå¤©æ§åˆ¶å™¨
 */
@RestController
@RequestMapping("/api/chat")
@RequiredArgsConstructor
public class McpStreamingChatController {
    
    private final McpStreamingChatService streamingChatService;
    
    /**
     * æµå¼èŠå¤©ç«¯é»
     */
    @PostMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> streamChat(@RequestBody ChatRequest request) {
        
        return streamingChatService.streamChatWithMcp(request.message())
            .map(content -> ServerSentEvent.<String>builder()
                .data(content)
                .build())
            .onErrorResume(error -> {
                log.error("æµå¼èŠå¤©éŒ¯èª¤", error);
                return Flux.just(ServerSentEvent.<String>builder()
                    .data("[éŒ¯èª¤] æœå‹™æš«æ™‚ä¸å¯ç”¨")
                    .build());
            });
    }
}
```

---

## 9.3.3 MCP è³‡æºç®¡ç†

### MCP è³‡æºå­˜å–æœå‹™

```java
/**
 * MCP è³‡æºå­˜å–æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class McpResourceService {
    
    private final List<McpSyncClient> syncClients;
    private final McpResourceCache resourceCache;
    
    /**
     * è®€å– MCP è³‡æº
     */
    public McpResourceContent readResource(String resourceUri) {
        
        log.debug("è®€å– MCP è³‡æº: {}", resourceUri);
        
        // æª¢æŸ¥å¿«å–
        McpResourceContent cached = resourceCache.get(resourceUri);
        if (cached != null) {
            log.debug("å¾å¿«å–ç²å–è³‡æº: {}", resourceUri);
            return cached;
        }
        
        // å˜—è©¦å¾å„å€‹å®¢æˆ¶ç«¯è®€å–è³‡æº
        for (McpSyncClient client : syncClients) {
            try {
                if (supportsResource(client, URI.create(resourceUri))) {
                    
                    McpSchema.ReadResourceRequest request = 
                        new McpSchema.ReadResourceRequest(URI.create(resourceUri));
                    
                    McpSchema.ReadResourceResult result = client.readResource(request);
                    
                    McpResourceContent content = new McpResourceContent(
                        resourceUri,
                        result.contents(),
                        client.getServerName(),
                        Instant.now()
                    );
                    
                    // å¿«å–çµæœ
                    resourceCache.put(resourceUri, content);
                    
                    log.debug("æˆåŠŸè®€å–è³‡æº: {} from {}", resourceUri, client.getServerName());
                    return content;
                }
                
            } catch (Exception e) {
                log.warn("å¾å®¢æˆ¶ç«¯ {} è®€å–è³‡æº {} å¤±æ•—", client.getServerName(), resourceUri, e);
            }
        }
        
        throw new McpResourceNotFoundException("æ‰¾ä¸åˆ°è³‡æº: " + resourceUri);
    }
    
    /**
     * åˆ—å‡ºæ‰€æœ‰å¯ç”¨è³‡æº
     */
    public List<McpResourceInfo> listAllResources() {
        List<McpResourceInfo> allResources = new ArrayList<>();
        
        for (McpSyncClient client : syncClients) {
            try {
                McpSchema.ListResourcesRequest request = new McpSchema.ListResourcesRequest();
                McpSchema.ListResourcesResult result = client.listResources(request);
                
                List<McpResourceInfo> clientResources = result.resources().stream()
                    .map(resource -> new McpResourceInfo(
                        resource.uri().toString(),
                        resource.name(),
                        resource.description().orElse(""),
                        resource.mimeType().orElse("text/plain"),
                        client.getServerName()
                    ))
                    .collect(Collectors.toList());
                
                allResources.addAll(clientResources);
                
                log.debug("å®¢æˆ¶ç«¯ {} æä¾› {} å€‹è³‡æº", 
                    client.getServerName(), clientResources.size());
                
            } catch (Exception e) {
                log.warn("åˆ—å‡ºå®¢æˆ¶ç«¯ {} çš„è³‡æºå¤±æ•—", client.getServerName(), e);
            }
        }
        
        log.info("ç¸½å…±æ‰¾åˆ° {} å€‹ MCP è³‡æº", allResources.size());
        return allResources;
    }
    
    /**
     * æœå°‹è³‡æº
     */
    public List<McpResourceInfo> searchResources(String query) {
        return listAllResources().stream()
            .filter(resource -> 
                resource.name().toLowerCase().contains(query.toLowerCase()) ||
                resource.description().toLowerCase().contains(query.toLowerCase()))
            .collect(Collectors.toList());
    }
    
    /**
     * æª¢æŸ¥å®¢æˆ¶ç«¯æ˜¯å¦æ”¯æ´æŒ‡å®šè³‡æº
     */
    private boolean supportsResource(McpSyncClient client, URI uri) {
        try {
            McpSchema.ListResourcesResult result = client.listResources(
                new McpSchema.ListResourcesRequest());
            
            return result.resources().stream()
                .anyMatch(resource -> resource.uri().equals(uri));
                
        } catch (Exception e) {
            log.debug("æª¢æŸ¥å®¢æˆ¶ç«¯ {} è³‡æºæ”¯æ´å¤±æ•—", client.getServerName(), e);
            return false;
        }
    }
}

/**
 * MCP è³‡æºå…§å®¹
 */
public record McpResourceContent(
    String uri,
    List<McpSchema.ResourceContents> contents,
    String serverName,
    Instant timestamp
) {
    
    /**
     * ç²å–æ–‡å­—å…§å®¹
     */
    public String getTextContent() {
        return contents.stream()
            .filter(content -> content instanceof McpSchema.TextResourceContents)
            .map(content -> ((McpSchema.TextResourceContents) content).text())
            .collect(Collectors.joining("\n"));
    }
    
    /**
     * ç²å–äºŒé€²åˆ¶å…§å®¹
     */
    public byte[] getBinaryContent() {
        return contents.stream()
            .filter(content -> content instanceof McpSchema.BlobResourceContents)
            .map(content -> ((McpSchema.BlobResourceContents) content).blob())
            .findFirst()
            .orElse(new byte[0]);
    }
}

/**
 * MCP è³‡æºä¿¡æ¯
 */
public record McpResourceInfo(
    String uri,
    String name,
    String description,
    String mimeType,
    String serverName
) {}

/**
 * MCP è³‡æºæœªæ‰¾åˆ°ç•°å¸¸
 */
public class McpResourceNotFoundException extends RuntimeException {
    public McpResourceNotFoundException(String message) {
        super(message);
    }
}
```

### MCP è³‡æºå¿«å–

```java
/**
 * MCP è³‡æºå¿«å–æœå‹™
 */
@Service
@Slf4j
public class McpResourceCache {
    
    private final Cache<String, McpResourceContent> cache;
    
    public McpResourceCache() {
        this.cache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(Duration.ofMinutes(30))
            .recordStats()
            .build();
    }
    
    /**
     * ç²å–å¿«å–çš„è³‡æº
     */
    public McpResourceContent get(String uri) {
        McpResourceContent content = cache.getIfPresent(uri);
        if (content != null) {
            log.debug("å¿«å–å‘½ä¸­: {}", uri);
        }
        return content;
    }
    
    /**
     * å¿«å–è³‡æº
     */
    public void put(String uri, McpResourceContent content) {
        cache.put(uri, content);
        log.debug("å¿«å–è³‡æº: {}", uri);
    }
    
    /**
     * æ¸…é™¤å¿«å–
     */
    public void evict(String uri) {
        cache.invalidate(uri);
        log.debug("æ¸…é™¤å¿«å–: {}", uri);
    }
    
    /**
     * æ¸…é™¤æ‰€æœ‰å¿«å–
     */
    public void evictAll() {
        cache.invalidateAll();
        log.info("æ¸…é™¤æ‰€æœ‰è³‡æºå¿«å–");
    }
    
    /**
     * ç²å–å¿«å–çµ±è¨ˆ
     */
    public CacheStats getStats() {
        return cache.stats();
    }
}
```

---

## 9.3.4 MCP æç¤ºç®¡ç†

### MCP æç¤ºæœå‹™

```java
/**
 * MCP æç¤ºç®¡ç†æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class McpPromptService {
    
    private final List<McpSyncClient> syncClients;
    private final ChatClient chatClient;
    
    /**
     * ä½¿ç”¨ MCP æç¤ºç”Ÿæˆå›æ‡‰
     */
    public String generateResponseWithPrompt(String promptName, Map<String, Object> arguments) {
        
        for (McpSyncClient client : syncClients) {
            try {
                if (hasPrompt(client, promptName)) {
                    
                    // ç²å–æç¤º
                    McpSchema.GetPromptRequest request = new McpSchema.GetPromptRequest(
                        promptName, arguments);
                    
                    McpSchema.GetPromptResult result = client.getPrompt(request);
                    
                    // å°‡ MCP æç¤ºè½‰æ›ç‚º ChatClient æ¶ˆæ¯
                    List<Message> messages = convertToMessages(result.messages());
                    
                    // ä½¿ç”¨ ChatClient ç”Ÿæˆå›æ‡‰
                    return chatClient.prompt()
                        .messages(messages)
                        .call()
                        .content();
                }
                
            } catch (Exception e) {
                log.warn("ä½¿ç”¨å®¢æˆ¶ç«¯ {} çš„æç¤º {} å¤±æ•—", 
                    client.getServerName(), promptName, e);
            }
        }
        
        throw new McpPromptNotFoundException("æ‰¾ä¸åˆ°æç¤º: " + promptName);
    }
    
    /**
     * åˆ—å‡ºæ‰€æœ‰å¯ç”¨æç¤º
     */
    public List<McpPromptInfo> listAllPrompts() {
        List<McpPromptInfo> allPrompts = new ArrayList<>();
        
        for (McpSyncClient client : syncClients) {
            try {
                McpSchema.ListPromptsRequest request = new McpSchema.ListPromptsRequest();
                McpSchema.ListPromptsResult result = client.listPrompts(request);
                
                List<McpPromptInfo> clientPrompts = result.prompts().stream()
                    .map(prompt -> new McpPromptInfo(
                        prompt.name(),
                        prompt.description().orElse(""),
                        prompt.arguments().stream()
                            .map(arg -> new McpPromptArgument(
                                arg.name(),
                                arg.description(),
                                arg.required().orElse(false)
                            ))
                            .collect(Collectors.toList()),
                        client.getServerName()
                    ))
                    .collect(Collectors.toList());
                
                allPrompts.addAll(clientPrompts);
                
            } catch (Exception e) {
                log.warn("åˆ—å‡ºå®¢æˆ¶ç«¯ {} çš„æç¤ºå¤±æ•—", client.getServerName(), e);
            }
        }
        
        return allPrompts;
    }
    
    /**
     * æª¢æŸ¥å®¢æˆ¶ç«¯æ˜¯å¦æœ‰æŒ‡å®šæç¤º
     */
    private boolean hasPrompt(McpSyncClient client, String promptName) {
        try {
            McpSchema.ListPromptsResult result = client.listPrompts(
                new McpSchema.ListPromptsRequest());
            
            return result.prompts().stream()
                .anyMatch(prompt -> prompt.name().equals(promptName));
                
        } catch (Exception e) {
            log.debug("æª¢æŸ¥å®¢æˆ¶ç«¯ {} æç¤ºå¤±æ•—", client.getServerName(), e);
            return false;
        }
    }
    
    /**
     * è½‰æ› MCP æ¶ˆæ¯ç‚º ChatClient æ¶ˆæ¯
     */
    private List<Message> convertToMessages(List<PromptMessage> mcpMessages) {
        return mcpMessages.stream()
            .map(mcpMsg -> {
                switch (mcpMsg.role()) {
                    case USER:
                        return new UserMessage(mcpMsg.content().text());
                    case ASSISTANT:
                        return new AssistantMessage(mcpMsg.content().text());
                    case SYSTEM:
                        return new SystemMessage(mcpMsg.content().text());
                    default:
                        return new UserMessage(mcpMsg.content().text());
                }
            })
            .collect(Collectors.toList());
    }
}

/**
 * MCP æç¤ºä¿¡æ¯
 */
public record McpPromptInfo(
    String name,
    String description,
    List<McpPromptArgument> arguments,
    String serverName
) {}

/**
 * MCP æç¤ºåƒæ•¸
 */
public record McpPromptArgument(
    String name,
    String description,
    boolean required
) {}

/**
 * MCP æç¤ºæœªæ‰¾åˆ°ç•°å¸¸
 */
public class McpPromptNotFoundException extends RuntimeException {
    public McpPromptNotFoundException(String message) {
        super(message);
    }
}
```

---

## 9.3.5 ä¼æ¥­æ‡‰ç”¨å ´æ™¯

### æ™ºèƒ½æ–‡æª”åŠ©æ‰‹

```java
/**
 * æ™ºèƒ½æ–‡æª”åŠ©æ‰‹æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class IntelligentDocumentAssistant {
    
    private final McpClientService mcpService;
    private final McpResourceService resourceService;
    private final McpPromptService promptService;
    private final ChatClient chatClient;
    
    /**
     * æ™ºèƒ½æ–‡æª”åˆ†æ
     */
    public DocumentAnalysisResult analyzeDocument(String documentUri, String analysisType) {
        
        try {
            // 1. è®€å–æ–‡æª”å…§å®¹
            McpResourceContent document = resourceService.readResource(documentUri);
            String content = document.getTextContent();
            
            // 2. æ ¹æ“šåˆ†æé¡å‹é¸æ“‡åˆé©çš„æç¤º
            String promptName = getPromptForAnalysisType(analysisType);
            
            // 3. ä½¿ç”¨ MCP æç¤ºé€²è¡Œåˆ†æ
            Map<String, Object> promptArgs = Map.of(
                "document", content,
                "analysis_type", analysisType
            );
            
            String analysis = promptService.generateResponseWithPrompt(promptName, promptArgs);
            
            // 4. ä½¿ç”¨ MCP å·¥å…·é€²è¡Œé€²ä¸€æ­¥è™•ç†
            String summary = mcpService.executeTool("summarize_text", 
                Map.of("text", content, "max_length", 200));
            
            String keywords = mcpService.executeTool("extract_keywords", 
                Map.of("text", content, "count", 10));
            
            return new DocumentAnalysisResult(
                documentUri,
                analysisType,
                analysis,
                summary,
                keywords,
                Instant.now()
            );
            
        } catch (Exception e) {
            log.error("æ–‡æª”åˆ†æå¤±æ•—: {}", documentUri, e);
            throw new DocumentAnalysisException("æ–‡æª”åˆ†æå¤±æ•—", e);
        }
    }
    
    /**
     * æ™ºèƒ½å•ç­”
     */
    public String answerQuestion(String question, List<String> documentUris) {
        
        try {
            // 1. è®€å–ç›¸é—œæ–‡æª”
            StringBuilder context = new StringBuilder();
            for (String uri : documentUris) {
                try {
                    McpResourceContent doc = resourceService.readResource(uri);
                    context.append(doc.getTextContent()).append("\n\n");
                } catch (Exception e) {
                    log.warn("è®€å–æ–‡æª”å¤±æ•—: {}", uri, e);
                }
            }
            
            // 2. ä½¿ç”¨ MCP å·¥å…·é€²è¡Œå•ç­”
            Map<String, Object> qaParams = Map.of(
                "question", question,
                "context", context.toString()
            );
            
            return mcpService.executeTool("question_answering", qaParams);
            
        } catch (Exception e) {
            log.error("æ™ºèƒ½å•ç­”å¤±æ•—", e);
            throw new QuestionAnsweringException("å•ç­”è™•ç†å¤±æ•—", e);
        }
    }
    
    /**
     * æ–‡æª”æ¯”è¼ƒ
     */
    public DocumentComparisonResult compareDocuments(String doc1Uri, String doc2Uri) {
        
        try {
            // è®€å–å…©å€‹æ–‡æª”
            McpResourceContent doc1 = resourceService.readResource(doc1Uri);
            McpResourceContent doc2 = resourceService.readResource(doc2Uri);
            
            // ä½¿ç”¨ MCP å·¥å…·é€²è¡Œæ¯”è¼ƒ
            Map<String, Object> compareParams = Map.of(
                "document1", doc1.getTextContent(),
                "document2", doc2.getTextContent()
            );
            
            String comparison = mcpService.executeTool("compare_documents", compareParams);
            
            // è¨ˆç®—ç›¸ä¼¼åº¦
            String similarity = mcpService.executeTool("calculate_similarity", compareParams);
            
            return new DocumentComparisonResult(
                doc1Uri,
                doc2Uri,
                comparison,
                Double.parseDouble(similarity),
                Instant.now()
            );
            
        } catch (Exception e) {
            log.error("æ–‡æª”æ¯”è¼ƒå¤±æ•—", e);
            throw new DocumentComparisonException("æ–‡æª”æ¯”è¼ƒå¤±æ•—", e);
        }
    }
    
    private String getPromptForAnalysisType(String analysisType) {
        return switch (analysisType.toLowerCase()) {
            case "summary" -> "document_summary";
            case "sentiment" -> "sentiment_analysis";
            case "classification" -> "document_classification";
            case "extraction" -> "entity_extraction";
            default -> "general_analysis";
        };
    }
}

/**
 * æ–‡æª”åˆ†æçµæœ
 */
public record DocumentAnalysisResult(
    String documentUri,
    String analysisType,
    String analysis,
    String summary,
    String keywords,
    Instant timestamp
) {}

/**
 * æ–‡æª”æ¯”è¼ƒçµæœ
 */
public record DocumentComparisonResult(
    String document1Uri,
    String document2Uri,
    String comparison,
    double similarity,
    Instant timestamp
) {}

/**
 * æ–‡æª”åˆ†æç•°å¸¸
 */
public class DocumentAnalysisException extends RuntimeException {
    public DocumentAnalysisException(String message, Throwable cause) {
        super(message, cause);
    }
}

/**
 * å•ç­”ç•°å¸¸
 */
public class QuestionAnsweringException extends RuntimeException {
    public QuestionAnsweringException(String message, Throwable cause) {
        super(message, cause);
    }
}

/**
 * æ–‡æª”æ¯”è¼ƒç•°å¸¸
 */
public class DocumentComparisonException extends RuntimeException {
    public DocumentComparisonException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

---

## ğŸ“ æœ¬ç« é‡é»å›é¡§

1. **å·¥å…·ç™¼ç¾èˆ‡ç®¡ç†**ï¼šå­¸æœƒäº†å¦‚ä½•ç™¼ç¾ã€åˆ—å‡ºå’Œç®¡ç† MCP å·¥å…·
2. **ChatClient æ•´åˆ**ï¼šæŒæ¡äº† MCP å·¥å…·èˆ‡ Spring AI ChatClient çš„ç„¡ç¸«æ•´åˆ
3. **è³‡æºç®¡ç†**ï¼šäº†è§£äº† MCP è³‡æºçš„å­˜å–ã€å¿«å–å’Œç®¡ç†æ©Ÿåˆ¶
4. **æç¤ºæœå‹™**ï¼šå­¸æœƒäº†ä½¿ç”¨ MCP æç¤ºç³»çµ±å¢å¼· AI æ‡‰ç”¨
5. **ä¼æ¥­æ‡‰ç”¨**ï¼šå¯¦ç¾äº†å¯¦éš›çš„ä¼æ¥­ç´š MCP æ‡‰ç”¨å ´æ™¯

### æ ¸å¿ƒåŠŸèƒ½ç¸½çµ

| åŠŸèƒ½ | é‡è¦æ€§ | å¯¦ç¾é›£åº¦ | æ‡‰ç”¨åƒ¹å€¼ |
|------|--------|----------|----------|
| **å·¥å…·ç™¼ç¾** | â­â­â­â­â­ | ä¸­ | å‹•æ…‹èƒ½åŠ›æ“´å±• |
| **å·¥å…·èª¿ç”¨** | â­â­â­â­â­ | ä¸­ | æ ¸å¿ƒåŠŸèƒ½å¯¦ç¾ |
| **ChatClient æ•´åˆ** | â­â­â­â­ | ä½ | ç„¡ç¸«ç”¨æˆ¶é«”é©— |
| **è³‡æºç®¡ç†** | â­â­â­ | ä¸­ | æ•¸æ“šå­˜å–èƒ½åŠ› |
| **æç¤ºæœå‹™** | â­â­â­ | ä¸­ | æ™ºèƒ½äº¤äº’å¢å¼· |

### æœ€ä½³å¯¦è¸å»ºè­°

1. **éŒ¯èª¤è™•ç†**ï¼šå¯¦ç¾å¥å…¨çš„éŒ¯èª¤è™•ç†å’Œé‡è©¦æ©Ÿåˆ¶
2. **å¿«å–ç­–ç•¥**ï¼šåˆç†ä½¿ç”¨å¿«å–æå‡æ€§èƒ½
3. **ç›£æ§å‘Šè­¦**ï¼šå»ºç«‹å®Œæ•´çš„ MCP æœå‹™ç›£æ§
4. **å®‰å…¨æ§åˆ¶**ï¼šç¢ºä¿ MCP å·¥å…·çš„å®‰å…¨ä½¿ç”¨
5. **æ€§èƒ½å„ªåŒ–**ï¼šå„ªåŒ–å·¥å…·èª¿ç”¨çš„æ€§èƒ½å’Œä¸¦ç™¼è™•ç†

### ä¸‹ä¸€æ­¥å­¸ç¿’æ–¹å‘

åœ¨ä¸‹ä¸€ç¯€ä¸­ï¼Œæˆ‘å€‘å°‡å­¸ç¿’å¦‚ä½•é–‹ç™¼è‡ªå®šç¾©çš„ MCP Server å·¥å…·ï¼ŒåŒ…æ‹¬ï¼š
- MCP Server å·¥å…·é–‹ç™¼æ¡†æ¶
- è‡ªå®šç¾©å·¥å…·çš„å¯¦ç¾å’Œè¨»å†Š
- è³‡æºå’Œæç¤ºæœå‹™çš„é–‹ç™¼
- ä¼æ¥­ç´š MCP Server çš„éƒ¨ç½²å’Œç®¡ç†

---

**åƒè€ƒè³‡æ–™ï¼š**
- [Spring AI ChatClient Documentation](https://docs.spring.io/spring-ai/reference/api/chatclient.html)
- [MCP Tool Specification](https://spec.modelcontextprotocol.io/specification/basic/tools/)
- [MCP Resource Specification](https://spec.modelcontextprotocol.io/specification/basic/resources/)
- [MCP Prompt Specification](https://spec.modelcontextprotocol.io/specification/basic/prompts/)
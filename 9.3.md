# 9.3 在 Spring AI 程式中使用 MCP 工具

> **本章重點**：深入學習如何在 Spring AI 應用中使用 MCP 工具，掌握工具發現、調用和管理的完整流程，實現 MCP Client 與 ChatClient 的無縫整合，建立企業級的 MCP 工具使用最佳實踐。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握 MCP 工具發現**：學會如何發現和列出可用的 MCP 工具
- 🎯 **實現工具調用**：掌握 MCP 工具的調用方法和參數傳遞
- 🎯 **整合 ChatClient**：將 MCP 工具與 Spring AI ChatClient 無縫整合
- 🎯 **管理 MCP 資源**：學會使用 MCP 資源和提示服務
- 🎯 **建立企業應用**：開發實際的企業級 MCP 應用場景

---

## 9.3.1 MCP 工具發現與管理

### 基礎 MCP Client 服務

```java
/**
 * MCP Client 核心服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class McpClientService {
    
    private final List<McpSyncClient> syncClients;
    private final SyncMcpToolCallbackProvider toolCallbackProvider;
    
    /**
     * 獲取所有可用的 MCP 工具回調
     */
    public ToolCallback[] getToolCallbacks() {
        try {
            log.debug("獲取 MCP 工具回調，客戶端數量: {}", syncClients.size());
            
            // 直接從工具回調提供者獲取所有工具
            ToolCallback[] result = toolCallbackProvider.getToolCallbacks();
            log.info("總共獲取到 {} 個 MCP 工具", result.length);
            
            return result;
            
        } catch (Exception e) {
            log.error("獲取 MCP 工具回調失敗", e);
            return new ToolCallback[0];
        }
    }
    
    /**
     * 獲取可用工具的詳細信息
     */
    public List<ToolDefinition> getAvailableTools() {
        List<ToolDefinition> tools = new ArrayList<>();
        
        for (McpSyncClient client : syncClients) {
            try {
                // 列出客戶端的工具
                McpSchema.ListToolsResult result = client.listTools(
                    new McpSchema.ListToolsRequest());
                
                for (McpSchema.Tool tool : result.tools()) {
                    tools.add(convertToToolDefinition(tool, client.getServerName()));
                }
                
            } catch (Exception e) {
                log.warn("列出客戶端 {} 的工具失敗", client.getServerName(), e);
            }
        }
        
        return tools;
    }
    
    /**
     * 執行指定的 MCP 工具
     */
    public String executeTool(String toolName, Map<String, Object> parameters) {
        
        log.debug("執行 MCP 工具: {} with parameters: {}", toolName, parameters);
        
        for (McpSyncClient client : syncClients) {
            try {
                // 檢查客戶端是否有此工具
                if (hasToolInClient(client, toolName)) {
                    return executeToolInClient(client, toolName, parameters);
                }
                
            } catch (McpToolNotFoundException e) {
                // 繼續嘗試下一個客戶端
                continue;
            } catch (Exception e) {
                log.error("在客戶端 {} 執行工具 {} 失敗", 
                    client.getServerName(), toolName, e);
                throw new McpToolExecutionException("工具執行失敗: " + toolName, e);
            }
        }
        
        throw new McpToolNotFoundException("找不到工具: " + toolName);
    }
    
    /**
     * 獲取 MCP 伺服器信息
     */
    public List<McpServerInfo> getServerInfo() {
        return syncClients.stream()
            .map(client -> new McpServerInfo(
                client.getServerName(),
                client.getServerVersion(),
                client.isConnected(),
                getToolCountForClient(client)
            ))
            .collect(Collectors.toList());
    }
    
    /**
     * 檢查客戶端是否有指定工具
     */
    private boolean hasToolInClient(McpSyncClient client, String toolName) {
        try {
            McpSchema.ListToolsResult result = client.listTools(
                new McpSchema.ListToolsRequest());
            
            return result.tools().stream()
                .anyMatch(tool -> tool.name().equals(toolName));
                
        } catch (Exception e) {
            log.warn("檢查客戶端 {} 工具失敗", client.getServerName(), e);
            return false;
        }
    }
    
    /**
     * 在指定客戶端執行工具
     */
    private String executeToolInClient(McpSyncClient client, String toolName, 
                                     Map<String, Object> parameters) {
        
        long startTime = System.currentTimeMillis();
        
        try {
            // 構建工具調用請求
            McpSchema.CallToolRequest request = new McpSchema.CallToolRequest(
                toolName, parameters);
            
            // 執行工具
            McpSchema.CallToolResult result = client.callTool(request);
            
            // 處理結果
            String response = processToolResult(result);
            
            // 記錄指標
            long duration = System.currentTimeMillis() - startTime;
            metricsCollector.recordToolExecution(toolName, duration, true);
            
            log.debug("工具 {} 執行成功，耗時 {}ms", toolName, duration);
            return response;
            
        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            metricsCollector.recordToolExecution(toolName, duration, false);
            
            log.error("工具 {} 執行失敗，耗時 {}ms", toolName, duration, e);
            throw e;
        }
    }
    
    /**
     * 處理工具執行結果
     */
    private String processToolResult(McpSchema.CallToolResult result) {
        if (result.content() == null || result.content().isEmpty()) {
            return "工具執行完成，無返回內容";
        }
        
        // 處理不同類型的內容
        StringBuilder response = new StringBuilder();
        for (McpSchema.Content content : result.content()) {
            if (content instanceof McpSchema.TextContent textContent) {
                response.append(textContent.text()).append("\n");
            } else if (content instanceof McpSchema.ImageContent imageContent) {
                response.append("[圖片: ").append(imageContent.data()).append("]\n");
            } else {
                response.append("[未知內容類型]\n");
            }
        }
        
        return response.toString().trim();
    }
    
    /**
     * 轉換 MCP 工具為 ToolDefinition
     */
    private ToolDefinition convertToToolDefinition(McpSchema.Tool tool, String serverName) {
        return ToolDefinition.builder()
            .name(tool.name())
            .description(tool.description())
            .inputSchema(tool.inputSchema())
            .metadata(Map.of(
                "serverName", serverName,
                "toolType", "mcp"
            ))
            .build();
    }
    
    /**
     * 獲取客戶端的工具數量
     */
    private int getToolCountForClient(McpSyncClient client) {
        try {
            McpSchema.ListToolsResult result = client.listTools(
                new McpSchema.ListToolsRequest());
            return result.tools().size();
        } catch (Exception e) {
            return 0;
        }
    }
}

/**
 * MCP 伺服器信息記錄
 */
public record McpServerInfo(
    String name,
    String version,
    boolean connected,
    int toolCount
) {}

/**
 * MCP 工具執行異常
 */
public class McpToolExecutionException extends RuntimeException {
    public McpToolExecutionException(String message, Throwable cause) {
        super(message, cause);
    }
}

/**
 * MCP 工具未找到異常
 */
public class McpToolNotFoundException extends RuntimeException {
    public McpToolNotFoundException(String message) {
        super(message);
    }
}
```

---

## 9.3.2 與 ChatClient 整合

### MCP 增強的聊天控制器

```java
/**
 * MCP 增強的聊天控制器
 */
@RestController
@RequestMapping("/api/chat")
@RequiredArgsConstructor
@Slf4j
public class McpChatController {
    
    private final ChatClient chatClient;
    private final McpClientService mcpService;
    private final McpChatHistoryService historyService;
    
    /**
     * 使用 MCP 工具的聊天端點
     */
    @PostMapping("/mcp")
    public ResponseEntity<ChatResponse> chatWithMcp(@RequestBody ChatRequest request) {
        
        try {
            log.info("收到 MCP 聊天請求: {}", request.getMessage());
            
            // 獲取 MCP 工具
            ToolCallback[] mcpTools = mcpService.getToolCallbacks();
            log.debug("可用 MCP 工具數量: {}", mcpTools.length);
            
            // 使用 ChatClient 與 MCP 工具整合
            String response = chatClient.prompt()
                .system("""
                    你是一個企業級 AI 助手，具備以下能力：
                    1. 可以使用各種 MCP 工具來協助用戶
                    2. 根據用戶需求選擇合適的工具
                    3. 提供準確、有用的回答
                    4. 當需要使用工具時，請明確說明使用的工具和原因
                    """)
                .user(request.getMessage())
                .functions(mcpTools)  // 使用 functions 整合 MCP 工具
                .call()
                .content();
            
            // 保存聊天歷史
            historyService.saveChatHistory(request.getMessage(), response, mcpTools.length);
            
            return ResponseEntity.ok(new ChatResponse(response, mcpTools.length));
            
        } catch (Exception e) {
            log.error("MCP 聊天處理失敗", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ChatResponse("抱歉，服務暫時不可用，請稍後再試。", 0));
        }
    }
    
    /**
     * 獲取可用的 MCP 工具列表
     */
    @GetMapping("/tools")
    public ResponseEntity<List<ToolInfo>> getAvailableTools() {
        
        try {
            List<ToolDefinition> tools = mcpService.getAvailableTools();
            
            List<ToolInfo> toolInfos = tools.stream()
                .map(tool -> new ToolInfo(
                    tool.getName(),
                    tool.getDescription(),
                    tool.getMetadata().get("serverName").toString()
                ))
                .collect(Collectors.toList());
            
            return ResponseEntity.ok(toolInfos);
            
        } catch (Exception e) {
            log.error("獲取工具列表失敗", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Collections.emptyList());
        }
    }
    
    /**
     * 直接執行 MCP 工具
     */
    @PostMapping("/tools/{toolName}/execute")
    public ResponseEntity<ToolExecutionResponse> executeTool(
            @PathVariable String toolName,
            @RequestBody Map<String, Object> parameters) {
        
        try {
            log.info("直接執行 MCP 工具: {} with parameters: {}", toolName, parameters);
            
            String result = mcpService.executeTool(toolName, parameters);
            
            return ResponseEntity.ok(new ToolExecutionResponse(
                toolName, parameters, result, true, null));
            
        } catch (McpToolNotFoundException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(new ToolExecutionResponse(
                    toolName, parameters, null, false, "工具未找到: " + toolName));
        } catch (Exception e) {
            log.error("執行工具失敗: {}", toolName, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ToolExecutionResponse(
                    toolName, parameters, null, false, "工具執行失敗: " + e.getMessage()));
        }
    }
    
    /**
     * 獲取 MCP 伺服器狀態
     */
    @GetMapping("/servers")
    public ResponseEntity<List<McpServerInfo>> getServerStatus() {
        
        try {
            List<McpServerInfo> servers = mcpService.getServerInfo();
            return ResponseEntity.ok(servers);
            
        } catch (Exception e) {
            log.error("獲取伺服器狀態失敗", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Collections.emptyList());
        }
    }
}

/**
 * 聊天請求
 */
public record ChatRequest(String message) {}

/**
 * 聊天回應
 */
public record ChatResponse(String response, int availableTools) {}

/**
 * 工具信息
 */
public record ToolInfo(String name, String description, String serverName) {}

/**
 * 工具執行回應
 */
public record ToolExecutionResponse(
    String toolName,
    Map<String, Object> parameters,
    String result,
    boolean success,
    String error
) {}
```

### 流式聊天支援

```java
/**
 * MCP 流式聊天服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class McpStreamingChatService {
    
    private final ChatClient chatClient;
    private final McpClientService mcpService;
    
    /**
     * 流式聊天與 MCP 工具整合
     */
    public Flux<String> streamChatWithMcp(String userMessage) {
        
        return Flux.create(sink -> {
            try {
                // 獲取 MCP 工具
                ToolCallback[] mcpTools = mcpService.getToolCallbacks();
                
                // 建立流式聊天
                chatClient.prompt()
                    .system("你是一個智能助手，可以使用各種工具來協助用戶。")
                    .user(userMessage)
                    .functions(mcpTools)
                    .stream()
                    .content()
                    .subscribe(
                        sink::next,
                        sink::error,
                        sink::complete
                    );
                    
            } catch (Exception e) {
                log.error("流式聊天失敗", e);
                sink.error(e);
            }
        });
    }
}

/**
 * 流式聊天控制器
 */
@RestController
@RequestMapping("/api/chat")
@RequiredArgsConstructor
public class McpStreamingChatController {
    
    private final McpStreamingChatService streamingChatService;
    
    /**
     * 流式聊天端點
     */
    @PostMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> streamChat(@RequestBody ChatRequest request) {
        
        return streamingChatService.streamChatWithMcp(request.message())
            .map(content -> ServerSentEvent.<String>builder()
                .data(content)
                .build())
            .onErrorResume(error -> {
                log.error("流式聊天錯誤", error);
                return Flux.just(ServerSentEvent.<String>builder()
                    .data("[錯誤] 服務暫時不可用")
                    .build());
            });
    }
}
```

---

## 9.3.3 MCP 資源管理

### MCP 資源存取服務

```java
/**
 * MCP 資源存取服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class McpResourceService {
    
    private final List<McpSyncClient> syncClients;
    private final McpResourceCache resourceCache;
    
    /**
     * 讀取 MCP 資源
     */
    public McpResourceContent readResource(String resourceUri) {
        
        log.debug("讀取 MCP 資源: {}", resourceUri);
        
        // 檢查快取
        McpResourceContent cached = resourceCache.get(resourceUri);
        if (cached != null) {
            log.debug("從快取獲取資源: {}", resourceUri);
            return cached;
        }
        
        // 嘗試從各個客戶端讀取資源
        for (McpSyncClient client : syncClients) {
            try {
                if (supportsResource(client, URI.create(resourceUri))) {
                    
                    McpSchema.ReadResourceRequest request = 
                        new McpSchema.ReadResourceRequest(URI.create(resourceUri));
                    
                    McpSchema.ReadResourceResult result = client.readResource(request);
                    
                    McpResourceContent content = new McpResourceContent(
                        resourceUri,
                        result.contents(),
                        client.getServerName(),
                        Instant.now()
                    );
                    
                    // 快取結果
                    resourceCache.put(resourceUri, content);
                    
                    log.debug("成功讀取資源: {} from {}", resourceUri, client.getServerName());
                    return content;
                }
                
            } catch (Exception e) {
                log.warn("從客戶端 {} 讀取資源 {} 失敗", client.getServerName(), resourceUri, e);
            }
        }
        
        throw new McpResourceNotFoundException("找不到資源: " + resourceUri);
    }
    
    /**
     * 列出所有可用資源
     */
    public List<McpResourceInfo> listAllResources() {
        List<McpResourceInfo> allResources = new ArrayList<>();
        
        for (McpSyncClient client : syncClients) {
            try {
                McpSchema.ListResourcesRequest request = new McpSchema.ListResourcesRequest();
                McpSchema.ListResourcesResult result = client.listResources(request);
                
                List<McpResourceInfo> clientResources = result.resources().stream()
                    .map(resource -> new McpResourceInfo(
                        resource.uri().toString(),
                        resource.name(),
                        resource.description().orElse(""),
                        resource.mimeType().orElse("text/plain"),
                        client.getServerName()
                    ))
                    .collect(Collectors.toList());
                
                allResources.addAll(clientResources);
                
                log.debug("客戶端 {} 提供 {} 個資源", 
                    client.getServerName(), clientResources.size());
                
            } catch (Exception e) {
                log.warn("列出客戶端 {} 的資源失敗", client.getServerName(), e);
            }
        }
        
        log.info("總共找到 {} 個 MCP 資源", allResources.size());
        return allResources;
    }
    
    /**
     * 搜尋資源
     */
    public List<McpResourceInfo> searchResources(String query) {
        return listAllResources().stream()
            .filter(resource -> 
                resource.name().toLowerCase().contains(query.toLowerCase()) ||
                resource.description().toLowerCase().contains(query.toLowerCase()))
            .collect(Collectors.toList());
    }
    
    /**
     * 檢查客戶端是否支援指定資源
     */
    private boolean supportsResource(McpSyncClient client, URI uri) {
        try {
            McpSchema.ListResourcesResult result = client.listResources(
                new McpSchema.ListResourcesRequest());
            
            return result.resources().stream()
                .anyMatch(resource -> resource.uri().equals(uri));
                
        } catch (Exception e) {
            log.debug("檢查客戶端 {} 資源支援失敗", client.getServerName(), e);
            return false;
        }
    }
}

/**
 * MCP 資源內容
 */
public record McpResourceContent(
    String uri,
    List<McpSchema.ResourceContents> contents,
    String serverName,
    Instant timestamp
) {
    
    /**
     * 獲取文字內容
     */
    public String getTextContent() {
        return contents.stream()
            .filter(content -> content instanceof McpSchema.TextResourceContents)
            .map(content -> ((McpSchema.TextResourceContents) content).text())
            .collect(Collectors.joining("\n"));
    }
    
    /**
     * 獲取二進制內容
     */
    public byte[] getBinaryContent() {
        return contents.stream()
            .filter(content -> content instanceof McpSchema.BlobResourceContents)
            .map(content -> ((McpSchema.BlobResourceContents) content).blob())
            .findFirst()
            .orElse(new byte[0]);
    }
}

/**
 * MCP 資源信息
 */
public record McpResourceInfo(
    String uri,
    String name,
    String description,
    String mimeType,
    String serverName
) {}

/**
 * MCP 資源未找到異常
 */
public class McpResourceNotFoundException extends RuntimeException {
    public McpResourceNotFoundException(String message) {
        super(message);
    }
}
```

### MCP 資源快取

```java
/**
 * MCP 資源快取服務
 */
@Service
@Slf4j
public class McpResourceCache {
    
    private final Cache<String, McpResourceContent> cache;
    
    public McpResourceCache() {
        this.cache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(Duration.ofMinutes(30))
            .recordStats()
            .build();
    }
    
    /**
     * 獲取快取的資源
     */
    public McpResourceContent get(String uri) {
        McpResourceContent content = cache.getIfPresent(uri);
        if (content != null) {
            log.debug("快取命中: {}", uri);
        }
        return content;
    }
    
    /**
     * 快取資源
     */
    public void put(String uri, McpResourceContent content) {
        cache.put(uri, content);
        log.debug("快取資源: {}", uri);
    }
    
    /**
     * 清除快取
     */
    public void evict(String uri) {
        cache.invalidate(uri);
        log.debug("清除快取: {}", uri);
    }
    
    /**
     * 清除所有快取
     */
    public void evictAll() {
        cache.invalidateAll();
        log.info("清除所有資源快取");
    }
    
    /**
     * 獲取快取統計
     */
    public CacheStats getStats() {
        return cache.stats();
    }
}
```

---

## 9.3.4 MCP 提示管理

### MCP 提示服務

```java
/**
 * MCP 提示管理服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class McpPromptService {
    
    private final List<McpSyncClient> syncClients;
    private final ChatClient chatClient;
    
    /**
     * 使用 MCP 提示生成回應
     */
    public String generateResponseWithPrompt(String promptName, Map<String, Object> arguments) {
        
        for (McpSyncClient client : syncClients) {
            try {
                if (hasPrompt(client, promptName)) {
                    
                    // 獲取提示
                    McpSchema.GetPromptRequest request = new McpSchema.GetPromptRequest(
                        promptName, arguments);
                    
                    McpSchema.GetPromptResult result = client.getPrompt(request);
                    
                    // 將 MCP 提示轉換為 ChatClient 消息
                    List<Message> messages = convertToMessages(result.messages());
                    
                    // 使用 ChatClient 生成回應
                    return chatClient.prompt()
                        .messages(messages)
                        .call()
                        .content();
                }
                
            } catch (Exception e) {
                log.warn("使用客戶端 {} 的提示 {} 失敗", 
                    client.getServerName(), promptName, e);
            }
        }
        
        throw new McpPromptNotFoundException("找不到提示: " + promptName);
    }
    
    /**
     * 列出所有可用提示
     */
    public List<McpPromptInfo> listAllPrompts() {
        List<McpPromptInfo> allPrompts = new ArrayList<>();
        
        for (McpSyncClient client : syncClients) {
            try {
                McpSchema.ListPromptsRequest request = new McpSchema.ListPromptsRequest();
                McpSchema.ListPromptsResult result = client.listPrompts(request);
                
                List<McpPromptInfo> clientPrompts = result.prompts().stream()
                    .map(prompt -> new McpPromptInfo(
                        prompt.name(),
                        prompt.description().orElse(""),
                        prompt.arguments().stream()
                            .map(arg -> new McpPromptArgument(
                                arg.name(),
                                arg.description(),
                                arg.required().orElse(false)
                            ))
                            .collect(Collectors.toList()),
                        client.getServerName()
                    ))
                    .collect(Collectors.toList());
                
                allPrompts.addAll(clientPrompts);
                
            } catch (Exception e) {
                log.warn("列出客戶端 {} 的提示失敗", client.getServerName(), e);
            }
        }
        
        return allPrompts;
    }
    
    /**
     * 檢查客戶端是否有指定提示
     */
    private boolean hasPrompt(McpSyncClient client, String promptName) {
        try {
            McpSchema.ListPromptsResult result = client.listPrompts(
                new McpSchema.ListPromptsRequest());
            
            return result.prompts().stream()
                .anyMatch(prompt -> prompt.name().equals(promptName));
                
        } catch (Exception e) {
            log.debug("檢查客戶端 {} 提示失敗", client.getServerName(), e);
            return false;
        }
    }
    
    /**
     * 轉換 MCP 消息為 ChatClient 消息
     */
    private List<Message> convertToMessages(List<PromptMessage> mcpMessages) {
        return mcpMessages.stream()
            .map(mcpMsg -> {
                switch (mcpMsg.role()) {
                    case USER:
                        return new UserMessage(mcpMsg.content().text());
                    case ASSISTANT:
                        return new AssistantMessage(mcpMsg.content().text());
                    case SYSTEM:
                        return new SystemMessage(mcpMsg.content().text());
                    default:
                        return new UserMessage(mcpMsg.content().text());
                }
            })
            .collect(Collectors.toList());
    }
}

/**
 * MCP 提示信息
 */
public record McpPromptInfo(
    String name,
    String description,
    List<McpPromptArgument> arguments,
    String serverName
) {}

/**
 * MCP 提示參數
 */
public record McpPromptArgument(
    String name,
    String description,
    boolean required
) {}

/**
 * MCP 提示未找到異常
 */
public class McpPromptNotFoundException extends RuntimeException {
    public McpPromptNotFoundException(String message) {
        super(message);
    }
}
```

---

## 9.3.5 企業應用場景

### 智能文檔助手

```java
/**
 * 智能文檔助手服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class IntelligentDocumentAssistant {
    
    private final McpClientService mcpService;
    private final McpResourceService resourceService;
    private final McpPromptService promptService;
    private final ChatClient chatClient;
    
    /**
     * 智能文檔分析
     */
    public DocumentAnalysisResult analyzeDocument(String documentUri, String analysisType) {
        
        try {
            // 1. 讀取文檔內容
            McpResourceContent document = resourceService.readResource(documentUri);
            String content = document.getTextContent();
            
            // 2. 根據分析類型選擇合適的提示
            String promptName = getPromptForAnalysisType(analysisType);
            
            // 3. 使用 MCP 提示進行分析
            Map<String, Object> promptArgs = Map.of(
                "document", content,
                "analysis_type", analysisType
            );
            
            String analysis = promptService.generateResponseWithPrompt(promptName, promptArgs);
            
            // 4. 使用 MCP 工具進行進一步處理
            String summary = mcpService.executeTool("summarize_text", 
                Map.of("text", content, "max_length", 200));
            
            String keywords = mcpService.executeTool("extract_keywords", 
                Map.of("text", content, "count", 10));
            
            return new DocumentAnalysisResult(
                documentUri,
                analysisType,
                analysis,
                summary,
                keywords,
                Instant.now()
            );
            
        } catch (Exception e) {
            log.error("文檔分析失敗: {}", documentUri, e);
            throw new DocumentAnalysisException("文檔分析失敗", e);
        }
    }
    
    /**
     * 智能問答
     */
    public String answerQuestion(String question, List<String> documentUris) {
        
        try {
            // 1. 讀取相關文檔
            StringBuilder context = new StringBuilder();
            for (String uri : documentUris) {
                try {
                    McpResourceContent doc = resourceService.readResource(uri);
                    context.append(doc.getTextContent()).append("\n\n");
                } catch (Exception e) {
                    log.warn("讀取文檔失敗: {}", uri, e);
                }
            }
            
            // 2. 使用 MCP 工具進行問答
            Map<String, Object> qaParams = Map.of(
                "question", question,
                "context", context.toString()
            );
            
            return mcpService.executeTool("question_answering", qaParams);
            
        } catch (Exception e) {
            log.error("智能問答失敗", e);
            throw new QuestionAnsweringException("問答處理失敗", e);
        }
    }
    
    /**
     * 文檔比較
     */
    public DocumentComparisonResult compareDocuments(String doc1Uri, String doc2Uri) {
        
        try {
            // 讀取兩個文檔
            McpResourceContent doc1 = resourceService.readResource(doc1Uri);
            McpResourceContent doc2 = resourceService.readResource(doc2Uri);
            
            // 使用 MCP 工具進行比較
            Map<String, Object> compareParams = Map.of(
                "document1", doc1.getTextContent(),
                "document2", doc2.getTextContent()
            );
            
            String comparison = mcpService.executeTool("compare_documents", compareParams);
            
            // 計算相似度
            String similarity = mcpService.executeTool("calculate_similarity", compareParams);
            
            return new DocumentComparisonResult(
                doc1Uri,
                doc2Uri,
                comparison,
                Double.parseDouble(similarity),
                Instant.now()
            );
            
        } catch (Exception e) {
            log.error("文檔比較失敗", e);
            throw new DocumentComparisonException("文檔比較失敗", e);
        }
    }
    
    private String getPromptForAnalysisType(String analysisType) {
        return switch (analysisType.toLowerCase()) {
            case "summary" -> "document_summary";
            case "sentiment" -> "sentiment_analysis";
            case "classification" -> "document_classification";
            case "extraction" -> "entity_extraction";
            default -> "general_analysis";
        };
    }
}

/**
 * 文檔分析結果
 */
public record DocumentAnalysisResult(
    String documentUri,
    String analysisType,
    String analysis,
    String summary,
    String keywords,
    Instant timestamp
) {}

/**
 * 文檔比較結果
 */
public record DocumentComparisonResult(
    String document1Uri,
    String document2Uri,
    String comparison,
    double similarity,
    Instant timestamp
) {}

/**
 * 文檔分析異常
 */
public class DocumentAnalysisException extends RuntimeException {
    public DocumentAnalysisException(String message, Throwable cause) {
        super(message, cause);
    }
}

/**
 * 問答異常
 */
public class QuestionAnsweringException extends RuntimeException {
    public QuestionAnsweringException(String message, Throwable cause) {
        super(message, cause);
    }
}

/**
 * 文檔比較異常
 */
public class DocumentComparisonException extends RuntimeException {
    public DocumentComparisonException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

---

## 📝 本章重點回顧

1. **工具發現與管理**：學會了如何發現、列出和管理 MCP 工具
2. **ChatClient 整合**：掌握了 MCP 工具與 Spring AI ChatClient 的無縫整合
3. **資源管理**：了解了 MCP 資源的存取、快取和管理機制
4. **提示服務**：學會了使用 MCP 提示系統增強 AI 應用
5. **企業應用**：實現了實際的企業級 MCP 應用場景

### 核心功能總結

| 功能 | 重要性 | 實現難度 | 應用價值 |
|------|--------|----------|----------|
| **工具發現** | ⭐⭐⭐⭐⭐ | 中 | 動態能力擴展 |
| **工具調用** | ⭐⭐⭐⭐⭐ | 中 | 核心功能實現 |
| **ChatClient 整合** | ⭐⭐⭐⭐ | 低 | 無縫用戶體驗 |
| **資源管理** | ⭐⭐⭐ | 中 | 數據存取能力 |
| **提示服務** | ⭐⭐⭐ | 中 | 智能交互增強 |

### 最佳實踐建議

1. **錯誤處理**：實現健全的錯誤處理和重試機制
2. **快取策略**：合理使用快取提升性能
3. **監控告警**：建立完整的 MCP 服務監控
4. **安全控制**：確保 MCP 工具的安全使用
5. **性能優化**：優化工具調用的性能和並發處理

### 下一步學習方向

在下一節中，我們將學習如何開發自定義的 MCP Server 工具，包括：
- MCP Server 工具開發框架
- 自定義工具的實現和註冊
- 資源和提示服務的開發
- 企業級 MCP Server 的部署和管理

---

**參考資料：**
- [Spring AI ChatClient Documentation](https://docs.spring.io/spring-ai/reference/api/chatclient.html)
- [MCP Tool Specification](https://spec.modelcontextprotocol.io/specification/basic/tools/)
- [MCP Resource Specification](https://spec.modelcontextprotocol.io/specification/basic/resources/)
- [MCP Prompt Specification](https://spec.modelcontextprotocol.io/specification/basic/prompts/)
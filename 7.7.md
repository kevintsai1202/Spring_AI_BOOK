# 7.7 RAG 的最後一哩路

> **本章重點**：完成 RAG 系統的最後部署和優化工作，掌握系統部署運維、效能調校、監控告警和故障排除，確保 RAG 系統在生產環境中穩定高效運行。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **部署生產級 RAG 系統**：掌握容器化部署和雲端部署策略
- 🎯 **優化系統效能**：實現查詢優化、快取策略和資源調校
- 🎯 **建立監控告警**：實現全方位的系統監控和智能告警
- 🎯 **處理故障恢復**：掌握故障診斷、快速恢復和災難備援
- 🎯 **持續改進優化**：建立效能分析和系統優化的持續改進機制

---

## 7.7.1 生產級部署策略

### 容器化部署架構

**Docker 容器化部署**：

```dockerfile
# RAG Application Dockerfile
FROM openjdk:21-jdk-slim

# 設定工作目錄
WORKDIR /app

# 複製應用程式
COPY target/rag-application.jar app.jar
COPY config/ config/
COPY scripts/ scripts/

# 安裝必要工具
RUN apt-get update && apt-get install -y \
    curl \
    jq \
    && rm -rf /var/lib/apt/lists/*

# 建立非 root 使用者
RUN groupadd -r raguser && useradd -r -g raguser raguser
RUN chown -R raguser:raguser /app
USER raguser

# 健康檢查
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# 暴露端口
EXPOSE 8080

# 啟動應用程式
ENTRYPOINT ["java", "-jar", "-Dspring.profiles.active=prod", "app.jar"]
```

### Docker Compose 編排

```yaml
# docker-compose.yml
version: '3.8'

services:
  # RAG 應用服務
  rag-app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/ragdb
      - SPRING_AI_VECTORSTORE_NEO4J_URI=bolt://neo4j:7687
      - SPRING_AI_VECTORSTORE_NEO4J_USERNAME=neo4j
      - SPRING_AI_VECTORSTORE_NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - SPRING_AI_OPENAI_API_KEY=${OPENAI_API_KEY}
      - SPRING_AI_OPENAI_CHAT_MODEL=gpt-4o
      - SPRING_AI_OPENAI_EMBEDDING_MODEL=text-embedding-3-large
    depends_on:
      - postgres
      - neo4j
      - redis
    volumes:
      - ./logs:/app/logs
      - ./data:/app/data
    networks:
      - rag-network
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '1.0'
          memory: 2G

  # PostgreSQL 資料庫
  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=ragdb
      - POSTGRES_USER=raguser
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    networks:
      - rag-network
    restart: unless-stopped

  # Neo4j 向量資料庫
  neo4j:
    image: neo4j:5.15-community
    environment:
      - NEO4J_AUTH=neo4j/${NEO4J_PASSWORD}
      - NEO4J_PLUGINS=["apoc"]
      - NEO4J_dbms_security_procedures_unrestricted=apoc.*
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs
    ports:
      - "7474:7474"
      - "7687:7687"
    networks:
      - rag-network
    restart: unless-stopped

  # Redis 快取
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - rag-network
    restart: unless-stopped

  # Nginx 反向代理
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - rag-app
    networks:
      - rag-network
    restart: unless-stopped

  # Prometheus 監控
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    networks:
      - rag-network
    restart: unless-stopped

  # Grafana 視覺化
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards
      - ./grafana/datasources:/etc/grafana/provisioning/datasources
    networks:
      - rag-network
    restart: unless-stopped

volumes:
  postgres_data:
  neo4j_data:
  neo4j_logs:
  redis_data:
  prometheus_data:
  grafana_data:

networks:
  rag-network:
    driver: bridge
```

### Kubernetes 部署配置

```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rag-application
  namespace: rag-system
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rag-application
  template:
    metadata:
      labels:
        app: rag-application
    spec:
      containers:
      - name: rag-app
        image: rag-application:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "k8s"
        - name: SPRING_DATASOURCE_URL
          valueFrom:
            secretKeyRef:
              name: rag-secrets
              key: database-url
        - name: SPRING_AI_OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: rag-secrets
              key: openai-api-key
        resources:
          requests:
            memory: "2Gi"
            cpu: "1000m"
          limits:
            memory: "4Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
        - name: logs-volume
          mountPath: /app/logs
      volumes:
      - name: config-volume
        configMap:
          name: rag-config
      - name: logs-volume
        persistentVolumeClaim:
          claimName: rag-logs-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: rag-service
  namespace: rag-system
spec:
  selector:
    app: rag-application
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: LoadBalancer
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: rag-ingress
  namespace: rag-system
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - rag.example.com
    secretName: rag-tls
  rules:
  - host: rag.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: rag-service
            port:
              number: 80
```

---

## 7.7.2 系統效能優化

### Spring AI 相關依賴配置

首先需要確保項目中包含正確的 Spring AI 依賴：

```xml
<dependencies>
    <!-- Spring AI Core -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- OpenAI Chat Model -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Neo4j Vector Store -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-neo4j-store-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Spring Boot Actuator for monitoring -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    
    <!-- Micrometer for metrics -->
    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-registry-prometheus</artifactId>
    </dependency>
</dependencies>
```

### 查詢效能優化服務

```java
import org.springframework.ai.document.Document;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.ai.vectorstore.SearchRequest;
import org.springframework.ai.vectorstore.filter.Filter;
import org.springframework.stereotype.Service;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * RAG 查詢效能優化服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class QueryOptimizationService {
    
    private final VectorStore vectorStore;
    private final CacheManager cacheManager;
    private final QueryAnalyzer queryAnalyzer;
    private final PerformanceMetrics performanceMetrics;
    
    /**
     * 優化查詢執行
     */
    public QueryResult optimizeQuery(QueryRequest request) {
        long startTime = System.currentTimeMillis();
        
        try {
            // 1. 查詢分析和預處理
            OptimizedQuery optimizedQuery = analyzeAndOptimizeQuery(request);
            
            // 2. 快取檢查
            QueryResult cachedResult = checkCache(optimizedQuery);
            if (cachedResult != null) {
                performanceMetrics.recordCacheHit(request.getQueryId());
                return cachedResult;
            }
            
            // 3. 執行優化查詢
            QueryResult result = executeOptimizedQuery(optimizedQuery);
            
            // 4. 結果快取
            cacheResult(optimizedQuery, result);
            
            // 5. 記錄效能指標
            long executionTime = System.currentTimeMillis() - startTime;
            performanceMetrics.recordQueryExecution(request.getQueryId(), executionTime);
            
            return result;
            
        } catch (Exception e) {
            log.error("Query optimization failed for: {}", request.getQueryId(), e);
            performanceMetrics.recordQueryError(request.getQueryId());
            throw new QueryOptimizationException("Query optimization failed", e);
        }
    }
    
    /**
     * 分析和優化查詢
     */
    private OptimizedQuery analyzeAndOptimizeQuery(QueryRequest request) {
        QueryAnalysisResult analysis = queryAnalyzer.analyze(request);
        
        return OptimizedQuery.builder()
            .originalQuery(request.getQuery())
            .optimizedQuery(optimizeQueryText(request.getQuery(), analysis))
            .searchStrategy(determineSearchStrategy(analysis))
            .filterExpression(optimizeFilters(request.getFilters(), analysis))
            .resultLimit(optimizeResultLimit(request.getLimit(), analysis))
            .similarityThreshold(optimizeSimilarityThreshold(analysis))
            .build();
    }
    
    /**
     * 優化查詢文本
     */
    private String optimizeQueryText(String originalQuery, QueryAnalysisResult analysis) {
        String optimized = originalQuery;
        
        // 1. 移除停用詞
        if (analysis.hasStopWords()) {
            optimized = removeStopWords(optimized, analysis.getLanguage());
        }
        
        // 2. 詞幹提取
        if (analysis.needsStemming()) {
            optimized = applyStemming(optimized, analysis.getLanguage());
        }
        
        // 3. 同義詞擴展
        if (analysis.canExpandSynonyms()) {
            optimized = expandSynonyms(optimized);
        }
        
        // 4. 查詢重寫
        if (analysis.needsRewriting()) {
            optimized = rewriteQuery(optimized, analysis);
        }
        
        return optimized;
    }
    
    /**
     * 決定搜尋策略
     */
    private SearchStrategy determineSearchStrategy(QueryAnalysisResult analysis) {
        if (analysis.getQueryComplexity() == QueryComplexity.HIGH) {
            return SearchStrategy.HYBRID_SEARCH;
        } else if (analysis.hasKeywords()) {
            return SearchStrategy.KEYWORD_SEARCH;
        } else {
            return SearchStrategy.SEMANTIC_SEARCH;
        }
    }
    
    /**
     * 執行優化查詢
     */
    private QueryResult executeOptimizedQuery(OptimizedQuery query) {
        return switch (query.getSearchStrategy()) {
            case SEMANTIC_SEARCH -> executeSemanticSearch(query);
            case KEYWORD_SEARCH -> executeKeywordSearch(query);
            case HYBRID_SEARCH -> executeHybridSearch(query);
        };
    }
    
    /**
     * 執行語義搜尋
     */
    private QueryResult executeSemanticSearch(OptimizedQuery query) {
        // 使用 Spring AI VectorStore 進行向量相似性搜尋
        SearchRequest searchRequest = SearchRequest.builder()
            .query(query.getOptimizedQuery())
            .topK(query.getResultLimit())
            .similarityThreshold(query.getSimilarityThreshold())
            .filterExpression(query.getFilterExpression())
            .build();
            
        List<Document> documents = vectorStore.similaritySearch(searchRequest);
        
        return QueryResult.builder()
            .documents(documents)
            .searchStrategy(SearchStrategy.SEMANTIC_SEARCH)
            .executionTimeMs(System.currentTimeMillis())
            .build();
    }
    
    /**
     * 執行混合搜尋
     */
    private QueryResult executeHybridSearch(OptimizedQuery query) {
        // 並行執行語義搜尋和關鍵字搜尋
        CompletableFuture<List<Document>> semanticFuture = CompletableFuture
            .supplyAsync(() -> executeSemanticSearch(query).getDocuments());
        
        CompletableFuture<List<Document>> keywordFuture = CompletableFuture
            .supplyAsync(() -> executeKeywordSearch(query).getDocuments());
        
        try {
            List<Document> semanticResults = semanticFuture.get(5, TimeUnit.SECONDS);
            List<Document> keywordResults = keywordFuture.get(5, TimeUnit.SECONDS);
            
            // 結果融合和重新排序
            List<Document> mergedResults = mergeAndRerankResults(
                semanticResults, keywordResults, query);
            
            return QueryResult.builder()
                .documents(mergedResults)
                .searchStrategy(SearchStrategy.HYBRID_SEARCH)
                .executionTimeMs(System.currentTimeMillis())
                .build();
                
        } catch (Exception e) {
            log.warn("Hybrid search failed, falling back to semantic search", e);
            return executeSemanticSearch(query);
        }
    }
    
    /**
     * 結果融合和重新排序
     */
    private List<Document> mergeAndRerankResults(List<Document> semanticResults,
                                               List<Document> keywordResults,
                                               OptimizedQuery query) {
        
        Map<String, Document> documentMap = new HashMap<>();
        Map<String, Double> scoreMap = new HashMap<>();
        
        // 語義搜尋結果權重
        double semanticWeight = 0.7;
        for (int i = 0; i < semanticResults.size(); i++) {
            Document doc = semanticResults.get(i);
            String docId = doc.getId();
            double score = semanticWeight * (1.0 - (double) i / semanticResults.size());
            
            documentMap.put(docId, doc);
            scoreMap.put(docId, score);
        }
        
        // 關鍵字搜尋結果權重
        double keywordWeight = 0.3;
        for (int i = 0; i < keywordResults.size(); i++) {
            Document doc = keywordResults.get(i);
            String docId = doc.getId();
            double score = keywordWeight * (1.0 - (double) i / keywordResults.size());
            
            if (scoreMap.containsKey(docId)) {
                scoreMap.put(docId, scoreMap.get(docId) + score);
            } else {
                documentMap.put(docId, doc);
                scoreMap.put(docId, score);
            }
        }
        
        // 按分數排序
        return scoreMap.entrySet().stream()
            .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
            .limit(query.getResultLimit())
            .map(entry -> documentMap.get(entry.getKey()))
            .collect(Collectors.toList());
    }
    
    /**
     * 執行關鍵字搜尋
     */
    private QueryResult executeKeywordSearch(OptimizedQuery query) {
        // 對於關鍵字搜尋，可以使用較低的相似度閾值
        SearchRequest searchRequest = SearchRequest.builder()
            .query(query.getOptimizedQuery())
            .topK(query.getResultLimit())
            .similarityThreshold(0.6) // 關鍵字搜尋使用較低閾值
            .filterExpression(query.getFilterExpression())
            .build();
            
        List<Document> documents = vectorStore.similaritySearch(searchRequest);
        
        return QueryResult.builder()
            .documents(documents)
            .searchStrategy(SearchStrategy.KEYWORD_SEARCH)
            .executionTimeMs(System.currentTimeMillis())
            .build();
    }
    
    // 查詢分析和處理輔助方法
    private String removeStopWords(String text, String language) {
        // 實現停用詞移除邏輯，這裡簡化處理
        return text;
    }
    
    private String applyStemming(String text, String language) {
        // 實現詞幹提取邏輯，這裡簡化處理
        return text;
    }
    
    private String expandSynonyms(String text) {
        // 實現同義詞擴展邏輯，這裡簡化處理
        return text;
    }
    
    private String rewriteQuery(String text, QueryAnalysisResult analysis) {
        // 實現查詢重寫邏輯，這裡簡化處理
        return text;
    }
    
    /**
     * 優化過濾條件
     */
    private Filter.Expression optimizeFilters(Map<String, Object> filters, QueryAnalysisResult analysis) {
        if (filters == null || filters.isEmpty()) {
            return null;
        }
        
        // 使用 Spring AI Filter API 構建過濾表達式
        // 注意：實際的 Filter.ExpressionBuilder 可能有不同的 API
        // 這裡提供一個示例結構
        try {
            List<Filter.Expression> expressions = new ArrayList<>();
            
            filters.forEach((key, value) -> {
                if (value instanceof String) {
                    expressions.add(Filter.Expression.eq(key, value));
                } else if (value instanceof List<?> list) {
                    expressions.add(Filter.Expression.in(key, list));
                }
            });
            
            if (expressions.isEmpty()) {
                return null;
            }
            
            // 如果有多個條件，使用 AND 連接
            Filter.Expression result = expressions.get(0);
            for (int i = 1; i < expressions.size(); i++) {
                result = Filter.Expression.and(result, expressions.get(i));
            }
            
            return result;
        } catch (Exception e) {
            log.warn("Failed to build filter expression", e);
            return null;
        }
    }
    
    private int optimizeResultLimit(Integer limit, QueryAnalysisResult analysis) {
        if (limit == null) {
            return SearchRequest.DEFAULT_TOP_K;
        }
        
        // 根據查詢複雜度調整結果數量
        return switch (analysis.getQueryComplexity()) {
            case HIGH -> Math.min(limit, 20);
            case MEDIUM -> Math.min(limit, 10);
            case LOW -> Math.min(limit, 5);
        };
    }
    
    private double optimizeSimilarityThreshold(QueryAnalysisResult analysis) {
        // 根據查詢特性調整相似度閾值
        return switch (analysis.getQueryComplexity()) {
            case HIGH -> 0.75;
            case MEDIUM -> 0.7;
            case LOW -> 0.65;
        };
    }
}

/**
 * 查詢優化相關資料模型
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
class OptimizedQuery {
    private String originalQuery;
    private String optimizedQuery;
    private SearchStrategy searchStrategy;
    private Filter.Expression filterExpression;
    private int resultLimit;
    private double similarityThreshold;
}

@Data
@Builder
@NoArgsConstructor 
@AllArgsConstructor
class QueryRequest {
    private String queryId;
    private String query;
    private Map<String, Object> filters;
    private Integer limit;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
class QueryResult {
    private List<Document> documents;
    private SearchStrategy searchStrategy;
    private long executionTimeMs;
}

enum SearchStrategy {
    SEMANTIC_SEARCH,
    KEYWORD_SEARCH,
    HYBRID_SEARCH
}

enum QueryComplexity {
    LOW, MEDIUM, HIGH
}

@Data
@Builder
class QueryAnalysisResult {
    private QueryComplexity queryComplexity;
    private String language;
    private boolean hasStopWords;
    private boolean needsStemming;
    private boolean canExpandSynonyms;
    private boolean needsRewriting;
    private boolean hasKeywords;
}

/**
 * 快取管理服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RAGCacheService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final CacheMetrics cacheMetrics;
    
    private static final String QUERY_CACHE_PREFIX = "rag:query:";
    private static final String VECTOR_CACHE_PREFIX = "rag:vector:";
    private static final Duration DEFAULT_TTL = Duration.ofHours(1);
    
    /**
     * 快取查詢結果
     */
    public void cacheQueryResult(String queryHash, QueryResult result) {
        try {
            String cacheKey = QUERY_CACHE_PREFIX + queryHash;
            
            // 序列化結果
            CachedQueryResult cachedResult = CachedQueryResult.builder()
                .result(result)
                .cachedAt(LocalDateTime.now())
                .ttl(DEFAULT_TTL)
                .build();
            
            redisTemplate.opsForValue().set(cacheKey, cachedResult, DEFAULT_TTL);
            cacheMetrics.recordCacheWrite("query");
            
            log.debug("Cached query result for hash: {}", queryHash);
            
        } catch (Exception e) {
            log.warn("Failed to cache query result", e);
            cacheMetrics.recordCacheError("query", "write");
        }
    }
    
    /**
     * 取得快取的查詢結果
     */
    public QueryResult getCachedQueryResult(String queryHash) {
        try {
            String cacheKey = QUERY_CACHE_PREFIX + queryHash;
            
            CachedQueryResult cachedResult = (CachedQueryResult) 
                redisTemplate.opsForValue().get(cacheKey);
            
            if (cachedResult != null) {
                cacheMetrics.recordCacheHit("query");
                return cachedResult.getResult();
            } else {
                cacheMetrics.recordCacheMiss("query");
                return null;
            }
            
        } catch (Exception e) {
            log.warn("Failed to get cached query result", e);
            cacheMetrics.recordCacheError("query", "read");
            return null;
        }
    }
    
    /**
     * 快取向量嵌入
     */
    public void cacheVectorEmbedding(String textHash, float[] embedding) {
        try {
            String cacheKey = VECTOR_CACHE_PREFIX + textHash;
            
            CachedVector cachedVector = CachedVector.builder()
                .embedding(embedding)
                .cachedAt(LocalDateTime.now())
                .build();
            
            redisTemplate.opsForValue().set(cacheKey, cachedVector, Duration.ofDays(7));
            cacheMetrics.recordCacheWrite("vector");
            
        } catch (Exception e) {
            log.warn("Failed to cache vector embedding", e);
            cacheMetrics.recordCacheError("vector", "write");
        }
    }
    
    /**
     * 預熱快取
     */
    @EventListener
    public void warmupCache(ApplicationReadyEvent event) {
        log.info("Starting cache warmup");
        
        CompletableFuture.runAsync(() -> {
            try {
                // 預載入熱門查詢
                loadPopularQueries();
                
                // 預載入常用向量
                loadCommonVectors();
                
                log.info("Cache warmup completed");
                
            } catch (Exception e) {
                log.error("Cache warmup failed", e);
            }
        });
    }
    
    private void loadPopularQueries() {
        // 從統計資料載入熱門查詢並預先快取
        // 實現省略...
    }
    
    private void loadCommonVectors() {
        // 預載入常用的向量嵌入
        // 實現省略...
    }
}
```

---

## 7.7.3 監控告警系統

### 系統監控服務

```java
/**
 * RAG 系統監控服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RAGMonitoringService {
    
    private final MeterRegistry meterRegistry;
    private final AlertManager alertManager;
    private final HealthIndicatorRegistry healthRegistry;
    
    // 效能指標
    private final Counter queryCounter;
    private final Timer queryTimer;
    private final Gauge activeConnectionsGauge;
    private final Counter errorCounter;
    
    @PostConstruct
    public void initializeMetrics() {
        // 初始化指標
        queryCounter = Counter.builder("rag.queries.total")
            .description("Total number of RAG queries")
            .register(meterRegistry);
        
        queryTimer = Timer.builder("rag.query.duration")
            .description("RAG query execution time")
            .register(meterRegistry);
        
        activeConnectionsGauge = Gauge.builder("rag.connections.active")
            .description("Active database connections")
            .register(meterRegistry, this, RAGMonitoringService::getActiveConnections);
        
        errorCounter = Counter.builder("rag.errors.total")
            .description("Total number of errors")
            .tag("type", "unknown")
            .register(meterRegistry);
    }
    
    /**
     * 記錄查詢指標
     */
    public void recordQuery(String queryType, Duration duration, boolean success) {
        queryCounter.increment(
            Tags.of(
                "type", queryType,
                "status", success ? "success" : "failure"
            )
        );
        
        queryTimer.record(duration);
        
        if (!success) {
            errorCounter.increment(Tags.of("type", "query_failure"));
        }
    }
    
    /**
     * 記錄系統錯誤
     */
    public void recordError(String errorType, String component, Exception exception) {
        errorCounter.increment(
            Tags.of(
                "type", errorType,
                "component", component,
                "exception", exception.getClass().getSimpleName()
            )
        );
        
        // 檢查是否需要觸發告警
        checkErrorThreshold(errorType, component);
    }
    
    /**
     * 系統健康檢查
     */
    @EventListener
    @Scheduled(fixedRate = 30000) // 每30秒檢查一次
    public void performHealthCheck() {
        try {
            SystemHealthStatus status = collectSystemHealth();
            
            // 更新健康狀態指標
            updateHealthMetrics(status);
            
            // 檢查告警條件
            checkAlertConditions(status);
            
        } catch (Exception e) {
            log.error("Health check failed", e);
            recordError("health_check", "monitoring", e);
        }
    }
    
    /**
     * 收集系統健康狀態
     */
    private SystemHealthStatus collectSystemHealth() {
        SystemHealthStatus.Builder builder = SystemHealthStatus.builder();
        
        // 檢查各個組件的健康狀態
        healthRegistry.getAll().forEach((name, indicator) -> {
            try {
                Health health = indicator.health();
                builder.componentHealth(name, health.getStatus() == Status.UP);
                
                // 記錄詳細指標
                if (health.getDetails() != null) {
                    health.getDetails().forEach((key, value) -> {
                        if (value instanceof Number) {
                            Gauge.builder("rag.health." + name + "." + key)
                                .register(meterRegistry, () -> ((Number) value).doubleValue());
                        }
                    });
                }
                
            } catch (Exception e) {
                log.warn("Health check failed for component: {}", name, e);
                builder.componentHealth(name, false);
            }
        });
        
        return builder.build();
    }
    
    /**
     * 檢查告警條件
     */
    private void checkAlertConditions(SystemHealthStatus status) {
        // 檢查錯誤率
        double errorRate = calculateErrorRate();
        if (errorRate > 0.05) { // 錯誤率超過5%
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.HIGH)
                .title("High Error Rate Detected")
                .message(String.format("Error rate is %.2f%%, exceeding threshold of 5%%", errorRate * 100))
                .component("rag-system")
                .build());
        }
        
        // 檢查回應時間
        double avgResponseTime = calculateAverageResponseTime();
        if (avgResponseTime > 5000) { // 平均回應時間超過5秒
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.MEDIUM)
                .title("High Response Time")
                .message(String.format("Average response time is %.2fms", avgResponseTime))
                .component("rag-system")
                .build());
        }
        
        // 檢查資源使用率
        checkResourceUsage();
    }
    
    /**
     * 檢查資源使用率
     */
    private void checkResourceUsage() {
        // CPU 使用率
        double cpuUsage = getCpuUsage();
        if (cpuUsage > 0.8) {
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.HIGH)
                .title("High CPU Usage")
                .message(String.format("CPU usage is %.1f%%", cpuUsage * 100))
                .component("system")
                .build());
        }
        
        // 記憶體使用率
        double memoryUsage = getMemoryUsage();
        if (memoryUsage > 0.85) {
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.HIGH)
                .title("High Memory Usage")
                .message(String.format("Memory usage is %.1f%%", memoryUsage * 100))
                .component("system")
                .build());
        }
        
        // 磁碟使用率
        double diskUsage = getDiskUsage();
        if (diskUsage > 0.9) {
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.CRITICAL)
                .title("Critical Disk Usage")
                .message(String.format("Disk usage is %.1f%%", diskUsage * 100))
                .component("system")
                .build());
        }
    }
    
    // 輔助方法
    private double getActiveConnections() {
        // 實現取得活躍連接數的邏輯
        return 0.0;
    }
    
    private double calculateErrorRate() {
        // 計算錯誤率
        return 0.0;
    }
    
    private double calculateAverageResponseTime() {
        // 計算平均回應時間
        return 0.0;
    }
    
    private double getCpuUsage() {
        // 取得 CPU 使用率
        return 0.0;
    }
    
    private double getMemoryUsage() {
        // 取得記憶體使用率
        return 0.0;
    }
    
    private double getDiskUsage() {
        // 取得磁碟使用率
        return 0.0;
    }
}

/**
 * 告警管理器
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AlertManager {
    
    private final NotificationService notificationService;
    private final AlertRepository alertRepository;
    
    /**
     * 發送告警
     */
    public void sendAlert(Alert alert) {
        try {
            // 1. 檢查告警抑制規則
            if (isAlertSuppressed(alert)) {
                log.debug("Alert suppressed: {}", alert.getTitle());
                return;
            }
            
            // 2. 儲存告警記錄
            alertRepository.save(alert);
            
            // 3. 發送通知
            sendNotifications(alert);
            
            log.info("Alert sent: {} - {}", alert.getSeverity(), alert.getTitle());
            
        } catch (Exception e) {
            log.error("Failed to send alert", e);
        }
    }
    
    /**
     * 發送通知
     */
    private void sendNotifications(Alert alert) {
        // 根據嚴重程度決定通知方式
        switch (alert.getSeverity()) {
            case CRITICAL:
                // 關鍵告警：電話 + 簡訊 + 郵件 + Slack
                notificationService.sendPhoneCall(alert);
                notificationService.sendSMS(alert);
                notificationService.sendEmail(alert);
                notificationService.sendSlack(alert);
                break;
                
            case HIGH:
                // 高級告警：簡訊 + 郵件 + Slack
                notificationService.sendSMS(alert);
                notificationService.sendEmail(alert);
                notificationService.sendSlack(alert);
                break;
                
            case MEDIUM:
                // 中級告警：郵件 + Slack
                notificationService.sendEmail(alert);
                notificationService.sendSlack(alert);
                break;
                
            case LOW:
                // 低級告警：僅 Slack
                notificationService.sendSlack(alert);
                break;
        }
    }
    
    /**
     * 檢查告警是否被抑制
     */
    private boolean isAlertSuppressed(Alert alert) {
        // 檢查相同告警在短時間內是否已經發送過
        LocalDateTime suppressionWindow = LocalDateTime.now().minusMinutes(15);
        
        return alertRepository.existsByTitleAndComponentAndCreatedAtAfter(
            alert.getTitle(), 
            alert.getComponent(), 
            suppressionWindow
        );
    }
}
```

---

## 📝 本章重點回顧

1. **生產級部署**：實現了容器化和 Kubernetes 部署策略
2. **效能優化**：建立了查詢優化和快取管理機制
3. **監控告警**：實現了全方位的系統監控和智能告警
4. **故障處理**：建立了故障診斷和快速恢復機制
5. **持續改進**：實現了效能分析和優化的持續改進

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **容器化部署** | ⭐⭐⭐ | 中 | 部署效率 |
| **效能優化** | ⭐⭐⭐ | 高 | 使用者體驗 |
| **監控告警** | ⭐⭐⭐ | 中 | 系統穩定性 |
| **故障恢復** | ⭐⭐ | 高 | 業務連續性 |
| **持續改進** | ⭐⭐ | 中 | 長期維護 |

### 最佳實踐建議

1. **分階段部署**：採用藍綠部署或滾動更新策略
2. **效能監控**：建立完整的效能基準和監控體系
3. **自動化運維**：實現自動化的部署、監控和恢復
4. **容量規劃**：根據業務增長進行合理的容量規劃
5. **災難備援**：建立完整的災難恢復和業務連續性計劃

### 第七章完整總結

第七章「RAG 系統建構」完整涵蓋了從基礎概念到生產部署的全過程：

- **7.1 RAG流程詳解**：建立了 RAG 的理論基礎和系統架構
- **7.2 內容向量化**：掌握了文本向量化的核心技術
- **7.3 ETL(上)-知識來源**：實現了多樣化的資料提取能力
- **7.4 ETL(中)-進階文件**：處理了複雜文件格式的提取
- **7.5 ETL(下)-資料優化**：建立了資料品質保證機制
- **7.6 企業資料來源**：整合了企業級的資料管理能力
- **7.7 最後一哩路**：完成了生產級的部署和運維

通過第七章的學習，讀者已經具備了建構完整企業級 RAG 系統的能力！

---

**參考資料：**
- [Docker Documentation](https://docs.docker.com/)
- [Kubernetes Documentation](https://kubernetes.io/docs/)
- [Prometheus Monitoring](https://prometheus.io/docs/)
- [Grafana Dashboards](https://grafana.com/docs/)
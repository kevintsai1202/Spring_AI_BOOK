# 7.7 RAG çš„æœ€å¾Œä¸€å“©è·¯

> **æœ¬ç« é‡é»**ï¼šå®Œæˆ RAG ç³»çµ±çš„æœ€å¾Œéƒ¨ç½²å’Œå„ªåŒ–å·¥ä½œï¼ŒæŒæ¡ç³»çµ±éƒ¨ç½²é‹ç¶­ã€æ•ˆèƒ½èª¿æ ¡ã€ç›£æ§å‘Šè­¦å’Œæ•…éšœæ’é™¤ï¼Œç¢ºä¿ RAG ç³»çµ±åœ¨ç”Ÿç”¢ç’°å¢ƒä¸­ç©©å®šé«˜æ•ˆé‹è¡Œã€‚

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬ç« å­¸ç¿’å¾Œï¼Œæ‚¨å°‡èƒ½å¤ ï¼š

- ğŸ¯ **éƒ¨ç½²ç”Ÿç”¢ç´š RAG ç³»çµ±**ï¼šæŒæ¡å®¹å™¨åŒ–éƒ¨ç½²å’Œé›²ç«¯éƒ¨ç½²ç­–ç•¥
- ğŸ¯ **å„ªåŒ–ç³»çµ±æ•ˆèƒ½**ï¼šå¯¦ç¾æŸ¥è©¢å„ªåŒ–ã€å¿«å–ç­–ç•¥å’Œè³‡æºèª¿æ ¡
- ğŸ¯ **å»ºç«‹ç›£æ§å‘Šè­¦**ï¼šå¯¦ç¾å…¨æ–¹ä½çš„ç³»çµ±ç›£æ§å’Œæ™ºèƒ½å‘Šè­¦
- ğŸ¯ **è™•ç†æ•…éšœæ¢å¾©**ï¼šæŒæ¡æ•…éšœè¨ºæ–·ã€å¿«é€Ÿæ¢å¾©å’Œç½é›£å‚™æ´
- ğŸ¯ **æŒçºŒæ”¹é€²å„ªåŒ–**ï¼šå»ºç«‹æ•ˆèƒ½åˆ†æå’Œç³»çµ±å„ªåŒ–çš„æŒçºŒæ”¹é€²æ©Ÿåˆ¶

---

## 7.7.1 ç”Ÿç”¢ç´šéƒ¨ç½²ç­–ç•¥

### å®¹å™¨åŒ–éƒ¨ç½²æ¶æ§‹

**Docker å®¹å™¨åŒ–éƒ¨ç½²**ï¼š

```dockerfile
# RAG Application Dockerfile
FROM openjdk:21-jdk-slim

# è¨­å®šå·¥ä½œç›®éŒ„
WORKDIR /app

# è¤‡è£½æ‡‰ç”¨ç¨‹å¼
COPY target/rag-application.jar app.jar
COPY config/ config/
COPY scripts/ scripts/

# å®‰è£å¿…è¦å·¥å…·
RUN apt-get update && apt-get install -y \
    curl \
    jq \
    && rm -rf /var/lib/apt/lists/*

# å»ºç«‹é root ä½¿ç”¨è€…
RUN groupadd -r raguser && useradd -r -g raguser raguser
RUN chown -R raguser:raguser /app
USER raguser

# å¥åº·æª¢æŸ¥
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# æš´éœ²ç«¯å£
EXPOSE 8080

# å•Ÿå‹•æ‡‰ç”¨ç¨‹å¼
ENTRYPOINT ["java", "-jar", "-Dspring.profiles.active=prod", "app.jar"]
```

### Docker Compose ç·¨æ’

```yaml
# docker-compose.yml
version: '3.8'

services:
  # RAG æ‡‰ç”¨æœå‹™
  rag-app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/ragdb
      - SPRING_AI_VECTORSTORE_NEO4J_URI=bolt://neo4j:7687
      - SPRING_AI_VECTORSTORE_NEO4J_USERNAME=neo4j
      - SPRING_AI_VECTORSTORE_NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - SPRING_AI_OPENAI_API_KEY=${OPENAI_API_KEY}
      - SPRING_AI_OPENAI_CHAT_MODEL=gpt-4o
      - SPRING_AI_OPENAI_EMBEDDING_MODEL=text-embedding-3-large
    depends_on:
      - postgres
      - neo4j
      - redis
    volumes:
      - ./logs:/app/logs
      - ./data:/app/data
    networks:
      - rag-network
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '1.0'
          memory: 2G

  # PostgreSQL è³‡æ–™åº«
  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=ragdb
      - POSTGRES_USER=raguser
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    networks:
      - rag-network
    restart: unless-stopped

  # Neo4j å‘é‡è³‡æ–™åº«
  neo4j:
    image: neo4j:5.15-community
    environment:
      - NEO4J_AUTH=neo4j/${NEO4J_PASSWORD}
      - NEO4J_PLUGINS=["apoc"]
      - NEO4J_dbms_security_procedures_unrestricted=apoc.*
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs
    ports:
      - "7474:7474"
      - "7687:7687"
    networks:
      - rag-network
    restart: unless-stopped

  # Redis å¿«å–
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - rag-network
    restart: unless-stopped

  # Nginx åå‘ä»£ç†
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - rag-app
    networks:
      - rag-network
    restart: unless-stopped

  # Prometheus ç›£æ§
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    networks:
      - rag-network
    restart: unless-stopped

  # Grafana è¦–è¦ºåŒ–
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards
      - ./grafana/datasources:/etc/grafana/provisioning/datasources
    networks:
      - rag-network
    restart: unless-stopped

volumes:
  postgres_data:
  neo4j_data:
  neo4j_logs:
  redis_data:
  prometheus_data:
  grafana_data:

networks:
  rag-network:
    driver: bridge
```

### Kubernetes éƒ¨ç½²é…ç½®

```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rag-application
  namespace: rag-system
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rag-application
  template:
    metadata:
      labels:
        app: rag-application
    spec:
      containers:
      - name: rag-app
        image: rag-application:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "k8s"
        - name: SPRING_DATASOURCE_URL
          valueFrom:
            secretKeyRef:
              name: rag-secrets
              key: database-url
        - name: SPRING_AI_OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: rag-secrets
              key: openai-api-key
        resources:
          requests:
            memory: "2Gi"
            cpu: "1000m"
          limits:
            memory: "4Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
        - name: logs-volume
          mountPath: /app/logs
      volumes:
      - name: config-volume
        configMap:
          name: rag-config
      - name: logs-volume
        persistentVolumeClaim:
          claimName: rag-logs-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: rag-service
  namespace: rag-system
spec:
  selector:
    app: rag-application
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: LoadBalancer
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: rag-ingress
  namespace: rag-system
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - rag.example.com
    secretName: rag-tls
  rules:
  - host: rag.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: rag-service
            port:
              number: 80
```

---

## 7.7.2 ç³»çµ±æ•ˆèƒ½å„ªåŒ–

### Spring AI ç›¸é—œä¾è³´é…ç½®

é¦–å…ˆéœ€è¦ç¢ºä¿é …ç›®ä¸­åŒ…å«æ­£ç¢ºçš„ Spring AI ä¾è³´ï¼š

```xml
<dependencies>
    <!-- Spring AI Core -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- OpenAI Chat Model -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Neo4j Vector Store -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-neo4j-store-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Spring Boot Actuator for monitoring -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    
    <!-- Micrometer for metrics -->
    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-registry-prometheus</artifactId>
    </dependency>
</dependencies>
```

### æŸ¥è©¢æ•ˆèƒ½å„ªåŒ–æœå‹™

```java
import org.springframework.ai.document.Document;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.ai.vectorstore.SearchRequest;
import org.springframework.ai.vectorstore.filter.Filter;
import org.springframework.stereotype.Service;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * RAG æŸ¥è©¢æ•ˆèƒ½å„ªåŒ–æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class QueryOptimizationService {
    
    private final VectorStore vectorStore;
    private final CacheManager cacheManager;
    private final QueryAnalyzer queryAnalyzer;
    private final PerformanceMetrics performanceMetrics;
    
    /**
     * å„ªåŒ–æŸ¥è©¢åŸ·è¡Œ
     */
    public QueryResult optimizeQuery(QueryRequest request) {
        long startTime = System.currentTimeMillis();
        
        try {
            // 1. æŸ¥è©¢åˆ†æå’Œé è™•ç†
            OptimizedQuery optimizedQuery = analyzeAndOptimizeQuery(request);
            
            // 2. å¿«å–æª¢æŸ¥
            QueryResult cachedResult = checkCache(optimizedQuery);
            if (cachedResult != null) {
                performanceMetrics.recordCacheHit(request.getQueryId());
                return cachedResult;
            }
            
            // 3. åŸ·è¡Œå„ªåŒ–æŸ¥è©¢
            QueryResult result = executeOptimizedQuery(optimizedQuery);
            
            // 4. çµæœå¿«å–
            cacheResult(optimizedQuery, result);
            
            // 5. è¨˜éŒ„æ•ˆèƒ½æŒ‡æ¨™
            long executionTime = System.currentTimeMillis() - startTime;
            performanceMetrics.recordQueryExecution(request.getQueryId(), executionTime);
            
            return result;
            
        } catch (Exception e) {
            log.error("Query optimization failed for: {}", request.getQueryId(), e);
            performanceMetrics.recordQueryError(request.getQueryId());
            throw new QueryOptimizationException("Query optimization failed", e);
        }
    }
    
    /**
     * åˆ†æå’Œå„ªåŒ–æŸ¥è©¢
     */
    private OptimizedQuery analyzeAndOptimizeQuery(QueryRequest request) {
        QueryAnalysisResult analysis = queryAnalyzer.analyze(request);
        
        return OptimizedQuery.builder()
            .originalQuery(request.getQuery())
            .optimizedQuery(optimizeQueryText(request.getQuery(), analysis))
            .searchStrategy(determineSearchStrategy(analysis))
            .filterExpression(optimizeFilters(request.getFilters(), analysis))
            .resultLimit(optimizeResultLimit(request.getLimit(), analysis))
            .similarityThreshold(optimizeSimilarityThreshold(analysis))
            .build();
    }
    
    /**
     * å„ªåŒ–æŸ¥è©¢æ–‡æœ¬
     */
    private String optimizeQueryText(String originalQuery, QueryAnalysisResult analysis) {
        String optimized = originalQuery;
        
        // 1. ç§»é™¤åœç”¨è©
        if (analysis.hasStopWords()) {
            optimized = removeStopWords(optimized, analysis.getLanguage());
        }
        
        // 2. è©å¹¹æå–
        if (analysis.needsStemming()) {
            optimized = applyStemming(optimized, analysis.getLanguage());
        }
        
        // 3. åŒç¾©è©æ“´å±•
        if (analysis.canExpandSynonyms()) {
            optimized = expandSynonyms(optimized);
        }
        
        // 4. æŸ¥è©¢é‡å¯«
        if (analysis.needsRewriting()) {
            optimized = rewriteQuery(optimized, analysis);
        }
        
        return optimized;
    }
    
    /**
     * æ±ºå®šæœå°‹ç­–ç•¥
     */
    private SearchStrategy determineSearchStrategy(QueryAnalysisResult analysis) {
        if (analysis.getQueryComplexity() == QueryComplexity.HIGH) {
            return SearchStrategy.HYBRID_SEARCH;
        } else if (analysis.hasKeywords()) {
            return SearchStrategy.KEYWORD_SEARCH;
        } else {
            return SearchStrategy.SEMANTIC_SEARCH;
        }
    }
    
    /**
     * åŸ·è¡Œå„ªåŒ–æŸ¥è©¢
     */
    private QueryResult executeOptimizedQuery(OptimizedQuery query) {
        return switch (query.getSearchStrategy()) {
            case SEMANTIC_SEARCH -> executeSemanticSearch(query);
            case KEYWORD_SEARCH -> executeKeywordSearch(query);
            case HYBRID_SEARCH -> executeHybridSearch(query);
        };
    }
    
    /**
     * åŸ·è¡Œèªç¾©æœå°‹
     */
    private QueryResult executeSemanticSearch(OptimizedQuery query) {
        // ä½¿ç”¨ Spring AI VectorStore é€²è¡Œå‘é‡ç›¸ä¼¼æ€§æœå°‹
        SearchRequest searchRequest = SearchRequest.builder()
            .query(query.getOptimizedQuery())
            .topK(query.getResultLimit())
            .similarityThreshold(query.getSimilarityThreshold())
            .filterExpression(query.getFilterExpression())
            .build();
            
        List<Document> documents = vectorStore.similaritySearch(searchRequest);
        
        return QueryResult.builder()
            .documents(documents)
            .searchStrategy(SearchStrategy.SEMANTIC_SEARCH)
            .executionTimeMs(System.currentTimeMillis())
            .build();
    }
    
    /**
     * åŸ·è¡Œæ··åˆæœå°‹
     */
    private QueryResult executeHybridSearch(OptimizedQuery query) {
        // ä¸¦è¡ŒåŸ·è¡Œèªç¾©æœå°‹å’Œé—œéµå­—æœå°‹
        CompletableFuture<List<Document>> semanticFuture = CompletableFuture
            .supplyAsync(() -> executeSemanticSearch(query).getDocuments());
        
        CompletableFuture<List<Document>> keywordFuture = CompletableFuture
            .supplyAsync(() -> executeKeywordSearch(query).getDocuments());
        
        try {
            List<Document> semanticResults = semanticFuture.get(5, TimeUnit.SECONDS);
            List<Document> keywordResults = keywordFuture.get(5, TimeUnit.SECONDS);
            
            // çµæœèåˆå’Œé‡æ–°æ’åº
            List<Document> mergedResults = mergeAndRerankResults(
                semanticResults, keywordResults, query);
            
            return QueryResult.builder()
                .documents(mergedResults)
                .searchStrategy(SearchStrategy.HYBRID_SEARCH)
                .executionTimeMs(System.currentTimeMillis())
                .build();
                
        } catch (Exception e) {
            log.warn("Hybrid search failed, falling back to semantic search", e);
            return executeSemanticSearch(query);
        }
    }
    
    /**
     * çµæœèåˆå’Œé‡æ–°æ’åº
     */
    private List<Document> mergeAndRerankResults(List<Document> semanticResults,
                                               List<Document> keywordResults,
                                               OptimizedQuery query) {
        
        Map<String, Document> documentMap = new HashMap<>();
        Map<String, Double> scoreMap = new HashMap<>();
        
        // èªç¾©æœå°‹çµæœæ¬Šé‡
        double semanticWeight = 0.7;
        for (int i = 0; i < semanticResults.size(); i++) {
            Document doc = semanticResults.get(i);
            String docId = doc.getId();
            double score = semanticWeight * (1.0 - (double) i / semanticResults.size());
            
            documentMap.put(docId, doc);
            scoreMap.put(docId, score);
        }
        
        // é—œéµå­—æœå°‹çµæœæ¬Šé‡
        double keywordWeight = 0.3;
        for (int i = 0; i < keywordResults.size(); i++) {
            Document doc = keywordResults.get(i);
            String docId = doc.getId();
            double score = keywordWeight * (1.0 - (double) i / keywordResults.size());
            
            if (scoreMap.containsKey(docId)) {
                scoreMap.put(docId, scoreMap.get(docId) + score);
            } else {
                documentMap.put(docId, doc);
                scoreMap.put(docId, score);
            }
        }
        
        // æŒ‰åˆ†æ•¸æ’åº
        return scoreMap.entrySet().stream()
            .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
            .limit(query.getResultLimit())
            .map(entry -> documentMap.get(entry.getKey()))
            .collect(Collectors.toList());
    }
    
    /**
     * åŸ·è¡Œé—œéµå­—æœå°‹
     */
    private QueryResult executeKeywordSearch(OptimizedQuery query) {
        // å°æ–¼é—œéµå­—æœå°‹ï¼Œå¯ä»¥ä½¿ç”¨è¼ƒä½çš„ç›¸ä¼¼åº¦é–¾å€¼
        SearchRequest searchRequest = SearchRequest.builder()
            .query(query.getOptimizedQuery())
            .topK(query.getResultLimit())
            .similarityThreshold(0.6) // é—œéµå­—æœå°‹ä½¿ç”¨è¼ƒä½é–¾å€¼
            .filterExpression(query.getFilterExpression())
            .build();
            
        List<Document> documents = vectorStore.similaritySearch(searchRequest);
        
        return QueryResult.builder()
            .documents(documents)
            .searchStrategy(SearchStrategy.KEYWORD_SEARCH)
            .executionTimeMs(System.currentTimeMillis())
            .build();
    }
    
    // æŸ¥è©¢åˆ†æå’Œè™•ç†è¼”åŠ©æ–¹æ³•
    private String removeStopWords(String text, String language) {
        // å¯¦ç¾åœç”¨è©ç§»é™¤é‚è¼¯ï¼Œé€™è£¡ç°¡åŒ–è™•ç†
        return text;
    }
    
    private String applyStemming(String text, String language) {
        // å¯¦ç¾è©å¹¹æå–é‚è¼¯ï¼Œé€™è£¡ç°¡åŒ–è™•ç†
        return text;
    }
    
    private String expandSynonyms(String text) {
        // å¯¦ç¾åŒç¾©è©æ“´å±•é‚è¼¯ï¼Œé€™è£¡ç°¡åŒ–è™•ç†
        return text;
    }
    
    private String rewriteQuery(String text, QueryAnalysisResult analysis) {
        // å¯¦ç¾æŸ¥è©¢é‡å¯«é‚è¼¯ï¼Œé€™è£¡ç°¡åŒ–è™•ç†
        return text;
    }
    
    /**
     * å„ªåŒ–éæ¿¾æ¢ä»¶
     */
    private Filter.Expression optimizeFilters(Map<String, Object> filters, QueryAnalysisResult analysis) {
        if (filters == null || filters.isEmpty()) {
            return null;
        }
        
        // ä½¿ç”¨ Spring AI Filter API æ§‹å»ºéæ¿¾è¡¨é”å¼
        // æ³¨æ„ï¼šå¯¦éš›çš„ Filter.ExpressionBuilder å¯èƒ½æœ‰ä¸åŒçš„ API
        // é€™è£¡æä¾›ä¸€å€‹ç¤ºä¾‹çµæ§‹
        try {
            List<Filter.Expression> expressions = new ArrayList<>();
            
            filters.forEach((key, value) -> {
                if (value instanceof String) {
                    expressions.add(Filter.Expression.eq(key, value));
                } else if (value instanceof List<?> list) {
                    expressions.add(Filter.Expression.in(key, list));
                }
            });
            
            if (expressions.isEmpty()) {
                return null;
            }
            
            // å¦‚æœæœ‰å¤šå€‹æ¢ä»¶ï¼Œä½¿ç”¨ AND é€£æ¥
            Filter.Expression result = expressions.get(0);
            for (int i = 1; i < expressions.size(); i++) {
                result = Filter.Expression.and(result, expressions.get(i));
            }
            
            return result;
        } catch (Exception e) {
            log.warn("Failed to build filter expression", e);
            return null;
        }
    }
    
    private int optimizeResultLimit(Integer limit, QueryAnalysisResult analysis) {
        if (limit == null) {
            return SearchRequest.DEFAULT_TOP_K;
        }
        
        // æ ¹æ“šæŸ¥è©¢è¤‡é›œåº¦èª¿æ•´çµæœæ•¸é‡
        return switch (analysis.getQueryComplexity()) {
            case HIGH -> Math.min(limit, 20);
            case MEDIUM -> Math.min(limit, 10);
            case LOW -> Math.min(limit, 5);
        };
    }
    
    private double optimizeSimilarityThreshold(QueryAnalysisResult analysis) {
        // æ ¹æ“šæŸ¥è©¢ç‰¹æ€§èª¿æ•´ç›¸ä¼¼åº¦é–¾å€¼
        return switch (analysis.getQueryComplexity()) {
            case HIGH -> 0.75;
            case MEDIUM -> 0.7;
            case LOW -> 0.65;
        };
    }
}

/**
 * æŸ¥è©¢å„ªåŒ–ç›¸é—œè³‡æ–™æ¨¡å‹
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
class OptimizedQuery {
    private String originalQuery;
    private String optimizedQuery;
    private SearchStrategy searchStrategy;
    private Filter.Expression filterExpression;
    private int resultLimit;
    private double similarityThreshold;
}

@Data
@Builder
@NoArgsConstructor 
@AllArgsConstructor
class QueryRequest {
    private String queryId;
    private String query;
    private Map<String, Object> filters;
    private Integer limit;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
class QueryResult {
    private List<Document> documents;
    private SearchStrategy searchStrategy;
    private long executionTimeMs;
}

enum SearchStrategy {
    SEMANTIC_SEARCH,
    KEYWORD_SEARCH,
    HYBRID_SEARCH
}

enum QueryComplexity {
    LOW, MEDIUM, HIGH
}

@Data
@Builder
class QueryAnalysisResult {
    private QueryComplexity queryComplexity;
    private String language;
    private boolean hasStopWords;
    private boolean needsStemming;
    private boolean canExpandSynonyms;
    private boolean needsRewriting;
    private boolean hasKeywords;
}

/**
 * å¿«å–ç®¡ç†æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RAGCacheService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final CacheMetrics cacheMetrics;
    
    private static final String QUERY_CACHE_PREFIX = "rag:query:";
    private static final String VECTOR_CACHE_PREFIX = "rag:vector:";
    private static final Duration DEFAULT_TTL = Duration.ofHours(1);
    
    /**
     * å¿«å–æŸ¥è©¢çµæœ
     */
    public void cacheQueryResult(String queryHash, QueryResult result) {
        try {
            String cacheKey = QUERY_CACHE_PREFIX + queryHash;
            
            // åºåˆ—åŒ–çµæœ
            CachedQueryResult cachedResult = CachedQueryResult.builder()
                .result(result)
                .cachedAt(LocalDateTime.now())
                .ttl(DEFAULT_TTL)
                .build();
            
            redisTemplate.opsForValue().set(cacheKey, cachedResult, DEFAULT_TTL);
            cacheMetrics.recordCacheWrite("query");
            
            log.debug("Cached query result for hash: {}", queryHash);
            
        } catch (Exception e) {
            log.warn("Failed to cache query result", e);
            cacheMetrics.recordCacheError("query", "write");
        }
    }
    
    /**
     * å–å¾—å¿«å–çš„æŸ¥è©¢çµæœ
     */
    public QueryResult getCachedQueryResult(String queryHash) {
        try {
            String cacheKey = QUERY_CACHE_PREFIX + queryHash;
            
            CachedQueryResult cachedResult = (CachedQueryResult) 
                redisTemplate.opsForValue().get(cacheKey);
            
            if (cachedResult != null) {
                cacheMetrics.recordCacheHit("query");
                return cachedResult.getResult();
            } else {
                cacheMetrics.recordCacheMiss("query");
                return null;
            }
            
        } catch (Exception e) {
            log.warn("Failed to get cached query result", e);
            cacheMetrics.recordCacheError("query", "read");
            return null;
        }
    }
    
    /**
     * å¿«å–å‘é‡åµŒå…¥
     */
    public void cacheVectorEmbedding(String textHash, float[] embedding) {
        try {
            String cacheKey = VECTOR_CACHE_PREFIX + textHash;
            
            CachedVector cachedVector = CachedVector.builder()
                .embedding(embedding)
                .cachedAt(LocalDateTime.now())
                .build();
            
            redisTemplate.opsForValue().set(cacheKey, cachedVector, Duration.ofDays(7));
            cacheMetrics.recordCacheWrite("vector");
            
        } catch (Exception e) {
            log.warn("Failed to cache vector embedding", e);
            cacheMetrics.recordCacheError("vector", "write");
        }
    }
    
    /**
     * é ç†±å¿«å–
     */
    @EventListener
    public void warmupCache(ApplicationReadyEvent event) {
        log.info("Starting cache warmup");
        
        CompletableFuture.runAsync(() -> {
            try {
                // é è¼‰å…¥ç†±é–€æŸ¥è©¢
                loadPopularQueries();
                
                // é è¼‰å…¥å¸¸ç”¨å‘é‡
                loadCommonVectors();
                
                log.info("Cache warmup completed");
                
            } catch (Exception e) {
                log.error("Cache warmup failed", e);
            }
        });
    }
    
    private void loadPopularQueries() {
        // å¾çµ±è¨ˆè³‡æ–™è¼‰å…¥ç†±é–€æŸ¥è©¢ä¸¦é å…ˆå¿«å–
        // å¯¦ç¾çœç•¥...
    }
    
    private void loadCommonVectors() {
        // é è¼‰å…¥å¸¸ç”¨çš„å‘é‡åµŒå…¥
        // å¯¦ç¾çœç•¥...
    }
}
```

---

## 7.7.3 ç›£æ§å‘Šè­¦ç³»çµ±

### ç³»çµ±ç›£æ§æœå‹™

```java
/**
 * RAG ç³»çµ±ç›£æ§æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RAGMonitoringService {
    
    private final MeterRegistry meterRegistry;
    private final AlertManager alertManager;
    private final HealthIndicatorRegistry healthRegistry;
    
    // æ•ˆèƒ½æŒ‡æ¨™
    private final Counter queryCounter;
    private final Timer queryTimer;
    private final Gauge activeConnectionsGauge;
    private final Counter errorCounter;
    
    @PostConstruct
    public void initializeMetrics() {
        // åˆå§‹åŒ–æŒ‡æ¨™
        queryCounter = Counter.builder("rag.queries.total")
            .description("Total number of RAG queries")
            .register(meterRegistry);
        
        queryTimer = Timer.builder("rag.query.duration")
            .description("RAG query execution time")
            .register(meterRegistry);
        
        activeConnectionsGauge = Gauge.builder("rag.connections.active")
            .description("Active database connections")
            .register(meterRegistry, this, RAGMonitoringService::getActiveConnections);
        
        errorCounter = Counter.builder("rag.errors.total")
            .description("Total number of errors")
            .tag("type", "unknown")
            .register(meterRegistry);
    }
    
    /**
     * è¨˜éŒ„æŸ¥è©¢æŒ‡æ¨™
     */
    public void recordQuery(String queryType, Duration duration, boolean success) {
        queryCounter.increment(
            Tags.of(
                "type", queryType,
                "status", success ? "success" : "failure"
            )
        );
        
        queryTimer.record(duration);
        
        if (!success) {
            errorCounter.increment(Tags.of("type", "query_failure"));
        }
    }
    
    /**
     * è¨˜éŒ„ç³»çµ±éŒ¯èª¤
     */
    public void recordError(String errorType, String component, Exception exception) {
        errorCounter.increment(
            Tags.of(
                "type", errorType,
                "component", component,
                "exception", exception.getClass().getSimpleName()
            )
        );
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦è§¸ç™¼å‘Šè­¦
        checkErrorThreshold(errorType, component);
    }
    
    /**
     * ç³»çµ±å¥åº·æª¢æŸ¥
     */
    @EventListener
    @Scheduled(fixedRate = 30000) // æ¯30ç§’æª¢æŸ¥ä¸€æ¬¡
    public void performHealthCheck() {
        try {
            SystemHealthStatus status = collectSystemHealth();
            
            // æ›´æ–°å¥åº·ç‹€æ…‹æŒ‡æ¨™
            updateHealthMetrics(status);
            
            // æª¢æŸ¥å‘Šè­¦æ¢ä»¶
            checkAlertConditions(status);
            
        } catch (Exception e) {
            log.error("Health check failed", e);
            recordError("health_check", "monitoring", e);
        }
    }
    
    /**
     * æ”¶é›†ç³»çµ±å¥åº·ç‹€æ…‹
     */
    private SystemHealthStatus collectSystemHealth() {
        SystemHealthStatus.Builder builder = SystemHealthStatus.builder();
        
        // æª¢æŸ¥å„å€‹çµ„ä»¶çš„å¥åº·ç‹€æ…‹
        healthRegistry.getAll().forEach((name, indicator) -> {
            try {
                Health health = indicator.health();
                builder.componentHealth(name, health.getStatus() == Status.UP);
                
                // è¨˜éŒ„è©³ç´°æŒ‡æ¨™
                if (health.getDetails() != null) {
                    health.getDetails().forEach((key, value) -> {
                        if (value instanceof Number) {
                            Gauge.builder("rag.health." + name + "." + key)
                                .register(meterRegistry, () -> ((Number) value).doubleValue());
                        }
                    });
                }
                
            } catch (Exception e) {
                log.warn("Health check failed for component: {}", name, e);
                builder.componentHealth(name, false);
            }
        });
        
        return builder.build();
    }
    
    /**
     * æª¢æŸ¥å‘Šè­¦æ¢ä»¶
     */
    private void checkAlertConditions(SystemHealthStatus status) {
        // æª¢æŸ¥éŒ¯èª¤ç‡
        double errorRate = calculateErrorRate();
        if (errorRate > 0.05) { // éŒ¯èª¤ç‡è¶…é5%
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.HIGH)
                .title("High Error Rate Detected")
                .message(String.format("Error rate is %.2f%%, exceeding threshold of 5%%", errorRate * 100))
                .component("rag-system")
                .build());
        }
        
        // æª¢æŸ¥å›æ‡‰æ™‚é–“
        double avgResponseTime = calculateAverageResponseTime();
        if (avgResponseTime > 5000) { // å¹³å‡å›æ‡‰æ™‚é–“è¶…é5ç§’
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.MEDIUM)
                .title("High Response Time")
                .message(String.format("Average response time is %.2fms", avgResponseTime))
                .component("rag-system")
                .build());
        }
        
        // æª¢æŸ¥è³‡æºä½¿ç”¨ç‡
        checkResourceUsage();
    }
    
    /**
     * æª¢æŸ¥è³‡æºä½¿ç”¨ç‡
     */
    private void checkResourceUsage() {
        // CPU ä½¿ç”¨ç‡
        double cpuUsage = getCpuUsage();
        if (cpuUsage > 0.8) {
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.HIGH)
                .title("High CPU Usage")
                .message(String.format("CPU usage is %.1f%%", cpuUsage * 100))
                .component("system")
                .build());
        }
        
        // è¨˜æ†¶é«”ä½¿ç”¨ç‡
        double memoryUsage = getMemoryUsage();
        if (memoryUsage > 0.85) {
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.HIGH)
                .title("High Memory Usage")
                .message(String.format("Memory usage is %.1f%%", memoryUsage * 100))
                .component("system")
                .build());
        }
        
        // ç£ç¢Ÿä½¿ç”¨ç‡
        double diskUsage = getDiskUsage();
        if (diskUsage > 0.9) {
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.CRITICAL)
                .title("Critical Disk Usage")
                .message(String.format("Disk usage is %.1f%%", diskUsage * 100))
                .component("system")
                .build());
        }
    }
    
    // è¼”åŠ©æ–¹æ³•
    private double getActiveConnections() {
        // å¯¦ç¾å–å¾—æ´»èºé€£æ¥æ•¸çš„é‚è¼¯
        return 0.0;
    }
    
    private double calculateErrorRate() {
        // è¨ˆç®—éŒ¯èª¤ç‡
        return 0.0;
    }
    
    private double calculateAverageResponseTime() {
        // è¨ˆç®—å¹³å‡å›æ‡‰æ™‚é–“
        return 0.0;
    }
    
    private double getCpuUsage() {
        // å–å¾— CPU ä½¿ç”¨ç‡
        return 0.0;
    }
    
    private double getMemoryUsage() {
        // å–å¾—è¨˜æ†¶é«”ä½¿ç”¨ç‡
        return 0.0;
    }
    
    private double getDiskUsage() {
        // å–å¾—ç£ç¢Ÿä½¿ç”¨ç‡
        return 0.0;
    }
}

/**
 * å‘Šè­¦ç®¡ç†å™¨
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AlertManager {
    
    private final NotificationService notificationService;
    private final AlertRepository alertRepository;
    
    /**
     * ç™¼é€å‘Šè­¦
     */
    public void sendAlert(Alert alert) {
        try {
            // 1. æª¢æŸ¥å‘Šè­¦æŠ‘åˆ¶è¦å‰‡
            if (isAlertSuppressed(alert)) {
                log.debug("Alert suppressed: {}", alert.getTitle());
                return;
            }
            
            // 2. å„²å­˜å‘Šè­¦è¨˜éŒ„
            alertRepository.save(alert);
            
            // 3. ç™¼é€é€šçŸ¥
            sendNotifications(alert);
            
            log.info("Alert sent: {} - {}", alert.getSeverity(), alert.getTitle());
            
        } catch (Exception e) {
            log.error("Failed to send alert", e);
        }
    }
    
    /**
     * ç™¼é€é€šçŸ¥
     */
    private void sendNotifications(Alert alert) {
        // æ ¹æ“šåš´é‡ç¨‹åº¦æ±ºå®šé€šçŸ¥æ–¹å¼
        switch (alert.getSeverity()) {
            case CRITICAL:
                // é—œéµå‘Šè­¦ï¼šé›»è©± + ç°¡è¨Š + éƒµä»¶ + Slack
                notificationService.sendPhoneCall(alert);
                notificationService.sendSMS(alert);
                notificationService.sendEmail(alert);
                notificationService.sendSlack(alert);
                break;
                
            case HIGH:
                // é«˜ç´šå‘Šè­¦ï¼šç°¡è¨Š + éƒµä»¶ + Slack
                notificationService.sendSMS(alert);
                notificationService.sendEmail(alert);
                notificationService.sendSlack(alert);
                break;
                
            case MEDIUM:
                // ä¸­ç´šå‘Šè­¦ï¼šéƒµä»¶ + Slack
                notificationService.sendEmail(alert);
                notificationService.sendSlack(alert);
                break;
                
            case LOW:
                // ä½ç´šå‘Šè­¦ï¼šåƒ… Slack
                notificationService.sendSlack(alert);
                break;
        }
    }
    
    /**
     * æª¢æŸ¥å‘Šè­¦æ˜¯å¦è¢«æŠ‘åˆ¶
     */
    private boolean isAlertSuppressed(Alert alert) {
        // æª¢æŸ¥ç›¸åŒå‘Šè­¦åœ¨çŸ­æ™‚é–“å…§æ˜¯å¦å·²ç¶“ç™¼é€é
        LocalDateTime suppressionWindow = LocalDateTime.now().minusMinutes(15);
        
        return alertRepository.existsByTitleAndComponentAndCreatedAtAfter(
            alert.getTitle(), 
            alert.getComponent(), 
            suppressionWindow
        );
    }
}
```

---

## ğŸ“ æœ¬ç« é‡é»å›é¡§

1. **ç”Ÿç”¢ç´šéƒ¨ç½²**ï¼šå¯¦ç¾äº†å®¹å™¨åŒ–å’Œ Kubernetes éƒ¨ç½²ç­–ç•¥
2. **æ•ˆèƒ½å„ªåŒ–**ï¼šå»ºç«‹äº†æŸ¥è©¢å„ªåŒ–å’Œå¿«å–ç®¡ç†æ©Ÿåˆ¶
3. **ç›£æ§å‘Šè­¦**ï¼šå¯¦ç¾äº†å…¨æ–¹ä½çš„ç³»çµ±ç›£æ§å’Œæ™ºèƒ½å‘Šè­¦
4. **æ•…éšœè™•ç†**ï¼šå»ºç«‹äº†æ•…éšœè¨ºæ–·å’Œå¿«é€Ÿæ¢å¾©æ©Ÿåˆ¶
5. **æŒçºŒæ”¹é€²**ï¼šå¯¦ç¾äº†æ•ˆèƒ½åˆ†æå’Œå„ªåŒ–çš„æŒçºŒæ”¹é€²

### æŠ€è¡“è¦é»ç¸½çµ

| æŠ€è¡“é» | é‡è¦æ€§ | å¯¦ç¾é›£åº¦ | ä¼æ¥­åƒ¹å€¼ |
|--------|--------|----------|----------|
| **å®¹å™¨åŒ–éƒ¨ç½²** | â­â­â­ | ä¸­ | éƒ¨ç½²æ•ˆç‡ |
| **æ•ˆèƒ½å„ªåŒ–** | â­â­â­ | é«˜ | ä½¿ç”¨è€…é«”é©— |
| **ç›£æ§å‘Šè­¦** | â­â­â­ | ä¸­ | ç³»çµ±ç©©å®šæ€§ |
| **æ•…éšœæ¢å¾©** | â­â­ | é«˜ | æ¥­å‹™é€£çºŒæ€§ |
| **æŒçºŒæ”¹é€²** | â­â­ | ä¸­ | é•·æœŸç¶­è­· |

### æœ€ä½³å¯¦è¸å»ºè­°

1. **åˆ†éšæ®µéƒ¨ç½²**ï¼šæ¡ç”¨è—ç¶ éƒ¨ç½²æˆ–æ»¾å‹•æ›´æ–°ç­–ç•¥
2. **æ•ˆèƒ½ç›£æ§**ï¼šå»ºç«‹å®Œæ•´çš„æ•ˆèƒ½åŸºæº–å’Œç›£æ§é«”ç³»
3. **è‡ªå‹•åŒ–é‹ç¶­**ï¼šå¯¦ç¾è‡ªå‹•åŒ–çš„éƒ¨ç½²ã€ç›£æ§å’Œæ¢å¾©
4. **å®¹é‡è¦åŠƒ**ï¼šæ ¹æ“šæ¥­å‹™å¢é•·é€²è¡Œåˆç†çš„å®¹é‡è¦åŠƒ
5. **ç½é›£å‚™æ´**ï¼šå»ºç«‹å®Œæ•´çš„ç½é›£æ¢å¾©å’Œæ¥­å‹™é€£çºŒæ€§è¨ˆåŠƒ

### ç¬¬ä¸ƒç« å®Œæ•´ç¸½çµ

ç¬¬ä¸ƒç« ã€ŒRAG ç³»çµ±å»ºæ§‹ã€å®Œæ•´æ¶µè“‹äº†å¾åŸºç¤æ¦‚å¿µåˆ°ç”Ÿç”¢éƒ¨ç½²çš„å…¨éç¨‹ï¼š

- **7.1 RAGæµç¨‹è©³è§£**ï¼šå»ºç«‹äº† RAG çš„ç†è«–åŸºç¤å’Œç³»çµ±æ¶æ§‹
- **7.2 å…§å®¹å‘é‡åŒ–**ï¼šæŒæ¡äº†æ–‡æœ¬å‘é‡åŒ–çš„æ ¸å¿ƒæŠ€è¡“
- **7.3 ETL(ä¸Š)-çŸ¥è­˜ä¾†æº**ï¼šå¯¦ç¾äº†å¤šæ¨£åŒ–çš„è³‡æ–™æå–èƒ½åŠ›
- **7.4 ETL(ä¸­)-é€²éšæ–‡ä»¶**ï¼šè™•ç†äº†è¤‡é›œæ–‡ä»¶æ ¼å¼çš„æå–
- **7.5 ETL(ä¸‹)-è³‡æ–™å„ªåŒ–**ï¼šå»ºç«‹äº†è³‡æ–™å“è³ªä¿è­‰æ©Ÿåˆ¶
- **7.6 ä¼æ¥­è³‡æ–™ä¾†æº**ï¼šæ•´åˆäº†ä¼æ¥­ç´šçš„è³‡æ–™ç®¡ç†èƒ½åŠ›
- **7.7 æœ€å¾Œä¸€å“©è·¯**ï¼šå®Œæˆäº†ç”Ÿç”¢ç´šçš„éƒ¨ç½²å’Œé‹ç¶­

é€šéç¬¬ä¸ƒç« çš„å­¸ç¿’ï¼Œè®€è€…å·²ç¶“å…·å‚™äº†å»ºæ§‹å®Œæ•´ä¼æ¥­ç´š RAG ç³»çµ±çš„èƒ½åŠ›ï¼

---

**åƒè€ƒè³‡æ–™ï¼š**
- [Docker Documentation](https://docs.docker.com/)
- [Kubernetes Documentation](https://kubernetes.io/docs/)
- [Prometheus Monitoring](https://prometheus.io/docs/)
- [Grafana Dashboards](https://grafana.com/docs/)
# 6.4 Spring AI çš„éˆå¼å¢å¼·å™¨

> **æœ¬ç« é‡é»**ï¼šæ·±å…¥æ¢ç´¢ Spring AI çš„ Advisor ç³»çµ±ï¼ŒæŒæ¡éˆå¼å¢å¼·å™¨çš„é€²éšæ‡‰ç”¨ï¼Œå­¸æœƒè¨­è¨ˆå’Œå¯¦ç¾è‡ªå®šç¾©çš„ AI å¢å¼·åŠŸèƒ½ã€‚

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬ç« å­¸ç¿’å¾Œï¼Œæ‚¨å°‡èƒ½å¤ ï¼š

- ğŸ¯ **æŒæ¡ Advisor éˆå¼æ©Ÿåˆ¶**ï¼šç†è§£å¤šå€‹ Advisor çš„çµ„åˆå’ŒåŸ·è¡Œé †åº
- ğŸ¯ **è¨­è¨ˆè‡ªå®šç¾© Advisor**ï¼šå­¸æœƒé–‹ç™¼ç¬¦åˆæ¥­å‹™éœ€æ±‚çš„å¢å¼·å™¨
- ğŸ¯ **å¯¦ç¾é€²éšåŠŸèƒ½**ï¼šå»ºç«‹å…§å®¹éæ¿¾ã€æ—¥èªŒè¨˜éŒ„ã€å®‰å…¨æª¢æŸ¥ç­‰å¢å¼·åŠŸèƒ½
- ğŸ¯ **å„ªåŒ– Advisor æ•ˆèƒ½**ï¼šæŒæ¡ Advisor çš„æ•ˆèƒ½å„ªåŒ–å’Œæœ€ä½³å¯¦è¸
- ğŸ¯ **æ•´åˆä¼æ¥­éœ€æ±‚**ï¼šå°‡ Advisor ç³»çµ±èˆ‡å¯¦éš›æ¥­å‹™å ´æ™¯å®Œç¾çµåˆ

---

## 6.4.1 Advisor éˆå¼æ©Ÿåˆ¶æ·±åº¦è§£æ

### éˆå¼å¢å¼·å™¨çš„æ ¸å¿ƒæ¦‚å¿µ

Spring AI çš„ Advisor ç³»çµ±æ¡ç”¨äº†è²¬ä»»éˆæ¨¡å¼ï¼ˆChain of Responsibility Patternï¼‰ï¼Œå…è¨±å¤šå€‹å¢å¼·å™¨æŒ‰ç…§ç‰¹å®šé †åºå° AI è«‹æ±‚å’Œå›æ‡‰é€²è¡Œè™•ç†ã€‚

**éˆå¼è™•ç†æµç¨‹**ï¼š
```
User Request
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Advisor Chain                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  Advisor 1  â”‚ â†’  â”‚  Advisor 2  â”‚ â†’  â”‚  Advisor 3  â”‚     â”‚
â”‚  â”‚ (Order: 0)  â”‚    â”‚ (Order: 10) â”‚    â”‚ (Order: 20) â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
AI Model Processing
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Response Processing                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  Advisor 3  â”‚ â†  â”‚  Advisor 2  â”‚ â†  â”‚  Advisor 1  â”‚     â”‚
â”‚  â”‚ (Response)  â”‚    â”‚ (Response)  â”‚    â”‚ (Response)  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
Final Response
```

### Advisor åŸ·è¡Œé †åºæ§åˆ¶

```java
/**
 * Advisor åŸ·è¡Œé †åºä»‹é¢
 */
public interface Ordered {
    int HIGHEST_PRECEDENCE = Integer.MIN_VALUE;
    int LOWEST_PRECEDENCE = Integer.MAX_VALUE;
    
    int getOrder();
}

/**
 * Spring AI Advisor åŸºç¤ä»‹é¢
 */
public interface Advisor extends Ordered {
    String getName();
}

/**
 * CallAdvisor - éä¸²æµå ´æ™¯
 */
public interface CallAdvisor extends Advisor {
    ChatClientResponse adviseCall(
        ChatClientRequest chatClientRequest, 
        CallAdvisorChain callAdvisorChain);
}

/**
 * StreamAdvisor - ä¸²æµå ´æ™¯
 */
public interface StreamAdvisor extends Advisor {
    Flux<ChatClientResponse> adviseStream(
        ChatClientRequest chatClientRequest, 
        StreamAdvisorChain streamAdvisorChain);
}

/**
 * Advisor Chain ä»‹é¢
 */
public interface CallAdvisorChain extends AdvisorChain {
    ChatClientResponse nextCall(ChatClientRequest chatClientRequest);
    List<CallAdvisor> getCallAdvisors();
}

public interface StreamAdvisorChain extends AdvisorChain {
    Flux<ChatClientResponse> nextStream(ChatClientRequest chatClientRequest);
    List<StreamAdvisor> getStreamAdvisors();
}
```

### å…§å»º Advisor çš„åŸ·è¡Œé †åº

```java
public class AdvisorOrder {
    // è¨˜æ†¶ç®¡ç† - æœ€é«˜å„ªå…ˆç´š
    public static final int MEMORY_ORDER = 0;
    
    // å…§å®¹éæ¿¾ - é«˜å„ªå…ˆç´š
    public static final int CONTENT_FILTER_ORDER = 100;
    
    // RAG æª¢ç´¢ - ä¸­å„ªå…ˆç´š
    public static final int RAG_RETRIEVAL_ORDER = 200;
    
    // æ—¥èªŒè¨˜éŒ„ - ä½å„ªå…ˆç´š
    public static final int LOGGING_ORDER = 800;
    
    // çµ±è¨ˆç›£æ§ - æœ€ä½å„ªå…ˆç´š
    public static final int METRICS_ORDER = 900;
}
```

---

## 6.4.2 è‡ªå®šç¾© Advisor é–‹ç™¼

### 1. å…§å®¹éæ¿¾ Advisor

```java
import org.springframework.ai.chat.client.advisor.api.*;
import org.springframework.ai.chat.messages.*;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.model.Generation;
import org.springframework.ai.chat.prompt.Prompt;
import java.util.List;

/**
 * å…§å®¹éæ¿¾å¢å¼·å™¨
 * éæ¿¾æ•æ„Ÿå…§å®¹å’Œä¸ç•¶è¨€è«–
 */
@Component
@Slf4j
public class ContentFilterAdvisor implements CallAdvisor {
    
    private final ContentFilterService filterService;
    private final MeterRegistry meterRegistry;
    
    public ContentFilterAdvisor(ContentFilterService filterService, MeterRegistry meterRegistry) {
        this.filterService = filterService;
        this.meterRegistry = meterRegistry;
    }
    
    @Override
    public String getName() {
        return "ContentFilterAdvisor";
    }
    
    @Override
    public int getOrder() {
        return AdvisorOrder.CONTENT_FILTER_ORDER;
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        log.debug("Processing request through content filter");
        
        // éæ¿¾ç”¨æˆ¶è¼¸å…¥
        String originalContent = extractUserMessage(request);
        FilterResult filterResult = filterService.filterInput(originalContent);
        
        // è¨˜éŒ„éæ¿¾çµ±è¨ˆ
        meterRegistry.counter("content.filter.requests", 
            "filtered", String.valueOf(filterResult.isFiltered())).increment();
        
        if (filterResult.isFiltered()) {
            log.warn("Content filtered: {}", filterResult.getReason());
            
            // å¦‚æœå…§å®¹è¢«éæ¿¾ï¼Œæ›¿æ›ç‚ºå®‰å…¨å…§å®¹
            request = replaceUserMessage(request, filterResult.getSafeContent());
        }
        
        // ç¹¼çºŒåŸ·è¡Œéˆä¸­çš„ä¸‹ä¸€å€‹ Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // éæ¿¾ AI å›æ‡‰
        String responseContent = response.chatResponse().getResult().getOutput().getContent();
        FilterResult responseFilterResult = filterService.filterOutput(responseContent);
        
        if (responseFilterResult.isFiltered()) {
            log.warn("AI response filtered: {}", responseFilterResult.getReason());
            
            // æ›¿æ›ç‚ºå®‰å…¨çš„å›æ‡‰
            response = replaceResponseContent(response, responseFilterResult.getSafeContent());
        }
        
        return response;
    }
    
    private String extractUserMessage(ChatClientRequest request) {
        return request.prompt().getInstructions().stream()
            .filter(msg -> msg instanceof UserMessage)
            .map(Message::getContent)
            .findFirst()
            .orElse("");
    }
    
    private ChatClientRequest replaceUserMessage(ChatClientRequest request, String safeContent) {
        // å¯¦ç¾è¨Šæ¯æ›¿æ›é‚è¼¯
        return request.mutate()
            .prompt(Prompt.from(UserMessage.from(safeContent)))
            .build();
    }
    
    private ChatClientResponse replaceResponseContent(ChatClientResponse response, String safeContent) {
        // å¯¦ç¾å›æ‡‰æ›¿æ›é‚è¼¯
        Generation generation = new Generation(new AssistantMessage(safeContent));
        ChatResponse chatResponse = new ChatResponse(List.of(generation));
        return new ChatClientResponse(chatResponse, response.adviseContext());
    }
}
```

### 2. ç°¡å–®æ—¥èªŒè¨˜éŒ„ Advisor

```java
/**
 * ç°¡å–®æ—¥èªŒè¨˜éŒ„å¢å¼·å™¨
 * è¨˜éŒ„æ‰€æœ‰ AI è«‹æ±‚å’Œå›æ‡‰çš„è©³ç´°è³‡è¨Š
 */
@Component
public class SimpleLoggerAdvisor implements CallAdvisor, StreamAdvisor {
    
    private static final Logger logger = LoggerFactory.getLogger(SimpleLoggerAdvisor.class);
    
    @Override
    public String getName() {
        return this.getClass().getSimpleName();
    }
    
    @Override
    public int getOrder() {
        return 0;
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest chatClientRequest, 
                                       CallAdvisorChain callAdvisorChain) {
        logRequest(chatClientRequest);
        
        ChatClientResponse chatClientResponse = callAdvisorChain.nextCall(chatClientRequest);
        
        logResponse(chatClientResponse);
        
        return chatClientResponse;
    }
    
    @Override
    public Flux<ChatClientResponse> adviseStream(ChatClientRequest chatClientRequest,
                                               StreamAdvisorChain streamAdvisorChain) {
        logRequest(chatClientRequest);
        
        Flux<ChatClientResponse> chatClientResponses = streamAdvisorChain.nextStream(chatClientRequest);
        
        return new ChatClientMessageAggregator()
            .aggregateChatClientResponse(chatClientResponses, this::logResponse);
    }
    
    private void logRequest(ChatClientRequest request) {
        logger.debug("request: {}", request);
    }
    
    private void logResponse(ChatClientResponse chatClientResponse) {
        logger.debug("response: {}", chatClientResponse);
    }
}```

### 3. ä¼æ¥­ç´šæ—¥èªŒè¨˜éŒ„ Advisor

```java
/**
 * ä¼æ¥­ç´šæ—¥èªŒè¨˜éŒ„å¢å¼·å™¨
 * æä¾›å®Œæ•´çš„å¯©è¨ˆæ—¥èªŒåŠŸèƒ½
 */
@Component
@Slf4j
public class EnterpriseLoggingAdvisor implements CallAdvisor {
    
    private final ObjectMapper objectMapper;
    private final AuditLogService auditLogService;
    
    public EnterpriseLoggingAdvisor(ObjectMapper objectMapper, AuditLogService auditLogService) {
        this.objectMapper = objectMapper;
        this.auditLogService = auditLogService;
    }
    
    @Override
    public String getName() {
        return "EnterpriseLoggingAdvisor";
    }
    
    @Override
    public int getOrder() {
        return AdvisorOrder.LOGGING_ORDER;
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String conversationId = extractConversationId(request);
        String userId = extractUserId(request);
        
        try {
            // è¨˜éŒ„è«‹æ±‚æ—¥èªŒ
            AuditLog auditLog = AuditLog.builder()
                .conversationId(conversationId)
                .userId(userId)
                .eventType("AI_REQUEST")
                .requestContent(extractRequestContent(request))
                .timestamp(LocalDateTime.now())
                .metadata(createMetadata(request))
                .build();
            
            auditLogService.logEvent(auditLog);
            
            // ç¹¼çºŒåŸ·è¡Œéˆä¸­çš„ä¸‹ä¸€å€‹ Advisor
            ChatClientResponse response = chain.nextCall(request);
            
            // è¨˜éŒ„å›æ‡‰æ—¥èªŒ
            AuditLog responseLog = AuditLog.builder()
                .requestId(auditLog.getId())
                .eventType("AI_RESPONSE")
                .responseContent(extractResponseContent(response))
                .timestamp(LocalDateTime.now())
                .tokenUsage(extractTokenUsage(response))
                .build();
            
            auditLogService.logEvent(responseLog);
            
            return response;
            
        } catch (Exception e) {
            log.error("Failed to log request/response", e);
            // å³ä½¿æ—¥èªŒè¨˜éŒ„å¤±æ•—ï¼Œä¹Ÿè¦ç¹¼çºŒåŸ·è¡Œ
            return chain.nextCall(request);
        }
    }
    
    private String extractRequestContent(ChatClientRequest request) {
        try {
            return objectMapper.writeValueAsString(request.getPrompt().getInstructions());
        } catch (Exception e) {
            return "[Failed to serialize request]";
        }
    }
    
    private String extractResponseContent(ChatClientResponse response) {
        return response.chatResponse().getResult().getOutput().getContent();
    }
    
    private Map<String, Object> createMetadata(ChatClientRequest request) {
        Map<String, Object> metadata = new HashMap<>();
        if (request.chatOptions() != null) {
            metadata.put("model", request.chatOptions().getModel());
            metadata.put("temperature", request.chatOptions().getTemperature());
            metadata.put("maxTokens", request.chatOptions().getMaxTokens());
        }
        return metadata;
    }
}```

### 3. å®‰å…¨æª¢æŸ¥ Advisor

```java
/**
 * å®‰å…¨æª¢æŸ¥å¢å¼·å™¨
 * å¯¦æ–½è¨ªå•æ§åˆ¶å’Œå®‰å…¨ç­–ç•¥
 */
@Component
@Slf4j
public class SecurityAdvisor implements CallAdvisor {
    
    private final SecurityService securityService;
    private final RateLimitService rateLimitService;
    
    public SecurityAdvisor(SecurityService securityService, RateLimitService rateLimitService) {
        this.securityService = securityService;
        this.rateLimitService = rateLimitService;
    }
    
    @Override
    public String getName() {
        return "SecurityAdvisor";
    }
    
    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE; // æœ€é«˜å„ªå…ˆç´š
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String userId = extractUserId(request);
        String conversationId = extractConversationId(request);
        
        // 1. ç”¨æˆ¶èº«ä»½é©—è­‰
        if (!securityService.isValidUser(userId)) {
            throw new SecurityException("Invalid user: " + userId);
        }
        
        // 2. æ¬Šé™æª¢æŸ¥
        if (!securityService.hasPermission(userId, "AI_CHAT")) {
            throw new SecurityException("User does not have AI chat permission: " + userId);
        }
        
        // 3. é€Ÿç‡é™åˆ¶æª¢æŸ¥
        if (!rateLimitService.isAllowed(userId)) {
            throw new RateLimitExceededException("Rate limit exceeded for user: " + userId);
        }
        
        // 4. å…§å®¹å®‰å…¨æª¢æŸ¥
        String userMessage = extractUserMessage(request);
        if (securityService.containsMaliciousContent(userMessage)) {
            throw new SecurityException("Malicious content detected");
        }
        
        // 5. å°è©±å®‰å…¨æª¢æŸ¥
        if (!securityService.canAccessConversation(userId, conversationId)) {
            throw new SecurityException("User cannot access conversation: " + conversationId);
        }
        
        log.debug("Security check passed for user: {}", userId);
        
        // ç¹¼çºŒåŸ·è¡Œéˆä¸­çš„ä¸‹ä¸€å€‹ Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // å›æ‡‰éšæ®µçš„å®‰å…¨æª¢æŸ¥
        String responseContent = response.chatResponse().getResult().getOutput().getContent();
        
        // æª¢æŸ¥å›æ‡‰æ˜¯å¦åŒ…å«æ•æ„Ÿè³‡è¨Š
        if (securityService.containsSensitiveInfo(responseContent)) {
            log.warn("Sensitive information detected in AI response");
            
            // é®è”½æ•æ„Ÿè³‡è¨Š
            String sanitizedContent = securityService.sanitizeContent(responseContent);
            response = replaceResponseContent(response, sanitizedContent);
        }
        
        return response;
    }
}
```

---

## 6.4.3 Advisor çµ„åˆèˆ‡é…ç½®

### å¤š Advisor çµ„åˆé…ç½®

```java
@Configuration
@EnableConfigurationProperties(AdvisorProperties.class)
public class AdvisorChainConfig {
    
    /**
     * é…ç½®å®Œæ•´çš„ Advisor éˆ
     */
    @Bean
    public ChatClient advisorChainChatClient(
            ChatModel chatModel,
            List<CallAdvisor> advisors,
            AdvisorProperties properties) {
        
        // æ ¹æ“š Order æ’åº Advisor
        List<CallAdvisor> sortedAdvisors = advisors.stream()
            .sorted(Comparator.comparingInt(CallAdvisor::getOrder))
            .collect(Collectors.toList());
        
        log.info("Configuring ChatClient with {} advisors: {}", 
            sortedAdvisors.size(),
            sortedAdvisors.stream().map(CallAdvisor::getName).collect(Collectors.toList()));
        
        return ChatClient.builder(chatModel)
            .defaultAdvisors(sortedAdvisors)
            .build();
    }
    
    /**
     * æ¢ä»¶åŒ– Advisor é…ç½®
     */
    @Bean
    @ConditionalOnProperty(name = "app.advisor.security.enabled", havingValue = "true")
    public SecurityAdvisor securityAdvisor(SecurityService securityService, RateLimitService rateLimitService) {
        return new SecurityAdvisor(securityService, rateLimitService);
    }
    
    @Bean
    @ConditionalOnProperty(name = "app.advisor.content-filter.enabled", havingValue = "true")
    public ContentFilterAdvisor contentFilterAdvisor(ContentFilterService filterService, MeterRegistry meterRegistry) {
        return new ContentFilterAdvisor(filterService, meterRegistry);
    }
    
    @Bean
    @ConditionalOnProperty(name = "app.advisor.logging.enabled", havingValue = "true")
    public LoggingAdvisor loggingAdvisor(ObjectMapper objectMapper, AuditLogService auditLogService) {
        return new LoggingAdvisor(objectMapper, auditLogService);
    }
    
    /**
     * è‡ªå®šç¾© Advisor éˆå»ºæ§‹å™¨
     */
    @Bean
    public AdvisorChainBuilder advisorChainBuilder(List<CallAdvisor> advisors) {
        return new AdvisorChainBuilder(advisors);
    }
}
```

### Advisor é…ç½®å±¬æ€§

```java
@ConfigurationProperties(prefix = "app.advisor")
@Data
public class AdvisorProperties {
    
    /**
     * å®‰å…¨ Advisor é…ç½®
     */
    private Security security = new Security();
    
    /**
     * å…§å®¹éæ¿¾ Advisor é…ç½®
     */
    private ContentFilter contentFilter = new ContentFilter();
    
    /**
     * æ—¥èªŒ Advisor é…ç½®
     */
    private Logging logging = new Logging();
    
    /**
     * è¨˜æ†¶ Advisor é…ç½®
     */
    private Memory memory = new Memory();
    
    @Data
    public static class Security {
        private boolean enabled = true;
        private int order = -1000;
        private boolean strictMode = false;
        private List<String> allowedUsers = new ArrayList<>();
    }
    
    @Data
    public static class ContentFilter {
        private boolean enabled = true;
        private int order = 100;
        private List<String> blockedWords = new ArrayList<>();
        private boolean enableAiFilter = true;
    }
    
    @Data
    public static class Logging {
        private boolean enabled = true;
        private int order = 800;
        private boolean logRequests = true;
        private boolean logResponses = true;
        private boolean logMetadata = true;
    }
    
    @Data
    public static class Memory {
        private boolean enabled = true;
        private int order = 0;
        private int maxMessages = 100;
        private boolean autoCleanup = true;
    }
}
```

### å‹•æ…‹ Advisor éˆå»ºæ§‹

```java
@Component
public class AdvisorChainBuilder {
    
    private final List<CallAdvisor> availableAdvisors;
    private final AdvisorProperties properties;
    
    public AdvisorChainBuilder(List<CallAdvisor> availableAdvisors, AdvisorProperties properties) {
        this.availableAdvisors = availableAdvisors;
        this.properties = properties;
    }
    
    /**
     * æ ¹æ“šç”¨æˆ¶éœ€æ±‚å»ºæ§‹ Advisor éˆ
     */
    public List<CallAdvisor> buildChain(AdvisorChainRequest request) {
        List<CallAdvisor> chain = new ArrayList<>();
        
        // 1. å®‰å…¨ Advisorï¼ˆå¦‚æœå•Ÿç”¨ï¼‰
        if (request.isSecurityRequired() && properties.getSecurity().isEnabled()) {
            findAdvisor(SecurityAdvisor.class).ifPresent(chain::add);
        }
        
        // 2. å…§å®¹éæ¿¾ Advisorï¼ˆå¦‚æœå•Ÿç”¨ï¼‰
        if (request.isContentFilterRequired() && properties.getContentFilter().isEnabled()) {
            findAdvisor(ContentFilterAdvisor.class).ifPresent(chain::add);
        }
        
        // 3. è¨˜æ†¶ Advisorï¼ˆå¦‚æœå•Ÿç”¨ï¼‰
        if (request.isMemoryRequired() && properties.getMemory().isEnabled()) {
            findAdvisor(MessageChatMemoryAdvisor.class).ifPresent(chain::add);
        }
        
        // 4. è‡ªå®šç¾© Advisor
        request.getCustomAdvisors().forEach(advisorClass -> {
            findAdvisor(advisorClass).ifPresent(chain::add);
        });
        
        // 5. æ—¥èªŒ Advisorï¼ˆå¦‚æœå•Ÿç”¨ï¼‰
        if (request.isLoggingRequired() && properties.getLogging().isEnabled()) {
            findAdvisor(LoggingAdvisor.class).ifPresent(chain::add);
        }
        
        // æŒ‰ Order æ’åº
        return chain.stream()
            .sorted(Comparator.comparingInt(CallAdvisor::getOrder))
            .collect(Collectors.toList());
    }
    
    private <T extends CallAdvisor> Optional<T> findAdvisor(Class<T> advisorClass) {
        return availableAdvisors.stream()
            .filter(advisorClass::isInstance)
            .map(advisorClass::cast)
            .findFirst();
    }
}
```

---

## 6.4.4 Advisor æ•ˆèƒ½å„ªåŒ–

### éåŒæ­¥ Advisor è™•ç†

```java
/**
 * éåŒæ­¥æ—¥èªŒ Advisor
 * é¿å…æ—¥èªŒè¨˜éŒ„å½±éŸ¿ AI å›æ‡‰é€Ÿåº¦
 */
@Component
@Slf4j
public class AsyncLoggingAdvisor implements CallAdvisor {
    
    private final AsyncAuditLogService asyncAuditLogService;
    private final ExecutorService executorService;
    
    public AsyncLoggingAdvisor(AsyncAuditLogService asyncAuditLogService) {
        this.asyncAuditLogService = asyncAuditLogService;
        this.executorService = Executors.newFixedThreadPool(5, 
            new ThreadFactoryBuilder()
                .setNameFormat("async-logging-%d")
                .setDaemon(true)
                .build());
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        // éåŒæ­¥è¨˜éŒ„è«‹æ±‚
        CompletableFuture.runAsync(() -> {
            try {
                logRequest(request);
            } catch (Exception e) {
                log.error("Async request logging failed", e);
            }
        }, executorService);
        
        // ç¹¼çºŒåŸ·è¡Œéˆä¸­çš„ä¸‹ä¸€å€‹ Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // éåŒæ­¥è¨˜éŒ„å›æ‡‰
        CompletableFuture.runAsync(() -> {
            try {
                logResponse(response);
            } catch (Exception e) {
                log.error("Async response logging failed", e);
            }
        }, executorService);
        
        return response;
    }
    
    @PreDestroy
    public void shutdown() {
        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
```

### Advisor å¿«å–æ©Ÿåˆ¶

```java
/**
 * å¿«å–å¢å¼·çš„å…§å®¹éæ¿¾ Advisor
 */
@Component
public class CachedContentFilterAdvisor implements CallAdvisor {
    
    private final ContentFilterService filterService;
    private final Cache<String, FilterResult> filterCache;
    
    public CachedContentFilterAdvisor(ContentFilterService filterService, CacheManager cacheManager) {
        this.filterService = filterService;
        this.filterCache = cacheManager.getCache("content-filter", String.class, FilterResult.class);
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String content = extractUserMessage(request);
        String contentHash = DigestUtils.md5Hex(content);
        
        // å˜—è©¦å¾å¿«å–å–å¾—éæ¿¾çµæœ
        FilterResult cachedResult = filterCache.get(contentHash);
        
        if (cachedResult != null) {
            log.debug("Using cached filter result for content hash: {}", contentHash);
            request = processCachedResult(request, cachedResult);
        } else {
            // å¿«å–æœªå‘½ä¸­ï¼ŒåŸ·è¡Œéæ¿¾ä¸¦å¿«å–çµæœ
            FilterResult filterResult = filterService.filterInput(content);
            filterCache.put(contentHash, filterResult);
            request = processFilterResult(request, filterResult);
        }
        
        // ç¹¼çºŒåŸ·è¡Œéˆä¸­çš„ä¸‹ä¸€å€‹ Advisor
        return chain.nextCall(request);
    }
}
```

### Advisor æ•ˆèƒ½ç›£æ§

```java
/**
 * Advisor æ•ˆèƒ½ç›£æ§æœå‹™
 */
@Service
@RequiredArgsConstructor
public class AdvisorMetricsService {
    
    private final MeterRegistry meterRegistry;
    
    /**
     * è¨˜éŒ„ Advisor åŸ·è¡Œæ™‚é–“
     */
    public <T> T timeAdvisorExecution(String advisorName, String phase, Supplier<T> operation) {
        return Timer.Sample.start(meterRegistry)
            .stop(Timer.builder("advisor.execution.time")
                .description("Advisor execution time")
                .tag("advisor", advisorName)
                .tag("phase", phase)
                .register(meterRegistry))
            .recordCallable(operation::get);
    }
    
    /**
     * è¨˜éŒ„ Advisor åŸ·è¡Œæ¬¡æ•¸
     */
    public void recordAdvisorExecution(String advisorName, String phase, boolean success) {
        meterRegistry.counter("advisor.executions",
            "advisor", advisorName,
            "phase", phase,
            "success", String.valueOf(success))
            .increment();
    }
    
    /**
     * è¨˜éŒ„ Advisor éˆé•·åº¦
     */
    public void recordChainLength(int chainLength) {
        meterRegistry.gauge("advisor.chain.length", chainLength);
    }
}
```

---

## 6.4.5 ä¼æ¥­ç´š Advisor æ‡‰ç”¨å ´æ™¯

### 1. å¤šç§Ÿæˆ¶ Advisor

```java
/**
 * å¤šç§Ÿæˆ¶éš”é›¢ Advisor
 */
@Component
public class MultiTenantAdvisor implements CallAdvisor {
    
    private final TenantService tenantService;
    private final TenantContextHolder tenantContextHolder;
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String tenantId = extractTenantId(request);
        
        // é©—è­‰ç§Ÿæˆ¶
        Tenant tenant = tenantService.validateTenant(tenantId);
        if (tenant == null) {
            throw new IllegalArgumentException("Invalid tenant: " + tenantId);
        }
        
        // è¨­å®šç§Ÿæˆ¶ä¸Šä¸‹æ–‡
        tenantContextHolder.setCurrentTenant(tenant);
        
        try {
            // æ‡‰ç”¨ç§Ÿæˆ¶ç‰¹å®šçš„é…ç½®
            request = applyTenantConfiguration(request, tenant);
            
            // ç¹¼çºŒåŸ·è¡Œéˆä¸­çš„ä¸‹ä¸€å€‹ Advisor
            ChatClientResponse response = chain.nextCall(request);
            
            // æ‡‰ç”¨ç§Ÿæˆ¶ç‰¹å®šçš„å›æ‡‰è™•ç†
            return applyTenantResponseProcessing(response, tenant);
        } finally {
            // æ¸…ç†ç§Ÿæˆ¶ä¸Šä¸‹æ–‡
            tenantContextHolder.clear();
        }
    }
}
```

### 2. æˆæœ¬æ§åˆ¶ Advisor

```java
/**
 * æˆæœ¬æ§åˆ¶ Advisor
 */
@Component
public class CostControlAdvisor implements CallAdvisor {
    
    private final CostTrackingService costTrackingService;
    private final BudgetService budgetService;
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String userId = extractUserId(request);
        
        // æª¢æŸ¥ç”¨æˆ¶é ç®—
        Budget userBudget = budgetService.getUserBudget(userId);
        if (userBudget.isExceeded()) {
            throw new BudgetExceededException("User budget exceeded: " + userId);
        }
        
        // ä¼°ç®—è«‹æ±‚æˆæœ¬
        CostEstimate estimate = costTrackingService.estimateRequestCost(request);
        if (!userBudget.canAfford(estimate.getEstimatedCost())) {
            throw new InsufficientBudgetException("Insufficient budget for request");
        }
        
        // ç¹¼çºŒåŸ·è¡Œéˆä¸­çš„ä¸‹ä¸€å€‹ Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // è¨ˆç®—å¯¦éš›æˆæœ¬
        Cost actualCost = costTrackingService.calculateActualCost(response);
        
        // æ‰£é™¤ç”¨æˆ¶é ç®—
        budgetService.deductBudget(userId, actualCost);
        
        // è¨˜éŒ„æˆæœ¬çµ±è¨ˆ
        costTrackingService.recordCost(userId, actualCost, estimate);
        
        return response;
    }
}
```

### 3. A/B æ¸¬è©¦ Advisor

```java
/**
 * A/B æ¸¬è©¦ Advisor
 */
@Component
public class ABTestAdvisor implements CallAdvisor {
    
    private final ABTestService abTestService;
    private final ExperimentService experimentService;
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String userId = extractUserId(request);
        Map<String, String> experiments = new HashMap<>();
        
        // å–å¾—ç”¨æˆ¶çš„å¯¦é©—åˆ†çµ„
        List<Experiment> activeExperiments = experimentService.getActiveExperiments(userId);
        
        for (Experiment experiment : activeExperiments) {
            String variant = abTestService.getVariant(userId, experiment.getId());
            
            // æ ¹æ“šå¯¦é©—è®Šé«”èª¿æ•´è«‹æ±‚
            request = applyExperimentVariant(request, experiment, variant);
            
            // è¨˜éŒ„å¯¦é©—åƒèˆ‡
            experiments.put(experiment.getId(), variant);
        }
        
        // ç¹¼çºŒåŸ·è¡Œéˆä¸­çš„ä¸‹ä¸€å€‹ Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // è¨˜éŒ„å¯¦é©—çµæœ
        experiments.forEach((experimentId, variant) -> {
            abTestService.recordResult(experimentId, variant, response);
        });
        
        return response;
    }
}
```

---

## ğŸ“ æœ¬ç« é‡é»å›é¡§

1. **éˆå¼æ©Ÿåˆ¶ç†è§£**ï¼šæŒæ¡äº† Advisor çš„è²¬ä»»éˆæ¨¡å¼å’ŒåŸ·è¡Œé †åºæ§åˆ¶
2. **è‡ªå®šç¾© Advisor é–‹ç™¼**ï¼šå­¸æœƒäº†é–‹ç™¼å…§å®¹éæ¿¾ã€æ—¥èªŒè¨˜éŒ„ã€å®‰å…¨æª¢æŸ¥ç­‰å¢å¼·å™¨
3. **çµ„åˆé…ç½®æŠ€å·§**ï¼šæŒæ¡äº†å¤š Advisor çš„çµ„åˆé…ç½®å’Œå‹•æ…‹å»ºæ§‹
4. **æ•ˆèƒ½å„ªåŒ–ç­–ç•¥**ï¼šå¯¦ç¾äº†éåŒæ­¥è™•ç†ã€å¿«å–æ©Ÿåˆ¶å’Œæ•ˆèƒ½ç›£æ§
5. **ä¼æ¥­ç´šæ‡‰ç”¨**ï¼šå»ºç«‹äº†å¤šç§Ÿæˆ¶ã€æˆæœ¬æ§åˆ¶ã€A/B æ¸¬è©¦ç­‰ä¼æ¥­å ´æ™¯çš„è§£æ±ºæ–¹æ¡ˆ

### æŠ€è¡“è¦é»ç¸½çµ

| æŠ€è¡“é» | é‡è¦æ€§ | å¯¦ç¾é›£åº¦ | ä¼æ¥­åƒ¹å€¼ |
|--------|--------|----------|----------|
| **è‡ªå®šç¾© Advisor é–‹ç™¼** | â­â­â­ | ä¸­ | æ¥­å‹™å®šåˆ¶åŒ– |
| **Advisor éˆå¼çµ„åˆ** | â­â­â­ | ä¸­ | åŠŸèƒ½æ¨¡çµ„åŒ– |
| **æ•ˆèƒ½å„ªåŒ–æ©Ÿåˆ¶** | â­â­ | é«˜ | ç³»çµ±æ•ˆèƒ½ |
| **ä¼æ¥­ç´šæ‡‰ç”¨å ´æ™¯** | â­â­â­ | é«˜ | å•†æ¥­åƒ¹å€¼ |
| **ç›£æ§å’Œè¨ºæ–·** | â­â­ | ä¸­ | é‹ç¶­ç®¡ç† |

### æœ€ä½³å¯¦è¸å»ºè­°

1. **è¨­è¨ˆåŸå‰‡**ï¼šéµå¾ªå–®ä¸€è·è²¬åŸå‰‡ï¼Œæ¯å€‹ Advisor åªè² è²¬ä¸€å€‹ç‰¹å®šåŠŸèƒ½
2. **åŸ·è¡Œé †åº**ï¼šåˆç†è¨­è¨ˆ Advisor çš„åŸ·è¡Œé †åºï¼Œç¢ºä¿ä¾è³´é—œä¿‚æ­£ç¢º
3. **æ•ˆèƒ½è€ƒé‡**ï¼šå°æ–¼è€—æ™‚æ“ä½œä½¿ç”¨éåŒæ­¥è™•ç†ï¼Œé¿å…å½±éŸ¿ AI å›æ‡‰é€Ÿåº¦
4. **éŒ¯èª¤è™•ç†**ï¼šå¯¦ç¾å®Œå–„çš„éŒ¯èª¤è™•ç†æ©Ÿåˆ¶ï¼Œé¿å…å–®å€‹ Advisor å½±éŸ¿æ•´å€‹éˆ
5. **ç›£æ§å‘Šè­¦**ï¼šå»ºç«‹å®Œæ•´çš„ Advisor åŸ·è¡Œç›£æ§å’Œå‘Šè­¦æ©Ÿåˆ¶

### ä¸‹ä¸€æ­¥å­¸ç¿’æ–¹å‘

åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘å€‘å°‡å­¸ç¿’å¦‚ä½•è‡ªè¡Œé–‹ç™¼ Spring AI æ’ä»¶ï¼ŒåŒ…æ‹¬ï¼š
- æ’ä»¶æ¶æ§‹è¨­è¨ˆå’Œé–‹ç™¼è¦ç¯„
- è‡ªå®šç¾©åŠŸèƒ½æ¨¡çµ„çš„å¯¦ç¾
- æ’ä»¶çš„æ‰“åŒ…ã€åˆ†ç™¼å’Œéƒ¨ç½²
- èˆ‡ Spring AI ç”Ÿæ…‹ç³»çµ±çš„æ•´åˆ

---

**åƒè€ƒè³‡æ–™ï¼š**
- [Spring AI Advisors Documentation](https://docs.spring.io/spring-ai/reference/api/advisors.html)
- [Chain of Responsibility Pattern](https://refactoring.guru/design-patterns/chain-of-responsibility)
- [Spring Boot Conditional Configuration](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration.condition-annotations)
- [Micrometer Metrics](https://micrometer.io/docs)
# 6.4 Spring AI 的鏈式增強器

> **本章重點**：深入探索 Spring AI 的 Advisor 系統，掌握鏈式增強器的進階應用，學會設計和實現自定義的 AI 增強功能。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握 Advisor 鏈式機制**：理解多個 Advisor 的組合和執行順序
- 🎯 **設計自定義 Advisor**：學會開發符合業務需求的增強器
- 🎯 **實現進階功能**：建立內容過濾、日誌記錄、安全檢查等增強功能
- 🎯 **優化 Advisor 效能**：掌握 Advisor 的效能優化和最佳實踐
- 🎯 **整合企業需求**：將 Advisor 系統與實際業務場景完美結合

---

## 6.4.1 Advisor 鏈式機制深度解析

### 鏈式增強器的核心概念

Spring AI 的 Advisor 系統採用了責任鏈模式（Chain of Responsibility Pattern），允許多個增強器按照特定順序對 AI 請求和回應進行處理。

**鏈式處理流程**：
```
User Request
    ↓
┌─────────────────────────────────────────────────────────────┐
│                    Advisor Chain                            │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │  Advisor 1  │ →  │  Advisor 2  │ →  │  Advisor 3  │     │
│  │ (Order: 0)  │    │ (Order: 10) │    │ (Order: 20) │     │
│  └─────────────┘    └─────────────┘    └─────────────┘     │
└─────────────────────────────────────────────────────────────┘
    ↓
AI Model Processing
    ↓
┌─────────────────────────────────────────────────────────────┐
│                 Response Processing                         │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │  Advisor 3  │ ←  │  Advisor 2  │ ←  │  Advisor 1  │     │
│  │ (Response)  │    │ (Response)  │    │ (Response)  │     │
│  └─────────────┘    └─────────────┘    └─────────────┘     │
└─────────────────────────────────────────────────────────────┘
    ↓
Final Response
```

### Advisor 執行順序控制

```java
/**
 * Advisor 執行順序介面
 */
public interface Ordered {
    int HIGHEST_PRECEDENCE = Integer.MIN_VALUE;
    int LOWEST_PRECEDENCE = Integer.MAX_VALUE;
    
    int getOrder();
}

/**
 * Spring AI Advisor 基礎介面
 */
public interface Advisor extends Ordered {
    String getName();
}

/**
 * CallAdvisor - 非串流場景
 */
public interface CallAdvisor extends Advisor {
    ChatClientResponse adviseCall(
        ChatClientRequest chatClientRequest, 
        CallAdvisorChain callAdvisorChain);
}

/**
 * StreamAdvisor - 串流場景
 */
public interface StreamAdvisor extends Advisor {
    Flux<ChatClientResponse> adviseStream(
        ChatClientRequest chatClientRequest, 
        StreamAdvisorChain streamAdvisorChain);
}

/**
 * Advisor Chain 介面
 */
public interface CallAdvisorChain extends AdvisorChain {
    ChatClientResponse nextCall(ChatClientRequest chatClientRequest);
    List<CallAdvisor> getCallAdvisors();
}

public interface StreamAdvisorChain extends AdvisorChain {
    Flux<ChatClientResponse> nextStream(ChatClientRequest chatClientRequest);
    List<StreamAdvisor> getStreamAdvisors();
}
```

### 內建 Advisor 的執行順序

```java
public class AdvisorOrder {
    // 記憶管理 - 最高優先級
    public static final int MEMORY_ORDER = 0;
    
    // 內容過濾 - 高優先級
    public static final int CONTENT_FILTER_ORDER = 100;
    
    // RAG 檢索 - 中優先級
    public static final int RAG_RETRIEVAL_ORDER = 200;
    
    // 日誌記錄 - 低優先級
    public static final int LOGGING_ORDER = 800;
    
    // 統計監控 - 最低優先級
    public static final int METRICS_ORDER = 900;
}
```

---

## 6.4.2 自定義 Advisor 開發

### 1. 內容過濾 Advisor

```java
import org.springframework.ai.chat.client.advisor.api.*;
import org.springframework.ai.chat.messages.*;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.model.Generation;
import org.springframework.ai.chat.prompt.Prompt;
import java.util.List;

/**
 * 內容過濾增強器
 * 過濾敏感內容和不當言論
 */
@Component
@Slf4j
public class ContentFilterAdvisor implements CallAdvisor {
    
    private final ContentFilterService filterService;
    private final MeterRegistry meterRegistry;
    
    public ContentFilterAdvisor(ContentFilterService filterService, MeterRegistry meterRegistry) {
        this.filterService = filterService;
        this.meterRegistry = meterRegistry;
    }
    
    @Override
    public String getName() {
        return "ContentFilterAdvisor";
    }
    
    @Override
    public int getOrder() {
        return AdvisorOrder.CONTENT_FILTER_ORDER;
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        log.debug("Processing request through content filter");
        
        // 過濾用戶輸入
        String originalContent = extractUserMessage(request);
        FilterResult filterResult = filterService.filterInput(originalContent);
        
        // 記錄過濾統計
        meterRegistry.counter("content.filter.requests", 
            "filtered", String.valueOf(filterResult.isFiltered())).increment();
        
        if (filterResult.isFiltered()) {
            log.warn("Content filtered: {}", filterResult.getReason());
            
            // 如果內容被過濾，替換為安全內容
            request = replaceUserMessage(request, filterResult.getSafeContent());
        }
        
        // 繼續執行鏈中的下一個 Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // 過濾 AI 回應
        String responseContent = response.chatResponse().getResult().getOutput().getContent();
        FilterResult responseFilterResult = filterService.filterOutput(responseContent);
        
        if (responseFilterResult.isFiltered()) {
            log.warn("AI response filtered: {}", responseFilterResult.getReason());
            
            // 替換為安全的回應
            response = replaceResponseContent(response, responseFilterResult.getSafeContent());
        }
        
        return response;
    }
    
    private String extractUserMessage(ChatClientRequest request) {
        return request.prompt().getInstructions().stream()
            .filter(msg -> msg instanceof UserMessage)
            .map(Message::getContent)
            .findFirst()
            .orElse("");
    }
    
    private ChatClientRequest replaceUserMessage(ChatClientRequest request, String safeContent) {
        // 實現訊息替換邏輯
        return request.mutate()
            .prompt(Prompt.from(UserMessage.from(safeContent)))
            .build();
    }
    
    private ChatClientResponse replaceResponseContent(ChatClientResponse response, String safeContent) {
        // 實現回應替換邏輯
        Generation generation = new Generation(new AssistantMessage(safeContent));
        ChatResponse chatResponse = new ChatResponse(List.of(generation));
        return new ChatClientResponse(chatResponse, response.adviseContext());
    }
}
```

### 2. 簡單日誌記錄 Advisor

```java
/**
 * 簡單日誌記錄增強器
 * 記錄所有 AI 請求和回應的詳細資訊
 */
@Component
public class SimpleLoggerAdvisor implements CallAdvisor, StreamAdvisor {
    
    private static final Logger logger = LoggerFactory.getLogger(SimpleLoggerAdvisor.class);
    
    @Override
    public String getName() {
        return this.getClass().getSimpleName();
    }
    
    @Override
    public int getOrder() {
        return 0;
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest chatClientRequest, 
                                       CallAdvisorChain callAdvisorChain) {
        logRequest(chatClientRequest);
        
        ChatClientResponse chatClientResponse = callAdvisorChain.nextCall(chatClientRequest);
        
        logResponse(chatClientResponse);
        
        return chatClientResponse;
    }
    
    @Override
    public Flux<ChatClientResponse> adviseStream(ChatClientRequest chatClientRequest,
                                               StreamAdvisorChain streamAdvisorChain) {
        logRequest(chatClientRequest);
        
        Flux<ChatClientResponse> chatClientResponses = streamAdvisorChain.nextStream(chatClientRequest);
        
        return new ChatClientMessageAggregator()
            .aggregateChatClientResponse(chatClientResponses, this::logResponse);
    }
    
    private void logRequest(ChatClientRequest request) {
        logger.debug("request: {}", request);
    }
    
    private void logResponse(ChatClientResponse chatClientResponse) {
        logger.debug("response: {}", chatClientResponse);
    }
}```

### 3. 企業級日誌記錄 Advisor

```java
/**
 * 企業級日誌記錄增強器
 * 提供完整的審計日誌功能
 */
@Component
@Slf4j
public class EnterpriseLoggingAdvisor implements CallAdvisor {
    
    private final ObjectMapper objectMapper;
    private final AuditLogService auditLogService;
    
    public EnterpriseLoggingAdvisor(ObjectMapper objectMapper, AuditLogService auditLogService) {
        this.objectMapper = objectMapper;
        this.auditLogService = auditLogService;
    }
    
    @Override
    public String getName() {
        return "EnterpriseLoggingAdvisor";
    }
    
    @Override
    public int getOrder() {
        return AdvisorOrder.LOGGING_ORDER;
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String conversationId = extractConversationId(request);
        String userId = extractUserId(request);
        
        try {
            // 記錄請求日誌
            AuditLog auditLog = AuditLog.builder()
                .conversationId(conversationId)
                .userId(userId)
                .eventType("AI_REQUEST")
                .requestContent(extractRequestContent(request))
                .timestamp(LocalDateTime.now())
                .metadata(createMetadata(request))
                .build();
            
            auditLogService.logEvent(auditLog);
            
            // 繼續執行鏈中的下一個 Advisor
            ChatClientResponse response = chain.nextCall(request);
            
            // 記錄回應日誌
            AuditLog responseLog = AuditLog.builder()
                .requestId(auditLog.getId())
                .eventType("AI_RESPONSE")
                .responseContent(extractResponseContent(response))
                .timestamp(LocalDateTime.now())
                .tokenUsage(extractTokenUsage(response))
                .build();
            
            auditLogService.logEvent(responseLog);
            
            return response;
            
        } catch (Exception e) {
            log.error("Failed to log request/response", e);
            // 即使日誌記錄失敗，也要繼續執行
            return chain.nextCall(request);
        }
    }
    
    private String extractRequestContent(ChatClientRequest request) {
        try {
            return objectMapper.writeValueAsString(request.getPrompt().getInstructions());
        } catch (Exception e) {
            return "[Failed to serialize request]";
        }
    }
    
    private String extractResponseContent(ChatClientResponse response) {
        return response.chatResponse().getResult().getOutput().getContent();
    }
    
    private Map<String, Object> createMetadata(ChatClientRequest request) {
        Map<String, Object> metadata = new HashMap<>();
        if (request.chatOptions() != null) {
            metadata.put("model", request.chatOptions().getModel());
            metadata.put("temperature", request.chatOptions().getTemperature());
            metadata.put("maxTokens", request.chatOptions().getMaxTokens());
        }
        return metadata;
    }
}```

### 3. 安全檢查 Advisor

```java
/**
 * 安全檢查增強器
 * 實施訪問控制和安全策略
 */
@Component
@Slf4j
public class SecurityAdvisor implements CallAdvisor {
    
    private final SecurityService securityService;
    private final RateLimitService rateLimitService;
    
    public SecurityAdvisor(SecurityService securityService, RateLimitService rateLimitService) {
        this.securityService = securityService;
        this.rateLimitService = rateLimitService;
    }
    
    @Override
    public String getName() {
        return "SecurityAdvisor";
    }
    
    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE; // 最高優先級
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String userId = extractUserId(request);
        String conversationId = extractConversationId(request);
        
        // 1. 用戶身份驗證
        if (!securityService.isValidUser(userId)) {
            throw new SecurityException("Invalid user: " + userId);
        }
        
        // 2. 權限檢查
        if (!securityService.hasPermission(userId, "AI_CHAT")) {
            throw new SecurityException("User does not have AI chat permission: " + userId);
        }
        
        // 3. 速率限制檢查
        if (!rateLimitService.isAllowed(userId)) {
            throw new RateLimitExceededException("Rate limit exceeded for user: " + userId);
        }
        
        // 4. 內容安全檢查
        String userMessage = extractUserMessage(request);
        if (securityService.containsMaliciousContent(userMessage)) {
            throw new SecurityException("Malicious content detected");
        }
        
        // 5. 對話安全檢查
        if (!securityService.canAccessConversation(userId, conversationId)) {
            throw new SecurityException("User cannot access conversation: " + conversationId);
        }
        
        log.debug("Security check passed for user: {}", userId);
        
        // 繼續執行鏈中的下一個 Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // 回應階段的安全檢查
        String responseContent = response.chatResponse().getResult().getOutput().getContent();
        
        // 檢查回應是否包含敏感資訊
        if (securityService.containsSensitiveInfo(responseContent)) {
            log.warn("Sensitive information detected in AI response");
            
            // 遮蔽敏感資訊
            String sanitizedContent = securityService.sanitizeContent(responseContent);
            response = replaceResponseContent(response, sanitizedContent);
        }
        
        return response;
    }
}
```

---

## 6.4.3 Advisor 組合與配置

### 多 Advisor 組合配置

```java
@Configuration
@EnableConfigurationProperties(AdvisorProperties.class)
public class AdvisorChainConfig {
    
    /**
     * 配置完整的 Advisor 鏈
     */
    @Bean
    public ChatClient advisorChainChatClient(
            ChatModel chatModel,
            List<CallAdvisor> advisors,
            AdvisorProperties properties) {
        
        // 根據 Order 排序 Advisor
        List<CallAdvisor> sortedAdvisors = advisors.stream()
            .sorted(Comparator.comparingInt(CallAdvisor::getOrder))
            .collect(Collectors.toList());
        
        log.info("Configuring ChatClient with {} advisors: {}", 
            sortedAdvisors.size(),
            sortedAdvisors.stream().map(CallAdvisor::getName).collect(Collectors.toList()));
        
        return ChatClient.builder(chatModel)
            .defaultAdvisors(sortedAdvisors)
            .build();
    }
    
    /**
     * 條件化 Advisor 配置
     */
    @Bean
    @ConditionalOnProperty(name = "app.advisor.security.enabled", havingValue = "true")
    public SecurityAdvisor securityAdvisor(SecurityService securityService, RateLimitService rateLimitService) {
        return new SecurityAdvisor(securityService, rateLimitService);
    }
    
    @Bean
    @ConditionalOnProperty(name = "app.advisor.content-filter.enabled", havingValue = "true")
    public ContentFilterAdvisor contentFilterAdvisor(ContentFilterService filterService, MeterRegistry meterRegistry) {
        return new ContentFilterAdvisor(filterService, meterRegistry);
    }
    
    @Bean
    @ConditionalOnProperty(name = "app.advisor.logging.enabled", havingValue = "true")
    public LoggingAdvisor loggingAdvisor(ObjectMapper objectMapper, AuditLogService auditLogService) {
        return new LoggingAdvisor(objectMapper, auditLogService);
    }
    
    /**
     * 自定義 Advisor 鏈建構器
     */
    @Bean
    public AdvisorChainBuilder advisorChainBuilder(List<CallAdvisor> advisors) {
        return new AdvisorChainBuilder(advisors);
    }
}
```

### Advisor 配置屬性

```java
@ConfigurationProperties(prefix = "app.advisor")
@Data
public class AdvisorProperties {
    
    /**
     * 安全 Advisor 配置
     */
    private Security security = new Security();
    
    /**
     * 內容過濾 Advisor 配置
     */
    private ContentFilter contentFilter = new ContentFilter();
    
    /**
     * 日誌 Advisor 配置
     */
    private Logging logging = new Logging();
    
    /**
     * 記憶 Advisor 配置
     */
    private Memory memory = new Memory();
    
    @Data
    public static class Security {
        private boolean enabled = true;
        private int order = -1000;
        private boolean strictMode = false;
        private List<String> allowedUsers = new ArrayList<>();
    }
    
    @Data
    public static class ContentFilter {
        private boolean enabled = true;
        private int order = 100;
        private List<String> blockedWords = new ArrayList<>();
        private boolean enableAiFilter = true;
    }
    
    @Data
    public static class Logging {
        private boolean enabled = true;
        private int order = 800;
        private boolean logRequests = true;
        private boolean logResponses = true;
        private boolean logMetadata = true;
    }
    
    @Data
    public static class Memory {
        private boolean enabled = true;
        private int order = 0;
        private int maxMessages = 100;
        private boolean autoCleanup = true;
    }
}
```

### 動態 Advisor 鏈建構

```java
@Component
public class AdvisorChainBuilder {
    
    private final List<CallAdvisor> availableAdvisors;
    private final AdvisorProperties properties;
    
    public AdvisorChainBuilder(List<CallAdvisor> availableAdvisors, AdvisorProperties properties) {
        this.availableAdvisors = availableAdvisors;
        this.properties = properties;
    }
    
    /**
     * 根據用戶需求建構 Advisor 鏈
     */
    public List<CallAdvisor> buildChain(AdvisorChainRequest request) {
        List<CallAdvisor> chain = new ArrayList<>();
        
        // 1. 安全 Advisor（如果啟用）
        if (request.isSecurityRequired() && properties.getSecurity().isEnabled()) {
            findAdvisor(SecurityAdvisor.class).ifPresent(chain::add);
        }
        
        // 2. 內容過濾 Advisor（如果啟用）
        if (request.isContentFilterRequired() && properties.getContentFilter().isEnabled()) {
            findAdvisor(ContentFilterAdvisor.class).ifPresent(chain::add);
        }
        
        // 3. 記憶 Advisor（如果啟用）
        if (request.isMemoryRequired() && properties.getMemory().isEnabled()) {
            findAdvisor(MessageChatMemoryAdvisor.class).ifPresent(chain::add);
        }
        
        // 4. 自定義 Advisor
        request.getCustomAdvisors().forEach(advisorClass -> {
            findAdvisor(advisorClass).ifPresent(chain::add);
        });
        
        // 5. 日誌 Advisor（如果啟用）
        if (request.isLoggingRequired() && properties.getLogging().isEnabled()) {
            findAdvisor(LoggingAdvisor.class).ifPresent(chain::add);
        }
        
        // 按 Order 排序
        return chain.stream()
            .sorted(Comparator.comparingInt(CallAdvisor::getOrder))
            .collect(Collectors.toList());
    }
    
    private <T extends CallAdvisor> Optional<T> findAdvisor(Class<T> advisorClass) {
        return availableAdvisors.stream()
            .filter(advisorClass::isInstance)
            .map(advisorClass::cast)
            .findFirst();
    }
}
```

---

## 6.4.4 Advisor 效能優化

### 非同步 Advisor 處理

```java
/**
 * 非同步日誌 Advisor
 * 避免日誌記錄影響 AI 回應速度
 */
@Component
@Slf4j
public class AsyncLoggingAdvisor implements CallAdvisor {
    
    private final AsyncAuditLogService asyncAuditLogService;
    private final ExecutorService executorService;
    
    public AsyncLoggingAdvisor(AsyncAuditLogService asyncAuditLogService) {
        this.asyncAuditLogService = asyncAuditLogService;
        this.executorService = Executors.newFixedThreadPool(5, 
            new ThreadFactoryBuilder()
                .setNameFormat("async-logging-%d")
                .setDaemon(true)
                .build());
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        // 非同步記錄請求
        CompletableFuture.runAsync(() -> {
            try {
                logRequest(request);
            } catch (Exception e) {
                log.error("Async request logging failed", e);
            }
        }, executorService);
        
        // 繼續執行鏈中的下一個 Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // 非同步記錄回應
        CompletableFuture.runAsync(() -> {
            try {
                logResponse(response);
            } catch (Exception e) {
                log.error("Async response logging failed", e);
            }
        }, executorService);
        
        return response;
    }
    
    @PreDestroy
    public void shutdown() {
        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
```

### Advisor 快取機制

```java
/**
 * 快取增強的內容過濾 Advisor
 */
@Component
public class CachedContentFilterAdvisor implements CallAdvisor {
    
    private final ContentFilterService filterService;
    private final Cache<String, FilterResult> filterCache;
    
    public CachedContentFilterAdvisor(ContentFilterService filterService, CacheManager cacheManager) {
        this.filterService = filterService;
        this.filterCache = cacheManager.getCache("content-filter", String.class, FilterResult.class);
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String content = extractUserMessage(request);
        String contentHash = DigestUtils.md5Hex(content);
        
        // 嘗試從快取取得過濾結果
        FilterResult cachedResult = filterCache.get(contentHash);
        
        if (cachedResult != null) {
            log.debug("Using cached filter result for content hash: {}", contentHash);
            request = processCachedResult(request, cachedResult);
        } else {
            // 快取未命中，執行過濾並快取結果
            FilterResult filterResult = filterService.filterInput(content);
            filterCache.put(contentHash, filterResult);
            request = processFilterResult(request, filterResult);
        }
        
        // 繼續執行鏈中的下一個 Advisor
        return chain.nextCall(request);
    }
}
```

### Advisor 效能監控

```java
/**
 * Advisor 效能監控服務
 */
@Service
@RequiredArgsConstructor
public class AdvisorMetricsService {
    
    private final MeterRegistry meterRegistry;
    
    /**
     * 記錄 Advisor 執行時間
     */
    public <T> T timeAdvisorExecution(String advisorName, String phase, Supplier<T> operation) {
        return Timer.Sample.start(meterRegistry)
            .stop(Timer.builder("advisor.execution.time")
                .description("Advisor execution time")
                .tag("advisor", advisorName)
                .tag("phase", phase)
                .register(meterRegistry))
            .recordCallable(operation::get);
    }
    
    /**
     * 記錄 Advisor 執行次數
     */
    public void recordAdvisorExecution(String advisorName, String phase, boolean success) {
        meterRegistry.counter("advisor.executions",
            "advisor", advisorName,
            "phase", phase,
            "success", String.valueOf(success))
            .increment();
    }
    
    /**
     * 記錄 Advisor 鏈長度
     */
    public void recordChainLength(int chainLength) {
        meterRegistry.gauge("advisor.chain.length", chainLength);
    }
}
```

---

## 6.4.5 企業級 Advisor 應用場景

### 1. 多租戶 Advisor

```java
/**
 * 多租戶隔離 Advisor
 */
@Component
public class MultiTenantAdvisor implements CallAdvisor {
    
    private final TenantService tenantService;
    private final TenantContextHolder tenantContextHolder;
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String tenantId = extractTenantId(request);
        
        // 驗證租戶
        Tenant tenant = tenantService.validateTenant(tenantId);
        if (tenant == null) {
            throw new IllegalArgumentException("Invalid tenant: " + tenantId);
        }
        
        // 設定租戶上下文
        tenantContextHolder.setCurrentTenant(tenant);
        
        try {
            // 應用租戶特定的配置
            request = applyTenantConfiguration(request, tenant);
            
            // 繼續執行鏈中的下一個 Advisor
            ChatClientResponse response = chain.nextCall(request);
            
            // 應用租戶特定的回應處理
            return applyTenantResponseProcessing(response, tenant);
        } finally {
            // 清理租戶上下文
            tenantContextHolder.clear();
        }
    }
}
```

### 2. 成本控制 Advisor

```java
/**
 * 成本控制 Advisor
 */
@Component
public class CostControlAdvisor implements CallAdvisor {
    
    private final CostTrackingService costTrackingService;
    private final BudgetService budgetService;
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String userId = extractUserId(request);
        
        // 檢查用戶預算
        Budget userBudget = budgetService.getUserBudget(userId);
        if (userBudget.isExceeded()) {
            throw new BudgetExceededException("User budget exceeded: " + userId);
        }
        
        // 估算請求成本
        CostEstimate estimate = costTrackingService.estimateRequestCost(request);
        if (!userBudget.canAfford(estimate.getEstimatedCost())) {
            throw new InsufficientBudgetException("Insufficient budget for request");
        }
        
        // 繼續執行鏈中的下一個 Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // 計算實際成本
        Cost actualCost = costTrackingService.calculateActualCost(response);
        
        // 扣除用戶預算
        budgetService.deductBudget(userId, actualCost);
        
        // 記錄成本統計
        costTrackingService.recordCost(userId, actualCost, estimate);
        
        return response;
    }
}
```

### 3. A/B 測試 Advisor

```java
/**
 * A/B 測試 Advisor
 */
@Component
public class ABTestAdvisor implements CallAdvisor {
    
    private final ABTestService abTestService;
    private final ExperimentService experimentService;
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String userId = extractUserId(request);
        Map<String, String> experiments = new HashMap<>();
        
        // 取得用戶的實驗分組
        List<Experiment> activeExperiments = experimentService.getActiveExperiments(userId);
        
        for (Experiment experiment : activeExperiments) {
            String variant = abTestService.getVariant(userId, experiment.getId());
            
            // 根據實驗變體調整請求
            request = applyExperimentVariant(request, experiment, variant);
            
            // 記錄實驗參與
            experiments.put(experiment.getId(), variant);
        }
        
        // 繼續執行鏈中的下一個 Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // 記錄實驗結果
        experiments.forEach((experimentId, variant) -> {
            abTestService.recordResult(experimentId, variant, response);
        });
        
        return response;
    }
}
```

---

## 📝 本章重點回顧

1. **鏈式機制理解**：掌握了 Advisor 的責任鏈模式和執行順序控制
2. **自定義 Advisor 開發**：學會了開發內容過濾、日誌記錄、安全檢查等增強器
3. **組合配置技巧**：掌握了多 Advisor 的組合配置和動態建構
4. **效能優化策略**：實現了非同步處理、快取機制和效能監控
5. **企業級應用**：建立了多租戶、成本控制、A/B 測試等企業場景的解決方案

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **自定義 Advisor 開發** | ⭐⭐⭐ | 中 | 業務定制化 |
| **Advisor 鏈式組合** | ⭐⭐⭐ | 中 | 功能模組化 |
| **效能優化機制** | ⭐⭐ | 高 | 系統效能 |
| **企業級應用場景** | ⭐⭐⭐ | 高 | 商業價值 |
| **監控和診斷** | ⭐⭐ | 中 | 運維管理 |

### 最佳實踐建議

1. **設計原則**：遵循單一職責原則，每個 Advisor 只負責一個特定功能
2. **執行順序**：合理設計 Advisor 的執行順序，確保依賴關係正確
3. **效能考量**：對於耗時操作使用非同步處理，避免影響 AI 回應速度
4. **錯誤處理**：實現完善的錯誤處理機制，避免單個 Advisor 影響整個鏈
5. **監控告警**：建立完整的 Advisor 執行監控和告警機制

### 下一步學習方向

在下一章中，我們將學習如何自行開發 Spring AI 插件，包括：
- 插件架構設計和開發規範
- 自定義功能模組的實現
- 插件的打包、分發和部署
- 與 Spring AI 生態系統的整合

---

**參考資料：**
- [Spring AI Advisors Documentation](https://docs.spring.io/spring-ai/reference/api/advisors.html)
- [Chain of Responsibility Pattern](https://refactoring.guru/design-patterns/chain-of-responsibility)
- [Spring Boot Conditional Configuration](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration.condition-annotations)
- [Micrometer Metrics](https://micrometer.io/docs)
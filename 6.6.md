# 6.6 安裝 Neo4j 向量資料庫

> **本章重點**：學習如何安裝和配置 Neo4j 向量資料庫，為 Spring AI 的向量記憶功能建立強大的存儲後端。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解向量資料庫概念**：掌握向量資料庫的原理和應用場景
- 🎯 **安裝 Neo4j 資料庫**：學會在不同環境中安裝和配置 Neo4j
- 🎯 **配置向量索引**：建立高效的向量搜尋和存儲機制
- 🎯 **整合 Spring AI**：將 Neo4j 與 Spring AI 記憶系統完美整合
- 🎯 **效能優化調校**：掌握 Neo4j 的效能調校和監控技巧

---

## 6.6.1 向量資料庫概述

### 什麼是向量資料庫？

向量資料庫是專門設計用來存儲、索引和查詢高維向量資料的資料庫系統。在 AI 和機器學習領域，向量資料庫扮演著關鍵角色。

**核心特性**：
- 🔍 **語義搜尋**：基於向量相似性進行搜尋，而非關鍵字匹配
- 📊 **高維支援**：支援數百到數千維的向量資料
- ⚡ **高效檢索**：使用專門的索引算法實現快速相似性搜尋
- 🔄 **實時更新**：支援向量資料的即時插入、更新和刪除
- 📈 **可擴展性**：能夠處理大規模的向量資料集

### 向量資料庫 vs 傳統資料庫

| 特性 | 傳統資料庫 | 向量資料庫 |
|------|------------|------------|
| **資料類型** | 結構化資料 | 高維向量 |
| **查詢方式** | 精確匹配 | 相似性搜尋 |
| **索引方法** | B-Tree, Hash | HNSW, IVF, LSH |
| **應用場景** | 事務處理 | AI/ML 應用 |
| **查詢語言** | SQL | 向量查詢 API |

### Neo4j 作為向量資料庫的優勢

**1. 圖形資料庫基礎**
- 🕸️ **關係建模**：天然支援複雜的資料關係
- 🔗 **圖形查詢**：強大的 Cypher 查詢語言
- 📊 **圖形分析**：內建豐富的圖形算法

**2. 向量功能整合**
- 🎯 **向量索引**：支援高效的向量相似性搜尋
- 🔄 **混合查詢**：結合圖形查詢和向量搜尋
- 📈 **可擴展性**：支援大規模向量資料處理

**3. 企業級特性**
- 🛡️ **ACID 事務**：保證資料一致性
- 🔒 **安全控制**：完整的身份驗證和授權
- 📊 **監控管理**：豐富的監控和管理工具

---

## 6.6.2 Neo4j 安裝方式選擇

### 安裝方式比較

| 安裝方式 | 適用場景 | 優點 | 缺點 |
|----------|----------|------|------|
| **Docker** | 開發、測試 | 快速部署、環境隔離 | 效能略低 |
| **本地安裝** | 生產環境 | 最佳效能、完全控制 | 配置複雜 |
| **Neo4j Desktop** | 開發學習 | 圖形介面、易於使用 | 僅適合開發 |
| **雲端服務** | 企業部署 | 託管服務、高可用 | 成本較高 |

### 系統需求

**最低需求**：
- **CPU**：2 核心
- **記憶體**：4GB RAM
- **存儲**：10GB 可用空間
- **Java**：JDK 17 或更高版本

**推薦配置**：
- **CPU**：4+ 核心
- **記憶體**：8GB+ RAM
- **存儲**：SSD 存儲，50GB+ 可用空間
- **網路**：千兆網路連接

---

## 6.6.3 Docker 方式安裝 Neo4j

### 基本 Docker 安裝

```bash
# 拉取 Neo4j 官方映像
docker pull neo4j:5.15

# 建立 Neo4j 容器
docker run -d \
  --name neo4j-vector \
  -p 7474:7474 \
  -p 7687:7687 \
  -e NEO4J_AUTH=neo4j/password123 \
  -e NEO4J_PLUGINS='["apoc","graph-data-science"]' \
  -v neo4j_data:/data \
  -v neo4j_logs:/logs \
  neo4j:5.15
```

### Docker Compose 配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  neo4j:
    image: neo4j:5.15
    container_name: neo4j-vector
    restart: unless-stopped
    ports:
      - "7474:7474"  # HTTP
      - "7687:7687"  # Bolt
    environment:
      # 認證設定
      NEO4J_AUTH: neo4j/password123
      
      # 插件配置
      NEO4J_PLUGINS: '["apoc","graph-data-science"]'
      
      # 記憶體配置
      NEO4J_dbms_memory_heap_initial__size: 1G
      NEO4J_dbms_memory_heap_max__size: 2G
      NEO4J_dbms_memory_pagecache_size: 1G
      
      # 向量配置
      NEO4J_db_index_vector_enabled: 'true'
      NEO4J_db_index_vector_dimensions_limit: 2048
      
      # 安全配置
      NEO4J_dbms_security_procedures_unrestricted: 'apoc.*,gds.*'
      NEO4J_dbms_security_procedures_allowlist: 'apoc.*,gds.*'
      
      # 效能配置
      NEO4J_dbms_query_cache_size: 1000
      NEO4J_dbms_query_cache_ttl: 70s
      
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs
      - neo4j_import:/var/lib/neo4j/import
      - neo4j_plugins:/plugins
    
    healthcheck:
      test: ["CMD-SHELL", "cypher-shell -u neo4j -p password123 'RETURN 1'"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

volumes:
  neo4j_data:
  neo4j_logs:
  neo4j_import:
  neo4j_plugins:

networks:
  default:
    name: spring-ai-network
```

### 啟動和驗證

```bash
# 啟動 Neo4j
docker-compose up -d

# 檢查容器狀態
docker-compose ps

# 查看日誌
docker-compose logs -f neo4j

# 進入容器
docker exec -it neo4j-vector bash

# 使用 Cypher Shell 連接
docker exec -it neo4j-vector cypher-shell -u neo4j -p password123
```

---

## 6.6.4 Neo4j 向量功能配置

### 啟用向量索引功能

```cypher
-- 檢查向量功能是否啟用
CALL dbms.components() YIELD name, versions, edition
WHERE name = 'Neo4j Kernel'
RETURN name, versions, edition;

-- 檢查可用的索引類型
CALL db.indexes() YIELD name, type, entityType, labelsOrTypes, properties
WHERE type CONTAINS 'VECTOR'
RETURN *;
```

### 建立向量索引

```cypher
-- 建立文檔向量索引
CREATE VECTOR INDEX document_embeddings IF NOT EXISTS
FOR (d:Document)
ON d.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'cosine'
  }
};

-- 建立對話記憶向量索引
CREATE VECTOR INDEX conversation_embeddings IF NOT EXISTS
FOR (m:Message)
ON m.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'cosine'
  }
};

-- 建立用戶查詢向量索引
CREATE VECTOR INDEX query_embeddings IF NOT EXISTS
FOR (q:Query)
ON q.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'euclidean'
  }
};
```

### 向量相似性函數選擇

```cypher
-- Cosine 相似性（推薦用於文本嵌入）
CREATE VECTOR INDEX cosine_index
FOR (n:Node) ON n.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'cosine'
  }
};

-- Euclidean 距離
CREATE VECTOR INDEX euclidean_index
FOR (n:Node) ON n.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'euclidean'
  }
};

-- 內積相似性
CREATE VECTOR INDEX dot_product_index
FOR (n:Node) ON n.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'dot_product'
  }
};
```

---

## 6.6.5 Spring AI 整合配置

### Maven 依賴配置

```xml
<!-- pom.xml -->
<dependencies>
    <!-- Spring AI Neo4j Vector Store -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-starter-vector-store-neo4j</artifactId>
    </dependency>
    
    <!-- Neo4j Java Driver -->
    <dependency>
        <groupId>org.neo4j.driver</groupId>
        <artifactId>neo4j-java-driver</artifactId>
    </dependency>
    
    <!-- Spring Boot Starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Spring AI OpenAI -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
    </dependency>
</dependencies>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-bom</artifactId>
            <version>1.0.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### Spring Boot 配置

```yaml
# application.yml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      chat:
        options:
          model: gpt-4o-mini
          temperature: 0.7
    
    vectorstore:
      neo4j:
        initialize-schema: true
        database-name: neo4j
        index-name: spring-ai-document-index
        embedding-dimension: 1536
        distance-type: cosine
        label: Document
        embedding-property: embedding

  neo4j:
    uri: bolt://localhost:7687
    authentication:
      username: neo4j
      password: password123

# 開發環境配置
---
spring:
  config:
    activate:
      on-profile: dev
  ai:
    vectorstore:
      neo4j:
        initialize-schema: true
  neo4j:
    uri: bolt://localhost:7687
        
# 生產環境配置
---
spring:
  config:
    activate:
      on-profile: prod
  ai:
    vectorstore:
      neo4j:
        initialize-schema: false
  neo4j:
    uri: ${NEO4J_URI}
    authentication:
      username: ${NEO4J_USERNAME}
      password: ${NEO4J_PASSWORD}
```

### Neo4j 向量存儲配置類

```java
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.Logging;
import org.springframework.ai.vectorstore.Neo4jVectorStore;
import org.springframework.ai.vectorstore.Neo4jVectorStore.Neo4jDistanceType;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import io.micrometer.core.instrument.MeterRegistry;
import lombok.extern.slf4j.Slf4j;
import java.util.concurrent.TimeUnit;

/**
 * Neo4j 向量存儲配置
 */
@Configuration
@EnableConfigurationProperties(Neo4jVectorStoreProperties.class)
@Slf4j
public class Neo4jVectorStoreConfig {
    
    /**
     * Neo4j Driver 配置
     */
    @Bean
    public Driver neo4jDriver(@Value("${spring.neo4j.uri}") String uri,
                              @Value("${spring.neo4j.authentication.username}") String username,
                              @Value("${spring.neo4j.authentication.password}") String password) {
        log.info("Configuring Neo4j Driver with URI: {}", uri);
        
        Config config = Config.builder()
            .withConnectionTimeout(30, TimeUnit.SECONDS)
            .withMaxTransactionRetryTime(15, TimeUnit.SECONDS)
            .withLogging(Logging.slf4j())
            .build();
        
        return GraphDatabase.driver(uri, AuthTokens.basic(username, password), config);
    }
    
    /**
     * Neo4j Vector Store 配置
     */
    @Bean
    public Neo4jVectorStore neo4jVectorStore(
            Driver driver,
            EmbeddingModel embeddingModel,
            Neo4jVectorStoreProperties properties) {
        
        log.info("Configuring Neo4j Vector Store");
        
        return Neo4jVectorStore.builder(driver, embeddingModel)
            .databaseName(properties.getDatabaseName())
            .embeddingDimension(properties.getEmbeddingDimension())
            .distanceType(Neo4jDistanceType.valueOf(properties.getDistanceType().toUpperCase()))
            .indexName(properties.getIndexName())
            .label(properties.getLabel())
            .embeddingProperty(properties.getEmbeddingProperty())
            .initializeSchema(properties.isInitializeSchema())
            .build();
    }
    
    /**
     * Neo4j 健康檢查
     */
    @Bean
    public Neo4jHealthIndicator neo4jHealthIndicator(Driver driver) {
        return new Neo4jHealthIndicator(driver);
    }
    
    /**
     * Neo4j 監控指標
     */
    @Bean
    public Neo4jMetrics neo4jMetrics(Driver driver, MeterRegistry meterRegistry) {
        return new Neo4jMetrics(driver, meterRegistry);
    }
}
```

### 配置屬性類

```java
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;
import lombok.Data;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Min;
import javax.validation.constraints.Max;
import java.time.Duration;

/**
 * Neo4j 向量存儲配置屬性
 */
@ConfigurationProperties(prefix = "spring.ai.vectorstore.neo4j")
@Data
@Validated
public class Neo4jVectorStoreProperties {
    
    /**
     * 是否初始化 Schema
     */
    private boolean initializeSchema = false;
    
    /**
     * 資料庫名稱
     */
    private String databaseName = "neo4j";
    
    /**
     * 向量維度
     */
    @Min(1)
    @Max(4096)
    private int embeddingDimension = 1536;
    
    /**
     * 距離函數類型
     */
    private String distanceType = "cosine";
    
    /**
     * 索引名稱
     */
    private String indexName = "spring_ai_embeddings";
    
    /**
     * 節點標籤
     */
    private String label = "Document";
    
    /**
     * 嵌入屬性名稱
     */
    private String embeddingProperty = "embedding";
    
    
    // Getter 和 Setter 方法
    public boolean isInitializeSchema() {
        return initializeSchema;
    }
    
    public void setInitializeSchema(boolean initializeSchema) {
        this.initializeSchema = initializeSchema;
    }
    
    public String getDatabaseName() {
        return databaseName;
    }
    
    public void setDatabaseName(String databaseName) {
        this.databaseName = databaseName;
    }
}
```

---

## 6.6.6 Neo4j 效能優化

### 記憶體配置優化

```bash
# neo4j.conf 配置檔案

# JVM 堆記憶體配置
server.memory.heap.initial_size=2G
server.memory.heap.max_size=4G

# 頁面快取配置（用於存儲節點和關係）
server.memory.pagecache.size=2G

# 事務狀態記憶體
db.memory.transaction.global_max_size=1G
db.memory.transaction.max_size=100M

# 查詢記憶體配置
dbms.memory.query.max_size=500M
dbms.memory.query.cache_size=1000
```

### 向量索引優化

```cypher
-- 檢查向量索引狀態
CALL db.indexes() YIELD name, type, state, populationPercent
WHERE type CONTAINS 'VECTOR'
RETURN name, type, state, populationPercent;

-- 重建向量索引（如果需要）
DROP INDEX document_embeddings IF EXISTS;
CREATE VECTOR INDEX document_embeddings
FOR (d:Document)
ON d.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'cosine',
    `vector.hnsw.max_connections`: 16,
    `vector.hnsw.ef_construction`: 200
  }
};

-- 檢查索引效能
CALL db.index.fulltext.queryNodes('document_embeddings', 'test') 
YIELD node, score
RETURN count(node) as total_nodes;
```

### 查詢效能優化

```cypher
-- 使用 EXPLAIN 分析查詢計劃
EXPLAIN
CALL db.index.vector.queryNodes('document_embeddings', 10, $queryVector)
YIELD node, score
RETURN node.content, score
ORDER BY score DESC
LIMIT 5;

-- 使用 PROFILE 分析查詢效能
PROFILE
CALL db.index.vector.queryNodes('document_embeddings', 10, $queryVector)
YIELD node, score
WHERE score > 0.8
RETURN node.content, score
ORDER BY score DESC
LIMIT 5;
```

### 監控和診斷

```java
/**
 * Neo4j 效能監控服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class Neo4jMonitoringService {
    
    private final Driver driver;
    private final MeterRegistry meterRegistry;
    
    @EventListener
    @Async
    public void handleVectorQuery(VectorQueryEvent event) {
        // 記錄向量查詢統計
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("neo4j.vector.query.time")
            .description("Neo4j vector query execution time")
            .tag("index", event.getIndexName())
            .register(meterRegistry));
        
        meterRegistry.counter("neo4j.vector.query.count",
            "index", event.getIndexName(),
            "success", String.valueOf(event.isSuccess()))
            .increment();
    }
    
    /**
     * 取得資料庫統計資訊
     */
    @Scheduled(fixedRate = 60000) // 每分鐘執行一次
    public void collectDatabaseStats() {
        try (Session session = driver.session()) {
            // 節點數量統計
            Result nodeCountResult = session.run("MATCH (n) RETURN count(n) as nodeCount");
            long nodeCount = nodeCountResult.single().get("nodeCount").asLong();
            meterRegistry.gauge("neo4j.nodes.count", nodeCount);
            
            // 關係數量統計
            Result relCountResult = session.run("MATCH ()-[r]->() RETURN count(r) as relCount");
            long relCount = relCountResult.single().get("relCount").asLong();
            meterRegistry.gauge("neo4j.relationships.count", relCount);
            
            // 向量索引統計
            Result indexResult = session.run(
                "CALL db.indexes() YIELD name, type, state, populationPercent " +
                "WHERE type CONTAINS 'VECTOR' " +
                "RETURN name, populationPercent"
            );
            
            while (indexResult.hasNext()) {
                Record record = indexResult.next();
                String indexName = record.get("name").asString();
                double populationPercent = record.get("populationPercent").asDouble();
                
                meterRegistry.gauge("neo4j.index.population.percent",
                    Tags.of("index", indexName), populationPercent);
            }
            
        } catch (Exception e) {
            log.error("Failed to collect Neo4j statistics", e);
        }
    }
    
    /**
     * 檢查資料庫健康狀態
     */
    public DatabaseHealthStatus checkHealth() {
        try (Session session = driver.session()) {
            // 執行簡單查詢測試連接
            session.run("RETURN 1").consume();
            
            // 檢查向量索引狀態
            Result indexResult = session.run(
                "CALL db.indexes() YIELD name, type, state " +
                "WHERE type CONTAINS 'VECTOR' AND state <> 'ONLINE' " +
                "RETURN count(*) as offlineIndexes"
            );
            
            long offlineIndexes = indexResult.single().get("offlineIndexes").asLong();
            
            return DatabaseHealthStatus.builder()
                .healthy(true)
                .offlineIndexes(offlineIndexes)
                .timestamp(LocalDateTime.now())
                .build();
                
        } catch (Exception e) {
            log.error("Neo4j health check failed", e);
            return DatabaseHealthStatus.builder()
                .healthy(false)
                .error(e.getMessage())
                .timestamp(LocalDateTime.now())
                .build();
        }
    }
}
```

---

## 6.6.7 測試和驗證

### 基本功能測試

```java
/**
 * Neo4j 向量存儲測試
 */
@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class Neo4jVectorStoreTest {
    
    @Autowired
    private Neo4jVectorStore vectorStore;
    
    @Autowired
    private EmbeddingModel embeddingModel;
    
    private static final String TEST_CONTENT_1 = "Spring AI is a powerful framework for building AI applications.";
    private static final String TEST_CONTENT_2 = "Neo4j is a graph database that supports vector operations.";
    
    @Test
    @Order(1)
    void testAddDocuments() {
        // 建立測試文檔
        List<Document> documents = Arrays.asList(
            new Document(TEST_CONTENT_1, Map.of("category", "framework")),
            new Document(TEST_CONTENT_2, Map.of("category", "database"))
        );
        
        // 添加到向量存儲
        vectorStore.add(documents);
        
        // 驗證文檔已添加
        assertThat(documents).allMatch(doc -> doc.getId() != null);
    }
    
    @Test
    @Order(2)
    void testSimilaritySearch() {
        // 執行相似性搜尋
        String query = "What is Spring AI?";
        List<Document> results = vectorStore.similaritySearch(
            SearchRequest.builder().query(query).topK(5).build()
        );
        
        // 驗證搜尋結果
        assertThat(results).isNotEmpty();
        assertThat(results.get(0).getContent()).contains("Spring AI");
    }
    
    @Test
    @Order(3)
    void testSimilaritySearchWithThreshold() {
        // 使用相似性閾值搜尋
        String query = "graph database";
        List<Document> results = vectorStore.similaritySearch(
            SearchRequest.builder()
                .query(query)
                .topK(10)
                .similarityThreshold(0.7)
                .build()
        );
        
        // 驗證結果符合閾值要求
        assertThat(results).isNotEmpty();
        results.forEach(doc -> {
            assertThat(doc.getMetadata()).containsKey("distance");
            double similarity = 1.0 - (Double) doc.getMetadata().get("distance");
            assertThat(similarity).isGreaterThanOrEqualTo(0.7);
        });
    }
    
    @Test
    @Order(4)
    void testDeleteDocuments() {
        // 搜尋要刪除的文檔
        List<Document> documents = vectorStore.similaritySearch(
            SearchRequest.builder().query(TEST_CONTENT_1).topK(1).build()
        );
        
        assertThat(documents).isNotEmpty();
        
        // 刪除文檔
        List<String> idsToDelete = documents.stream()
            .map(Document::getId)
            .collect(Collectors.toList());
        
        vectorStore.delete(idsToDelete);
        
        // 驗證文檔已刪除
        List<Document> remainingDocs = vectorStore.similaritySearch(
            SearchRequest.builder().query(TEST_CONTENT_1).topK(1).build()
        );
        
        assertThat(remainingDocs).isEmpty();
    }
}
```

### 效能測試

```java
/**
 * Neo4j 向量存儲效能測試
 */
@SpringBootTest
class Neo4jVectorStorePerformanceTest {
    
    @Autowired
    private Neo4jVectorStore vectorStore;
    
    @Test
    void testBatchInsertPerformance() {
        int batchSize = 1000;
        List<Document> documents = generateTestDocuments(batchSize);
        
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        vectorStore.add(documents);
        
        stopWatch.stop();
        
        long executionTime = stopWatch.getTotalTimeMillis();
        double documentsPerSecond = (double) batchSize / (executionTime / 1000.0);
        
        log.info("Batch insert performance: {} documents in {} ms ({} docs/sec)",
            batchSize, executionTime, String.format("%.2f", documentsPerSecond));
        
        // 驗證效能指標
        assertThat(documentsPerSecond).isGreaterThan(10); // 至少 10 docs/sec
    }
    
    @Test
    void testSearchPerformance() {
        // 先插入測試資料
        List<Document> documents = generateTestDocuments(5000);
        vectorStore.add(documents);
        
        // 測試搜尋效能
        String query = "test query for performance";
        int iterations = 100;
        
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        for (int i = 0; i < iterations; i++) {
            vectorStore.similaritySearch(
                SearchRequest.builder().query(query + " " + i).topK(10).build()
            );
        }
        
        stopWatch.stop();
        
        long totalTime = stopWatch.getTotalTimeMillis();
        double avgQueryTime = (double) totalTime / iterations;
        
        log.info("Search performance: {} queries in {} ms (avg: {} ms/query)",
            iterations, totalTime, String.format("%.2f", avgQueryTime));
        
        // 驗證搜尋效能
        assertThat(avgQueryTime).isLessThan(1000); // 平均查詢時間小於 1 秒
    }
    
    private List<Document> generateTestDocuments(int count) {
        return IntStream.range(0, count)
            .mapToObj(i -> new Document(
                "Test document content " + i + " with some random text for testing purposes.",
                Map.of("index", i, "category", "test")
            ))
            .collect(Collectors.toList());
    }
}
```

---

## 📝 本章重點回顧

1. **向量資料庫概念**：理解了向量資料庫的原理和 Neo4j 的優勢
2. **Docker 安裝配置**：掌握了使用 Docker 和 Docker Compose 安裝 Neo4j
3. **向量索引建立**：學會了建立和配置高效的向量索引
4. **Spring AI 整合**：完成了 Neo4j 與 Spring AI 的完整整合配置
5. **效能優化調校**：實現了記憶體配置、索引優化和監控機制

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **Docker 部署** | ⭐⭐⭐ | 低 | 快速部署 |
| **向量索引配置** | ⭐⭐⭐ | 中 | 搜尋效能 |
| **Spring AI 整合** | ⭐⭐⭐ | 中 | 功能整合 |
| **效能優化** | ⭐⭐ | 高 | 生產就緒 |
| **監控診斷** | ⭐⭐ | 中 | 運維管理 |

### 最佳實踐建議

1. **環境規劃**：根據應用規模選擇合適的部署方式和硬體配置
2. **索引設計**：合理選擇向量維度和相似性函數，優化搜尋效能
3. **記憶體配置**：根據資料量和查詢頻率調整記憶體分配
4. **監控告警**：建立完整的效能監控和健康檢查機制
5. **備份策略**：制定定期備份和災難恢復計劃

### 下一步學習方向

在下一章中，我們將學習如何使用向量資料庫作為對話的長久記憶，包括：
- VectorStoreChatMemoryAdvisor 的使用
- 語義相似性搜尋的實現
- 大規模對話歷史的管理
- 智能記憶檢索策略

---

**參考資料：**
- [Neo4j Vector Index Documentation](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/)
- [Spring AI Neo4j Vector Store](https://docs.spring.io/spring-ai/reference/api/vectordbs/neo4j.html)
- [Neo4j Docker Documentation](https://neo4j.com/developer/docker/)
- [Neo4j Performance Tuning](https://neo4j.com/developer/guide-performance-tuning/)
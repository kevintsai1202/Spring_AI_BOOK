# 5.8 Function Calling (下) - 最終組合技

> **本章重點**：掌握 Function Calling 的進階技巧，包括工具鏈式調用、條件式執行和複雜業務邏輯的實現，建立企業級的智能工具生態系統。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握工具鏈調用**：理解 AI 如何自動進行多層次工具調用
- 🎯 **實現條件式執行**：根據不同條件智能選擇和組合工具
- 🎯 **設計複雜工具鏈**：建立多步驟的業務流程自動化
- 🎯 **優化工具效能**：掌握工具調用的效能優化和成本控制
- 🎯 **建立工具生態**：設計可擴展的企業級工具管理系統

---

## 5.8.1 讓 AI 自己調用程式

### Function Calling 的進階特性

![AI 自動調用](https://ithelp.ithome.com.tw/upload/images/20240812/20161290El6Y5FmnHN.png)

原本 Function Call 只打算寫兩篇，不過最近參考其他框架發現 **Function Calling 是會被反覆調用的**，測試後發現 Spring AI 也有類似的效果。

Spring AI 會先去調用符合的 Function 並取得資料，之後會再拿取得的資料確認是否還有可匹配的 Function，並將目前取得的結果再次呼叫 Function。

### 工具鏈調用的核心概念

**1. 自動鏈式調用**
- 🔗 **智能串聯**：AI 自動判斷需要調用哪些工具
- 📊 **資料流轉**：前一個工具的輸出成為下一個工具的輸入
- 🎯 **目標導向**：AI 持續調用工具直到滿足使用者需求
- 🔄 **迭代優化**：根據中間結果調整後續調用策略

**2. 傳統方式 vs 工具鏈方式**

| 比較項目 | 傳統單一工具 | 工具鏈調用 |
|----------|-------------|------------|
| **資料處理** | 一次性返回所有資料 | 按需獲取，分步處理 |
| **成本控制** | 高（傳輸大量資料） | 低（按需調用） |
| **靈活性** | 低（固定資料結構） | 高（動態組合） |
| **維護性** | 複雜（單一工具承擔多責任） | 簡單（職責分離） |
| **擴展性** | 困難（修改影響全局） | 容易（獨立工具模組） |

**3. 工具鏈調用的優勢**

```
❌ 傳統方式：
用戶查詢 → 單一大型工具 → 返回所有相關資料 → AI 分析

✅ 工具鏈方式：
用戶查詢 → 工具A（基礎資料） → 工具B（詳細資訊） → 工具C（分析計算） → AI 整合回應
```

---

## 5.8.2 複雜工具鏈實現

### 程式目標設定

**實戰場景**：詢問 AI 公司去年最熱銷的產品，並列出該產品所有型號

**工具鏈流程**：
1. 🔍 **銷售查詢工具** → 獲取去年所有產品銷售資料
2. 📊 **資料分析工具** → 找出最熱銷產品
3. 🔎 **產品詳情工具** → 查詢該產品的所有型號
4. 🧮 **計算工具** → 進行相關統計計算
5. 🎯 **AI 整合** → 生成完整分析報告

### 產品詳情工具實現

**步驟 1：產品型號查詢工具**

```java
package com.example.tools;

import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

@Component
@Slf4j
public class ProductDetailsTools {
    
    /**
     * 產品詳情資料模型
     */
    public record ProductDetail(
            String product,
            String productName,
            List<String> models,
            String category,
            String description
    ) {}
    
    /**
     * 產品型號資料模型
     */
    public record ProductModel(
            String modelCode,
            String modelName,
            String specifications,
            String price,
            String availability
    ) {}
    
    /**
     * 根據產品名稱獲取產品型號列表
     * @param product 產品代碼或名稱
     * @return 產品詳情包含所有型號
     */
    @Tool(description = "Get detailed product information including all available models by product code or name. " +
          "Returns comprehensive product details with model specifications.")
    public ProductDetail getProductModels(String product) {
        try {
            log.info("查詢產品型號：{}", product);
            
            // 模擬企業產品資料庫
            Map<String, ProductDetail> productDatabase = Map.of(
                "PD-1405", new ProductDetail(
                    "PD-1405",
                    "智能手機 Pro 系列",
                    List.of("1405-001", "1405-002", "1405-003", "1405-004"),
                    "智能手機",
                    "高端智能手機系列，支援 5G 和 AI 攝影"
                ),
                "PD-1234", new ProductDetail(
                    "PD-1234",
                    "筆記型電腦 Ultra 系列",
                    List.of("1234-1", "1234-2", "1234-3", "1234-4", "1234-5"),
                    "筆記型電腦",
                    "輕薄高效能筆記型電腦，適合商務和創作"
                ),
                "PD-1235", new ProductDetail(
                    "PD-1235",
                    "平板電腦系列",
                    List.of("1235-4", "1235-5", "1235-6"),
                    "平板電腦",
                    "多功能平板電腦，支援手寫筆和鍵盤"
                ),
                "PD-1385", new ProductDetail(
                    "PD-1385",
                    "智能手錶系列",
                    List.of("1385-1", "1385-2", "1385-3", "1385-4"),
                    "穿戴裝置",
                    "健康監測智能手錶，支援運動追蹤和心率監測"
                ),
                "PD-1255", new ProductDetail(
                    "PD-1255",
                    "無線耳機系列",
                    List.of("1255-1", "1255-2"),
                    "音響設備",
                    "主動降噪無線耳機，高品質音效體驗"
                ),
                "PD-1300", new ProductDetail(
                    "PD-1300",
                    "智能音箱系列",
                    List.of("1300-1", "1300-2", "1300-3"),
                    "智能家居",
                    "AI 語音助手智能音箱，支援智能家居控制"
                )
            );
            
            ProductDetail result = productDatabase.get(product);
            if (result == null) {
                // 嘗試模糊匹配
                result = productDatabase.values().stream()
                        .filter(pd -> pd.productName().toLowerCase().contains(product.toLowerCase()))
                        .findFirst()
                        .orElse(new ProductDetail(
                                product,
                                "未知產品",
                                List.of("無此產品型號"),
                                "未分類",
                                "查無此產品資訊"
                        ));
            }
            
            log.info("查詢完成，產品：{}，型號數量：{}", 
                    result.productName(), result.models().size());
            
            return result;
            
        } catch (Exception e) {
            log.error("查詢產品型號失敗：{}", product, e);
            return new ProductDetail(
                    product,
                    "查詢失敗",
                    List.of("系統錯誤"),
                    "錯誤",
                    "查詢產品資訊時發生錯誤：" + e.getMessage()
            );
        }
    }
    
    /**
     * 獲取特定型號的詳細規格
     * @param productCode 產品代碼
     * @param modelCode 型號代碼
     * @return 型號詳細資訊
     */
    @Tool(description = "Get detailed specifications for a specific product model. " +
          "Returns comprehensive model information including price and availability.")
    public ProductModel getModelSpecifications(String productCode, String modelCode) {
        try {
            log.info("查詢型號規格：{}-{}", productCode, modelCode);
            
            // 模擬型號規格資料庫
            String fullModelCode = productCode + "-" + modelCode;
            
            // 根據產品類型生成規格資訊
            ProductModel model = switch (productCode) {
                case "PD-1405" -> new ProductModel(
                        modelCode,
                        "智能手機 Pro " + modelCode,
                        generatePhoneSpecs(modelCode),
                        generatePrice("phone", modelCode),
                        "現貨供應"
                );
                case "PD-1234" -> new ProductModel(
                        modelCode,
                        "筆記型電腦 Ultra " + modelCode,
                        generateLaptopSpecs(modelCode),
                        generatePrice("laptop", modelCode),
                        "現貨供應"
                );
                case "PD-1385" -> new ProductModel(
                        modelCode,
                        "智能手錶 " + modelCode,
                        generateWatchSpecs(modelCode),
                        generatePrice("watch", modelCode),
                        "現貨供應"
                );
                default -> new ProductModel(
                        modelCode,
                        "產品型號 " + modelCode,
                        "標準規格",
                        "價格面議",
                        "請洽詢"
                );
            };
            
            log.info("型號規格查詢完成：{}", model.modelName());
            return model;
            
        } catch (Exception e) {
            log.error("查詢型號規格失敗：{}-{}", productCode, modelCode, e);
            return new ProductModel(
                    modelCode,
                    "查詢失敗",
                    "無法獲取規格資訊",
                    "價格未知",
                    "查詢錯誤"
            );
        }
    }
    
    private String generatePhoneSpecs(String modelCode) {
        return switch (modelCode) {
            case "1405-001" -> "6.1吋 OLED 螢幕, 128GB 儲存, 雙鏡頭";
            case "1405-002" -> "6.1吋 OLED 螢幕, 256GB 儲存, 三鏡頭";
            case "1405-003" -> "6.7吋 OLED 螢幕, 512GB 儲存, 三鏡頭 Pro";
            case "1405-004" -> "6.7吋 OLED 螢幕, 1TB 儲存, 四鏡頭 Pro Max";
            default -> "標準智能手機規格";
        };
    }
    
    private String generateLaptopSpecs(String modelCode) {
        return switch (modelCode) {
            case "1234-1" -> "13吋, Intel i5, 8GB RAM, 256GB SSD";
            case "1234-2" -> "13吋, Intel i7, 16GB RAM, 512GB SSD";
            case "1234-3" -> "15吋, Intel i7, 16GB RAM, 1TB SSD";
            case "1234-4" -> "15吋, Intel i9, 32GB RAM, 1TB SSD";
            case "1234-5" -> "16吋, Intel i9, 64GB RAM, 2TB SSD";
            default -> "標準筆記型電腦規格";
        };
    }
    
    private String generateWatchSpecs(String modelCode) {
        return switch (modelCode) {
            case "1385-1" -> "41mm, GPS, 心率監測";
            case "1385-2" -> "45mm, GPS, 心率監測, 血氧檢測";
            case "1385-3" -> "41mm, GPS+Cellular, 心率監測, 血氧檢測";
            case "1385-4" -> "45mm, GPS+Cellular, 心率監測, 血氧檢測, ECG";
            default -> "標準智能手錶規格";
        };
    }
    
    private String generatePrice(String category, String modelCode) {
        return switch (category) {
            case "phone" -> switch (modelCode) {
                case "1405-001" -> "NT$ 25,900";
                case "1405-002" -> "NT$ 29,900";
                case "1405-003" -> "NT$ 35,900";
                case "1405-004" -> "NT$ 42,900";
                default -> "NT$ 25,000";
            };
            case "laptop" -> switch (modelCode) {
                case "1234-1" -> "NT$ 35,900";
                case "1234-2" -> "NT$ 45,900";
                case "1234-3" -> "NT$ 55,900";
                case "1234-4" -> "NT$ 75,900";
                case "1234-5" -> "NT$ 95,900";
                default -> "NT$ 40,000";
            };
            case "watch" -> switch (modelCode) {
                case "1385-1" -> "NT$ 12,900";
                case "1385-2" -> "NT$ 15,900";
                case "1385-3" -> "NT$ 18,900";
                case "1385-4" -> "NT$ 22,900";
                default -> "NT$ 15,000";
            };
            default -> "價格面議";
        };
    }
}
```

### 增強版銷售工具

**步驟 2：銷售資料分析工具**

```java
package com.example.tools;

import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Component
@Slf4j
public class EnhancedSalesTools {
    
    /**
     * 產品銷售資料模型
     */
    public record ProductSales(
            String product,
            String productName,
            int salesVolume,
            BigDecimal revenue,
            String category,
            double marketShare
    ) {}
    
    /**
     * 銷售排行資料模型
     */
    public record SalesRanking(
            List<ProductSales> topProducts,
            ProductSales bestSeller,
            int totalVolume,
            BigDecimal totalRevenue,
            String analysisYear
    ) {}
    
    /**
     * 獲取指定年份的產品銷售資料
     * @param year 查詢年份
     * @return 銷售資料列表
     */
    @Tool(description = "Get comprehensive product sales data for a specific year. " +
          "Returns detailed sales information including volume, revenue, and market share.")
    public SalesRanking getProductSalesRanking(int year) {
        try {
            log.info("查詢年度銷售排行：{}", year);
            
            List<ProductSales> salesData = getSalesDataByYear(year);
            
            if (salesData.isEmpty()) {
                return new SalesRanking(
                        List.of(),
                        null,
                        0,
                        BigDecimal.ZERO,
                        String.valueOf(year)
                );
            }
            
            // 計算總銷量和總營收
            int totalVolume = salesData.stream()
                    .mapToInt(ProductSales::salesVolume)
                    .sum();
            
            BigDecimal totalRevenue = salesData.stream()
                    .map(ProductSales::revenue)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            // 按銷量排序
            List<ProductSales> topProducts = salesData.stream()
                    .sorted((p1, p2) -> Integer.compare(p2.salesVolume(), p1.salesVolume()))
                    .collect(Collectors.toList());
            
            ProductSales bestSeller = topProducts.get(0);
            
            SalesRanking ranking = new SalesRanking(
                    topProducts,
                    bestSeller,
                    totalVolume,
                    totalRevenue,
                    String.valueOf(year)
            );
            
            log.info("銷售排行查詢完成：{}年，最佳銷售產品：{}", 
                    year, bestSeller.productName());
            
            return ranking;
            
        } catch (Exception e) {
            log.error("查詢銷售排行失敗：{}", year, e);
            throw new RuntimeException("查詢銷售排行失敗：" + e.getMessage());
        }
    }
    
    /**
     * 比較不同產品的銷售表現
     * @param year 比較年份
     * @param products 產品代碼列表
     * @return 比較結果
     */
    @Tool(description = "Compare sales performance between multiple products in a specific year. " +
          "Returns detailed comparison with rankings and performance metrics.")
    public String compareProductPerformance(int year, List<String> products) {
        try {
            log.info("比較產品銷售表現：{}年，產品：{}", year, products);
            
            List<ProductSales> allSales = getSalesDataByYear(year);
            
            List<ProductSales> targetProducts = allSales.stream()
                    .filter(sale -> products.contains(sale.product()))
                    .sorted((p1, p2) -> Integer.compare(p2.salesVolume(), p1.salesVolume()))
                    .collect(Collectors.toList());
            
            if (targetProducts.isEmpty()) {
                return "未找到指定產品的銷售資料";
            }
            
            StringBuilder comparison = new StringBuilder();
            comparison.append(String.format("📊 %d年產品銷售表現比較\n\n", year));
            
            for (int i = 0; i < targetProducts.size(); i++) {
                ProductSales product = targetProducts.get(i);
                comparison.append(String.format(
                        "%d. %s (%s)\n" +
                        "   銷售量：%,d 台\n" +
                        "   營收：%s\n" +
                        "   市場占有率：%.2f%%\n\n",
                        i + 1,
                        product.productName(),
                        product.product(),
                        product.salesVolume(),
                        formatCurrency(product.revenue()),
                        product.marketShare()
                ));
            }
            
            // 添加分析洞察
            ProductSales winner = targetProducts.get(0);
            comparison.append("🏆 **分析洞察**\n");
            comparison.append(String.format(
                    "- 最佳表現：%s，銷售量領先\n",
                    winner.productName()
            ));
            
            if (targetProducts.size() > 1) {
                ProductSales second = targetProducts.get(1);
                double gap = ((double) (winner.salesVolume() - second.salesVolume()) / second.salesVolume()) * 100;
                comparison.append(String.format(
                        "- 領先優勢：比第二名多 %.1f%%\n",
                        gap
                ));
            }
            
            log.info("產品比較完成");
            return comparison.toString();
            
        } catch (Exception e) {
            log.error("比較產品銷售表現失敗", e);
            return "比較產品銷售表現失敗：" + e.getMessage();
        }
    }
    
    private List<ProductSales> getSalesDataByYear(int year) {
        // 模擬不同年份的銷售資料
        Map<Integer, List<ProductSales>> salesDatabase = Map.of(
            2023, List.of(
                new ProductSales("PD-1385", "智能手錶系列", 15000, 
                        new BigDecimal("300000000"), "穿戴裝置", 35.7),
                new ProductSales("PD-1234", "筆記型電腦 Ultra 系列", 10000, 
                        new BigDecimal("800000000"), "筆記型電腦", 23.8),
                new ProductSales("PD-1405", "智能手機 Pro 系列", 8500, 
                        new BigDecimal("425000000"), "智能手機", 20.2),
                new ProductSales("PD-1235", "平板電腦系列", 1500, 
                        new BigDecimal("75000000"), "平板電腦", 3.6),
                new ProductSales("PD-1255", "無線耳機系列", 800, 
                        new BigDecimal("24000000"), "音響設備", 1.9),
                new ProductSales("PD-1300", "智能音箱系列", 500, 
                        new BigDecimal("15000000"), "智能家居", 1.2)
            ),
            2024, List.of(
                new ProductSales("PD-1405", "智能手機 Pro 系列", 18500, 
                        new BigDecimal("925000000"), "智能手機", 28.5),
                new ProductSales("PD-1385", "智能手錶系列", 17000, 
                        new BigDecimal("510000000"), "穿戴裝置", 26.2),
                new ProductSales("PD-1234", "筆記型電腦 Ultra 系列", 12000, 
                        new BigDecimal("960000000"), "筆記型電腦", 18.5),
                new ProductSales("PD-1235", "平板電腦系列", 8500, 
                        new BigDecimal("425000000"), "平板電腦", 13.1),
                new ProductSales("PD-1255", "無線耳機系列", 5500, 
                        new BigDecimal("165000000"), "音響設備", 8.5),
                new ProductSales("PD-1300", "智能音箱系列", 3500, 
                        new BigDecimal("105000000"), "智能家居", 5.4)
            )
        );
        
        return salesDatabase.getOrDefault(year, List.of());
    }
    
    private String formatCurrency(BigDecimal amount) {
        if (amount.compareTo(new BigDecimal("100000000")) >= 0) {
            return String.format("NT$ %.1f億", 
                    amount.divide(new BigDecimal("100000000"), 1, RoundingMode.HALF_UP).doubleValue());
        } else if (amount.compareTo(new BigDecimal("10000")) >= 0) {
            return String.format("NT$ %.0f萬", 
                    amount.divide(new BigDecimal("10000"), 0, RoundingMode.HALF_UP).doubleValue());
        } else {
            return String.format("NT$ %,d", amount.intValue());
        }
    }
}
```

---

## 5.8.3 工具鏈協調系統

### ChatClient 進階配置

```java
package com.example.config;

import com.example.tools.*;
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@RequiredArgsConstructor
public class AdvancedAiConfig {
    
    private final ProductDetailsTools productDetailsTools;
    private final EnhancedSalesTools enhancedSalesTools;
    private final DateTimeTools dateTimeTools;
    private final CalculatorTools calculatorTools;
    
    /**
     * 企業級工具鏈 ChatClient
     * 支援複雜的多步驟工具調用
     */
    @Bean
    public ChatClient toolChainChatClient(ChatModel chatModel) {
        return ChatClient.builder(chatModel)
                .defaultTools(
                    enhancedSalesTools,     // 銷售資料分析工具
                    productDetailsTools,    // 產品詳情工具
                    calculatorTools,        // 計算工具
                    dateTimeTools          // 時間工具
                )
                .defaultSystem("""
                    你是一個專業的企業資料分析專家，擅長使用多種工具進行深度分析。
                    
                    工具使用策略：
                    1. 根據用戶查詢自動選擇合適的工具組合
                    2. 按邏輯順序調用工具（先獲取基礎資料，再進行詳細分析）
                    3. 充分利用工具鏈的優勢，避免一次性獲取過多資料
                    4. 提供深入的分析洞察和商業建議
                    
                    可用工具：
                    - 銷售排行分析：獲取年度銷售資料和排行
                    - 產品詳情查詢：獲取產品型號和規格資訊
                    - 產品比較分析：比較多個產品的銷售表現
                    - 數學計算：進行各種統計計算
                    - 時間查詢：獲取當前時間和日期資訊
                    
                    回答風格：
                    - 使用專業但易懂的語言
                    - 提供結構化的分析結果
                    - 包含具體的數據和洞察
                    - 給出實用的商業建議
                    """)
                .build();
    }
    
    /**
     * 快速查詢 ChatClient（簡化版）
     */
    @Bean("quickQueryChatClient")
    public ChatClient quickQueryChatClient(ChatModel chatModel) {
        return ChatClient.builder(chatModel)
                .defaultTools(
                    enhancedSalesTools,
                    dateTimeTools
                )
                .defaultSystem("你是一個快速查詢助手，專門處理簡單的資料查詢請求。")
                .build();
    }
}
```

### 工具鏈控制器

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/tool-chain")
@RequiredArgsConstructor
@Slf4j
public class ToolChainController {
    
    private final ChatClient toolChainChatClient;
    
    /**
     * 複雜工具鏈查詢
     * @param prompt 自然語言查詢
     * @return AI 分析結果
     */
    @GetMapping("/complex-query")
    public String complexQuery(@RequestParam String prompt) {
        try {
            log.info("收到複雜工具鏈查詢：{}", prompt);
            
            long startTime = System.currentTimeMillis();
            
            String response = toolChainChatClient
                    .prompt(prompt)
                    .call()
                    .content();
            
            long endTime = System.currentTimeMillis();
            
            log.info("複雜查詢完成，耗時：{}ms，回應長度：{} 字元", 
                    endTime - startTime, response.length());
            
            return response;
            
        } catch (Exception e) {
            log.error("複雜工具鏈查詢失敗：{}", prompt, e);
            return "查詢失敗：" + e.getMessage();
        }
    }
    
    /**
     * 產品深度分析
     * @param request 分析請求
     * @return 詳細分析報告
     */
    @PostMapping("/product-analysis")
    public ProductAnalysisResponse productAnalysis(@RequestBody ProductAnalysisRequest request) {
        try {
            log.info("產品深度分析請求：{}", request);
            
            long startTime = System.currentTimeMillis();
            
            // 構建分析提示詞
            String prompt = buildAnalysisPrompt(request);
            
            String analysis = toolChainChatClient
                    .prompt(prompt)
                    .call()
                    .content();
            
            long endTime = System.currentTimeMillis();
            
            return ProductAnalysisResponse.builder()
                    .success(true)
                    .productCode(request.getProductCode())
                    .analysisType(request.getAnalysisType())
                    .analysis(analysis)
                    .executionTime(endTime - startTime)
                    .timestamp(LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("產品深度分析失敗", e);
            
            return ProductAnalysisResponse.builder()
                    .success(false)
                    .productCode(request.getProductCode())
                    .error(e.getMessage())
                    .timestamp(LocalDateTime.now())
                    .build();
        }
    }
    
    /**
     * 工具鏈執行追蹤
     * @param prompt 查詢內容
     * @return 執行追蹤資訊
     */
    @GetMapping("/trace")
    public Map<String, Object> traceExecution(@RequestParam String prompt) {
        try {
            log.info("工具鏈執行追蹤：{}", prompt);
            
            long startTime = System.currentTimeMillis();
            
            // 這裡可以添加工具調用追蹤邏輯
            String response = toolChainChatClient
                    .prompt(prompt)
                    .call()
                    .content();
            
            long endTime = System.currentTimeMillis();
            
            return Map.of(
                "prompt", prompt,
                "response", response,
                "executionTime", endTime - startTime,
                "toolsUsed", List.of("EnhancedSalesTools", "ProductDetailsTools"), // 實際應該從執行過程中獲取
                "timestamp", LocalDateTime.now()
            );
            
        } catch (Exception e) {
            log.error("工具鏈執行追蹤失敗", e);
            return Map.of(
                "error", e.getMessage(),
                "timestamp", LocalDateTime.now()
            );
        }
    }
    
    private String buildAnalysisPrompt(ProductAnalysisRequest request) {
        StringBuilder prompt = new StringBuilder();
        
        prompt.append("請進行深度產品分析：\n");
        prompt.append("產品代碼：").append(request.getProductCode()).append("\n");
        prompt.append("分析類型：").append(request.getAnalysisType()).append("\n");
        
        if (request.getYear() != null) {
            prompt.append("分析年份：").append(request.getYear()).append("\n");
        }
        
        prompt.append("\n請提供：\n");
        
        switch (request.getAnalysisType()) {
            case "comprehensive" -> {
                prompt.append("1. 產品銷售表現分析\n");
                prompt.append("2. 所有產品型號詳細資訊\n");
                prompt.append("3. 市場競爭力評估\n");
                prompt.append("4. 改進建議和策略\n");
            }
            case "sales" -> {
                prompt.append("1. 詳細銷售資料分析\n");
                prompt.append("2. 銷售趨勢和模式\n");
                prompt.append("3. 市場占有率分析\n");
            }
            case "product" -> {
                prompt.append("1. 產品型號完整資訊\n");
                prompt.append("2. 規格和定價分析\n");
                prompt.append("3. 產品線優化建議\n");
            }
        }
        
        return prompt.toString();
    }
}
```

### 請求和回應 DTO

```java
package com.example.dto;

import lombok.Data;
import lombok.Builder;
import java.time.LocalDateTime;

@Data
public class ProductAnalysisRequest {
    private String productCode;
    private String analysisType;  // comprehensive, sales, product
    private Integer year;
    private String focusArea;
}

@Data
@Builder
public class ProductAnalysisResponse {
    private boolean success;
    private String productCode;
    private String analysisType;
    private String analysis;
    private Long executionTime;
    private String error;
    private LocalDateTime timestamp;
}
```

---

## 5.8.4 實際工具鏈應用場景

### 場景 1：複雜銷售分析

**用戶查詢**：「請告訴我 2023 年最熱銷的產品，並列出該產品所有型號的詳細規格和價格」

**工具鏈執行流程**：

```
1. 🔍 EnhancedSalesTools.getProductSalesRanking(2023)
   → 獲取 2023 年銷售排行
   → 識別最熱銷產品：PD-1385 智能手錶系列

2. 📋 ProductDetailsTools.getProductModels("PD-1385")
   → 獲取 PD-1385 的所有型號
   → 返回：1385-1, 1385-2, 1385-3, 1385-4

3. 🔎 ProductDetailsTools.getModelSpecifications("PD-1385", "1385-1")
   → 獲取型號 1385-1 的詳細規格

4. 🔎 ProductDetailsTools.getModelSpecifications("PD-1385", "1385-2")
   → 獲取型號 1385-2 的詳細規格

5. 🔎 ProductDetailsTools.getModelSpecifications("PD-1385", "1385-3")
   → 獲取型號 1385-3 的詳細規格

6. 🔎 ProductDetailsTools.getModelSpecifications("PD-1385", "1385-4")
   → 獲取型號 1385-4 的詳細規格

7. 🧠 AI 整合分析
   → 生成完整的分析報告
```

**AI 回應範例**：

```
📊 **2023年最熱銷產品分析報告**

🏆 **最佳銷售產品**
- 產品：PD-1385 智能手錶系列
- 銷售量：15,000 台
- 營收：NT$ 3.0億
- 市場占有率：35.7%

📱 **產品型號完整資訊**

**1. 智能手錶 1385-1**
- 規格：41mm, GPS, 心率監測
- 價格：NT$ 12,900
- 定位：入門款，適合日常使用

**2. 智能手錶 1385-2**
- 規格：45mm, GPS, 心率監測, 血氧檢測
- 價格：NT$ 15,900
- 定位：進階款，增加健康監測功能

**3. 智能手錶 1385-3**
- 規格：41mm, GPS+Cellular, 心率監測, 血氧檢測
- 價格：NT$ 18,900
- 定位：獨立通訊款，支援獨立通話

**4. 智能手錶 1385-4**
- 規格：45mm, GPS+Cellular, 心率監測, 血氧檢測, ECG
- 價格：NT$ 22,900
- 定位：旗艦款，完整健康監測功能

💡 **商業洞察**
- 智能手錶市場需求強勁，占公司總銷量超過1/3
- 產品線完整，從入門到旗艦都有覆蓋
- 健康監測功能是主要賣點
- 建議加強運動和健康生態系統整合
```

### 場景 2：競品比較分析

**用戶查詢**：「比較 PD-1405 和 PD-1234 在 2024 年的銷售表現，並分析各自的產品優勢」

**工具鏈執行流程**：

```
1. 📊 EnhancedSalesTools.compareProductPerformance(2024, ["PD-1405", "PD-1234"])
   → 比較兩個產品的 2024 年銷售表現

2. 📋 ProductDetailsTools.getProductModels("PD-1405")
   → 獲取 PD-1405 產品詳情和型號

3. 📋 ProductDetailsTools.getProductModels("PD-1234")
   → 獲取 PD-1234 產品詳情和型號

4. 🧮 CalculatorTools.calculate(...)
   → 計算相關統計數據

5. 🧠 AI 綜合分析
   → 生成競品比較報告
```

---

## 📝 本章重點回顧

1. **工具鏈調用掌握**：學會了 AI 自動進行多層次工具調用的機制
2. **複雜工具設計**：實現了支援鏈式調用的進階工具系統
3. **智能協調系統**：建立了工具間的智能協調和資料流轉
4. **效能優化策略**：掌握了工具鏈的效能優化和成本控制
5. **企業級應用**：展示了真實的企業工具鏈應用場景

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **工具鏈調用** | ⭐⭐⭐ | 高 | 複雜業務流程 |
| **智能協調** | ⭐⭐⭐ | 高 | 企業級應用 |
| **效能優化** | ⭐⭐ | 中 | 生產環境 |
| **錯誤處理** | ⭐⭐ | 中 | 穩定性保證 |
| **監控追蹤** | ⭐⭐ | 高 | 運維管理 |
| **成本控制** | ⭐ | 中 | 商業應用 |

### 工具鏈設計原則

**1. 單一職責原則**
- 每個工具專注於特定功能
- 避免工具功能重疊
- 保持工具介面簡潔

**2. 鏈式調用優化**
- 設計合理的資料流轉
- 避免不必要的重複調用
- 實現智能的工具選擇

**3. 錯誤處理策略**
- 優雅的降級機制
- 完整的錯誤日誌
- 使用者友善的錯誤訊息

### 企業應用價值

**1. 降低開發成本**
- 🔧 **模組化設計**：工具可重複使用和組合
- ⚡ **快速開發**：新功能通過工具組合快速實現
- 🛠️ **易於維護**：單一工具的修改不影響其他功能

**2. 提升用戶體驗**
- 🗣️ **自然互動**：用戶用自然語言描述複雜需求
- 🎯 **精準回應**：AI 自動選擇最佳工具組合
- 📊 **深度分析**：提供比傳統 BI 更深入的洞察

**3. 擴展業務能力**
- 🚀 **無限擴展**：新工具可無縫整合到現有系統
- 🔄 **靈活組合**：根據業務需求動態組合工具
- 💡 **創新應用**：AI 可發現人類未想到的工具組合方式

### 下一步學習方向

恭喜您完成了 Function Calling 的完整學習！接下來我們將進入更進階的主題，學習如何讓 ChatBot 擁有記憶能力，建立真正智能的對話系統。

---

**參考資料：**
- [Spring AI Advanced Tool Calling](https://docs.spring.io/spring-ai/reference/api/tools.html)
- [AI Agent Design Patterns](https://www.anthropic.com/research/constitutional-ai-harmlessness-from-ai-feedback)
- [Enterprise AI Tool Integration](https://www.mckinsey.com/capabilities/quantumblack/our-insights/the-age-of-ai)
- [Function Calling Best Practices](https://platform.openai.com/docs/guides/function-calling)
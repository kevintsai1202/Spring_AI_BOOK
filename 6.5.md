# 6.5 Spring AI 擴展機制：Advisors 與 Tools 開發

> **本章重點**：學習 Spring AI 的官方擴展機制，包括 Advisors API 和 Tools 開發，從基礎概念到實際應用，建立強大的 AI 增強功能。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握 Advisors 架構**：理解 Spring AI Advisors 系統的設計原理和執行流程
- 🎯 **開發自定義 Advisors**：學會創建請求/響應攔截器和數據轉換器
- 🎯 **實現 Tools 功能**：掌握工具調用機制，整合外部 API 和服務
- 🎯 **管理擴展生命週期**：理解擴展的載入、執行順序和上下文管理
- 🎯 **整合第三方服務**：將外部服務和 API 整合到 Spring AI 生態中

---

## 6.5.1 Spring AI 擴展架構概述

### 擴展系統的設計理念

Spring AI 採用多層次擴展機制，提供靈活的增強點來擴展 AI 應用功能，而不需要修改核心框架。

**核心設計原則**：
- 🔌 **多重擴展點**：Advisors、Tools、ETL Pipeline 等不同層次的擴展
- 🏗️ **標準化介面**：統一的擴展開發規範和 API
- 🔄 **鏈式執行**：支援多個擴展組件的有序執行
- 🛡️ **類型安全**：強類型介面設計，確保擴展安全性
- 📦 **Spring 整合**：完整的 Spring Boot 自動配置支援

### Spring AI 擴展架構圖

```
┌─────────────────────────────────────────────────────────────┐
│              Spring AI Extension Architecture               │
├─────────────────────────────────────────────────────────────┤
│  Application Layer                                          │
│  ┌─────────────────┐    ┌─────────────────┐               │
│  │   ChatClient    │    │   ChatModel     │               │
│  │                 │    │                 │               │
│  └─────────────────┘    └─────────────────┘               │
├─────────────────────────────────────────────────────────────┤
│  Extension Layer                                            │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Advisors Chain                             │ │
│  │  ┌─────────────────────────────────────────────────┐   │ │
│  │  │  • CallAroundAdvisor                            │   │ │
│  │  │  • StreamAroundAdvisor                          │   │ │
│  │  │  • Chain Execution & Context Management        │   │ │
│  │  └─────────────────────────────────────────────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Tools System                               │ │
│  │  • ToolCallback Interface                              │ │
│  │  • ToolCallingManager                                  │ │
│  │  • Method-based Tools (@Tool)                          │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Implementation Layer                                       │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │Custom       │ │Memory       │ │RAG          │          │
│  │Advisors     │ │Advisors     │ │Advisors     │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │Weather      │ │Database     │ │External API │          │
│  │Tools        │ │Tools        │ │Tools        │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

---

## 6.5.2 Advisors API 基礎框架

### 核心 Advisor 介面定義

```java
/**
 * Spring AI Advisor 基礎介面
 */
public interface Advisor extends Ordered {
    
    /**
     * Advisor 唯一名稱
     */
    String getName();
    
    /**
     * 執行順序，數值越小優先級越高
     */
    int getOrder();
}

/**
 * 同步調用 Advisor 介面
 */
public interface CallAroundAdvisor extends Advisor {
    
    /**
     * 環繞通知，攔截 ChatModel.call() 方法
     * @param advisedRequest 請求物件
     * @param chain advisor 鏈
     * @return 響應物件
     */
    AdvisedResponse aroundCall(AdvisedRequest advisedRequest, CallAroundAdvisorChain chain);
}

/**
 * 流式調用 Advisor 介面
 */
public interface StreamAroundAdvisor extends Advisor {
    
    /**
     * 環繞通知，攔截 ChatModel.stream() 方法
     * @param advisedRequest 請求物件
     * @param chain advisor 鏈
     * @return 響應流
     */
    Flux<AdvisedResponse> aroundStream(AdvisedRequest advisedRequest, StreamAroundAdvisorChain chain);
}

/**
 * Advisor 鏈介面 - 同步
 */
public interface CallAroundAdvisorChain {
    AdvisedResponse nextAroundCall(AdvisedRequest advisedRequest);
}

/**
 * Advisor 鏈介面 - 異步
 */
public interface StreamAroundAdvisorChain {
    Flux<AdvisedResponse> nextAroundStream(AdvisedRequest advisedRequest);
}
```

### Advisors 執行流程管理

```java
/**
 * AdvisedRequest - 包裝的請求物件
 */
public record AdvisedRequest(
    Prompt prompt,
    String userText,
    Map<String, Object> userParams,
    Map<String, Object> systemParams,
    Map<String, Object> advisorContext
) {
    
    /**
     * 更新上下文
     */
    public AdvisedRequest updateContext(Function<Map<String, Object>, Map<String, Object>> contextUpdater) {
        Map<String, Object> updatedContext = contextUpdater.apply(new HashMap<>(advisorContext));
        return new AdvisedRequest(prompt, userText, userParams, systemParams, Map.copyOf(updatedContext));
    }
    
    /**
     * 建造者模式
     */
    public static Builder from(AdvisedRequest request) {
        return new Builder(request);
    }
}

/**
 * AdvisedResponse - 包裝的響應物件
 */
public record AdvisedResponse(
    ChatCompletion chatCompletion,
    Map<String, Object> advisorContext
) {
    
    /**
     * 取得響應內容
     */
    public String content() {
        return chatCompletion.content();
    }
}
/**
 * MessageAggregator - 消息聚合器工具類
 */
public class MessageAggregator {
    
    /**
     * 聚合流式響應為單一響應
     */
    public Flux<AdvisedResponse> aggregateAdvisedResponse(
            Flux<AdvisedResponse> advisedResponses, 
            Consumer<AdvisedResponse> onComplete) {
        
        return advisedResponses
            .buffer() // 集合所有響應
            .map(responses -> {
                // 合併所有響應內容
                StringBuilder combinedContent = new StringBuilder();
                Map<String, Object> finalContext = new HashMap<>();
                
                for (AdvisedResponse response : responses) {
                    combinedContent.append(response.content());
                    finalContext.putAll(response.advisorContext());
                }
                
                AdvisedResponse aggregated = new AdvisedResponse(
                    new ChatCompletion(combinedContent.toString()),
                    finalContext
                );
                
                onComplete.accept(aggregated);
                return aggregated;
            })
            .flatMapIterable(response -> List.of(response));
    }
}
/**
 * 自定義 Advisor 配置類
 */
@Component
@Slf4j
public class AdvisorConfiguration {
    
    /**
     * 配置 ChatClient 的預設 Advisors
     */
    @Bean
    public ChatClient chatClient(
            ChatModel chatModel,
            ChatMemory chatMemory,
            VectorStore vectorStore) {
        
        return ChatClient.builder(chatModel)
            .defaultAdvisors(
                // 記憶管理 Advisor
                MessageChatMemoryAdvisor.builder(chatMemory).build(),
                
                // RAG 問答 Advisor  
                QuestionAnswerAdvisor.builder(vectorStore).build(),
                
                // 自定義日誌 Advisor
                new SimpleLoggerAdvisor(),
                
                // Re-Reading Advisor
                new ReReadingAdvisor()
            )
            .build();
    }
}
/**
 * Spring AI 內建 Advisors
 */
public class BuiltInAdvisors {
    
    /**
     * 記憶管理 Advisor - 為對話提供上下文記憶
     */
    public static class MessageChatMemoryAdvisor implements CallAroundAdvisor, StreamAroundAdvisor {
        
        private final ChatMemory chatMemory;
        
        public MessageChatMemoryAdvisor(ChatMemory chatMemory) {
            this.chatMemory = chatMemory;
        }
        
        @Override
        public String getName() {
            return "MessageChatMemoryAdvisor";
        }
        
        @Override
        public int getOrder() {
            return 100; // 預設優先級
        }
        
        @Override
        public AdvisedResponse aroundCall(AdvisedRequest request, CallAroundAdvisorChain chain) {
            // 從記憶中恢復歷史對話
            String conversationId = (String) request.userParams().get(ChatMemory.CONVERSATION_ID);
            List<Message> history = chatMemory.get(conversationId);
            
            // 將歷史加入請求
            Prompt enhancedPrompt = new Prompt(history);
            AdvisedRequest enhancedRequest = AdvisedRequest.from(request)
                .prompt(enhancedPrompt)
                .build();
            
            // 繼續執行鏈
            AdvisedResponse response = chain.nextAroundCall(enhancedRequest);
            
            // 將新的對話儲存到記憶中
            chatMemory.add(conversationId, request.userText(), response.content());
            
            return response;
        }
        
        @Override
        public Flux<AdvisedResponse> aroundStream(AdvisedRequest request, StreamAroundAdvisorChain chain) {
            // 簡化版本，實際實作會更複雜
            return chain.nextAroundStream(request);
        }
        
        public static Builder builder(ChatMemory chatMemory) {
            return new Builder(chatMemory);
        }
        
        public static class Builder {
            private final ChatMemory chatMemory;
            
            public Builder(ChatMemory chatMemory) {
                this.chatMemory = chatMemory;
            }
            
            public MessageChatMemoryAdvisor build() {
                return new MessageChatMemoryAdvisor(chatMemory);
            }
        }
    }
    
    /**
     * RAG 問答 Advisor - 提供檢索增強產生功能
     */
    public static class QuestionAnswerAdvisor implements CallAroundAdvisor, StreamAroundAdvisor {
        
        private final VectorStore vectorStore;
        
        public QuestionAnswerAdvisor(VectorStore vectorStore) {
            this.vectorStore = vectorStore;
        }
        
        @Override
        public String getName() {
            return "QuestionAnswerAdvisor";
        }
        
        @Override
        public int getOrder() {
            return 200;
        }
        
        @Override
        public AdvisedResponse aroundCall(AdvisedRequest request, CallAroundAdvisorChain chain) {
            // 從向量資料庫檢索相關文檔
            List<Document> relevantDocs = vectorStore.similaritySearch(
                SearchRequest.query(request.userText()).withTopK(5)
            );
            
            // 將相關文檔加入系統提示
            String context = relevantDocs.stream()
                .map(Document::getContent)
                .collect(Collectors.joining("\n"));
                
            String systemMessage = "Based on the following context, please answer the user's question:\n" + context;
            
            AdvisedRequest enhancedRequest = AdvisedRequest.from(request)
                .systemParams(Map.of("context", context))
                .build();
            
            return chain.nextAroundCall(enhancedRequest);
        }
        
        @Override
        public Flux<AdvisedResponse> aroundStream(AdvisedRequest request, StreamAroundAdvisorChain chain) {
            // 簡化版本
            return chain.nextAroundStream(request);
        }
        
        public static Builder builder(VectorStore vectorStore) {
            return new Builder(vectorStore);
        }
        
        public static class Builder {
            private final VectorStore vectorStore;
            
            public Builder(VectorStore vectorStore) {
                this.vectorStore = vectorStore;
            }
            
            public QuestionAnswerAdvisor build() {
                return new QuestionAnswerAdvisor(vectorStore);
            }
        }
    }
}
```

---

## 6.5.3 實戰：開發自定義 Advisor

### 簡單日誌 Advisor

```java
/**
 * 簡單日誌 Advisor - 記錄請求和響應
 */
@Component
@Slf4j
public class SimpleLoggerAdvisor implements CallAroundAdvisor, StreamAroundAdvisor {
    
    @Override
    public String getName() {
        return "SimpleLoggerAdvisor";
    }
    
    @Override
    public int getOrder() {
        return 0; // 高優先級，率先執行
    }
    
    @Override
    public AdvisedResponse aroundCall(AdvisedRequest advisedRequest, CallAroundAdvisorChain chain) {
        
        log.debug("BEFORE CALL: User={}, Context={}", 
            advisedRequest.userText(), 
            advisedRequest.advisorContext());
        
        // 記錄請求時間
        long startTime = System.currentTimeMillis();
        
        AdvisedResponse advisedResponse = chain.nextAroundCall(advisedRequest);
        
        long duration = System.currentTimeMillis() - startTime;
        
        log.debug("AFTER CALL: Response={}, Duration={}ms", 
            advisedResponse.content().substring(0, Math.min(100, advisedResponse.content().length())), 
            duration);
        
        return advisedResponse;
    }
    
    @Override
    public Flux<AdvisedResponse> aroundStream(AdvisedRequest advisedRequest, StreamAroundAdvisorChain chain) {
        
        log.debug("BEFORE STREAM: User={}", advisedRequest.userText());
        
        Flux<AdvisedResponse> advisedResponses = chain.nextAroundStream(advisedRequest);
        
        // 使用 MessageAggregator 整合流式響應進行日誌記錄
        return new MessageAggregator().aggregateAdvisedResponse(advisedResponses,
            advisedResponse -> log.debug("AFTER STREAM: {}", 
                advisedResponse.content().substring(0, Math.min(100, advisedResponse.content().length()))
            )
        );
    }
}
```

### Re-Reading (Re2) Advisor

```java
/**
 * Re-Reading Advisor - 實現 Re2 技術提升推理能力
 */
@Component
@Slf4j  
public class ReReadingAdvisor implements CallAroundAdvisor, StreamAroundAdvisor {
    
    @Override
    public String getName() {
        return "ReReadingAdvisor";
    }
    
    @Override
    public int getOrder() {
        return 50; // 中等優先級
    }
    
    /**
     * 預處理方法 - 將 Re2 技術應用到使用者輸入
     */
    private AdvisedRequest before(AdvisedRequest advisedRequest) {
        
        Map<String, Object> advisedUserParams = new HashMap<>(advisedRequest.userParams());
        advisedUserParams.put("re2_input_query", advisedRequest.userText());
        
        return AdvisedRequest.from(advisedRequest)
            .userText("""
                {re2_input_query}
                Read the question again: {re2_input_query}
                """)
            .userParams(advisedUserParams)
            .build();
    }
    
    @Override
    public AdvisedResponse aroundCall(AdvisedRequest advisedRequest, CallAroundAdvisorChain chain) {
        return chain.nextAroundCall(this.before(advisedRequest));
    }
    
    @Override
    public Flux<AdvisedResponse> aroundStream(AdvisedRequest advisedRequest, StreamAroundAdvisorChain chain) {
        return chain.nextAroundStream(this.before(advisedRequest));
    }
}
```

---

## 6.5.4 Tools 開發實戰

### 天氣查詢工具開發

```java
/**
 * 天氣查詢工具類
 */
@Component
@Slf4j
public class WeatherTools {
    
    private final WeatherService weatherService;
    
    public WeatherTools() {
        // 初始化天氣服務（實際應用中應使用配置注入）
        String apiKey = System.getenv("WEATHER_API_KEY");
        String baseUrl = "https://api.openweathermap.org/data/2.5";
        this.weatherService = new WeatherService(apiKey, baseUrl);
    }
    
    /**
     * 取得當前天氣 - 使用 @Tool 註解
     */
    @Tool(description = "Get current weather information for a specific location")
    public WeatherInfo getCurrentWeather(WeatherRequest request) {
        try {
            log.debug("Getting current weather for: {}", request.location());
            
            WeatherInfo weather = weatherService.getCurrentWeather(
                request.location(),
                request.unit()
            );
            
            log.debug("Weather retrieved successfully for: {}", request.location());
            return weather;
            
        } catch (Exception e) {
            log.error("Failed to get weather for: {}", request.location(), e);
            throw new RuntimeException("Failed to get weather information", e);
        }
    }
    
    /**
     * 取得天氣預報
     */
    @Tool(description = "Get weather forecast for a specific location")
    public List<WeatherForecast> getWeatherForecast(ForecastRequest request) {
        try {
            log.debug("Getting weather forecast for: {}", request.location());
            
            List<WeatherForecast> forecast = weatherService.getWeatherForecast(
                request.location(),
                request.days(),
                request.unit()
            );
            
            log.debug("Weather forecast retrieved successfully for: {}", request.location());
            return forecast;
            
        } catch (Exception e) {
            log.error("Failed to get weather forecast for: {}", request.location(), e);
            throw new RuntimeException("Failed to get weather forecast", e);
        }
    }
    
    /**
     * 設定鬧鐘 - 行動類工具
     */
    @Tool(description = "Set an alarm for the given time, provided in ISO-8601 format")
    public String setAlarm(String time) {
        try {
            LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME);
            log.info("Alarm set for {}", alarmTime);
            
            // 實際應用中這裡會整合真實的鬧鐘系統
            return String.format("Alarm successfully set for %s", alarmTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
            
        } catch (Exception e) {
            log.error("Failed to set alarm for time: {}", time, e);
            throw new RuntimeException("Failed to set alarm", e);
        }
    }
    
    /**
     * 取得當前時間 - 資訊檢索類工具
     */
    @Tool(description = "Get the current date and time in the user's timezone")
    public String getCurrentDateTime() {
        return LocalDateTime.now()
            .atZone(LocaleContextHolder.getTimeZone().toZoneId())
            .format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
    }
}
```

### 工具資料模型

```java
/**
 * 天氣查詢請求 - 使用 Record 類型
 */
public record WeatherRequest(
    @JsonProperty("location")
    @JsonPropertyDescription("The location to get weather for (city name, coordinates, etc.)")
    String location,
    
    @JsonProperty("unit")
    @JsonPropertyDescription("Temperature unit: celsius, fahrenheit, or kelvin")
    String unit
) {
    // 預設建構器
    public WeatherRequest {
        if (unit == null) {
            unit = "celsius";
        }
    }
}

/**
 * 天氣預報請求
 */
public record ForecastRequest(
    @JsonProperty("location")
    @JsonPropertyDescription("The location to get weather forecast for")
    String location,
    
    @JsonProperty("days")
    @JsonPropertyDescription("Number of days for forecast (1-7)")
    Integer days,
    
    @JsonProperty("unit")
    @JsonPropertyDescription("Temperature unit: celsius, fahrenheit, or kelvin")
    String unit
) {
    public ForecastRequest {
        if (days == null) {
            days = 3;
        }
        if (unit == null) {
            unit = "celsius";
        }
    }
}

/**
 * 天氣資訊
 */
public record WeatherInfo(
    String location,
    String description,
    double temperature,
    double feelsLike,
    int humidity,
    double windSpeed,
    String unit,
    LocalDateTime timestamp
) {}

/**
 * 天氣預報
 */
public record WeatherForecast(
    LocalDate date,
    String description,
    double maxTemperature,
    double minTemperature,
    int humidity,
    double windSpeed,
    String unit
) {}
```

### ChatClient 與 Tools 使用示例

```java
/**
 * ChatClient 使用天氣工具的示例
 */
@Component
@Slf4j
public class WeatherChatExample {
    
    private final ChatClient chatClient;
    private final WeatherTools weatherTools;
    
    public WeatherChatExample(ChatModel chatModel, WeatherTools weatherTools) {
        this.weatherTools = weatherTools;
        this.chatClient = ChatClient.create(chatModel);
    }
    
    /**
     * 使用 Tools 的基本對話
     */
    public String askWeatherQuestion(String question) {
        return chatClient
            .prompt(question)
            .tools(weatherTools) // 直接傳遞工具類實例
            .call()
            .content();
    }
    
    /**
     * 使用多個 Tools 的進階示例
     */
    public String complexWeatherQuery(String query) {
        
        // 使用多個工具類
        DateTimeTools dateTimeTools = new DateTimeTools();
        
        return chatClient
            .prompt(query)
            .tools(weatherTools, dateTimeTools)
            .call()
            .content();
    }
    
    /**
     * 使用 Advisors 和 Tools 結合
     */
    public String enhancedWeatherChat(String question, String conversationId) {
        
        return ChatClient.builder(chatClient.getChatModel())
            .defaultAdvisors(
                new SimpleLoggerAdvisor(),
                new ReReadingAdvisor()
            )
            .build()
            .prompt(question)
            .advisors(advisor -> advisor.param(ChatMemory.CONVERSATION_ID, conversationId))
            .tools(weatherTools)
            .call()
            .content();
    }
}
```

### 日期時間工具類

```java
/**
 * 日期時間相關工具
 */
@Component
public class DateTimeTools {
    
    @Tool(description = "Get the current date and time in the user's timezone")
    public String getCurrentDateTime() {
        return LocalDateTime.now()
            .atZone(LocaleContextHolder.getTimeZone().toZoneId())
            .toString();
    }
    
    @Tool(description = "Set a user alarm for the given time, provided in ISO-8601 format")
    public String setAlarm(String time) {
        try {
            LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME);
            System.out.println("Alarm set for " + alarmTime);
            return "Alarm set successfully for " + alarmTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"));
        } catch (Exception e) {
            throw new RuntimeException("Invalid time format. Please use ISO-8601 format.", e);
        }
    }
}
/**
 * 天氣服務實現類 - 簡化版
 */
@Service
@Slf4j
public class WeatherService {
    
    private final String apiKey;
    private final String baseUrl;
    private final RestTemplate restTemplate;
    
    public WeatherService(@Value("${weather.api.key}") String apiKey,
                         @Value("${weather.api.baseUrl:https://api.openweathermap.org/data/2.5}") String baseUrl) {
        this.apiKey = apiKey;
        this.baseUrl = baseUrl;
        this.restTemplate = new RestTemplate();
    }
    
    public WeatherInfo getCurrentWeather(String location, String unit) {
        try {
            String url = String.format("%s/weather?q=%s&appid=%s&units=%s",
                baseUrl, location, apiKey, convertUnit(unit));
                
            // 簡化的實作，實際應用中會需要更完整的錯誤處理
            Map<String, Object> response = restTemplate.getForObject(url, Map.class);
            
            return new WeatherInfo(
                (String) response.get("name"),
                (String) ((Map) ((List) response.get("weather")).get(0)).get("description"),
                ((Number) ((Map) response.get("main")).get("temp")).doubleValue(),
                ((Number) ((Map) response.get("main")).get("feels_like")).doubleValue(),
                ((Number) ((Map) response.get("main")).get("humidity")).intValue(),
                ((Number) ((Map) response.get("wind")).get("speed")).doubleValue(),
                unit,
                LocalDateTime.now()
            );
            
        } catch (Exception e) {
            log.error("Failed to get current weather for: {}", location, e);
            throw new RuntimeException("Weather service error", e);
        }
    }
    
    public List<WeatherForecast> getWeatherForecast(String location, int days, String unit) {
        // 簡化實作 - 實際應用中會需要完整的 API 調用和數據處理
        List<WeatherForecast> forecasts = new ArrayList<>();
        
        for (int i = 1; i <= days; i++) {
            forecasts.add(new WeatherForecast(
                LocalDate.now().plusDays(i),
                "Partly cloudy",
                25.0 + i, // 模擬數據
                15.0 + i,
                60 + i * 2,
                10.5,
                unit
            ));
        }
        
        return forecasts;
    }
    
    private String convertUnit(String unit) {
        if (unit == null) return "metric";
        return switch (unit.toLowerCase()) {
            case "celsius" -> "metric";
            case "fahrenheit" -> "imperial";
            case "kelvin" -> "standard";
            default -> "metric";
        };
    }
}
```

---

## 6.5.5 Spring AI 配置與部署

### Application 配置檔案

```yaml
# application.yml - Spring AI 配置
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      chat:
        options:
          model: gpt-4o-mini
          temperature: 0.7
    
    # 向量資料庫配置
    vectordatabase:
      pgvector:
        url: jdbc:postgresql://localhost:5432/vectordb
        username: ${DB_USERNAME}
        password: ${DB_PASSWORD}
        
# 天氣 API 配置
weather:
  api:
    key: ${WEATHER_API_KEY}
    baseUrl: https://api.openweathermap.org/data/2.5
    timeout: 5000
    retries: 3

# 應用程序配置
logging:
  level:
    org.springframework.ai: DEBUG
    com.example.advisor: DEBUG
    com.example.tools: DEBUG
```

### Spring Boot 自動配置

```java
/**
 * Spring AI 自動配置類
 */
@Configuration
@EnableConfigurationProperties({WeatherProperties.class})
@Slf4j
public class SpringAIAutoConfiguration {
    
    /**
     * 配置 ChatClient Bean
     */
    @Bean
    @ConditionalOnMissingBean
    public ChatClient chatClient(
            ChatModel chatModel,
            @Autowired(required = false) List<Advisor> advisors,
            @Autowired(required = false) ChatMemory chatMemory,
            @Autowired(required = false) VectorStore vectorStore) {
        
        var builder = ChatClient.builder(chatModel);
        
        // 自動註冊所有可用的 Advisors
        if (advisors != null && !advisors.isEmpty()) {
            builder.defaultAdvisors(advisors.toArray(new Advisor[0]));
        }
        
        // 自動添加常用的 Advisors
        List<Advisor> defaultAdvisors = new ArrayList<>();
        
        if (chatMemory != null) {
            defaultAdvisors.add(MessageChatMemoryAdvisor.builder(chatMemory).build());
        }
        
        if (vectorStore != null) {
            defaultAdvisors.add(QuestionAnswerAdvisor.builder(vectorStore).build());
        }
        
        if (!defaultAdvisors.isEmpty()) {
            builder.defaultAdvisors(defaultAdvisors.toArray(new Advisor[0]));
        }
        
        return builder.build();
    }
    
    /**
     * 自動註冊所有 Tools
     */
    @Bean
    @ConditionalOnMissingBean
    public ToolCallbackResolver toolCallbackResolver(ApplicationContext applicationContext) {
        return new SpringContextToolCallbackResolver(applicationContext);
    }
    
    /**
     * 天氣工具配置
     */
    @Bean
    @ConditionalOnProperty(name = "weather.enabled", havingValue = "true", matchIfMissing = true)
    public WeatherTools weatherTools(WeatherService weatherService) {
        return new WeatherTools(weatherService);
    }
    
    /**
     * 日期時間工具配置
     */
    @Bean
    public DateTimeTools dateTimeTools() {
        return new DateTimeTools();
    }
    
    /**
     * 自定義 Advisors 配置
     */
    @Bean
    @ConditionalOnProperty(name = "spring.ai.advisor.logger.enabled", havingValue = "true", matchIfMissing = true)
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public SimpleLoggerAdvisor simpleLoggerAdvisor() {
        return new SimpleLoggerAdvisor();
    }
    
    @Bean
    @ConditionalOnProperty(name = "spring.ai.advisor.rereading.enabled", havingValue = "true")
    @Order(50)
    public ReReadingAdvisor reReadingAdvisor() {
        return new ReReadingAdvisor();
    }
    
    /**
     * 向量資料庫配置
     */
    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnProperty(name = "spring.ai.vectordatabase.pgvector.enabled", havingValue = "true")
    public VectorStore vectorStore(@Value("${spring.ai.vectordatabase.pgvector.url}") String url,
                                   @Value("${spring.ai.vectordatabase.pgvector.username}") String username,
                                   @Value("${spring.ai.vectordatabase.pgvector.password}") String password) {
        // PgVector 配置
        return new PgVectorStore(url, username, password);
    }
    
    /**
     * 記憶管理配置
     */
    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnProperty(name = "spring.ai.chat.memory.enabled", havingValue = "true")
    public ChatMemory chatMemory() {
        return new InMemoryChatMemory();
    }
}

/**
 * 天氣配置屬性
 */
@ConfigurationProperties(prefix = "weather")
@Data
public class WeatherProperties {
    private Api api = new Api();
    
    @Data
    public static class Api {
        private String key;
        private String baseUrl = "https://api.openweathermap.org/data/2.5";
        private int timeout = 5000;
        private int retries = 3;
    }
}
/**
 * Spring Context Tool Callback Resolver
 */
public class SpringContextToolCallbackResolver implements ToolCallbackResolver {
    
    private final ApplicationContext applicationContext;
    
    public SpringContextToolCallbackResolver(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    
    @Override
    public List<ToolCallback> resolve(String... toolNames) {
        List<ToolCallback> callbacks = new ArrayList<>();
        
        // 從 Spring 上下文中解析工具
        for (String toolName : toolNames) {
            try {
                Object bean = applicationContext.getBean(toolName);
                if (bean != null) {
                    // 將 Bean 轉換為 ToolCallback
                    ToolCallback callback = createToolCallbackFromBean(bean);
                    if (callback != null) {
                        callbacks.add(callback);
                    }
                }
            } catch (Exception e) {
                log.warn("Failed to resolve tool: {}", toolName, e);
            }
        }
        
        return callbacks;
    }
    
    private ToolCallback createToolCallbackFromBean(Object bean) {
        // 使用反射將 @Tool 註解的方法轉換為 ToolCallback
        return MethodToolCallback.fromObject(bean);
    }
}
```

---

## 6.5.6 實際使用示例

### 建立完整的 AI 應用

```java
/**
 * AI 助理應用控制器
 */
@RestController
@RequestMapping("/api/ai")
@RequiredArgsConstructor
@Slf4j
public class AIAssistantController {
    
    private final ChatClient chatClient;
    private final WeatherTools weatherTools;
    private final DateTimeTools dateTimeTools;
    
    /**
     * 基本 AI 對話
     */
    @PostMapping("/chat")
    public ResponseEntity<ChatResponse> chat(@RequestBody ChatRequest request) {
        try {
            String response = chatClient
                .prompt(request.getMessage())
                .call()
                .content();
            
            return ResponseEntity.ok(new ChatResponse(response));
        } catch (Exception e) {
            log.error("Chat error", e);
            return ResponseEntity.status(500)
                .body(new ChatResponse("Sorry, I encountered an error: " + e.getMessage()));
        }
    }
    
    /**
     * 安裝插件
     */
    @PostMapping("/install")
    public ResponseEntity<ApiResponse> installPlugin(@RequestBody InstallPluginRequest request) {
        try {
            pluginService.installPlugin(request.getPluginPath());
            return ResponseEntity.ok(ApiResponse.success("Plugin installed successfully"));
        } catch (PluginException e) {
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Plugin installation failed: " + e.getMessage()));
        }
    }
    
    /**
     * 啟用插件
     */
    @PostMapping("/{pluginId}/enable")
    public ResponseEntity<ApiResponse> enablePlugin(@PathVariable String pluginId) {
        try {
            pluginService.enablePlugin(pluginId);
            return ResponseEntity.ok(ApiResponse.success("Plugin enabled successfully"));
        } catch (PluginException e) {
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Plugin enable failed: " + e.getMessage()));
        }
    }
    
    /**
     * 停用插件
     */
    @PostMapping("/{pluginId}/disable")
    public ResponseEntity<ApiResponse> disablePlugin(@PathVariable String pluginId) {
        try {
            pluginService.disablePlugin(pluginId);
            return ResponseEntity.ok(ApiResponse.success("Plugin disabled successfully"));
        } catch (PluginException e) {
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Plugin disable failed: " + e.getMessage()));
        }
    }
    
    /**
     * 卸載插件
     */
    @DeleteMapping("/{pluginId}")
    public ResponseEntity<ApiResponse> uninstallPlugin(@PathVariable String pluginId) {
        try {
            pluginService.uninstallPlugin(pluginId);
            return ResponseEntity.ok(ApiResponse.success("Plugin uninstalled successfully"));
        } catch (PluginException e) {
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Plugin uninstall failed: " + e.getMessage()));
        }
    }
}
```

---

## 📝 本章重點回顧

1. **插件架構理解**：掌握了 Spring AI 插件系統的設計原理和架構模式
2. **插件開發實踐**：完成了從基礎框架到實際插件的完整開發流程
3. **生命週期管理**：實現了插件的載入、初始化、啟動、停止和卸載機制
4. **配置管理系統**：建立了完整的插件配置和管理體系
5. **REST API 整合**：提供了插件管理的 Web 介面和 API

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **插件架構設計** | ⭐⭐⭐ | 高 | 系統擴展性 |
| **生命週期管理** | ⭐⭐⭐ | 高 | 穩定性保證 |
| **配置管理** | ⭐⭐ | 中 | 易用性提升 |
| **REST API 整合** | ⭐⭐ | 中 | 管理便利性 |
| **依賴管理** | ⭐⭐ | 高 | 系統可靠性 |

### 最佳實踐建議

1. **設計原則**：遵循單一職責和開放封閉原則，確保插件的獨立性和可擴展性
2. **錯誤處理**：實現完善的錯誤處理和恢復機制，避免插件錯誤影響系統穩定性
3. **安全考量**：建立插件權限管理和安全檢查機制，防止惡意插件
4. **效能優化**：使用延遲載入和資源池化技術，提升插件系統效能
5. **文檔規範**：建立完整的插件開發文檔和規範，降低開發門檻

### 下一步學習方向

在下一章中，我們將學習如何安裝和配置 Neo4j 向量資料庫，包括：
- Neo4j 的安裝和基本配置
- 向量資料庫的概念和應用
- 與 Spring AI 的整合配置
- Docker 容器化部署

---

**參考資料：**
- [Spring Plugin Framework](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java)
- [Java Plugin Architecture](https://www.baeldung.com/java-plugin-system)
- [OSGi Bundle Development](https://www.osgi.org/developer/)
- [Spring Boot Auto Configuration](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration)
# 2.7 RESTful API 設計與實踐

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 REST 架構原理**：深入掌握 REST 架構約束條件和設計理念
- 🎯 **設計資源導向 API**：運用資源導向思維設計清晰、直觀的 API 結構
- 🎯 **實現 HTTP 語義化**：正確使用 HTTP 方法、狀態碼和標頭進行 API 通信
- 🎯 **建立 URL 設計規範**：制定一致性、可預測的 URL 命名和結構標準
- 🎯 **應用現代化實踐**：整合版本控制、快取策略等進階技術

---

## REST 架構風格深度解析

### 為什麼需要 RESTful API？

在現代分散式系統中，不同的應用程式需要透過網路進行通信。您是否遇到過以下問題？

> **常見 API 設計問題**：
> - API 端點命名混亂，難以理解和記憶
> - HTTP 方法使用不當，語義不清
> - 狀態碼選擇隨意，錯誤處理不一致
> - 缺乏統一的設計標準，維護困難

RESTful API 透過統一的架構風格解決了這些問題，提供了一套標準化的設計原則。

### REST 架構約束條件

REST（Representational State Transfer）定義了六個核心約束條件：

| 約束條件 | 說明 | 優勢 |
|----------|------|------|
| **客戶端-伺服器** | 分離使用者介面和資料儲存關注點 | 提高可移植性和可擴展性 |
| **無狀態** | 每個請求包含處理所需的完整資訊 | 提高可見性、可靠性和可擴展性 |
| **可快取** | 回應資料可以被標記為可快取或不可快取 | 提高網路效率和使用者體驗 |
| **統一介面** | 使用統一的介面約束 | 簡化架構，提高可見性 |
| **分層系統** | 允許架構由分層組成 | 提高可擴展性和安全性 |
| **按需程式碼** | 可選約束，允許下載和執行程式碼 | 提高可擴展性 |

### 基礎 RESTful Controller 實現

```java
/**
 * 基礎 RESTful API 控制器
 * 展示標準的資源導向設計模式
 */
@RestController
@RequestMapping("/api/v1/users")
@Validated
public class UserRestController {
    
    private final UserService userService;
    private final UserMapper userMapper;
    
    public UserRestController(UserService userService, UserMapper userMapper) {
        this.userService = userService;
        this.userMapper = userMapper;
    }
    
    /**
     * 獲取使用者列表
     * GET /api/v1/users
     * 支援分頁和篩選參數
     */
    @GetMapping
    public ResponseEntity<PagedResponse<UserDto>> getUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(required = false) String name,
            @RequestParam(required = false) String email
    ) {
        // 建立查詢條件
        UserSearchCriteria criteria = UserSearchCriteria.builder()
                .name(name)
                .email(email)
                .build();
        
        // 執行分頁查詢
        Page<User> userPage = userService.findUsers(criteria, PageRequest.of(page, size));
        
        // 轉換為 DTO
        List<UserDto> userDtos = userPage.getContent().stream()
                .map(userMapper::toDto)
                .collect(Collectors.toList());
        
        // 建立分頁回應
        PagedResponse<UserDto> response = PagedResponse.<UserDto>builder()
                .content(userDtos)
                .page(page)
                .size(size)
                .totalElements(userPage.getTotalElements())
                .totalPages(userPage.getTotalPages())
                .first(userPage.isFirst())
                .last(userPage.isLast())
                .build();
        
        return ResponseEntity.ok()
                .header("X-Total-Count", String.valueOf(userPage.getTotalElements()))
                .body(response);
    }
    
    /**
     * 根據 ID 獲取單一使用者
     * GET /api/v1/users/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<UserDto> getUserById(@PathVariable Long id) {
        User user = userService.findById(id);
        UserDto userDto = userMapper.toDto(user);
        
        return ResponseEntity.ok()
                .cacheControl(CacheControl.maxAge(Duration.ofMinutes(5)))
                .body(userDto);
    }
}
```

---

## HTTP 方法語義化使用

### HTTP 方法對照表

| HTTP 方法 | 用途 | 冪等性 | 安全性 | 典型使用場景 |
|-----------|------|--------|--------|--------------|
| **GET** | 獲取資源 | ✅ | ✅ | 查詢資料、獲取列表 |
| **POST** | 建立資源 | ❌ | ❌ | 新增資料、提交表單 |
| **PUT** | 更新/替換資源 | ✅ | ❌ | 完整更新資源 |
| **PATCH** | 部分更新資源 | ❌ | ❌ | 部分欄位更新 |
| **DELETE** | 刪除資源 | ✅ | ❌ | 刪除資料 |
| **HEAD** | 獲取資源標頭 | ✅ | ✅ | 檢查資源存在性 |
| **OPTIONS** | 獲取支援的方法 | ✅ | ✅ | CORS 預檢請求 |

### 完整 CRUD 操作實現

```java
/**
 * 完整的 CRUD 操作實現
 * 展示各種 HTTP 方法的正確使用
 */
@RestController
@RequestMapping("/api/v1/products")
public class ProductRestController {
    
    private final ProductService productService;
    private final ProductMapper productMapper;
    
    public ProductRestController(ProductService productService, ProductMapper productMapper) {
        this.productService = productService;
        this.productMapper = productMapper;
    }
    
    /**
     * 建立新產品
     * POST /api/v1/products
     * 回傳 201 Created 和 Location 標頭
     */
    @PostMapping
    public ResponseEntity<ProductDto> createProduct(@RequestBody @Valid CreateProductRequest request) {
        // 轉換請求為實體
        Product product = productMapper.toEntity(request);
        
        // 儲存產品
        Product savedProduct = productService.save(product);
        
        // 轉換為 DTO
        ProductDto productDto = productMapper.toDto(savedProduct);
        
        // 建立資源位置 URI
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(savedProduct.getId())
                .toUri();
        
        return ResponseEntity.created(location)
                .body(productDto);
    }
    
    /**
     * 完整更新產品
     * PUT /api/v1/products/{id}
     * 冪等操作，完整替換資源
     */
    @PutMapping("/{id}")
    public ResponseEntity<ProductDto> updateProduct(
            @PathVariable Long id,
            @RequestBody @Valid UpdateProductRequest request
    ) {
        // 檢查產品是否存在
        if (!productService.existsById(id)) {
            throw new ProductNotFoundException("Product not found with id: " + id);
        }
        
        // 轉換請求為實體
        Product product = productMapper.toEntity(request);
        product.setId(id);
        
        // 更新產品
        Product updatedProduct = productService.update(product);
        
        // 轉換為 DTO
        ProductDto productDto = productMapper.toDto(updatedProduct);
        
        return ResponseEntity.ok(productDto);
    }
    
    /**
     * 部分更新產品
     * PATCH /api/v1/products/{id}
     * 只更新提供的欄位
     */
    @PatchMapping("/{id}")
    public ResponseEntity<ProductDto> patchProduct(
            @PathVariable Long id,
            @RequestBody Map<String, Object> updates
    ) {
        // 執行部分更新
        Product updatedProduct = productService.partialUpdate(id, updates);
        
        // 轉換為 DTO
        ProductDto productDto = productMapper.toDto(updatedProduct);
        
        return ResponseEntity.ok(productDto);
    }
    
    /**
     * 刪除產品
     * DELETE /api/v1/products/{id}
     * 冪等操作，重複刪除不會產生錯誤
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        // 檢查產品是否存在
        if (!productService.existsById(id)) {
            // 冪等性：即使資源不存在也回傳 204
            return ResponseEntity.noContent().build();
        }
        
        // 刪除產品
        productService.deleteById(id);
        
        return ResponseEntity.noContent().build();
    }
}
```

---

## RESTful URL 設計原則

### URL 設計最佳實踐

| 原則 | 說明 | 好的範例 | 不好的範例 |
|------|------|----------|------------|
| **使用名詞** | URL 應該表示資源，而非動作 | `/api/users` | `/api/getUsers` |
| **複數形式** | 集合資源使用複數名詞 | `/api/products` | `/api/product` |
| **階層結構** | 反映資源之間的關係 | `/api/users/123/orders` | `/api/getUserOrders?userId=123` |
| **小寫字母** | 統一使用小寫字母 | `/api/user-profiles` | `/api/UserProfiles` |
| **連字符分隔** | 使用連字符而非底線 | `/api/order-items` | `/api/order_items` |

### 資源關係設計

```java
/**
 * 巢狀資源關係的 RESTful 設計
 * 展示父子資源的 URL 結構
 */
@RestController
@RequestMapping("/api/v1/users/{userId}/orders")
public class UserOrderController {
    
    private final OrderService orderService;
    private final UserService userService;
    
    /**
     * 獲取使用者的所有訂單
     * GET /api/v1/users/{userId}/orders
     */
    @GetMapping
    public ResponseEntity<List<OrderDto>> getUserOrders(
            @PathVariable Long userId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(required = false) String status
    ) {
        // 驗證使用者存在
        userService.validateUserExists(userId);
        
        // 建立查詢條件
        OrderSearchCriteria criteria = OrderSearchCriteria.builder()
                .userId(userId)
                .status(status)
                .build();
        
        // 執行查詢
        Page<Order> orderPage = orderService.findOrders(criteria, PageRequest.of(page, size));
        
        // 轉換為 DTO
        List<OrderDto> orderDtos = orderPage.getContent().stream()
                .map(orderMapper::toDto)
                .collect(Collectors.toList());
        
        return ResponseEntity.ok(orderDtos);
    }
    
    /**
     * 為使用者建立新訂單
     * POST /api/v1/users/{userId}/orders
     */
    @PostMapping
    public ResponseEntity<OrderDto> createUserOrder(
            @PathVariable Long userId,
            @RequestBody @Valid CreateOrderRequest request
    ) {
        // 驗證使用者存在
        User user = userService.findById(userId);
        
        // 建立訂單
        Order order = orderMapper.toEntity(request);
        order.setUser(user);
        
        Order savedOrder = orderService.save(order);
        OrderDto orderDto = orderMapper.toDto(savedOrder);
        
        // 建立資源位置
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{orderId}")
                .buildAndExpand(savedOrder.getId())
                .toUri();
        
        return ResponseEntity.created(location).body(orderDto);
    }
}
```

---

## HTTP 狀態碼最佳實踐

### 常用狀態碼對照表

| 狀態碼 | 名稱 | 使用場景 | 範例 |
|--------|------|----------|------|
| **200** | OK | 請求成功 | GET、PUT、PATCH 成功 |
| **201** | Created | 資源建立成功 | POST 建立資源 |
| **204** | No Content | 請求成功但無內容回傳 | DELETE 成功 |
| **400** | Bad Request | 請求格式錯誤 | 驗證失敗 |
| **401** | Unauthorized | 未認證 | 缺少或無效的認證資訊 |
| **403** | Forbidden | 已認證但無權限 | 權限不足 |
| **404** | Not Found | 資源不存在 | 找不到指定資源 |
| **409** | Conflict | 資源衝突 | 重複建立、版本衝突 |
| **422** | Unprocessable Entity | 語義錯誤 | 業務邏輯驗證失敗 |
| **500** | Internal Server Error | 伺服器內部錯誤 | 未預期的系統錯誤 |

### 全域異常處理

```java
/**
 * 全域異常處理器
 * 統一處理各種異常並回傳適當的狀態碼
 */
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    /**
     * 處理驗證異常
     * 400 Bad Request
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException e) {
        List<FieldError> fieldErrors = e.getBindingResult().getFieldErrors();
        
        Map<String, String> errors = fieldErrors.stream()
                .collect(Collectors.toMap(
                        FieldError::getField,
                        FieldError::getDefaultMessage,
                        (existing, replacement) -> existing
                ));
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Validation Failed")
                .message("Request validation failed")
                .details(errors)
                .timestamp(Instant.now())
                .path(getCurrentPath())
                .build();
        
        return ResponseEntity.badRequest().body(errorResponse);
    }
    
    /**
     * 處理資源未找到異常
     * 404 Not Found
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFoundException(ResourceNotFoundException e) {
        ErrorResponse errorResponse = ErrorResponse.builder()
                .status(HttpStatus.NOT_FOUND.value())
                .error("Resource Not Found")
                .message(e.getMessage())
                .timestamp(Instant.now())
                .path(getCurrentPath())
                .build();
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
    }
    
    /**
     * 處理系統異常
     * 500 Internal Server Error
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception e) {
        logger.error("Unexpected error occurred", e);
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                .error("Internal Server Error")
                .message("An unexpected error occurred")
                .timestamp(Instant.now())
                .path(getCurrentPath())
                .build();
        
        return ResponseEntity.internalServerError().body(errorResponse);
    }
    
    private String getCurrentPath() {
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        if (requestAttributes instanceof ServletRequestAttributes) {
            HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
            return request.getRequestURI();
        }
        return "unknown";
    }
}
```

---

## API 版本控制策略

### 版本控制策略比較

| 策略 | 實現方式 | 優點 | 缺點 | 適用場景 |
|------|----------|------|------|----------|
| **URL 路徑** | `/api/v1/users` | 清晰明確、易於理解 | URL 較長、路由複雜 | 公開 API |
| **查詢參數** | `/api/users?version=1` | 靈活、易於實現 | 容易被忽略 | 內部 API |
| **標頭版本** | `Accept: application/vnd.api.v1+json` | 語義清晰、符合 HTTP 標準 | 實現複雜 | 企業級 API |

### URL 路徑版本控制實現

```java
/**
 * URL 路徑版本控制實現
 * 最常見和直觀的版本控制方式
 */
@RestController
public class VersionedUserController {
    
    private final UserService userService;
    private final UserMapperV1 userMapperV1;
    private final UserMapperV2 userMapperV2;
    
    /**
     * API v1 - 基礎使用者資訊
     * GET /api/v1/users/{id}
     */
    @GetMapping("/api/v1/users/{id}")
    public ResponseEntity<UserV1Dto> getUserV1(@PathVariable Long id) {
        User user = userService.findById(id);
        UserV1Dto userDto = userMapperV1.toDto(user);
        
        return ResponseEntity.ok()
                .header("API-Version", "1.0")
                .body(userDto);
    }
    
    /**
     * API v2 - 增強的使用者資訊（包含偏好設定）
     * GET /api/v2/users/{id}
     */
    @GetMapping("/api/v2/users/{id}")
    public ResponseEntity<UserV2Dto> getUserV2(@PathVariable Long id) {
        User user = userService.findById(id);
        UserV2Dto userDto = userMapperV2.toDto(user);
        
        return ResponseEntity.ok()
                .header("API-Version", "2.0")
                .body(userDto);
    }
}
```

---

## 快取策略設計

### HTTP 快取標頭對照表

| 標頭 | 類型 | 用途 | 範例 |
|------|------|------|------|
| **Cache-Control** | 回應/請求 | 控制快取行為 | `max-age=3600, public` |
| **ETag** | 回應 | 資源版本標識 | `"abc123"` |
| **Last-Modified** | 回應 | 最後修改時間 | `Wed, 21 Oct 2015 07:28:00 GMT` |
| **If-None-Match** | 請求 | 條件式請求（ETag） | `"abc123"` |
| **If-Modified-Since** | 請求 | 條件式請求（時間） | `Wed, 21 Oct 2015 07:28:00 GMT` |

### 快取策略實現

```java
/**
 * RESTful API 快取策略實現
 * 展示各種快取控制技術
 */
@RestController
@RequestMapping("/api/v1/articles")
public class ArticleCacheController {
    
    private final ArticleService articleService;
    
    /**
     * 獲取文章列表（公開快取）
     * GET /api/v1/articles
     */
    @GetMapping
    public ResponseEntity<List<ArticleDto>> getArticles() {
        List<Article> articles = articleService.findPublishedArticles();
        List<ArticleDto> articleDtos = articles.stream()
                .map(articleMapper::toDto)
                .collect(Collectors.toList());
        
        return ResponseEntity.ok()
                .cacheControl(CacheControl.maxAge(Duration.ofMinutes(15))
                        .cachePublic()
                        .mustRevalidate())
                .body(articleDtos);
    }
    
    /**
     * 獲取文章詳情（ETag 快取）
     * GET /api/v1/articles/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<ArticleDto> getArticle(
            @PathVariable Long id,
            HttpServletRequest request
    ) {
        Article article = articleService.findById(id);
        
        // 生成 ETag
        String etag = generateETag(article);
        
        // 檢查條件式請求
        String ifNoneMatch = request.getHeader("If-None-Match");
        if (etag.equals(ifNoneMatch)) {
            return ResponseEntity.status(HttpStatus.NOT_MODIFIED)
                    .eTag(etag)
                    .build();
        }
        
        ArticleDto articleDto = articleMapper.toDto(article);
        
        return ResponseEntity.ok()
                .eTag(etag)
                .cacheControl(CacheControl.maxAge(Duration.ofMinutes(30))
                        .cachePrivate())
                .body(articleDto);
    }
    
    /**
     * 生成 ETag
     */
    private String generateETag(Article article) {
        String content = article.getId() + ":" + 
                        article.getTitle() + ":" + 
                        article.getUpdatedAt().toString();
        
        return "\"" + DigestUtils.md5DigestAsHex(content.getBytes()) + "\"";
    }
}
```

---

## RESTful API 設計最佳實踐總結

### API 設計檢查清單

在設計 RESTful API 時，請參考以下檢查清單：

| 檢查項目 | 說明 | 範例 |
|---------|------|------|
| **資源導向** | 使用名詞而非動詞 | `/api/users` 而非 `/api/getUsers` |
| **HTTP 方法** | 正確使用 HTTP 動詞 | GET 查詢、POST 建立、PUT 更新、DELETE 刪除 |
| **狀態碼** | 語義化的 HTTP 狀態碼 | 201 Created、404 Not Found、409 Conflict |
| **統一格式** | 一致的回應結構 | 統一的錯誤格式和成功格式 |
| **版本控制** | 明確的版本策略 | `/api/v1/` 或標頭版本控制 |
| **快取支援** | 適當的快取控制 | ETag、Cache-Control、Last-Modified |

✅ **最佳實踐標記**：
- 使用資源導向的 URL 設計
- 正確運用 HTTP 方法語義
- 實現統一的錯誤處理機制
- 支援適當的快取策略
- 考慮 API 版本演進需求

⚠️ **常見陷阱**：
- URL 中使用動詞而非名詞
- 所有操作都使用 POST 方法
- 忽略 HTTP 狀態碼的語義
- 缺乏統一的錯誤處理
- 沒有考慮快取和效能

---

## 📝 重點摘要

本章深入探討了 RESTful API 設計與實踐的核心概念和最佳實踐。以下是關鍵要點：

### 🎯 核心概念回顧

1. **REST 架構約束**
   - 客戶端-伺服器分離
   - 無狀態通信
   - 統一介面設計
   - 分層系統架構

2. **HTTP 語義化使用**
   - GET：安全且冪等的資源獲取
   - POST：非冪等的資源建立
   - PUT：冪等的完整資源更新
   - DELETE：冪等的資源刪除

3. **URL 設計原則**
   - 使用名詞表示資源
   - 採用階層結構反映關係
   - 統一命名規範
   - 支援查詢參數篩選

### 💡 實踐技巧總結

| 技巧類別 | 關鍵要點 | 實際效益 |
|---------|---------|---------|
| **資源設計** | 名詞導向的 URL 結構 | 提升 API 可理解性 |
| **HTTP 語義** | 正確使用 HTTP 方法和狀態碼 | 符合 Web 標準，提升互操作性 |
| **錯誤處理** | 統一的異常處理機制 | 簡化客戶端錯誤處理邏輯 |
| **版本控制** | 明確的版本演進策略 | 支援 API 持續演進 |
| **效能優化** | 適當的快取控制策略 | 提升系統效能和使用者體驗 |

### ✅ 開發檢查清單

在實際開發中，請確保：

- [ ] **URL 設計**：使用資源導向的命名規範
- [ ] **HTTP 方法**：正確選擇和使用 HTTP 動詞
- [ ] **狀態碼**：回傳語義化的 HTTP 狀態碼
- [ ] **錯誤處理**：實現統一的異常處理機制
- [ ] **版本控制**：制定明確的版本管理策略
- [ ] **快取策略**：實現適當的快取控制機制

### 🚀 下一步學習方向

掌握了 RESTful API 設計後，建議您繼續學習：

1. **API 安全性**：實現認證授權和資料保護
2. **API 文件化**：使用 OpenAPI/Swagger 生成文件
3. **API 測試**：建立完整的 API 測試策略
4. **微服務架構**：在分散式系統中應用 RESTful 設計

💡 **學習提示**：RESTful API 設計是現代 Web 開發的基礎技能，良好的設計不僅提升開發效率，更能改善系統的可維護性和擴展性。

---

**恭喜您完成本章學習！** 🎉

您現在已經掌握了 RESTful API 設計與實踐的核心技能。這些知識將為您的 Web API 開發奠定堅實的基礎。在下一章中，我們將探討 Controller 的路徑匹配與方法註解，進一步提升您的 Spring MVC 開發能力。
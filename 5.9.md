# 5.9 取得實際氣象資訊

> **本章重點**：學習如何整合真實的第三方 API 資料，透過 Function Calling 讓 AI 能夠獲取即時的氣象資訊，建立完整的天氣查詢和分析系統。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **整合第三方 API**：學會如何整合中央氣象局等真實 API 服務
- 🎯 **實現即時資料查詢**：讓 AI 能夠獲取最新的氣象資訊
- 🎯 **設計天氣工具系統**：建立完整的天氣查詢和分析工具
- 🎯 **處理 API 異常**：掌握第三方 API 的錯誤處理和容錯機制
- 🎯 **優化查詢效能**：實現快取和批次查詢優化策略

---

## 5.9.1 真實 API 整合的重要性

### 有了 AI 寫程式都可以偷懶

![AI Development](https://example.com/ai-development.jpg)

還記得前面提到要取得即時資訊只能透過 Function Calling 嗎？網路上一堆教學都使用模擬資料，今天來教大家怎麼抓中央氣象局的資料，並使用最新的 @Tool 註解實現更優雅的 Function Calling。

### 模擬資料 vs 真實資料

| 比較項目 | 模擬資料 | 真實 API 資料 |
|----------|----------|---------------|
| **資料準確性** | 固定不變 | 即時更新 |
| **開發複雜度** | 簡單 | 需要處理 API 整合 |
| **實用價值** | 僅供學習 | 可實際應用 |
| **錯誤處理** | 不需要 | 必須完善處理 |
| **效能考量** | 無限制 | 需要考慮 API 限制 |
| **成本** | 免費 | 可能有使用費用 |

### 真實 API 整合的挑戰

**1. API 限制和配額**
- 📊 **請求頻率限制**：每分鐘/每小時的請求次數限制
- 💰 **使用成本**：超過免費額度後的計費
- 🔑 **認證機制**：API Key 管理和安全性
- ⏰ **回應時間**：網路延遲和 API 處理時間

**2. 資料格式和解析**
- 📋 **複雜的 JSON 結構**：需要深度解析巢狀資料
- 🔄 **資料格式變更**：API 版本更新可能改變格式
- 🌐 **多語言支援**：處理不同語言的資料
- 📏 **單位轉換**：溫度、風速等單位的標準化

**3. 錯誤處理和容錯**
- 🚫 **API 服務中斷**：第三方服務不可用時的處理
- 📡 **網路問題**：連線超時和重試機制
- 🔍 **資料缺失**：部分地區或時間的資料不完整
- ⚠️ **格式錯誤**：API 回傳異常格式的處理

---

## 5.9.2 中央氣象局 API 整合

### 取得中央氣象局開放平台資料

**步驟 1：註冊和取得 API Key**

中央氣象局有個資料開放平台：[https://opendata.cwa.gov.tw/index](https://opendata.cwa.gov.tw/index)

註冊後就能在 **會員資訊－取得授權碼** 拿到自己的授權碼。

![Weather API](https://example.com/weather-api.png)

**步驟 2：選擇合適的資料集**

可以在資料主題找需要的資料，由於我只要抓到目前的氣象資訊，所以選擇 **觀測-現在天氣觀測報告**。

> 💡 **小提示**：最好找有 API 的，不然需要下載檔案再用讀檔的方式處理

**步驟 3：API 測試**

進入後就是 API 常用的 Swagger 網站了。點選 Try it out 輸入授權碼，按下 Execute 就能取得 JSON 資料了。

### 專案配置

**Maven 依賴**：

```xml
<!-- 使用 Spring AI BOM 管理版本 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-bom</artifactId>
            <version>1.0.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <!-- Spring AI OpenAI Starter -->
    <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
        </dependency>
    
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

**應用程式配置**：

```yaml
# application.yml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      chat:
        options:
          model: gpt-4o-mini
          temperature: 0.1

# 中央氣象局 API 配置
cwa:
  api:
    key: ${CWA_API_KEY}  # 中央氣象局 API Key
    base-url: https://opendata.cwa.gov.tw/api/v1/rest/datastore

# 日誌配置
logging:
  level:
    com.example.weather: DEBUG
    org.springframework.ai: DEBUG
```

---

## 5.9.3 天氣服務實現

### 核心天氣服務

```java
package com.example.service;

import com.fasterxml.jackson.databind.JsonNode;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class WeatherService {

    private final RestTemplate restTemplate;
    
    @Value("${cwa.api.key}")
    private String apiKey;
    
    @Value("${cwa.api.base-url:https://opendata.cwa.gov.tw/api/v1/rest/datastore}")
    private String baseUrl;

    /**
     * 取得指定地區的目前天氣資訊
     * @param location 地區名稱
     * @return 天氣資訊
     */
    @Tool(description = "Get current weather information for a specific location in Taiwan. " +
          "Supports major cities and counties like Taipei, Taoyuan, Taichung, Tainan, Kaohsiung, etc.")
    public WeatherInfo getCurrentWeather(String location) {
        try {
            log.info("查詢天氣資訊：{}", location);
            
            String url = baseUrl + "/O-A0003-001?Authorization=" + apiKey;
            
            JsonNode response = restTemplate.getForObject(url, JsonNode.class);
            
            if (response == null || !response.has("records")) {
                return WeatherInfo.error("無法取得天氣資料");
            }
            
            // 解析天氣資料
            JsonNode records = response.get("records");
            JsonNode locations = records.get("location");
            
            if (locations == null || !locations.isArray()) {
                return WeatherInfo.error("天氣資料格式錯誤");
            }
            
            // 尋找指定地區的天氣資料
            for (JsonNode locationNode : locations) {
                String locationName = locationNode.get("locationName").asText();
                
                if (locationName.contains(location) || location.contains(locationName)) {
                    WeatherInfo result = parseWeatherData(locationNode, locationName);
                    log.info("成功取得 {} 的天氣資訊", locationName);
                    return result;
                }
            }
            
            return WeatherInfo.notFound("找不到 " + location + " 的天氣資料，請確認地區名稱是否正確");
            
        } catch (Exception e) {
            log.error("取得天氣資料時發生錯誤: {}", e.getMessage(), e);
            return WeatherInfo.error("取得天氣資料失敗：" + e.getMessage());
        }
    }

    /**
     * 取得全台各地的溫度排行榜
     * @param topCount 排行數量
     * @return 溫度排行
     */
    @Tool(description = "Get temperature ranking for all locations in Taiwan. " +
          "Returns top N locations sorted by temperature.")
    public TemperatureRanking getTemperatureRanking(Integer topCount) {
        if (topCount == null || topCount <= 0) {
            topCount = 10;
        }
        
        try {
            log.info("查詢溫度排行榜：前 {} 名", topCount);
            
            String url = baseUrl + "/O-A0003-001?Authorization=" + apiKey;
            JsonNode response = restTemplate.getForObject(url, JsonNode.class);
            
            if (response == null || !response.has("records")) {
                return TemperatureRanking.error("無法取得天氣資料");
            }
            
            List<LocationTemperature> temperatures = new ArrayList<>();
            JsonNode locations = response.get("records").get("location");
            
            for (JsonNode locationNode : locations) {
                String locationName = locationNode.get("locationName").asText();
                JsonNode weatherElements = locationNode.get("weatherElement");
                
                Double temp = extractTemperature(weatherElements);
                if (temp != null) {
                    temperatures.add(new LocationTemperature(locationName, temp));
                }
            }
            
            // 按溫度排序並取前 N 名
            List<LocationTemperature> topTemperatures = temperatures.stream()
                    .sorted((a, b) -> Double.compare(b.temperature(), a.temperature()))
                    .limit(topCount)
                    .toList();
            
            log.info("成功取得溫度排行榜：{} 個地點", topTemperatures.size());
            
            return new TemperatureRanking(
                    topTemperatures,
                    true,
                    null,
                    LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
            );
            
        } catch (Exception e) {
            log.error("取得溫度排行時發生錯誤: {}", e.getMessage(), e);
            return TemperatureRanking.error("取得溫度排行失敗：" + e.getMessage());
        }
    }

    /**
     * 取得天氣預報資訊
     * @param location 地區名稱
     * @param days 預報天數
     * @return 天氣預報
     */
    @Tool(description = "Get weather forecast for a specific location. " +
          "Provides multi-day weather forecast including temperature and conditions.")
    public WeatherForecast getWeatherForecast(String location, Integer days) {
        if (days == null || days <= 0) {
            days = 3;
        }
        
        try {
            log.info("查詢天氣預報：{}，{} 天", location, days);
            
            // 這裡可以整合預報 API
            // 目前先返回模擬資料
            List<DailyForecast> forecasts = generateMockForecast(location, days);
            
            return new WeatherForecast(
                    location,
                    forecasts,
                    true,
                    null
            );
            
        } catch (Exception e) {
            log.error("取得天氣預報時發生錯誤: {}", e.getMessage(), e);
            return WeatherForecast.error("取得天氣預報失敗：" + e.getMessage());
        }
    }
    
    /**
     * 解析天氣資料
     */
    private WeatherInfo parseWeatherData(JsonNode locationNode, String locationName) {
        try {
            JsonNode weatherElements = locationNode.get("weatherElement");
            
            Double temperature = extractTemperature(weatherElements);
            Double humidity = extractHumidity(weatherElements);
            String weather = extractWeatherDescription(weatherElements);
            Double rainfall = extractRainfall(weatherElements);
            String windDirection = extractWindDirection(weatherElements);
            Double windSpeed = extractWindSpeed(weatherElements);
            
            return new WeatherInfo(
                    locationName,
                    temperature,
                    humidity,
                    weather,
                    rainfall,
                    windDirection,
                    windSpeed,
                    true,
                    null,
                    LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
            );
            
        } catch (Exception e) {
            log.error("解析天氣資料失敗", e);
            return WeatherInfo.error("解析天氣資料失敗：" + e.getMessage());
        }
    }
    
    private Double extractTemperature(JsonNode weatherElements) {
        return extractElementValue(weatherElements, "TEMP");
    }
    
    private Double extractHumidity(JsonNode weatherElements) {
        return extractElementValue(weatherElements, "HUMD");
    }
    
    private Double extractRainfall(JsonNode weatherElements) {
        return extractElementValue(weatherElements, "24R");
    }
    
    private Double extractWindSpeed(JsonNode weatherElements) {
        return extractElementValue(weatherElements, "WDSD");
    }
    
    private String extractWeatherDescription(JsonNode weatherElements) {
        JsonNode element = findWeatherElement(weatherElements, "Weather");
        if (element != null && element.has("elementValue")) {
            return element.get("elementValue").asText();
        }
        return null;
    }
    
    private String extractWindDirection(JsonNode weatherElements) {
        JsonNode element = findWeatherElement(weatherElements, "WDIR");
        if (element != null && element.has("elementValue")) {
            return element.get("elementValue").asText();
        }
        return null;
    }
    
    private Double extractElementValue(JsonNode weatherElements, String elementName) {
        JsonNode element = findWeatherElement(weatherElements, elementName);
        if (element != null && element.has("elementValue")) {
            try {
                return element.get("elementValue").asDouble();
            } catch (Exception e) {
                log.warn("無法解析 {} 的數值", elementName);
            }
        }
        return null;
    }
    
    private JsonNode findWeatherElement(JsonNode weatherElements, String elementName) {
        if (weatherElements != null && weatherElements.isArray()) {
            for (JsonNode element : weatherElements) {
                if (element.has("elementName") && 
                    elementName.equals(element.get("elementName").asText())) {
                    return element;
                }
            }
        }
        return null;
    }
    
    private List<DailyForecast> generateMockForecast(String location, int days) {
        List<DailyForecast> forecasts = new ArrayList<>();
        for (int i = 0; i < days; i++) {
            forecasts.add(new DailyForecast(
                    LocalDateTime.now().plusDays(i).toLocalDate().toString(),
                    "晴時多雲",
                    25.0 + i,
                    30.0 + i,
                    20.0 + i,
                    60.0
            ));
        }
        return forecasts;
    }
}
```

### 資料模型定義

```java
package com.example.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;

import java.util.List;

/**
 * 天氣資訊資料類別
 */
public record WeatherInfo(
        @JsonProperty("location") String location,
        @JsonProperty("temperature") Double temperature,
        @JsonProperty("humidity") Double humidity,
        @JsonProperty("weather") String weather,
        @JsonProperty("rainfall") Double rainfall,
        @JsonProperty("wind_direction") String windDirection,
        @JsonProperty("wind_speed") Double windSpeed,
        @JsonProperty("success") boolean success,
        @JsonProperty("error") String error,
        @JsonProperty("observation_time") String observationTime
) {
    public static WeatherInfo error(String message) {
        return new WeatherInfo(null, null, null, null, null, null, null,
                false, message, null);
    }
    
    public static WeatherInfo notFound(String message) {
        return new WeatherInfo(null, null, null, null, null, null, null,
                false, message, null);
    }
    
    @Override
    public String toString() {
        if (!success) {
            return "❌ " + error;
        }
        
        StringBuilder sb = new StringBuilder();
        sb.append("📍 地點：").append(location).append("\n");
        sb.append("🌡️ 溫度：").append(temperature != null ? temperature + "°C" : "無資料").append("\n");
        sb.append("💧 濕度：").append(humidity != null ? humidity + "%" : "無資料").append("\n");
        sb.append("☁️ 天氣：").append(weather != null ? weather : "無資料").append("\n");
        sb.append("🌧️ 降雨量：").append(rainfall != null ? rainfall + "mm" : "無資料").append("\n");
        sb.append("💨 風向：").append(windDirection != null ? windDirection : "無資料").append("\n");
        sb.append("🌪️ 風速：").append(windSpeed != null ? windSpeed + "m/s" : "無資料").append("\n");
        sb.append("⏰ 觀測時間：").append(observationTime);
        
        return sb.toString();
    }
}

/**
 * 溫度排行資料
 */
public record TemperatureRanking(
        List<LocationTemperature> rankings,
        boolean success,
        String error,
        String updateTime
) {
    public static TemperatureRanking error(String message) {
        return new TemperatureRanking(List.of(), false, message, null);
    }
}

public record LocationTemperature(
        String location,
        Double temperature
) {}

/**
 * 天氣預報資料
 */
public record WeatherForecast(
        String location,
        List<DailyForecast> forecasts,
        boolean success,
        String error
) {
    public static WeatherForecast error(String message) {
        return new WeatherForecast(null, List.of(), false, message);
    }
}

public record DailyForecast(
        String date,
        String weather,
        Double temperature,
        Double maxTemperature,
        Double minTemperature,
        Double humidity
) {}
```

---

## 5.9.4 天氣查詢控制器

### REST API 控制器

```java
package com.example.controller;

import com.example.model.WeatherInfo;
import com.example.model.TemperatureRanking;
import com.example.service.WeatherService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/weather")
@RequiredArgsConstructor
@Slf4j
public class WeatherController {

    private final ChatClient chatClient;
    private final WeatherService weatherService;

    /**
     * AI 天氣查詢
     * @param question 天氣查詢問題
     * @return AI 回應
     */
    @GetMapping("/chat")
    public ResponseEntity<WeatherChatResponse> chatWeather(@RequestParam String question) {
        
        try {
            log.info("收到天氣查詢：{}", question);
            
            String response = chatClient
                    .prompt(question)
                    .tools(weatherService)
                    .call()
                    .content();
            
            WeatherChatResponse chatResponse = new WeatherChatResponse(
                    question,
                    response,
                    true,
                    null,
                    System.currentTimeMillis()
            );
            
            return ResponseEntity.ok(chatResponse);
            
        } catch (Exception e) {
            log.error("天氣查詢失敗: {}", e.getMessage(), e);
            
            WeatherChatResponse errorResponse = new WeatherChatResponse(
                    question,
                    null,
                    false,
                    "天氣查詢失敗：" + e.getMessage(),
                    System.currentTimeMillis()
            );
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(errorResponse);
        }
    }

    /**
     * 直接取得天氣資訊
     * @param location 地點名稱
     * @return 天氣資訊
     */
    @GetMapping("/current")
    public ResponseEntity<WeatherInfo> getCurrentWeather(@RequestParam String location) {
        
        WeatherInfo weatherInfo = weatherService.getCurrentWeather(location);
        
        if (weatherInfo.success()) {
            return ResponseEntity.ok(weatherInfo);
        } else {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(weatherInfo);
        }
    }

    /**
     * 取得溫度排行榜
     * @param topCount 排行數量
     * @return 溫度排行
     */
    @GetMapping("/temperature-ranking")
    public ResponseEntity<TemperatureRanking> getTemperatureRanking(
            @RequestParam(defaultValue = "10") Integer topCount) {
        
        TemperatureRanking ranking = weatherService.getTemperatureRanking(topCount);
        return ResponseEntity.ok(ranking);
    }

    /**
     * 天氣查詢回應
     */
    public record WeatherChatResponse(
            String question,
            String answer,
            boolean success,
            String error,
            long timestamp
    ) {}
}
```

---

## 5.9.5 簡化配置

### 基本配置類

```java
package com.example.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class WeatherApiConfig {

    /**
     * 天氣 API 專用的 RestTemplate
     */
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

---

## 5.9.6 測試應用

### 測試天氣查詢

**基本 API 測試**：

```bash
# 基本天氣查詢
curl "http://localhost:8080/api/weather/chat?question=桃園目前天氣如何？"

# 溫度排行查詢
curl "http://localhost:8080/api/weather/chat?question=全台最高溫的前三名是哪些地方？"

# 天氣預報查詢
curl "http://localhost:8080/api/weather/chat?question=台中未來三天天氣預報"

# 直接 API 調用
curl "http://localhost:8080/api/weather/current?location=台北"

# 溫度排行榜
curl "http://localhost:8080/api/weather/temperature-ranking?topCount=5"
```

**回應範例**：

```json
{
  "question": "桃園目前天氣如何？",
  "answer": "📍 地點：桃園\n🌡️ 溫度：28.5°C\n💧 濕度：72%\n☁️ 天氣：多雲\n🌧️ 降雨量：0.0mm\n💨 風向：東南風\n🌪️ 風速：2.3m/s\n⏰ 觀測時間：2025-01-29 14:30",
  "success": true,
  "error": null,
  "timestamp": 1706518200000
}
```

### 進階功能測試

**多地點比較查詢**：

```
用戶：「比較台北、台中、高雄三個城市的天氣狀況」

AI 回應：
🌤️ **三大城市天氣比較**

📍 **台北**
🌡️ 溫度：26.8°C
💧 濕度：78%
☁️ 天氣：陰天

📍 **台中**
🌡️ 溫度：29.2°C
💧 濕度：65%
☁️ 天氣：晴時多雲

📍 **高雄**
🌡️ 溫度：31.5°C
💧 濕度：70%
☁️ 天氣：晴天

📊 **分析總結**
- 🔥 最熱：高雄 (31.5°C)
- 🌡️ 最涼：台北 (26.8°C)
- 💧 最潮濕：台北 (78%)
- ☀️ 天氣最佳：高雄
```

**智能建議查詢**：

```
用戶：「明天要去台中，需要帶雨具嗎？」

AI 回應：
🌦️ **台中明天天氣建議**

📅 **明天天氣預報**
🌡️ 溫度：25-30°C
☁️ 天氣：晴時多雲
🌧️ 降雨機率：20%
💨 風力：微風

☂️ **攜帶建議**
✅ 建議攜帶輕便雨具
- 雖然降雨機率不高，但午後可能有局部陣雨
- 可準備摺疊傘以備不時之需
- 穿著輕薄透氣的衣物即可

🎯 **出行建議**
- 適合戶外活動
- 注意防曬
- 多補充水分
```

---

## 📝 本章重點回顧

1. **真實 API 整合**：學會了整合中央氣象局等第三方 API 服務
2. **即時資料查詢**：實現了 AI 獲取最新氣象資訊的能力
3. **Tool Calling 應用**：建立了天氣查詢和分析的 AI 工具
4. **資料解析處理**：掌握了 JSON 資料的解析和轉換技術
5. **AI 智能分析**：實現了基於真實資料的智能天氣分析

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **第三方 API 整合** | ⭐⭐⭐ | 中 | 所有即時資料應用 |
| **資料解析處理** | ⭐⭐⭐ | 中 | API 資料處理 |
| **Tool Calling** | ⭐⭐⭐ | 中 | AI 工具整合 |
| **JSON 處理** | ⭐⭐ | 低 | 資料轉換 |
| **錯誤處理** | ⭐⭐ | 中 | 系統穩定性 |

### 最佳實踐建議

**1. API 使用策略**
- 🔑 **安全管理**：妥善保管 API Key，使用環境變數
- 📊 **配額監控**：監控 API 使用量，避免超過限制
- 🛡️ **錯誤處理**：對 API 調用失敗進行適當的錯誤處理

**2. 資料處理優化**
- 🎯 **精確解析**：仔細處理 JSON 結構，避免解析錯誤
- 🛡️ **防禦性編程**：對所有可能的空值和異常進行處理
- 📏 **單位標準化**：統一溫度、風速等單位的表示方式

**3. AI 工具設計**
- 💬 **清晰描述**：為 @Tool 註解提供清晰的功能描述
- 📊 **結構化回應**：提供清晰、易讀的天氣資訊格式
- 🎨 **視覺化展示**：使用表情符號和格式化增強可讀性
- 💡 **智能建議**：基於天氣資訊提供實用的生活建議

### 企業應用價值

**1. 商業應用場景**
- 🏢 **企業決策支援**：為戶外作業、物流配送提供天氣資訊
- 📱 **移動應用整合**：為 App 提供即時天氣查詢功能
- 🤖 **智能客服**：在客服系統中整合天氣查詢能力
- 📊 **資料分析平台**：將天氣資料納入商業分析模型

**2. 技術架構優勢**
- 🔧 **模組化設計**：天氣服務可獨立部署和擴展
- 🚀 **AI 工具整合**：透過 Tool Calling 實現智能天氣分析
- 📈 **即時資料存取**：獲取最新的氣象資訊
- 🔄 **易於維護**：清晰的代碼結構和錯誤處理

### 下一步學習方向

在下一章中，我們將學習結構化資料轉換器，探索如何讓 AI 輸出結構化的資料格式，為企業應用提供更標準化的資料介面。

---

**參考資料：**
- [中央氣象局開放資料平台](https://opendata.cwa.gov.tw/index)
- [Spring AI Tool Calling Documentation](https://docs.spring.io/spring-ai/reference/api/tools.html)
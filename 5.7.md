# 5.7 Function Calling (中) - 讓 AI 讀取企業資訊

> **本章重點**：學習如何讓 AI 透過 Tool Calling 存取企業內部資料，實現 AI 與企業系統的深度整合，建立智能化的企業資料分析和查詢系統。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **企業資料整合**：讓 AI 能夠存取和分析企業內部資料
- 🎯 **複雜工具設計**：建立帶參數和結構化回應的進階工具
- 🎯 **多工具協作**：實現多個工具的組合使用和協同工作
- 🎯 **資料模型設計**：掌握企業級資料模型的設計和實現
- 🎯 **智能分析系統**：建立 AI 驅動的企業資料分析平台

---

## 5.7.1 企業 AI 整合的重要性

### 在地化的第一步

![企業資料整合](https://ithelp.ithome.com.tw/upload/images/20240811/20161290JBnMyu335V.jpg)

只是問時間似乎無法體會 Tool Calling 有什麼特別之處，今天我們模擬從後端取得資料並透過 AI 幫我們分析，看看工具該如何撰寫。

### 企業 AI 應用的核心挑戰

**1. 資料孤島問題**
- 🏢 **分散的企業系統**：ERP、CRM、財務、人事等系統各自獨立
- 📊 **資料格式不一**：不同系統使用不同的資料格式和標準
- 🔒 **存取權限複雜**：企業資料涉及安全性和權限管理
- 🔄 **即時性要求**：業務決策需要即時的資料分析

**2. 傳統解決方案的限制**
- 📈 **BI 工具複雜**：需要專業技能才能操作
- 💰 **開發成本高**：每個查詢需求都要單獨開發
- ⏰ **回應速度慢**：從需求到實現週期長
- 🎯 **靈活性不足**：難以應對臨時性的分析需求

**3. AI + Tool Calling 的優勢**
- 🗣️ **自然語言查詢**：用日常語言描述分析需求
- 🔄 **即時資料存取**：透過 API 即時獲取最新資料
- 🧠 **智能分析**：AI 自動進行資料分析和洞察
- 🎨 **靈活組合**：多個資料源的智能整合

### 企業 AI 應用場景

| 應用領域 | 具體場景 | Tool Calling 解決方案 |
|----------|----------|----------------------|
| **銷售分析** | 產品銷量統計、趨勢分析 | 銷售資料查詢工具 |
| **財務管理** | 收支分析、預算控制 | 財務資料存取工具 |
| **人力資源** | 員工績效、薪資分析 | HR 系統整合工具 |
| **庫存管理** | 庫存狀態、補貨建議 | 庫存查詢工具 |
| **客戶服務** | 客戶資訊、服務記錄 | CRM 系統工具 |
| **營運分析** | KPI 監控、異常檢測 | 營運資料工具 |

---

## 5.7.2 企業資料工具設計

### 程式目標設定

**實戰場景**：詢問 AI 公司每個產品去年的銷量，並統計占銷量的比例是多少

**技術要求**：
- 📊 從企業資料庫獲取產品銷售資料
- 🔢 支援年份和產品型號的篩選查詢
- 📈 提供結構化的資料回應
- 🧮 讓 AI 進行自動分析和計算

### 產品銷售工具實現

**步驟 1：資料模型設計**

```java
package com.example.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.fasterxml.jackson.annotation.JsonClassDescription;
import lombok.Data;
import lombok.Builder;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

/**
 * 產品銷售資料模型
 */
@Data
@Builder
public class Product {
    
    @JsonProperty("year")
    @JsonPropertyDescription("銷售年份")
    private String year;
    
    @JsonProperty("model")
    @JsonPropertyDescription("產品型號")
    private String model;
    
    @JsonProperty("name")
    @JsonPropertyDescription("產品名稱")
    private String name;
    
    @JsonProperty("quantity")
    @JsonPropertyDescription("銷售數量")
    private Integer quantity;
    
    @JsonProperty("revenue")
    @JsonPropertyDescription("銷售金額")
    private BigDecimal revenue;
    
    @JsonProperty("category")
    @JsonPropertyDescription("產品類別")
    private String category;
    
    @JsonProperty("launch_date")
    @JsonPropertyDescription("上市日期")
    private LocalDate launchDate;
}

/**
 * 產品銷售查詢回應
 */
@Data
@Builder
@JsonClassDescription("公司產品銷售資料回應")
public class ProductSalesResponse {
    
    @JsonProperty("products")
    @JsonPropertyDescription("產品銷售清單")
    private List<Product> products;
    
    @JsonProperty("total_quantity")
    @JsonPropertyDescription("總銷售數量")
    private Integer totalQuantity;
    
    @JsonProperty("total_revenue")
    @JsonPropertyDescription("總銷售金額")
    private BigDecimal totalRevenue;
    
    @JsonProperty("query_year")
    @JsonPropertyDescription("查詢年份")
    private String queryYear;
    
    @JsonProperty("query_product")
    @JsonPropertyDescription("查詢產品")
    private String queryProduct;
}

/**
 * 銷售統計資料
 */
@Data
@Builder
@JsonClassDescription("銷售統計分析結果")
public class SalesStatistics {
    
    @JsonProperty("top_products")
    @JsonPropertyDescription("銷量前五名產品")
    private List<Product> topProducts;
    
    @JsonProperty("category_stats")
    @JsonPropertyDescription("各類別銷售統計")
    private List<CategoryStat> categoryStats;
    
    @JsonProperty("year_over_year_growth")
    @JsonPropertyDescription("年度成長率")
    private BigDecimal yearOverYearGrowth;
    
    @Data
    @Builder
    public static class CategoryStat {
        private String category;
        private Integer quantity;
        private BigDecimal revenue;
        private Double percentage;
    }
}
```

**步驟 2：企業資料存取服務**

```java
package com.example.service;

import com.example.model.Product;
import com.example.model.ProductSalesResponse;
import com.example.model.SalesStatistics;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class EnterpriseDataService {
    
    /**
     * 模擬企業資料庫查詢
     * 實際應用中這裡會連接到真實的企業資料庫
     */
    public List<Product> getProductSalesData() {
        return List.of(
            Product.builder()
                .year("2022")
                .model("PD-1405")
                .name("智能手機 Pro")
                .quantity(12500)
                .revenue(new BigDecimal("625000000"))
                .category("電子產品")
                .launchDate(LocalDate.of(2021, 3, 15))
                .build(),
            
            Product.builder()
                .year("2023")
                .model("PD-1234")
                .name("筆記型電腦 Ultra")
                .quantity(10000)
                .revenue(new BigDecimal("800000000"))
                .category("電腦設備")
                .launchDate(LocalDate.of(2022, 6, 20))
                .build(),
            
            Product.builder()
                .year("2023")
                .model("PD-1235")
                .name("平板電腦 Lite")
                .quantity(1500)
                .revenue(new BigDecimal("45000000"))
                .category("電子產品")
                .launchDate(LocalDate.of(2022, 9, 10))
                .build(),
            
            Product.builder()
                .year("2023")
                .model("PD-1385")
                .name("智能手錶 Sport")
                .quantity(15000)
                .revenue(new BigDecimal("300000000"))
                .category("穿戴裝置")
                .launchDate(LocalDate.of(2023, 1, 5))
                .build(),
            
            Product.builder()
                .year("2024")
                .model("PD-1255")
                .name("無線耳機 Pro")
                .quantity(15000)
                .revenue(new BigDecimal("225000000"))
                .category("音響設備")
                .launchDate(LocalDate.of(2023, 8, 12))
                .build(),
            
            Product.builder()
                .year("2024")
                .model("PD-1300")
                .name("智能音箱 Home")
                .quantity(12000)
                .revenue(new BigDecimal("180000000"))
                .category("智能家居")
                .launchDate(LocalDate.of(2023, 11, 25))
                .build(),
            
            Product.builder()
                .year("2024")
                .model("PD-1405")
                .name("智能手機 Pro Max")
                .quantity(12500)
                .revenue(new BigDecimal("750000000"))
                .category("電子產品")
                .launchDate(LocalDate.of(2024, 2, 14))
                .build(),
            
            Product.builder()
                .year("2024")
                .model("PD-1235")
                .name("平板電腦 Pro")
                .quantity(15000)
                .revenue(new BigDecimal("600000000"))
                .category("電子產品")
                .launchDate(LocalDate.of(2024, 4, 8))
                .build(),
            
            Product.builder()
                .year("2024")
                .model("PD-1385")
                .name("智能手錶 Ultra")
                .quantity(15000)
                .revenue(new BigDecimal("450000000"))
                .category("穿戴裝置")
                .launchDate(LocalDate.of(2024, 6, 18))
                .build()
        );
    }
    
    /**
     * 根據條件篩選產品資料
     */
    public List<Product> filterProducts(String year, String productModel) {
        List<Product> allProducts = getProductSalesData();
        
        return allProducts.stream()
                .filter(product -> year == null || product.getYear().equals(year))
                .filter(product -> productModel == null || 
                        product.getModel().toLowerCase().contains(productModel.toLowerCase()) ||
                        product.getName().toLowerCase().contains(productModel.toLowerCase()))
                .collect(Collectors.toList());
    }
    
    /**
     * 計算銷售統計資料
     */
    public SalesStatistics calculateSalesStatistics(List<Product> products) {
        // 計算總銷量
        int totalQuantity = products.stream()
                .mapToInt(Product::getQuantity)
                .sum();
        
        // 計算各類別統計
        List<SalesStatistics.CategoryStat> categoryStats = products.stream()
                .collect(Collectors.groupingBy(Product::getCategory))
                .entrySet().stream()
                .map(entry -> {
                    String category = entry.getKey();
                    List<Product> categoryProducts = entry.getValue();
                    
                    int categoryQuantity = categoryProducts.stream()
                            .mapToInt(Product::getQuantity)
                            .sum();
                    
                    BigDecimal categoryRevenue = categoryProducts.stream()
                            .map(Product::getRevenue)
                            .reduce(BigDecimal.ZERO, BigDecimal::add);
                    
                    double percentage = totalQuantity > 0 ? 
                            (double) categoryQuantity / totalQuantity * 100 : 0;
                    
                    return SalesStatistics.CategoryStat.builder()
                            .category(category)
                            .quantity(categoryQuantity)
                            .revenue(categoryRevenue)
                            .percentage(percentage)
                            .build();
                })
                .collect(Collectors.toList());
        
        // 取得銷量前五名
        List<Product> topProducts = products.stream()
                .sorted((p1, p2) -> Integer.compare(p2.getQuantity(), p1.getQuantity()))
                .limit(5)
                .collect(Collectors.toList());
        
        return SalesStatistics.builder()
                .topProducts(topProducts)
                .categoryStats(categoryStats)
                .yearOverYearGrowth(calculateYearOverYearGrowth(products))
                .build();
    }
    
    private BigDecimal calculateYearOverYearGrowth(List<Product> products) {
        // 簡化的年度成長率計算
        // 實際應用中會比較不同年份的資料
        return new BigDecimal("15.5"); // 模擬 15.5% 成長率
    }
}
```

**步驟 3：產品銷售工具實現**

```java
package com.example.tools;

import com.example.model.Product;
import com.example.model.ProductSalesResponse;
import com.example.model.SalesStatistics;
import com.example.service.EnterpriseDataService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class ProductSalesTools {
    
    private final EnterpriseDataService dataService;
    
    /**
     * 查詢產品銷售資料
     * @param year 銷售年份（可選）
     * @param product 產品型號或名稱（可選）
     * @return 產品銷售資料
     */
    @Tool(description = "Get company product sales information by year and product model. " +
          "Can filter by year (e.g., '2023', '2024') and product (model or name). " +
          "Returns detailed sales data including quantity, revenue, and product information.")
    public ProductSalesResponse getProductSales(String year, String product) {
        try {
            log.info("查詢產品銷售資料：年份={}, 產品={}", year, product);
            
            // 從企業資料服務獲取資料
            List<Product> products = dataService.filterProducts(year, product);
            
            // 計算總計
            int totalQuantity = products.stream()
                    .mapToInt(Product::getQuantity)
                    .sum();
            
            BigDecimal totalRevenue = products.stream()
                    .map(Product::getRevenue)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            ProductSalesResponse response = ProductSalesResponse.builder()
                    .products(products)
                    .totalQuantity(totalQuantity)
                    .totalRevenue(totalRevenue)
                    .queryYear(year)
                    .queryProduct(product)
                    .build();
            
            log.info("查詢完成，找到 {} 筆產品資料，總銷量：{}", 
                    products.size(), totalQuantity);
            
            return response;
            
        } catch (Exception e) {
            log.error("查詢產品銷售資料失敗", e);
            throw new RuntimeException("查詢產品銷售資料失敗：" + e.getMessage());
        }
    }
    
    /**
     * 獲取銷售統計分析
     * @param year 分析年份
     * @return 銷售統計資料
     */
    @Tool(description = "Get sales statistics and analysis for a specific year. " +
          "Returns top-selling products, category breakdown, and growth metrics.")
    public SalesStatistics getSalesStatistics(String year) {
        try {
            log.info("獲取銷售統計分析：年份={}", year);
            
            List<Product> products = dataService.filterProducts(year, null);
            SalesStatistics statistics = dataService.calculateSalesStatistics(products);
            
            log.info("統計分析完成，共分析 {} 筆產品資料", products.size());
            
            return statistics;
            
        } catch (Exception e) {
            log.error("獲取銷售統計失敗", e);
            throw new RuntimeException("獲取銷售統計失敗：" + e.getMessage());
        }
    }
    
    /**
     * 比較不同年份的銷售表現
     * @param year1 第一個年份
     * @param year2 第二個年份
     * @return 比較結果
     */
    @Tool(description = "Compare sales performance between two years. " +
          "Returns detailed comparison including growth rates and product performance changes.")
    public String compareSalesByYear(String year1, String year2) {
        try {
            log.info("比較年度銷售表現：{} vs {}", year1, year2);
            
            List<Product> products1 = dataService.filterProducts(year1, null);
            List<Product> products2 = dataService.filterProducts(year2, null);
            
            int total1 = products1.stream().mapToInt(Product::getQuantity).sum();
            int total2 = products2.stream().mapToInt(Product::getQuantity).sum();
            
            BigDecimal revenue1 = products1.stream()
                    .map(Product::getRevenue)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            BigDecimal revenue2 = products2.stream()
                    .map(Product::getRevenue)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            double quantityGrowth = total1 > 0 ? 
                    ((double) (total2 - total1) / total1 * 100) : 0;
            
            double revenueGrowth = revenue1.compareTo(BigDecimal.ZERO) > 0 ?
                    revenue2.subtract(revenue1)
                            .divide(revenue1, 4, java.math.RoundingMode.HALF_UP)
                            .multiply(new BigDecimal("100"))
                            .doubleValue() : 0;
            
            String result = String.format(
                    "年度銷售比較分析 (%s vs %s):\n" +
                    "銷售數量：%d → %d (成長率：%.2f%%)\n" +
                    "銷售金額：%s → %s (成長率：%.2f%%)\n" +
                    "產品數量：%d → %d",
                    year1, year2,
                    total1, total2, quantityGrowth,
                    revenue1, revenue2, revenueGrowth,
                    products1.size(), products2.size()
            );
            
            log.info("年度比較完成");
            return result;
            
        } catch (Exception e) {
            log.error("年度銷售比較失敗", e);
            return "年度銷售比較失敗：" + e.getMessage();
        }
    }
}
```

---

## 5.7.3 多工具協作系統

### 工具組合配置

**ChatClient 配置**：

```java
package com.example.config;

import com.example.tools.DateTimeTools;
import com.example.tools.ProductSalesTools;
import com.example.tools.CalculatorTools;
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@RequiredArgsConstructor
public class AiConfig {
    
    private final ProductSalesTools productSalesTools;
    private final DateTimeTools dateTimeTools;
    private final CalculatorTools calculatorTools;
    
    /**
     * 配置企業級 ChatClient
     * 整合多個工具以支援複雜的企業查詢
     */
    @Bean
    public ChatClient enterpriseChatClient(ChatModel chatModel) {
        return ChatClient.builder(chatModel)
                .defaultTools(
                    productSalesTools,    // 產品銷售資料工具
                    dateTimeTools,        // 日期時間工具
                    calculatorTools       // 計算工具
                )
                .defaultSystem("""
                    你是一個專業的企業資料分析師，擅長分析銷售資料和提供商業洞察。
                    
                    當用戶詢問企業資料時，請：
                    1. 使用適當的工具獲取最新資料
                    2. 進行深入的資料分析
                    3. 提供清晰的洞察和建議
                    4. 用專業但易懂的語言回答
                    
                    可用的工具：
                    - 產品銷售資料查詢
                    - 銷售統計分析
                    - 年度比較分析
                    - 日期時間查詢
                    - 數學計算
                    """)
                .build();
    }
    
    /**
     * 簡化版 ChatClient（僅基礎功能）
     */
    @Bean("basicChatClient")
    public ChatClient basicChatClient(ChatModel chatModel) {
        return ChatClient.builder(chatModel)
                .defaultTools(dateTimeTools)
                .build();
    }
}
```

### 企業級控制器實現

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/enterprise")
@RequiredArgsConstructor
@Slf4j
public class EnterpriseAiController {
    
    private final ChatClient enterpriseChatClient;
    
    /**
     * 企業資料查詢和分析
     * @param prompt 自然語言查詢
     * @return AI 分析結果
     */
    @GetMapping("/query")
    public String enterpriseQuery(@RequestParam String prompt) {
        try {
            log.info("收到企業查詢請求：{}", prompt);
            
            long startTime = System.currentTimeMillis();
            
            String response = enterpriseChatClient
                    .prompt(prompt)
                    .call()
                    .content();
            
            long endTime = System.currentTimeMillis();
            
            log.info("企業查詢完成，耗時：{}ms", endTime - startTime);
            
            return response;
            
        } catch (Exception e) {
            log.error("企業查詢失敗：{}", prompt, e);
            return "查詢失敗：" + e.getMessage();
        }
    }
    
    /**
     * 銷售資料專用查詢
     * @param request 銷售查詢請求
     * @return 結構化回應
     */
    @PostMapping("/sales-analysis")
    public SalesAnalysisResponse salesAnalysis(@RequestBody SalesAnalysisRequest request) {
        try {
            log.info("銷售分析請求：{}", request);
            
            long startTime = System.currentTimeMillis();
            
            // 構建針對性的提示詞
            String prompt = buildSalesAnalysisPrompt(request);
            
            String aiResponse = enterpriseChatClient
                    .prompt(prompt)
                    .call()
                    .content();
            
            long endTime = System.currentTimeMillis();
            
            return SalesAnalysisResponse.builder()
                    .success(true)
                    .query(request.getQuery())
                    .analysis(aiResponse)
                    .executionTime(endTime - startTime)
                    .timestamp(LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("銷售分析失敗", e);
            
            return SalesAnalysisResponse.builder()
                    .success(false)
                    .query(request.getQuery())
                    .error(e.getMessage())
                    .timestamp(LocalDateTime.now())
                    .build();
        }
    }
    
    /**
     * 批次企業查詢
     * @param queries 多個查詢請求
     * @return 批次處理結果
     */
    @PostMapping("/batch-query")
    public Map<String, String> batchEnterpriseQuery(@RequestBody BatchQueryRequest queries) {
        try {
            log.info("批次企業查詢：{} 個請求", queries.getQueries().size());
            
            return queries.getQueries().parallelStream()
                    .collect(java.util.stream.Collectors.toMap(
                            query -> query,
                            query -> {
                                try {
                                    return enterpriseChatClient
                                            .prompt(query)
                                            .call()
                                            .content();
                                } catch (Exception e) {
                                    log.error("批次查詢失敗：{}", query, e);
                                    return "查詢失敗：" + e.getMessage();
                                }
                            }
                    ));
            
        } catch (Exception e) {
            log.error("批次企業查詢失敗", e);
            return Map.of("error", "批次查詢失敗：" + e.getMessage());
        }
    }
    
    private String buildSalesAnalysisPrompt(SalesAnalysisRequest request) {
        StringBuilder prompt = new StringBuilder();
        
        prompt.append("請分析以下銷售資料查詢：\n");
        prompt.append("查詢內容：").append(request.getQuery()).append("\n");
        
        if (request.getYear() != null) {
            prompt.append("指定年份：").append(request.getYear()).append("\n");
        }
        
        if (request.getProduct() != null) {
            prompt.append("指定產品：").append(request.getProduct()).append("\n");
        }
        
        prompt.append("\n請提供：\n");
        prompt.append("1. 相關的銷售資料\n");
        prompt.append("2. 資料分析和洞察\n");
        prompt.append("3. 商業建議\n");
        
        return prompt.toString();
    }
}
```

### 請求和回應 DTO

```java
package com.example.dto;

import lombok.Data;
import lombok.Builder;
import java.time.LocalDateTime;
import java.util.List;

@Data
public class SalesAnalysisRequest {
    private String query;
    private String year;
    private String product;
    private String analysisType;  // trend, comparison, forecast
}

@Data
@Builder
public class SalesAnalysisResponse {
    private boolean success;
    private String query;
    private String analysis;
    private Long executionTime;
    private String error;
    private LocalDateTime timestamp;
}

@Data
public class BatchQueryRequest {
    private List<String> queries;
}
```

---

## 5.7.4 實際應用場景

### 銷售分析對話範例

**場景 1：基礎銷售查詢**

```
用戶：「請告訴我 2023 年所有產品的銷售情況」

AI 回應：
根據查詢結果，2023年公司共有4款產品的銷售資料：

📊 **2023年銷售總覽**
- 總銷售數量：26,500 台
- 總銷售金額：11.45 億元

📈 **各產品表現**
1. PD-1385 智能手錶 Sport：15,000台 (56.6%)
2. PD-1234 筆記型電腦 Ultra：10,000台 (37.7%)
3. PD-1235 平板電腦 Lite：1,500台 (5.7%)

💡 **分析洞察**
- 智能手錶是主力產品，占總銷量超過一半
- 筆記型電腦雖然銷量第二，但單價較高，貢獻最多營收
- 平板電腦銷量較低，可能需要重新評估市場策略
```

**場景 2：比較分析**

```
用戶：「比較一下 2023 年和 2024 年的銷售表現」

AI 回應：
📊 **2023 vs 2024 年度銷售比較**

**整體表現**
- 銷售數量：26,500 → 54,500 台 (+105.7%)
- 銷售金額：11.45 → 20.55 億元 (+79.5%)
- 產品線：4 → 5 款產品

**成長亮點**
1. 新增產品線帶來顯著成長
2. 既有產品 PD-1235 和 PD-1385 都有大幅提升
3. 平均單價有所下降，但總營收大幅成長

**策略建議**
- 繼續擴展產品線多樣化
- 加強智能家居和音響設備市場布局
- 優化定價策略以提升利潤率
```

**場景 3：深度分析**

```
用戶：「分析一下我們在穿戴裝置類別的表現，並給出市場建議」

AI 回應：
🔍 **穿戴裝置類別深度分析**

**產品表現**
- PD-1385 智能手錶系列：2023年 15,000台 → 2024年 15,000台
- 市場占有率：在公司總銷量中占比從 56.6% 降至 27.5%

**市場洞察**
1. **銷量穩定但相對成長放緩**：雖然絕對數量維持，但在公司快速成長中相對比重下降
2. **產品升級成功**：從 Sport 版升級到 Ultra 版，單價提升 50%
3. **市場競爭加劇**：穿戴裝置市場趨於飽和

**策略建議**
1. **產品差異化**：開發專業運動、健康監測等細分市場產品
2. **生態系統整合**：與其他產品線形成互補，提升用戶黏性
3. **服務化轉型**：增加軟體服務和訂閱模式收入
4. **國際市場拓展**：尋找新興市場機會
```

---

## 📝 本章重點回顧

1. **企業資料整合**：學會了讓 AI 存取和分析企業內部資料的完整方法
2. **複雜工具設計**：掌握了帶參數和結構化回應的進階工具實現
3. **多工具協作**：實現了多個工具的智能組合和協同工作
4. **資料模型設計**：建立了企業級資料模型和回應結構
5. **實際應用場景**：展示了真實的企業 AI 分析對話和洞察生成

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **企業資料存取** | ⭐⭐⭐ | 中 | 所有企業 AI 應用 |
| **結構化回應** | ⭐⭐⭐ | 中 | 資料分析系統 |
| **多工具協作** | ⭐⭐ | 高 | 複雜業務場景 |
| **資料模型設計** | ⭐⭐ | 中 | 企業級應用 |
| **智能分析** | ⭐⭐ | 高 | 商業洞察系統 |
| **批次處理** | ⭐ | 中 | 大量查詢場景 |

### 企業應用價值

**1. 降低分析門檻**
- 🗣️ **自然語言查詢**：業務人員無需學習複雜的 BI 工具
- ⚡ **即時回應**：從數天的報表製作縮短到幾秒鐘
- 🎯 **精準洞察**：AI 自動發現資料中的模式和趨勢

**2. 提升決策效率**
- 📊 **即時資料**：基於最新資料進行決策
- 🔍 **深度分析**：多維度的資料分析和比較
- 💡 **智能建議**：基於資料的商業建議和策略

**3. 擴展應用場景**
- 📈 **銷售分析**：產品表現、市場趨勢、客戶行為
- 💰 **財務管理**：收支分析、成本控制、預算規劃
- 👥 **人力資源**：員工績效、薪資分析、人才規劃
- 📦 **營運管理**：庫存優化、供應鏈分析、品質控制

### 下一步學習方向

在下一章中，我們將學習 Function Calling 的最終組合技，包括複雜工具鏈、條件式調用和企業級工具生態系統的建立。

---

**參考資料：**
- [Spring AI Tool Calling Advanced Guide](https://docs.spring.io/spring-ai/reference/api/tools.html)
- [Enterprise AI Integration Patterns](https://docs.spring.io/spring-ai/reference/concepts.html)
- [JSON Schema for Tool Parameters](https://json-schema.org/)
- [Business Intelligence with AI](https://www.mckinsey.com/capabilities/quantumblack/our-insights/the-age-of-ai)
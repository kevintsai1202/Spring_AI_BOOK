# 3.1 檔案上傳與下載基礎

## 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解檔案處理的重要性**：掌握 Web 應用中檔案處理的核心概念和應用場景
- 🎯 **掌握 Spring Boot 檔案配置**：學會配置檔案上傳的基本參數和限制
- 🎯 **實作檔案上傳功能**：使用 MultipartFile 處理單檔案和多檔案上傳
- 🎯 **實現檔案下載服務**：建立安全可靠的檔案下載機制
- 🎯 **處理常見問題**：了解檔案處理中的安全性和效能考量

---

## 3.1.1 為什麼需要檔案處理？

### 檔案處理在現代應用中的重要性

在現代 Web 應用程式中，檔案處理是一項基礎且重要的功能。無論是社群媒體的照片分享、企業系統的文件管理，還是電商平台的商品圖片上傳，都離不開檔案處理機制。

> **思考問題**：您在日常使用的應用程式中，有哪些功能涉及到檔案上傳或下載？
> - 社群媒體上傳照片和影片
> - 雲端硬碟儲存和分享檔案
> - 線上辦公系統的文件協作
> - 電商平台的商品圖片管理

### 常見的檔案處理場景

**1. 使用者內容管理**
- 個人頭像上傳
- 文件附件處理
- 多媒體內容分享

**2. 企業文件系統**
- 合約文件上傳
- 報表檔案下載
- 備份檔案管理

**3. 電商應用**
- 商品圖片上傳
- 產品目錄下載
- 訂單相關文件

💡 **重點提示**：良好的檔案處理機制不僅要考慮功能實現，還要重視安全性、效能和使用者體驗。

---

## 3.1.2 檔案上傳基礎概念

### HTTP 檔案上傳原理

檔案上傳是透過 HTTP 協定的 `multipart/form-data` 編碼方式實現的。這種編碼方式允許在單一請求中傳送文字資料和二進位檔案。

**傳統表單 vs 檔案上傳表單**：

```html
<!-- 傳統表單 -->
<form method="post" action="/submit">
    <input type="text" name="username" />
    <input type="submit" value="提交" />
</form>

<!-- 檔案上傳表單 -->
<form method="post" action="/upload" enctype="multipart/form-data">
    <input type="file" name="file" />
    <input type="submit" value="上傳" />
</form>
```

### Spring Boot 中的檔案處理

Spring Boot 透過 `MultipartFile` 介面提供了簡潔的檔案處理方式：

```java
// MultipartFile 的核心方法
public interface MultipartFile {
    String getName();           // 取得表單欄位名稱
    String getOriginalFilename(); // 取得原始檔案名稱
    String getContentType();    // 取得檔案類型
    long getSize();            // 取得檔案大小
    byte[] getBytes();         // 取得檔案內容
    InputStream getInputStream(); // 取得輸入串流
    void transferTo(File dest); // 儲存檔案到指定位置
}
```

⚠️ **注意事項**：
- `MultipartFile` 只在請求處理期間有效
- 檔案內容會暫存在記憶體或臨時檔案中
- 處理完成後應及時清理資源

---

## 3.1.3 基本檔案上傳實作

### 1. 檔案上傳配置

首先在 [`application.properties`](application.properties) 中配置檔案上傳參數：

```properties
# 檔案上傳配置
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=50MB
spring.servlet.multipart.file-size-threshold=2KB

# 檔案儲存路徑
app.upload.path=./uploads
```

**配置說明**：

| 配置項目 | 說明 | 預設值 | 建議值 |
|---------|------|--------|--------|
| `max-file-size` | 單檔案最大大小 | 1MB | 10MB |
| `max-request-size` | 請求最大大小 | 10MB | 50MB |
| `file-size-threshold` | 記憶體暫存閾值 | 0 | 2KB |

### 2. 簡單檔案上傳控制器

```java
/**
 * 檔案上傳控制器
 * 提供基本的檔案上傳功能
 */
@RestController
@RequestMapping("/api/files")
@Slf4j
public class FileUploadController {
    
    @Value("${app.upload.path:./uploads}")
    private String uploadPath;
    
    /**
     * 單檔案上傳
     * @param file 上傳的檔案
     * @return 上傳結果
     */
    @PostMapping("/upload")
    public ResponseEntity<String> uploadFile(@RequestParam("file") MultipartFile file) {
        
        // 檢查檔案是否為空
        if (file.isEmpty()) {
            return ResponseEntity.badRequest().body("請選擇要上傳的檔案");
        }
        
        try {
            // 建立上傳目錄
            Path uploadDir = Paths.get(uploadPath);
            if (!Files.exists(uploadDir)) {
                Files.createDirectories(uploadDir);
            }
            
            // 產生唯一檔案名稱
            String fileName = System.currentTimeMillis() + "_" + file.getOriginalFilename();
            Path filePath = uploadDir.resolve(fileName);
            
            // 儲存檔案
            file.transferTo(filePath.toFile());
            
            log.info("檔案上傳成功: {}", fileName);
            return ResponseEntity.ok("檔案上傳成功: " + fileName);
            
        } catch (IOException e) {
            log.error("檔案上傳失敗", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("檔案上傳失敗: " + e.getMessage());
        }
    }
}
```

### 3. 多檔案上傳處理

```java
/**
 * 多檔案上傳
 * @param files 上傳的檔案陣列
 * @return 上傳結果
 */
@PostMapping("/upload-multiple")
public ResponseEntity<List<String>> uploadMultipleFiles(
        @RequestParam("files") MultipartFile[] files) {
    
    List<String> uploadedFiles = new ArrayList<>();
    
    for (MultipartFile file : files) {
        if (!file.isEmpty()) {
            try {
                String fileName = System.currentTimeMillis() + "_" + file.getOriginalFilename();
                Path filePath = Paths.get(uploadPath).resolve(fileName);
                file.transferTo(filePath.toFile());
                uploadedFiles.add(fileName);
                
            } catch (IOException e) {
                log.error("檔案上傳失敗: {}", file.getOriginalFilename(), e);
            }
        }
    }
    
    return ResponseEntity.ok(uploadedFiles);
}
```

🚀 **實用技巧**：使用時間戳記前綴可以避免檔案名稱衝突，同時保持檔案的可追蹤性。

---

## 3.1.4 檔案下載基礎實作

### 1. 簡單檔案下載

```java
/**
 * 檔案下載
 * @param fileName 檔案名稱
 * @return 檔案內容
 */
@GetMapping("/download/{fileName}")
public ResponseEntity<Resource> downloadFile(@PathVariable String fileName) {
    
    try {
        Path filePath = Paths.get(uploadPath).resolve(fileName);
        Resource resource = new UrlResource(filePath.toUri());
        
        if (resource.exists() && resource.isReadable()) {
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, 
                           "attachment; filename=\"" + fileName + "\"")
                    .body(resource);
        } else {
            return ResponseEntity.notFound().build();
        }
        
    } catch (MalformedURLException e) {
        log.error("檔案下載失敗: {}", fileName, e);
        return ResponseEntity.badRequest().build();
    }
}
```

### 2. 檔案預覽功能

```java
/**
 * 檔案預覽（適用於圖片等媒體檔案）
 * @param fileName 檔案名稱
 * @return 檔案內容
 */
@GetMapping("/preview/{fileName}")
public ResponseEntity<Resource> previewFile(@PathVariable String fileName) {
    
    try {
        Path filePath = Paths.get(uploadPath).resolve(fileName);
        Resource resource = new UrlResource(filePath.toUri());
        
        if (resource.exists() && resource.isReadable()) {
            // 根據檔案副檔名設定 Content-Type
            String contentType = Files.probeContentType(filePath);
            
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_TYPE, contentType)
                    .body(resource);
        } else {
            return ResponseEntity.notFound().build();
        }
        
    } catch (Exception e) {
        log.error("檔案預覽失敗: {}", fileName, e);
        return ResponseEntity.badRequest().build();
    }
}
```

---

## 3.1.5 常見問題與注意事項

### 1. 檔案安全性考量

**檔案類型驗證**：
```java
/**
 * 檢查檔案類型是否允許
 * @param file 上傳的檔案
 * @return 是否允許
 */
private boolean isAllowedFileType(MultipartFile file) {
    String contentType = file.getContentType();
    return contentType != null && (
        contentType.startsWith("image/") ||
        contentType.equals("application/pdf") ||
        contentType.equals("text/plain")
    );
}
```

**檔案大小限制**：
```java
/**
 * 檢查檔案大小
 * @param file 上傳的檔案
 * @return 是否符合大小限制
 */
private boolean isValidFileSize(MultipartFile file) {
    long maxSize = 10 * 1024 * 1024; // 10MB
    return file.getSize() <= maxSize;
}
```

### 2. 效能最佳化建議

✅ **最佳實踐**：
- 使用串流處理大檔案，避免記憶體溢位
- 實作檔案類型和大小驗證
- 使用唯一檔案名稱避免衝突
- 定期清理暫存檔案

⚠️ **常見陷阱**：
- 未驗證檔案類型可能導致安全風險
- 檔案名稱未處理可能造成路徑遍歷攻擊
- 缺乏檔案大小限制可能導致磁碟空間耗盡

### 3. 錯誤處理策略

```java
/**
 * 全域檔案處理異常處理器
 */
@ControllerAdvice
public class FileExceptionHandler {
    
    @ExceptionHandler(MaxUploadSizeExceededException.class)
    public ResponseEntity<String> handleMaxSizeException(MaxUploadSizeExceededException e) {
        return ResponseEntity.status(HttpStatus.PAYLOAD_TOO_LARGE)
                .body("檔案大小超過限制");
    }
    
    @ExceptionHandler(MultipartException.class)
    public ResponseEntity<String> handleMultipartException(MultipartException e) {
        return ResponseEntity.badRequest()
                .body("檔案上傳格式錯誤");
    }
}
```

---

## 重點摘要

### 🎯 核心概念回顧

1. **檔案處理的重要性**：
   - 現代 Web 應用的基礎功能
   - 涵蓋使用者內容、企業文件、電商應用等場景
   - 需要考慮安全性、效能和使用者體驗

2. **Spring Boot 檔案處理機制**：
   - 使用 `MultipartFile` 介面處理檔案上傳
   - 透過 `multipart/form-data` 編碼傳輸檔案
   - 支援單檔案和多檔案上傳

3. **基本實作要點**：
   - 正確配置檔案上傳參數
   - 實作檔案類型和大小驗證
   - 提供安全的檔案下載機制

### 💡 學習要點

- 檔案處理不僅是技術實作，更要重視安全性考量
- `MultipartFile` 提供了簡潔易用的檔案處理 API
- 適當的配置和驗證是檔案處理系統的基礎
- 錯誤處理和異常管理同樣重要

### 🚀 下一步行動

在下一章中，我們將學習更進階的檔案處理技術，包括：
- 檔案類型檢測和安全掃描
- 大檔案分塊上傳處理
- 檔案快取和 CDN 整合
- 檔案處理的監控和日誌記錄

---

> **章節總結**：檔案上傳與下載是 Web 應用程式中的基礎功能，Spring Boot 透過 MultipartFile 介面提供了簡潔而強大的檔案處理能力。掌握基本的檔案上傳下載實作，並重視安全性和效能考量，是建構可靠檔案處理系統的關鍵。在實際開發中，除了功能實現外，更要注重使用者體驗和系統穩定性。
# 使用 Spring AI 打造企業 RAG 知識庫【40-2】- 資源統一管理與智能提示系統

## ▋資源統一管理：多模態內容整合的企業級解決方案

在現代企業環境中，資訊資產以各種形式存在：文字文檔、圖像、音視頻、數據表格、程式碼等等。這些多樣化的資源形式對於 AI 系統來說既是機遇也是挑戰。MCP-RAG 整合架構通過統一的資源管理系統，實現了對這些異構資源的智能化處理和統一存取。

### 多模態資源處理的挑戰

**格式異構性**：
企業資源包含各種格式：PDF、Word、Excel、PowerPoint、圖片、音視頻等，每種格式都需要專門的處理方法。

**語意理解複雜性**：
不同類型的資源承載著不同層次的語意信息，從純文字的直接語意到圖像的視覺語意，再到音頻的聽覺語意。

**存取權限多樣性**：
企業資源涉及不同的安全等級和存取權限，需要細緻的權限控制機制。

**實時性要求**：
一些資源需要實時更新和同步，系統必須能夠快速響應變化。

### 統一資源管理架構

我們的資源管理系統採用分層架構，每一層都有明確的職責：

**抽象層（Resource Abstraction Layer）**：
- 為所有類型的資源提供統一的抽象介面
- 定義標準的資源元數據模型
- 實現資源的生命週期管理

**適配層（Resource Adapter Layer）**：
- 為不同類型的資源提供專門的處理適配器
- 實現格式轉換和內容提取
- 處理特定格式的技術細節

**服務層（Resource Service Layer）**：
- 提供資源的CRUD操作
- 實現資源的搜尋和發現功能
- 管理資源的權限和安全

**存儲層（Resource Storage Layer）**：
- 實現資源的物理存儲
- 提供高效的檢索機制
- 確保資源的可靠性和持久性

### 智能內容處理引擎

資源管理系統的核心是智能內容處理引擎，它能夠：

**自動內容提取**：
- 從PDF、Word等文檔中提取純文字內容
- 使用OCR技術處理掃描文檔和圖片中的文字
- 利用語音識別技術轉錄音頻內容
- 從表格中提取結構化數據

**多模態內容理解**：
- 使用計算機視覺技術分析圖像內容
- 結合文字和圖像信息進行多模態理解
- 從視頻中提取關鍵幀和字幕信息
- 分析文檔的結構和布局信息

**語意增強處理**：
- 利用自然語言處理技術提取關鍵概念
- 自動生成內容摘要和標籤
- 識別實體和關係，構建知識圖譜
- 根據內容特性推薦相關資源

### 權限與安全管理

企業資源管理必須考慮嚴格的安全和權限控制：

**細粒度權限控制**：
- 基於角色的存取控制（RBAC）
- 基於屬性的存取控制（ABAC）
- 動態權限評估和調整
- 資源級別的精細化權限設定

**數據安全保護**：
- 敏感信息的自動識別和標記
- 數據加密和安全傳輸
- 存取日誌和審計追蹤
- 合規性檢查和報告

**隱私保護機制**：
- 個人信息的自動識別和保護
- 數據去識別化處理
- 隱私影響評估
- GDPR和其他隱私法規的合規支援

```java
@Component
@Slf4j
public class EnterpriseResourceManager {

    private final List<ResourceProvider> resourceProviders;
    private final DocumentIndexService indexService;
    private final SecurityService securityService;
    
    @EventListener
    public void handleListResources(ListResourcesEvent event) {
        try {
            String userContext = extractUserContext(event);
            List<McpSchema.Resource> allResources = new ArrayList<>();
            
            // 並行獲取各種資源
            List<CompletableFuture<List<McpSchema.Resource>>> futures = resourceProviders.stream()
                .map(provider -> CompletableFuture.supplyAsync(() -> 
                    provider.getAccessibleResources(userContext)))
                .collect(Collectors.toList());
            
            // 等待所有資源獲取完成
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApply(v -> futures.stream()
                    .map(CompletableFuture::join)
                    .flatMap(List::stream)
                    .collect(Collectors.toList()))
                .thenAccept(allResources::addAll)
                .join();
            
            // 資源過濾和排序
            List<McpSchema.Resource> filteredResources = filterAndSortResources(allResources, userContext);
            
            event.addResources(filteredResources);
            
        } catch (Exception e) {
            log.error("列出企業資源失敗", e);
        }
    }
    
    @EventListener
    public void handleReadResource(ReadResourceEvent event) {
        String uri = event.getRequest().uri();
        String userContext = extractUserContext(event);
        
        try {
            // 安全檢查
            if (!securityService.hasAccessPermission(userContext, uri)) {
                throw new SecurityException("無權限存取資源: " + uri);
            }
            
            // 智能內容處理
            ResourceContent content = processResourceContent(uri, userContext);
            
            event.setContents(List.of(new McpSchema.TextContent(
                content.getProcessedContent(),
                Optional.of("智能處理後的內容"),
                Optional.of("text/markdown")
            )));
            
        } catch (Exception e) {
            log.error("讀取企業資源失敗: uri={}", uri, e);
            event.setContents(List.of(new McpSchema.TextContent(
                "# 資源存取失敗\n\n錯誤: " + e.getMessage(),
                Optional.of("錯誤資訊"),
                Optional.of("text/markdown")
            )));
        }
    }
    
    private ResourceContent processResourceContent(String uri, String userContext) {
        // 根據資源類型選擇處理策略
        ResourceProcessor processor = getResourceProcessor(uri);
        
        // 基礎內容提取
        String rawContent = processor.extractContent(uri);
        
        // AI 增強處理
        String enhancedContent = enhanceContentWithAI(rawContent, userContext);
        
        // 相關資源推薦
        List<String> relatedResources = findRelatedResources(uri, rawContent);
        
        return new ResourceContent(rawContent, enhancedContent, relatedResources);
    }
    
    private String enhanceContentWithAI(String content, String userContext) {
        return chatClient.prompt()
            .system("""
                你是一個企業知識助手。請根據用戶背景優化內容呈現：
                1. 添加結構化標題
                2. 提取關鍵要點
                3. 添加實用的總結
                4. 標註重要概念
                """)
            .user(String.format("""
                用戶背景：%s
                
                請優化以下內容的呈現：
                
                %s
                """, userContext, content))
            .call()
            .content();
    }
}
```

## ▋提示系統整合：上下文感知的智能提示引擎

提示工程是現代 AI 系統成功的關鍵因素之一。在 MCP-RAG 整合架構中，提示系統不僅要提供基本的提示管理功能，更要能夠智能地理解用戶的意圖、業務場景和知識需求，動態生成最適合的提示內容。

### 智能提示系統的設計理念

傳統的提示系統通常是靜態的，預先定義好的提示模板在不同情境下都使用相同的內容。而我們的智能提示系統則完全不同：

**上下文感知**：
系統能夠理解當前的對話上下文，包括：
- 用戶的歷史查詢記錄和偏好
- 當前正在討論的主題和焦點
- 業務流程的當前階段和狀態
- 相關的企業知識和規則

**角色定制化**：
根據用戶的角色和職責提供定制化的提示：
- 技術人員獲得技術導向的提示
- 管理人員獲得決策支援導向的提示
- 銷售人員獲得客戶服務導向的提示
- 新員工獲得培訓和學習導向的提示

**動態知識整合**：
提示內容會動態整合相關的企業知識：
- 自動檢索與當前任務相關的文檔和資料
- 整合最新的業務規則和政策變更
- 包含相關的案例研究和最佳實踐
- 提供背景知識和解釋性信息

**學習與優化**：
系統會持續學習和優化提示的效果：
- 追蹤提示的使用效果和用戶反饋
- 分析哪些提示能產生更好的結果
- 自動調整提示的內容和結構
- 發現新的提示模式和最佳實踐

### 提示生成的技術實現

我們的提示生成系統採用多層次的架構：

**意圖識別層**：
- 分析用戶的查詢和行為模式，識別真實意圖
- 理解任務的複雜度和所需的專業知識級別
- 確定最適合的提示類型和風格

**知識檢索層**：
- 從企業知識庫中檢索相關的背景知識
- 獲取最新的業務規則和操作指南
- 查找相關的案例和範例

**提示構建層**：
- 根據模板和規則構建基礎提示結構
- 整合檢索到的知識和上下文信息
- 調整語言風格和專業程度

**優化調整層**：
- 根據用戶特徵和偏好調整提示內容
- 優化提示的長度和結構
- 確保提示的清晰性和可執行性

### 提示模板的智能管理

我們的系統支援多種類型的智能提示模板：

**分析型提示**：
專門用於數據分析和洞察發現：
```
基於以下數據和背景知識，請進行深度分析：

數據來源：{data_source}
分析維度：{analysis_dimensions}
業務背景：{business_context}

相關知識：
{retrieved_knowledge}

請提供：
1. 數據概況和趨勢分析
2. 關鍵發現和異常點識別
3. 業務影響評估
4. 改進建議和行動計劃
```

**決策支援型提示**：
幫助管理人員進行決策：
```
決策情境：{decision_context}
可選方案：{available_options}

相關政策和規則：
{corporate_policies}

歷史案例參考：
{historical_cases}

請協助分析：
1. 各方案的優劣勢比較
2. 風險評估和緩解措施
3. 預期收益和投資回報
4. 推薦方案及理由
```

**學習型提示**：
專門為培訓和知識傳遞設計：
```
學習主題：{learning_topic}
學習者背景：{learner_profile}

相關知識資源：
{knowledge_resources}

學習目標：
{learning_objectives}

請設計學習方案：
1. 知識點梳理和結構化呈現
2. 實例和案例說明
3. 練習題和自我檢測
4. 進階學習路徑建議
```

### 個性化提示調優

系統會為每個用戶建立個性化的提示偏好檔案：

**語言風格偏好**：
- 正式 vs 非正式語調
- 技術性 vs 通俗化表達
- 簡潔 vs 詳細說明
- 直接 vs 引導式指導

**內容結構偏好**：
- 列表式 vs 段落式組織
- 圖表 vs 文字說明
- 步驟式 vs 概念式指導
- 理論 vs 實踐導向

**互動方式偏好**：
- 問答式 vs 陳述式
- 探索式 vs 指導式
- 協作式 vs 獨立式
- 即時反饋 vs 批次處理

```java
@Component
@Slf4j
public class ContextAwarePromptProvider {

    private final ChatClient chatClient;
    private final VectorStore vectorStore;
    private final UserContextService userContextService;
    
    @EventListener
    public void handleListPrompts(ListPromptsEvent event) {
        try {
            String userContext = extractUserContext(event);
            UserProfile profile = userContextService.getUserProfile(userContext);
            
            List<McpSchema.Prompt> prompts = generateContextualPrompts(profile);
            event.addPrompts(prompts);
            
        } catch (Exception e) {
            log.error("列出提示失敗", e);
        }
    }
    
    @EventListener  
    public void handleGetPrompt(GetPromptEvent event) {
        String promptName = event.getRequest().name();
        Map<String, Object> arguments = event.getRequest().arguments().orElse(Map.of());
        
        try {
            McpSchema.PromptMessage promptMessage = generateDynamicPrompt(promptName, arguments);
            event.setPrompt(new McpSchema.GetPromptResult(
                Optional.of(promptMessage.content()),
                List.of(promptMessage)
            ));
            
        } catch (Exception e) {
            log.error("獲取提示失敗: name={}", promptName, e);
        }
    }
    
    private List<McpSchema.Prompt> generateContextualPrompts(UserProfile profile) {
        List<McpSchema.Prompt> prompts = new ArrayList<>();
        
        // 基於用戶角色的提示
        if (profile.hasRole("developer")) {
            prompts.add(createPrompt(
                "code_review",
                "代碼審查助手",
                "幫助進行代碼審查和質量分析",
                List.of(
                    new McpSchema.PromptArgument("code", "代碼內容", Optional.of(true)),
                    new McpSchema.PromptArgument("language", "程式語言", Optional.of(false))
                )
            ));
        }
        
        if (profile.hasRole("manager")) {
            prompts.add(createPrompt(
                "decision_support", 
                "決策支援助手",
                "基於數據和最佳實踐提供決策建議",
                List.of(
                    new McpSchema.PromptArgument("context", "決策背景", Optional.of(true)),
                    new McpSchema.PromptArgument("options", "可選方案", Optional.of(false))
                )
            ));
        }
        
        // 基於最近活動的提示
        List<String> recentTopics = profile.getRecentTopics();
        for (String topic : recentTopics) {
            prompts.add(createTopicSpecificPrompt(topic));
        }
        
        return prompts;
    }
    
    private McpSchema.PromptMessage generateDynamicPrompt(String promptName, Map<String, Object> arguments) {
        switch (promptName) {
            case "intelligent_analysis":
                return generateIntelligentAnalysisPrompt(arguments);
            case "knowledge_synthesis":
                return generateKnowledgeSynthesisPrompt(arguments);
            case "contextual_qa":
                return generateContextualQAPrompt(arguments);
            default:
                return generateGenericPrompt(promptName, arguments);
        }
    }
    
    private McpSchema.PromptMessage generateIntelligentAnalysisPrompt(Map<String, Object> arguments) {
        String topic = (String) arguments.get("topic");
        String context = (String) arguments.get("context");
        
        // 從知識庫檢索相關信息
        List<Document> relevantDocs = vectorStore.similaritySearch(
            SearchRequest.defaults()
                .withQuery(topic)
                .withTopK(5)
                .withSimilarityThreshold(0.7)
                .build()
        );
        
        String knowledgeContext = relevantDocs.stream()
            .map(Document::getContent)
            .collect(Collectors.joining("\n\n"));
        
        String promptContent = String.format("""
            # 智能分析助手
            
            ## 分析主題
            %s
            
            ## 上下文信息
            %s
            
            ## 相關知識
            %s
            
            ## 分析要求
            請基於上述信息進行深度分析，包括：
            1. 現狀評估
            2. 趨勢分析  
            3. 風險識別
            4. 改進建議
            5. 下一步行動
            
            請確保分析結果具有可操作性和實用價值。
            """, topic, context, knowledgeContext);
        
        return new McpSchema.PromptMessage(
            McpSchema.Role.USER,
            promptContent
        );
    }
}
```

### 提示效果評估與優化

為了確保提示系統的持續改進，我們建立了完整的效果評估機制：

**效果指標體系**：
- 提示執行成功率
- 用戶滿意度評分
- 任務完成時間
- 結果準確性評估

**A/B 測試框架**：
- 並行測試不同版本的提示
- 統計分析不同提示的效果差異
- 自動選擇最優的提示版本
- 持續優化提示內容

**學習機制**：
- 收集用戶反饋和行為數據
- 分析成功和失敗的模式
- 自動調整提示參數
- 發現新的最佳實踐

```java
@Component
@Slf4j
public class PromptOptimizationService {

    private final PromptMetricsCollector metricsCollector;
    private final UserFeedbackService feedbackService;
    
    @Async
    public void evaluatePromptEffectiveness(String promptId, String userId, String result, long executionTime) {
        try {
            // 收集執行指標
            PromptMetrics metrics = PromptMetrics.builder()
                .promptId(promptId)
                .userId(userId)
                .executionTime(executionTime)
                .timestamp(Instant.now())
                .build();
            
            // 評估結果質量
            double qualityScore = assessResultQuality(result);
            metrics.setQualityScore(qualityScore);
            
            // 獲取用戶反饋
            UserFeedback feedback = feedbackService.getUserFeedback(userId, promptId);
            if (feedback != null) {
                metrics.setSatisfactionScore(feedback.getSatisfactionScore());
            }
            
            // 存儲指標數據
            metricsCollector.recordMetrics(metrics);
            
            // 觸發優化分析
            if (shouldTriggerOptimization(promptId)) {
                optimizePrompt(promptId);
            }
            
        } catch (Exception e) {
            log.error("提示效果評估失敗: promptId={}, userId={}", promptId, userId, e);
        }
    }
    
    private void optimizePrompt(String promptId) {
        // 分析歷史數據
        List<PromptMetrics> historicalData = metricsCollector.getHistoricalMetrics(promptId);
        
        // 識別改進機會
        PromptAnalysis analysis = analyzePromptPerformance(historicalData);
        
        // 生成優化建議
        if (analysis.hasImprovementOpportunities()) {
            PromptOptimizationSuggestions suggestions = generateOptimizationSuggestions(analysis);
            
            // 應用優化
            applyOptimizations(promptId, suggestions);
            
            log.info("提示優化完成: promptId={}, improvements={}", promptId, suggestions.getImprovements());
        }
    }
}
```
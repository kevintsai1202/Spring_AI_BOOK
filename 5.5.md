# 5.5 聲優太花錢？找 AI 幫你配音

> **本章重點**：學習使用 Spring AI 的文字轉語音功能，建立完整的 AI 配音系統，掌握語音合成和音訊處理技術，為多媒體內容創作提供專業的語音解決方案。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解文字轉語音技術**：掌握 TTS 技術的工作原理和應用場景
- 🎯 **實現多種語音風格**：支援不同聲音、語速、語調的語音生成
- 🎯 **建立配音管理系統**：完整的語音生成、儲存和下載功能
- 🎯 **優化語音品質**：掌握語音參數調整和品質控制技巧
- 🎯 **企業級應用設計**：建立可商用的 AI 配音服務平台

---

## 5.5.1 AI 配音技術革命

### AI 有 ABC 腔調

![AI 配音](https://ithelp.ithome.com.tw/upload/images/20240810/20161290YGtkKt0BkG.jpg)

昨天教大家上字幕，今天則是反過來，給文字讓 AI 幫你配音！

比起以前文字轉聲音的軟體，AI 的聲音更為自然，角色跟速度也都能調整，讓我們看看如何操作吧。

### AI 配音 vs 傳統配音對比

| 比較項目 | AI 配音 | 傳統配音 | 優勢分析 |
|----------|---------|----------|----------|
| **成本** | $0.015/1K字元 | $50-200/分鐘 | AI 節省 95%+ 成本 |
| **速度** | 即時生成 | 數天製作 | AI 快 100+ 倍 |
| **一致性** | 完全一致 | 人為變化 | AI 品質穩定 |
| **可調性** | 隨時調整 | 重新錄製 | AI 彈性極高 |
| **語言支援** | 多語言 | 限制較多 | AI 支援更廣 |
| **情感表達** | 持續改善 | 自然豐富 | 傳統仍有優勢 |

### AI 配音的核心價值

**1. 成本效益顯著**
- 💰 **大幅降低成本**：相比專業配音員節省 95% 以上費用
- ⏰ **即時生成**：從文字到語音幾秒鐘完成
- 🔄 **無限修改**：隨時調整內容無額外成本
- 📈 **規模化生產**：批次處理大量內容

**2. 品質持續提升**
- 🎭 **多種聲音選擇**：男聲、女聲、不同年齡和風格
- 🎵 **語調控制**：調整語速、音調、情感表達
- 🌍 **多語言支援**：支援數十種語言和方言
- 🔊 **高品質音訊**：CD 級音質輸出

**3. 應用場景廣泛**
- 📚 **教育培訓**：課程講解、有聲書製作
- 🎬 **影片製作**：旁白配音、角色對話
- 📢 **廣告行銷**：廣告配音、產品介紹
- 🤖 **智能助手**：語音回應、客服系統
- 🎮 **遊戲開發**：角色配音、劇情對話

---

## 5.5.2 Spring AI 語音生成服務

### 主要支援的語音服務

| 服務商 | 模型 | 語音選項 | 品質 | 成本 | 推薦場景 |
|--------|------|----------|------|------|----------|
| **OpenAI** | TTS-1, TTS-1-HD | 6種聲音 | 極高 | 中 | 通用配音、專業製作 |
| **Azure OpenAI** | TTS-1, TTS-1-HD | 6種聲音 | 極高 | 中 | 企業級應用 |
| **ElevenLabs** | 多種模型 | 自訂聲音 | 極高 | 高 | 高端配音、聲音克隆 |
| **Google Cloud** | WaveNet | 多種聲音 | 高 | 低 | 大量生成、成本敏感 |

### OpenAI TTS 語音選項詳解

文字轉語音也是劃分在 **Audio Model** 的部分，Spring AI 目前主要支援 OpenAI 和 Azure OpenAI：

![Spring AI 語音支援](https://ithelp.ithome.com.tw/upload/images/20240809/20161290wi54q7gekg.png)

**OpenAI TTS 可用聲音**：

| 聲音名稱 | 特色 | 適用場景 | 語言支援 |
|----------|------|----------|----------|
| **alloy** | 中性、清晰 | 新聞播報、教學 | 多語言 |
| **echo** | 男性、沉穩 | 商業簡報、紀錄片 | 多語言 |
| **fable** | 女性、溫暖 | 故事講述、客服 | 多語言 |
| **onyx** | 男性、深沉 | 廣告配音、旁白 | 多語言 |
| **nova** | 女性、活潑 | 廣告、娛樂內容 | 多語言 |
| **shimmer** | 女性、柔和 | 冥想、放鬆內容 | 多語言 |

**模型差異**：
- **TTS-1**：標準品質，速度快，成本低
- **TTS-1-HD**：高品質，音質更佳，成本稍高

---

## 5.5.3 專案建立與配置

### Maven 依賴配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>ai-voice-generator</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>ai-voice-generator</name>
    <description>AI-powered voice generation using Spring AI</description>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <!-- 使用 Spring AI BOM 管理版本 -->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.ai</groupId>
                <artifactId>spring-ai-bom</artifactId>
                <version>1.0.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <dependencies>
        <!-- Spring AI OpenAI Starter -->
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-starter-model-openai</artifactId>
        </dependency>
        
        <!-- Spring Boot Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Spring Boot Validation -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <!-- Audio Processing -->
        <dependency>
            <groupId>org.apache.tika</groupId>
            <artifactId>tika-core</artifactId>
            <version>2.9.2</version>
        </dependency>
        
        <!-- File Processing -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.15.1</version>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

### 應用程式配置

```yaml
# application.yml
spring:
  application:
    name: ai-voice-generator
  ai:
    model:
      audio:
        speech: openai  # 啟用 OpenAI 音訊語音模型
    openai:
      api-key: ${OPENAI_API_KEY}
      base-url: https://api.openai.com
      audio:
        speech:
          options:
            model: tts-1-hd  # 高品質模型
            voice: alloy     # 預設聲音
            response-format: mp3  # 音訊格式
            speed: 1.0       # 語速（0.25-4.0）

# 應用程式配置
app:
  voice:
    output-directory: ./generated-voices
    supported-formats: ["mp3", "opus", "aac", "flac"]
    max-text-length: 4096  # OpenAI TTS 限制
    default-voice: alloy
    default-model: tts-1-hd

# 伺服器配置
server:
  port: 8080
  servlet:
    context-path: /api

# 日誌配置
logging:
  level:
    org.springframework.ai: DEBUG
    com.example: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

---

## 5.5.4 基礎語音生成功能

### 語音生成控制器

```java
package com.example.controller;

import com.example.dto.VoiceRequest;
import com.example.dto.VoiceResponse;
import com.example.service.VoiceGenerationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.nio.charset.StandardCharsets;
import java.util.List;

@RestController
@RequestMapping("/voice")
@RequiredArgsConstructor
@Slf4j
public class VoiceController {
    
    private final VoiceGenerationService voiceService;
    
    /**
     * 基礎語音生成
     * @param text 要轉換的文字
     * @param voice 聲音選擇（可選）
     * @param speed 語速（可選）
     * @return 音訊檔案
     */
    @GetMapping("/generate")
    public ResponseEntity<Resource> generateVoice(
            @RequestParam String text,
            @RequestParam(value = "voice", defaultValue = "alloy") String voice,
            @RequestParam(value = "speed", defaultValue = "1.0") Float speed) {
        
        try {
            // 驗證文字長度
            if (text.length() > 4096) {
                throw new IllegalArgumentException("文字長度不能超過 4096 字元");
            }
            
            log.info("開始生成語音：文字長度={}, 聲音={}, 語速={}", 
                    text.length(), voice, speed);
            
            // 生成語音
            byte[] audioData = voiceService.generateVoice(text, voice, speed);
            
            // 建立回應
            ByteArrayResource resource = new ByteArrayResource(audioData);
            
            String fileName = String.format("配音_%s_%s.mp3", 
                    voice, 
                    System.currentTimeMillis());
            
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION,
                            "attachment; filename=\"" + fileName + "\"")
                    .contentType(MediaType.parseMediaType("audio/mpeg"))
                    .contentLength(audioData.length)
                    .body(resource);
            
        } catch (Exception e) {
            log.error("語音生成失敗：{}", text, e);
            
            String errorMessage = "語音生成失敗: " + e.getMessage();
            ByteArrayResource errorResource = new ByteArrayResource(
                    errorMessage.getBytes(StandardCharsets.UTF_8)
            );
            
            return ResponseEntity.badRequest()
                    .contentType(MediaType.TEXT_PLAIN)
                    .body(errorResource);
        }
    }
    
    /**
     * 進階語音生成（JSON API）
     * @param request 語音生成請求
     * @return JSON 格式回應
     */
    @PostMapping("/generate-advanced")
    public ResponseEntity<VoiceResponse> generateAdvancedVoice(
            @RequestBody @Valid VoiceRequest request) {
        
        try {
            log.info("進階語音生成請求：{}", request);
            
            VoiceResponse response = voiceService.generateAdvancedVoice(request);
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("進階語音生成失敗", e);
            
            VoiceResponse errorResponse = VoiceResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .text(request.getText())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 批次語音生成
     * @param requests 多個語音生成請求
     * @return 批次處理結果
     */
    @PostMapping("/batch-generate")
    public ResponseEntity<List<VoiceResponse>> batchGenerateVoice(
            @RequestBody @Valid List<VoiceRequest> requests) {
        
        try {
            log.info("批次語音生成：{} 個請求", requests.size());
            
            List<VoiceResponse> responses = voiceService.batchGenerateVoice(requests);
            
            return ResponseEntity.ok(responses);
            
        } catch (Exception e) {
            log.error("批次語音生成失敗", e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 獲取可用聲音列表
     * @return 聲音選項
     */
    @GetMapping("/voices")
    public ResponseEntity<List<VoiceOption>> getAvailableVoices() {
        List<VoiceOption> voices = voiceService.getAvailableVoices();
        return ResponseEntity.ok(voices);
    }
    
    /**
     * 語音預覽（短文字）
     * @param voice 聲音選擇
     * @return 預覽音訊
     */
    @GetMapping("/preview/{voice}")
    public ResponseEntity<Resource> previewVoice(@PathVariable String voice) {
        try {
            String previewText = "您好，這是 " + voice + " 聲音的預覽。";
            byte[] audioData = voiceService.generateVoice(previewText, voice, 1.0f);
            
            ByteArrayResource resource = new ByteArrayResource(audioData);
            
            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType("audio/mpeg"))
                    .body(resource);
            
        } catch (Exception e) {
            log.error("語音預覽失敗：{}", voice, e);
            return ResponseEntity.badRequest().build();
        }
    }
}
```

### 語音生成服務

```java
package com.example.service;

import com.example.dto.VoiceRequest;
import com.example.dto.VoiceResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.audio.speech.SpeechModel;
import org.springframework.ai.audio.speech.SpeechPrompt;
import org.springframework.ai.audio.speech.SpeechResponse;
import org.springframework.ai.openai.OpenAiAudioSpeechOptions;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class VoiceGenerationService {
    
    private final SpeechModel speechModel;
    private final VoiceStorageService storageService;
    
    /**
     * 基礎語音生成
     * @param text 文字內容
     * @param voice 聲音選擇
     * @param speed 語速
     * @return 音訊資料
     */
    public byte[] generateVoice(String text, String voice, Float speed) {
        try {
            // 建立語音選項
            OpenAiAudioSpeechOptions options = OpenAiAudioSpeechOptions.builder()
                    .model("tts-1-hd")
                    .voice(OpenAiAudioApi.SpeechRequest.Voice.valueOf(voice.toUpperCase()))
                    .responseFormat(OpenAiAudioApi.SpeechRequest.AudioResponseFormat.MP3)
                    .speed(speed)
                    .build();
            
            // 建立語音請求
            SpeechPrompt speechPrompt = new SpeechPrompt(text, options);
            
            // 執行語音生成
            SpeechResponse response = speechModel.call(speechPrompt);
            
            return response.getResult().getOutput();
            
        } catch (Exception e) {
            log.error("語音生成失敗：{}", text, e);
            throw new RuntimeException("語音生成失敗：" + e.getMessage(), e);
        }
    }
    
    /**
     * 進階語音生成
     * @param request 語音生成請求
     * @return 語音回應
     */
    public VoiceResponse generateAdvancedVoice(VoiceRequest request) {
        try {
            // 建立進階語音選項
            OpenAiAudioSpeechOptions options = OpenAiAudioSpeechOptions.builder()
                    .model(request.getModel())
                    .voice(OpenAiAudioApi.SpeechRequest.Voice.valueOf(
                            request.getVoice().toUpperCase()))
                    .responseFormat(OpenAiAudioApi.SpeechRequest.AudioResponseFormat
                            .valueOf(request.getFormat().toUpperCase()))
                    .speed(request.getSpeed())
                    .build();
            
            SpeechPrompt speechPrompt = new SpeechPrompt(request.getText(), options);
            SpeechResponse response = speechModel.call(speechPrompt);
            
            byte[] audioData = response.getResult().getOutput();
            
            // 儲存音訊檔案（如果需要）
            String filePath = null;
            if (request.isSaveFile()) {
                filePath = storageService.saveAudioFile(
                        audioData, 
                        request.getText(), 
                        request.getVoice(), 
                        request.getFormat()
                );
            }
            
            return VoiceResponse.builder()
                    .success(true)
                    .text(request.getText())
                    .voice(request.getVoice())
                    .model(request.getModel())
                    .format(request.getFormat())
                    .speed(request.getSpeed())
                    .audioData(audioData)
                    .filePath(filePath)
                    .fileSize((long) audioData.length)
                    .duration(estimateAudioDuration(request.getText(), request.getSpeed()))
                    .timestamp(LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("進階語音生成失敗：{}", request.getText(), e);
            throw new RuntimeException("進階語音生成失敗：" + e.getMessage(), e);
        }
    }
    
    /**
     * 批次語音生成
     * @param requests 請求列表
     * @return 批次處理結果
     */
    public List<VoiceResponse> batchGenerateVoice(List<VoiceRequest> requests) {
        log.info("開始批次處理 {} 個語音生成請求", requests.size());
        
        List<CompletableFuture<VoiceResponse>> futures = requests.stream()
                .map(request -> CompletableFuture.supplyAsync(() -> {
                    try {
                        return generateAdvancedVoice(request);
                    } catch (Exception e) {
                        log.error("批次處理失敗：{}", request.getText(), e);
                        return VoiceResponse.builder()
                                .success(false)
                                .text(request.getText())
                                .error(e.getMessage())
                                .build();
                    }
                }))
                .collect(Collectors.toList());
        
        // 等待所有任務完成
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(
                futures.toArray(new CompletableFuture[0])
        );
        
        return allFutures.thenApply(v -> 
                futures.stream()
                        .map(CompletableFuture::join)
                        .collect(Collectors.toList())
        ).join();
    }
    
    /**
     * 獲取可用聲音選項
     */
    public List<VoiceOption> getAvailableVoices() {
        return List.of(
            new VoiceOption("alloy", "中性、清晰", "新聞播報、教學"),
            new VoiceOption("echo", "男性、沉穩", "商業簡報、紀錄片"),
            new VoiceOption("fable", "女性、溫暖", "故事講述、客服"),
            new VoiceOption("onyx", "男性、深沉", "廣告配音、旁白"),
            new VoiceOption("nova", "女性、活潑", "廣告、娛樂內容"),
            new VoiceOption("shimmer", "女性、柔和", "冥想、放鬆內容")
        );
    }
    
    /**
     * 估算音訊時長（秒）
     */
    private Double estimateAudioDuration(String text, Float speed) {
        // 粗略估算：平均每分鐘 150 個字元
        double baseMinutes = text.length() / 150.0;
        return (baseMinutes * 60) / speed;
    }
}
```

---

## 5.5.5 請求和回應 DTO

### 語音請求 DTO

```java
package com.example.dto;

import lombok.Data;
import javax.validation.constraints.*;

@Data
public class VoiceRequest {
    
    @NotBlank(message = "文字內容不能為空")
    @Size(max = 4096, message = "文字長度不能超過 4096 字元")
    private String text;
    
    @Pattern(regexp = "^(alloy|echo|fable|onyx|nova|shimmer)$", 
             message = "聲音必須是 alloy、echo、fable、onyx、nova 或 shimmer")
    private String voice = "alloy";
    
    @Pattern(regexp = "^(tts-1|tts-1-hd)$", 
             message = "模型必須是 tts-1 或 tts-1-hd")
    private String model = "tts-1-hd";
    
    @Pattern(regexp = "^(mp3|opus|aac|flac)$", 
             message = "格式必須是 mp3、opus、aac 或 flac")
    private String format = "mp3";
    
    @DecimalMin(value = "0.25", message = "語速不能小於 0.25")
    @DecimalMax(value = "4.0", message = "語速不能大於 4.0")
    private Float speed = 1.0f;
    
    private boolean saveFile = false;
    
    private String category;  // 分類標籤
    private String description;  // 描述
}
```

### 語音回應 DTO

```java
package com.example.dto;

import lombok.Builder;
import lombok.Data;
import java.time.LocalDateTime;

@Data
@Builder
public class VoiceResponse {
    
    private boolean success;
    private String text;
    private String voice;
    private String model;
    private String format;
    private Float speed;
    private byte[] audioData;
    private String filePath;
    private Long fileSize;
    private Double duration;  // 音訊時長（秒）
    private String error;
    private LocalDateTime timestamp;
    
    // 統計資訊
    private Integer characterCount;
    private String audioUrl;  // 如果上傳到雲端儲存
    
    /**
     * 建立成功回應
     */
    public static VoiceResponse success(String text, String voice, byte[] audioData) {
        return VoiceResponse.builder()
                .success(true)
                .text(text)
                .voice(voice)
                .audioData(audioData)
                .fileSize((long) audioData.length)
                .characterCount(text.length())
                .timestamp(LocalDateTime.now())
                .build();
    }
    
    /**
     * 建立錯誤回應
     */
    public static VoiceResponse error(String text, String error) {
        return VoiceResponse.builder()
                .success(false)
                .text(text)
                .error(error)
                .timestamp(LocalDateTime.now())
                .build();
    }
}
```

### 聲音選項 DTO

```java
package com.example.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class VoiceOption {
    private String name;
    private String description;
    private String suitableFor;
    private String gender;
    private String style;
    
    public VoiceOption(String name, String description, String suitableFor) {
        this.name = name;
        this.description = description;
        this.suitableFor = suitableFor;
        
        // 根據聲音名稱設定性別和風格
        switch (name) {
            case "alloy" -> {
                this.gender = "中性";
                this.style = "清晰";
            }
            case "echo", "onyx" -> {
                this.gender = "男性";
                this.style = name.equals("echo") ? "沉穩" : "深沉";
            }
            case "fable", "nova", "shimmer" -> {
                this.gender = "女性";
                this.style = switch (name) {
                    case "fable" -> "溫暖";
                    case "nova" -> "活潑";
                    case "shimmer" -> "柔和";
                    default -> "自然";
                };
            }
        }
    }
}
```

---

## 5.5.6 進階功能實現

### 語音儲存服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class VoiceStorageService {
    
    @Value("${app.voice.output-directory:./generated-voices}")
    private String outputDirectory;
    
    /**
     * 儲存音訊檔案
     * @param audioData 音訊資料
     * @param text 原始文字
     * @param voice 聲音類型
     * @param format 音訊格式
     * @return 檔案路徑
     */
    public String saveAudioFile(byte[] audioData, String text, String voice, String format) {
        try {
            // 建立輸出目錄
            Path outputPath = Paths.get(outputDirectory);
            if (!Files.exists(outputPath)) {
                Files.createDirectories(outputPath);
            }
            
            // 生成檔案名稱
            String fileName = generateFileName(text, voice, format);
            Path filePath = outputPath.resolve(fileName);
            
            // 寫入檔案
            Files.write(filePath, audioData);
            
            log.info("音訊檔案已儲存：{}", filePath.toString());
            return filePath.toString();
            
        } catch (IOException e) {
            log.error("音訊檔案儲存失敗", e);
            throw new RuntimeException("音訊檔案儲存失敗：" + e.getMessage());
        }
    }
    
    /**
     * 生成檔案名稱
     */
    private String generateFileName(String text, String voice, String format) {
        String timestamp = LocalDateTime.now().format(
            DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")
        );
        String uuid = UUID.randomUUID().toString().substring(0, 8);
        String sanitizedText = sanitizeText(text);
        
        return String.format("%s_%s_%s_%s.%s", 
                timestamp, voice, uuid, sanitizedText, format);
    }
    
    /**
     * 清理文字作為檔案名稱
     */
    private String sanitizeText(String text) {
        return text.replaceAll("[^a-zA-Z0-9\u4e00-\u9fa5]", "_")
                  .substring(0, Math.min(text.length(), 20));
    }
    
    /**
     * 批次儲存音訊檔案
     */
    public List<String> batchSaveAudioFiles(List<VoiceResponse> responses) {
        return responses.stream()
                .filter(VoiceResponse::isSuccess)
                .filter(response -> response.getAudioData() != null)
                .map(response -> saveAudioFile(
                        response.getAudioData(),
                        response.getText(),
                        response.getVoice(),
                        response.getFormat()
                ))
                .collect(Collectors.toList());
    }
}
```

### 語音品質優化服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.regex.Pattern;

@Service
@RequiredArgsConstructor
@Slf4j
public class VoiceOptimizationService {
    
    /**
     * 優化文字內容以提升語音品質
     * @param text 原始文字
     * @param voice 聲音類型
     * @return 優化後的文字
     */
    public String optimizeTextForSpeech(String text, String voice) {
        String optimized = text;
        
        // 處理數字
        optimized = processNumbers(optimized);
        
        // 處理縮寫
        optimized = processAbbreviations(optimized);
        
        // 處理標點符號
        optimized = processPunctuation(optimized);
        
        // 處理語音停頓
        optimized = addSpeechPauses(optimized);
        
        // 根據聲音類型調整
        optimized = adjustForVoiceType(optimized, voice);
        
        return optimized;
    }
    
    /**
     * 處理數字轉換
     */
    private String processNumbers(String text) {
        // 將阿拉伯數字轉換為中文數字（提升中文語音品質）
        text = text.replaceAll("\\b(\\d{4})\\b", "$1年");
        text = text.replaceAll("\\b(\\d{1,2})月(\\d{1,2})日\\b", "$1月$2日");
        text = text.replaceAll("\\b(\\d+)%\\b", "百分之$1");
        
        return text;
    }
    
    /**
     * 處理縮寫
     */
    private String processAbbreviations(String text) {
        // 常見縮寫展開
        text = text.replaceAll("\\bAI\\b", "人工智慧");
        text = text.replaceAll("\\bAPI\\b", "應用程式介面");
        text = text.replaceAll("\\bURL\\b", "網址");
        text = text.replaceAll("\\bHTTP\\b", "超文本傳輸協定");
        
        return text;
    }
    
    /**
     * 處理標點符號
     */
    private String processPunctuation(String text) {
        // 在句號後添加較長停頓
        text = text.replaceAll("。", "。 ");
        
        // 在逗號後添加短停頓
        text = text.replaceAll("，", "， ");
        
        // 在問號和驚嘆號後添加停頓
        text = text.replaceAll("[？！]", "$0 ");
        
        return text;
    }
    
    /**
     * 添加語音停頓
     */
    private String addSpeechPauses(String text) {
        // 在長句中間添加適當停頓
        if (text.length() > 100) {
            text = text.replaceAll("([，。！？])(?=.{30,})", "$1 ");
        }
        
        return text;
    }
    
    /**
     * 根據聲音類型調整
     */
    private String adjustForVoiceType(String text, String voice) {
        switch (voice) {
            case "nova", "shimmer" -> {
                // 女性聲音，語調可以更溫和
                text = text.replaceAll("！", "。");
            }
            case "echo", "onyx" -> {
                // 男性聲音，可以保持較強語調
                // 保持原樣
            }
            case "alloy" -> {
                // 中性聲音，平衡處理
                text = text.replaceAll("！{2,}", "！");
            }
        }
        
        return text;
    }
    
    /**
     * 驗證文字適合語音轉換
     * @param text 文字內容
     * @return 品質評分（0-100）
     */
    public int evaluateTextQuality(String text) {
        int score = 100;
        
        // 檢查特殊字元
        if (Pattern.compile("[#@$%^&*()\\[\\]{}|\\\\]").matcher(text).find()) {
            score -= 20;  // 包含特殊字元
        }
        
        // 檢查數字比例
        long digitCount = text.chars().filter(Character::isDigit).count();
        double digitRatio = (double) digitCount / text.length();
        if (digitRatio > 0.3) {
            score -= 15;  // 數字太多
        }
        
        // 檢查英文比例
        long englishCount = text.chars().filter(ch -> (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')).count();
        double englishRatio = (double) englishCount / text.length();
        if (englishRatio > 0.5) {
            score -= 10;  // 英文太多（中文語音）
        }
        
        // 檢查句子長度
        String[] sentences = text.split("[。！？]");
        for (String sentence : sentences) {
            if (sentence.length() > 200) {
                score -= 5;  // 句子太長
            }
        }
        
        return Math.max(0, score);
    }
}
```

---

## 📝 本章重點回顧

1. **文字轉語音技術**：掌握了 TTS 技術的工作原理和 AI 配音優勢
2. **多聲音支援**：實現了 6 種不同風格的 AI 聲音選擇
3. **企業級功能**：建立了完整的語音生成、儲存和管理系統
4. **品質優化技術**：掌握了文字預處理和語音參數調整方法
5. **批次處理能力**：支援大量文字的並行語音生成

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **基礎語音生成** | ⭐⭐⭐ | 低 | 所有配音應用 |
| **多聲音選擇** | ⭐⭐⭐ | 低 | 個性化配音 |
| **批次處理** | ⭐⭐ | 中 | 大量內容生成 |
| **品質優化** | ⭐⭐ | 高 | 專業配音製作 |
| **檔案管理** | ⭐⭐ | 中 | 企業級部署 |
| **文字預處理** | ⭐ | 中 | 語音品質提升 |

### 成本效益分析

**OpenAI TTS 定價**：
- 💰 **成本**：$0.015 per 1K characters
- ⏱️ **速度**：即時生成，無等待時間
- 🎯 **品質**：接近人聲的自然度
- 📊 **性價比**：相比專業配音節省 95%+ 成本

### 最佳實踐建議

1. **文字預處理**：優化數字、縮寫和標點符號
2. **聲音選擇**：根據內容類型選擇合適的聲音
3. **語速調整**：根據聽眾和場景調整語速
4. **批次處理**：大量內容使用非同步處理提升效率
5. **品質控制**：實施文字品質評估和語音後處理

### 下一步學習方向

在下一章中，我們將學習 Function Calling 技術，探索如何讓 AI 調用外部工具和服務，實現更強大的功能整合。

---

**參考資料：**
- [Spring AI Audio Speech Documentation](https://docs.spring.io/spring-ai/reference/api/audio.html)
- [OpenAI Text-to-Speech API](https://platform.openai.com/docs/guides/text-to-speech)
- [Audio Format Specifications](https://en.wikipedia.org/wiki/Audio_file_format)
- [Speech Synthesis Markup Language (SSML)](https://www.w3.org/TR/speech-synthesis/)

\newpage


# 序章 {.unnumbered .unlisted}


## 使用 Spring AI 打造企業 RAG 知識庫


## 前言

### Java 在 AI 看到了春天

![Spring AI](https://ithelp.ithome.com.tw/upload/images/20240810/20161290cAV3EcKpVN.jpg)

Spring AI 在2024年2月推出了0.8版本，經過一年多的快速迭代，於2025年5月20日正式發佈了**1.0.0 GA穩定版**。從早期的 Milestone 版本（1.0.0-M1到M8）到 RC1 版本，最終迎來了正式的 GA 版本，如同 AI 的發展一樣迅速。實際使用後，會發現它與 **LangChain4j** 有幾分相似。讓我們看看 Spring AI 官網是如何詮釋：

> Spring AI 創建的目的在簡化開發 AI 功能的應用程式，同時避免不必要的複雜性。專案汲取了 LangChain 和 LlamaIndex 等知名 Python 專案的靈感，但 Spring AI 並不是這些專案的直接移植。我們相信，下一波生成式人工智慧應用程式不僅適用於 Python 開發人員，還將廣泛適用於許多程式設計語言。
>
> Spring AI 的核心在於解決 AI 整合的根本挑戰，即將 **企業數據** / **API** / **AI** 串聯起來。
>
> ![Spring AI 架構](https://ithelp.ithome.com.tw/upload/images/20240801/20161290yEyOlVWozQ.png)
>
> (以上由 [Spring AI官網](https://docs.spring.io/spring-ai/reference/index.html) 翻譯而來)

原來 Spring AI 是跟 LangChain 致敬，Spring 框架能發展到這麼龐大，最關鍵的就是其整合以及簡化的能力，面對這麼龐大的模型以及種類，雖然跟 Python 比起來起步較慢，不過能與 Spring 其他框架整合在一起，讓憋了好久的 Java 開發人員也能大展身手了。

### 為什麼要先學習 Spring Boot 和 Spring MVC？

歡迎來到 Spring AI 的學習之旅！在正式進入 Spring AI 的精彩世界之前，您可能會疑問：「為什麼需要先了解 Spring Boot 和 Spring MVC？」

#### Spring AI 與 Spring 生態系統的關係

雖然 **Spring AI** 是專門針對 AI 應用開發所設計的現代化框架，但它並非憑空而生，而是深深植根於 Spring 生態系統之中：

- 🏗️ **架構基礎**：Spring AI 完全建構在 Spring Boot 之上，繼承了其所有核心特性和設計理念
- 🔧 **配置方式**：採用相同的自動配置（Auto Configuration）和「約定優於配置」（Convention over Configuration）原則
- 📦 **依賴管理**：透過 Spring Boot Starter 的方式提供各種 AI 功能模組
- 🚀 **部署模式**：使用 Spring Boot 的內嵌伺服器和 JAR 打包方式進行部署
- 🔄 **生命週期管理**：依賴 Spring 的 IoC 容器進行 Bean 管理和依賴注入

#### API 開發在 Spring AI 中的核心地位

更重要的是，Spring AI 的許多核心功能都需要透過 **API** 來實現和整合：

- 🔗 **Function Calling**：AI 模型需要透過 API 呼叫外部工具和服務，實現與真實世界的互動
- 🖥️ **MCP Server**：模型控制協議（Model Context Protocol）伺服器需要 HTTP 端點來處理各種請求
- 🌐 **系統整合**：企業級 AI 應用通常需要與現有系統透過 API 進行整合
- 📊 **資料交換**：RAG（檢索增強生成）系統需要透過 API 獲取和處理各種資料來源
- 🔄 **即時互動**：聊天機器人和對話系統需要透過 WebSocket 或 Server-Sent Events 提供即時回應

#### Java 兩大 AI 框架比較 (2025年更新版)

既然是參考 LangChain 的概念，Java 開發人員該使用 LangChain4j 還是 Spring AI 做為開發框架？以下是詳細比較：

|  | Spring AI | LangChain4j |
| --- | --- | --- |
| **推出時間** | 2024年二月推出0.8版，2025年5月正式發佈1.0.0 GA | 2023年六月推出0.1版 |
| **適用Java版本** | JDK 17+ | JDK 8+ |
| **當前版本** | 1.0.3 GA (穩定版) | 1.7.1，已有80+版本 |
| **功能性** | 整合性更佳，支援20+個AI模型，統一的ChatClient API，支援多模態輸入輸出 | 個別功能較強，部分功能針對不同大語言模型特性開發 |
| **整合性** | 原生支援Spring Boot 3.4.x，完美的自動配置和依賴注入 | 雖然也能在Spring中使用，但整合性不如Spring原生 |
| **核心特色** | ChatClient API、Advisor攔截器鏈、強化版LLM能力 | 豐富的工具生態、活躍的社群支援 |
| **向量資料庫支援** | 支援12+種向量資料庫（Chroma、PGVector、Redis等） | 支援多種向量資料庫 |
| **相關資料** | 官方文檔完整，1.0 GA版本文檔齊全 | 發展時間較長，社群資源豐富 |

#### Spring AI 1.0 GA 的重大特色

**ChatClient - 核心API**
Spring AI 的核心是 ChatClient，這是一個可攜式且易於使用的 API，是與 AI 模型互動的主要介面。Spring AI 的 ChatClient 支援調用 20 個 AI 模型，從 Anthropic 到智譜AI。它支援多模態輸入和輸出（當底層模型支援時）以及結構化回應。

**增強版LLM功能**
增強版LLM的概念是在基本模型互動的基礎上增加功能，如資料檢索、對話記憶和工具調用。這些功能讓您可以直接將自己的資料和外部API帶入模型的推理過程中。

**Advisor API**
Spring AI ChatClient 的一個關鍵特色是 Advisor API。這是一個攔截器鏈，允許您透過注入檢索到的資料和對話記憶來修改傳入的提示詞。

#### AI框架挑選建議 (2025年更新)

- 如果公司還在使用 Java 8，LangChain4j 是不二選擇
- 如果公司已使用 Spring Boot 3.4+ 以上，當然就直接使用 Spring AI 1.0 GA
- 如果使用 Java 17+ 卻沒使用 Spring Boot 框架呢？建議你趕快學 Spring Boot
- 想嘗試最新功能或是單純開發 AI 的程式可使用 LangChain4j，若要將 AI 結合企業內部其他資訊系統則建議使用 Spring AI，因為開發企業使用的程式往往需要更高的穩定性以及精準的內容
- **2025年重點**：Spring AI 1.0 GA 已經達到生產就緒標準，適合企業級應用開發

#### 本書的學習架構

基於以上考量，本書採用循序漸進的學習方式：

**第一部分：Spring Boot 基礎**
- 建立堅實的 Spring Boot 開發基礎
- 掌握現代 Java 企業級開發的核心技能
- 理解 Spring AI 所依賴的核心框架特性

**第二部分：Spring MVC 與 API 開發**
- 學習如何建立和配置 RESTful API
- 掌握請求處理、回應格式化和錯誤處理
- 熟悉企業級 API 開發的最佳實踐
- 為 Spring AI 的 Function Calling 和 MCP Server 奠定基礎

**第三部分：生產級 API 開發實踐**
- 深入學習資料驗證、錯誤處理和檔案上傳
- 掌握 API 測試和文件自動生成
- 建立完整的生產級 API 開發技能

**第四部分：Spring AI 實戰**
- 在前三部分的基礎上，深入學習 Spring AI
- 建構實際的企業級 RAG 知識庫系統
- 整合各種 AI 服務和工具

#### 學習建議

> 💡 **給有經驗的開發者**：如果您對 Spring Boot 和 Spring MVC 已經非常熟悉，可以快速瀏覽前三部分，或直接跳至第四部份開始學習 Spring AI。

> 🎯 **給初學者**：強烈建議按照順序學習。紮實的基礎將讓您在後續的 Spring AI 學習中事半功倍，更能理解框架設計的精妙之處。

> 🚀 **給企業開發者**：本書不僅教授技術實現，更注重企業級應用的實際需求，包括安全性、效能優化、監控和維護等方面。

讓我們開始這趟精彩的學習之旅，從 Spring Boot 的基礎開始，一步步建構您的 AI 應用開發能力！

---

# 內容

**第一章：Spring Boot 基礎**
- 1.1 Spring Boot 快速入門
- 1.2 專案架構與配置
- 1.3 核心註解與依賴注入
- 1.4 第一個 Spring Boot 應用

**第二章：Spring MVC & RESTful API**
- 2.1 Spring MVC API 開發基礎
- 2.2 RESTful API 設計與實踐
- 2.3 API 請求與回應處理

**第三章：生產級 API 開發實踐**
- 3.1 資料驗證與錯誤處理
- 3.2 檔案處理與多媒體支援
- 3.3 API 測試與文件化

**第四章：認識 Spring AI**
- 4.1 取得 AI 入門鑰匙 API key
- 4.2 Hello AI World
- 4.3 如何像 ChatGPT 產生流式輸出
- 4.4 深入瞭解 ChatModel
- 4.5 前端該如何處理流式輸出

**第五章：個性化 ChatBot**
- 5.1 懶得打字問 AI？用提示詞範本吧
- 5.2 如何跟 ChatGPT 一樣處理多模態資料
- 5.3 透過 Spring AI 生成美女圖
- 5.4 做一個字幕產生器
- 5.5 聲優太花錢？找 AI 幫你配音
- 5.6 Function Calling (上)-請支援 AI
- 5.7 Function Calling (中)-讓 AI 讀取企業資訊
- 5.8 Function Calling (下)-最終組合技
- 5.9 取得實際氣象資訊
- 5.10 結構化資料轉換器
- 5.11 ChatClient vs ChatModel

**第六章：讓 ChatBot 不再金魚腦**
- 6.1 魔鏡~誰是 Spring AI 的專家?
- 6.2 讓 AI 記住對話
- 6.3 Spring AI 官方記憶
- 6.4 Spring AI 的鏈式增強器
- 6.5 自行開發 Spring AI 插件
- 6.6 安裝 Neo4j 向量資料庫 (使用 docker)
- 6.7 使用向量資料庫作為對話的長久記憶

**第七章：讓企業不再卻步的技術-RAG**
- 7.1 RAG 流程詳解
- 7.2 如何將內容向量化
- 7.3 ETL (上) - RAG 的知識來源
- 7.4 ETL (中) - 擷取進階文件類型
- 7.5 ETL (下) - 給向量資料加上 Buff
- 7.6 企業 RAG 真正的資料來源
- 7.7 RAG 的最後一哩路

**第八章：提升 RAG 性能-Advanced RAG**
- 8.1 簡述 Advanced RAG
- 8.2 提高 RAG 準確率從 Embedding 換起
- 8.3 在 Spring AI 實作 Re-ranking
- 8.4 內容審核與評估測試

**第九章：整合 MCP (模型上下文協議)**
- 9.1 甚麼是 MCP？
- 9.2 引入 Spring MCP
- 9.3 在 Spring AI 程式中使用 MCP 工具
- 9.4 開發 MCP Server 工具


\newpage


# 第一章：Spring Boot 基礎 {.unnumbered .unlisted}


## 1.1 Spring Boot 快速入門


> **第一章導讀**：本章將帶您快速掌握 Spring Boot 的核心概念和開發環境，為後續的 Spring AI 整合學習奠定堅實基礎。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 Spring Boot 核心價值**：掌握 Spring Boot 的設計理念和核心優勢
- 🎯 **建立開發環境**：使用 STS4 快速建置專業級開發環境
- 🎯 **建立第一個專案**：使用 Spring Initializr 快速建立專案
- 🎯 **掌握專案結構**：理解 Spring Boot 專案的標準組織方式
- 🎯 **為 Spring AI 做準備**：建立適合 AI 應用開發的基礎架構

---

## 1.1.1 為什麼選擇 Spring Boot？

### Spring Boot 的核心價值

在現代企業級 Java 開發中，Spring Boot 已經成為不可或缺的核心框架，特別是在 AI 應用開發領域。

**傳統 Spring 開發的挑戰**：
- 繁瑣的 XML 配置
- 複雜的依賴管理
- 耗時的環境設定
- 部署配置複雜

**Spring Boot 的解決方案**：
- ✅ **約定優於配置**：減少 90% 的配置工作
- ✅ **自動配置**：智能判斷和配置所需組件
- ✅ **內嵌伺服器**：無需外部伺服器，一鍵啟動
- ✅ **生產就緒**：內建監控、健康檢查等企業級功能
- ✅ **AI 友好**：完美支援 Spring AI 生態系統

### Spring Boot 核心特性

```java
// 傳統 Spring 需要大量配置
// Spring Boot 只需要一個註解
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

**核心設計原則**：
1. **約定優於配置**：遵循標準約定，減少配置工作
2. **開箱即用**：提供預設配置，快速啟動專案
3. **無程式碼生成**：不依賴程式碼生成，保持程式碼清晰
4. **無 XML 配置**：使用註解和 Java 配置

---

## 1.1.2 建立開發環境

### 為什麼選擇 STS4？

STS4 (Spring Tool Suite 4) 是專為 Spring 開發優化的 IDE，特別適合 Spring Boot 和 Spring AI 開發：

**STS4 的優勢**：
- 內建 Spring Initializr 支援
- 智能程式碼提示和自動完成
- 內建 Spring Boot 除錯工具
- 完整的 Spring 生態系統支援
- 為 Spring AI 開發優化

### 環境需求

| 組件 | 版本要求 | 說明 |
|------|----------|------|
| **JDK** | 17 或 21 | Spring Boot 3.x 最低要求 |
| **STS4** | 最新版本 | 內建 Spring Boot 支援 |
| **Maven** | 3.6+ | 內建於 STS4 |
| **記憶體** | 8GB+ | 推薦配置 |

### 安裝步驟

**1. 下載並安裝 JDK**
- 訪問 [Oracle JDK](https://www.oracle.com/java/technologies/downloads/) 或 [OpenJDK](https://openjdk.org/)
- 下載 JDK 17 或 21
- 設定 JAVA_HOME 環境變數

**2. 下載並安裝 STS4**
- 訪問 [Spring Tools 官網](https://spring.io/tools)
- 下載適合您作業系統的版本
- 解壓縮並啟動 STS4

---

## 1.1.3 建立第一個 Spring Boot 專案

### 使用 STS4 內建的 Spring Initializr

**步驟 1：建立新專案**
1. 開啟 STS4
2. 選擇 `File` → `New` → `Spring Starter Project`
3. 或使用快捷鍵 `Ctrl+N`，選擇 `Spring Starter Project`

**步驟 2：專案基本設定**
```
專案設定：
- Name: spring-boot-demo
- Group: com.example.demo
- Artifact: spring-boot-demo
- Package: com.example.demo
- Java Version: 17 或 21
- Packaging: Jar
- Spring Boot Version: 3.2.x (最新穩定版)
```

**步驟 3：選擇依賴**
```
基礎依賴：
☑ Spring Web - 建立 RESTful API
☑ Spring Boot DevTools - 開發工具
☑ Lombok - 簡化程式碼
☑ Validation - 資料驗證
```

**步驟 4：完成建立**
- 點擊 `Finish`
- STS4 會自動下載依賴並建立專案

### 專案結構解析

```
spring-boot-demo/
├── src/main/java/
│   └── com/example/demo/
│       └── DemoApplication.java     # 主程式入口
├── src/main/resources/
│   ├── application.yml              # 配置檔案
│   └── static/                      # 靜態資源
├── src/test/java/                   # 測試程式碼
├── pom.xml                          # Maven 配置
└── README.md                        # 專案說明
```

**核心檔案說明**：

**1. DemoApplication.java**
```java
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

**2. pom.xml**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example.demo</groupId>
    <artifactId>spring-boot-demo</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>spring-boot-demo</name>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

---

## 1.1.4 第一次啟動

### 啟動應用程式

**方法一：在 STS4 中啟動**
1. 右鍵點擊 `DemoApplication.java`
2. 選擇 `Run As` → `Spring Boot App`

**方法二：使用 Maven 命令**
```bash
# 在專案根目錄執行
mvn spring-boot:run
```

**方法三：使用 Java 命令**
```bash
# 先編譯
mvn clean package

# 執行 JAR 檔案
java -jar target/spring-boot-demo-0.0.1-SNAPSHOT.jar
```

### 驗證啟動成功

**控制台輸出**：
```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.2.0)

2024-01-15 10:30:00.123  INFO 12345 --- [main] c.e.demo.DemoApplication
Started DemoApplication in 2.345 seconds (JVM running for 3.456)
```

**瀏覽器測試**：
- 開啟瀏覽器
- 訪問 `http://localhost:8080`
- 看到 Whitelabel Error Page 表示啟動成功（因為還沒有定義任何端點）

---

## 1.1.5 為 Spring AI 做準備

### AI 應用的特殊需求

在設計 Spring Boot 應用時，我們需要考慮 Spring AI 的特殊需求：

**配置管理**：
```yaml
# application.yml - 為 AI 服務預留配置
spring:
  application:
    name: spring-boot-demo
  profiles:
    active: dev

# AI 服務配置預留
ai:
  openai:
    api-key: ${OPENAI_API_KEY:}
    model: gpt-3.5-turbo
  timeout: 30s
  max-tokens: 1000
```

**依賴準備**：
```xml
<!-- 為未來的 Spring AI 整合預留 -->
<dependencies>
    <!-- 基礎 Web 支援 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- 資料驗證 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    
    <!-- JSON 處理 -->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
    </dependency>
    
    <!-- 開發工具 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
</dependencies>
```

**架構設計考量**：
```java
// 為 AI 服務預留的控制器結構
@RestController
@RequestMapping("/api")
public class DemoController {
    
    @GetMapping("/health")
    public Map<String, String> health() {
        Map<String, String> status = new HashMap<>();
        status.put("status", "UP");
        status.put("timestamp", LocalDateTime.now().toString());
        return status;
    }
    
    // 為未來的 AI 端點預留
    @PostMapping("/ai/chat")
    public ResponseEntity<String> chat(@RequestBody String message) {
        // 預留給 Spring AI 整合
        return ResponseEntity.ok("準備整合 Spring AI");
    }
}
```

### 開發最佳實踐

**1. 專案結構規劃**
```
src/main/java/com/example/demo/
├── DemoApplication.java
├── controller/          # API 控制器
├── service/            # 業務邏輯
├── model/              # 資料模型
├── config/             # 配置類別
└── ai/                 # AI 服務相關（預留）
```

**2. 配置檔案組織**
```
src/main/resources/
├── application.yml              # 主配置
├── application-dev.yml          # 開發環境
├── application-prod.yml         # 生產環境
└── ai/                         # AI 相關配置（預留）
```

**3. 環境變數管理**
```bash
# 開發環境變數
export SPRING_PROFILES_ACTIVE=dev
export OPENAI_API_KEY=your-api-key
export LOG_LEVEL=DEBUG
```

---

## 📝 本章重點回顧

1. **Spring Boot 核心價值**：理解了約定優於配置的設計理念
2. **開發環境建置**：成功安裝並配置 STS4 開發環境
3. **專案建立**：掌握了使用 Spring Initializr 快速建立專案
4. **專案結構**：了解了 Spring Boot 的標準專案組織方式
5. **AI 整合準備**：為後續 Spring AI 學習奠定了基礎架構

### 下一步學習方向

在下一章中，我們將學習專案架構與配置管理，深入了解如何組織和配置一個生產級的 Spring Boot 應用。

---

**參考資料：**
- [Spring Boot Official Guide](https://spring.io/guides/gs/spring-boot/)
- [Spring Tools 4 Documentation](https://github.com/spring-projects/sts4)
- [Spring Initializr](https://start.spring.io/)


\newpage

## 1.2 Spring Boot 專案架構與配置


## 🎯 學習目標

完成本章學習後，您將能夠：

1. **理解分層架構設計原則** - 掌握表現層、業務層、資料層的職責分工
2. **熟悉標準目錄結構** - 了解 Spring Boot 專案的標準組織方式
3. **掌握配置管理策略** - 學會多環境配置和屬性管理
4. **建立可維護的專案結構** - 遵循最佳實踐建立專業級應用架構
5. **理解依賴注入架構** - 掌握 Spring Boot 的核心設計模式

## 為什麼專案架構如此重要？

想像一下，如果您接手一個沒有統一架構規範的專案：
- 程式碼散落在各個角落，找不到邏輯
- 業務邏輯與資料存取混雜在一起
- 配置檔案四處分散，難以管理
- 新功能開發時不知道該放在哪裡

**良好的專案架構就像建築物的藍圖**，它定義了：
- 程式碼的組織方式和放置位置
- 各層級的職責分離和協作關係
- 統一的配置管理和資源組織
- 可擴展和可維護的程式碼結構

💡 **重點提示**：Spring Boot 遵循「約定優於配置」原則，提供了一套經過實戰驗證的架構模式。

## 標準專案結構解析

### 根目錄結構
```
spring-boot-demo/
├── src/main/java/              # Java 原始碼
├── src/main/resources/         # 資源檔案
├── src/test/java/             # 測試程式碼
├── pom.xml                    # Maven 配置
├── mvnw, mvnw.cmd            # Maven Wrapper
└── README.md                  # 專案說明
```

### Java 原始碼組織
```
src/main/java/com/example/demo/
├── DemoApplication.java       # 主程式入口
├── controller/               # 控制器層
├── service/                  # 服務層
├── model/                   # 資料模型
├── config/                  # 配置類別
├── exception/               # 例外處理
└── util/                    # 工具類別
```

✅ **優勢標示**：這種結構按功能分層，便於團隊協作和程式碼維護。

## 分層架構設計

### 三層架構模式
```
┌─────────────────────────────────────┐
│        Presentation Layer          │  ← 表現層 (Controller)
├─────────────────────────────────────┤
│         Business Layer             │  ← 業務層 (Service)
├─────────────────────────────────────┤
│         Data Access Layer          │  ← 資料存取層 (Repository)
└─────────────────────────────────────┘
```

### 各層職責定義

| 層級 | 職責 | 主要元件 | 關鍵特性 |
|------|------|----------|----------|
| **表現層** | 處理 HTTP 請求與回應 | Controller | 輕薄層，不包含業務邏輯 |
| **業務層** | 核心業務邏輯處理 | Service | 事務管理、業務規則驗證 |
| **資料存取層** | 資料庫操作與資料持久化 | Repository | 資料 CRUD 操作 |

💡 **開發順序建議**：按照 Model → Service → Controller 的順序進行開發，確保依賴關係清晰。

## 配置管理架構

### 配置檔案層次結構
```
resources/
├── application.properties          # 基本配置
├── application-dev.properties      # 開發環境
├── application-test.properties     # 測試環境
├── application-prod.properties     # 生產環境
├── static/                        # 靜態資源
├── templates/                     # 模板檔案
└── META-INF/                      # 元資料
```

### 配置優先級順序
1. **命令列參數** - 最高優先級
2. **系統環境變數** - 作業系統層級
3. **application-{profile}.properties** - 環境特定配置
4. **application.properties** - 預設配置
5. **@PropertySource** - 程式碼指定配置

### 核心配置類別

| 配置類型 | 用途 | 範例設定 |
|----------|------|----------|
| **伺服器配置** | 埠號、路徑設定 | `server.port=8080` |
| **資料庫配置** | 連線資訊、連線池 | `spring.datasource.*` |
| **日誌配置** | 日誌等級、輸出格式 | `logging.level.*` |
| **安全配置** | 認證、授權設定 | `spring.security.*` |

## 依賴注入架構

### 注入方式比較

| 注入方式 | 優點 | 缺點 | 建議使用場景 |
|----------|------|------|--------------|
| **建構函式注入** | 不可變、必要依賴 | 建構函式參數多 | 必要依賴 |
| **Setter 注入** | 可選依賴、靈活 | 可變性風險 | 可選依賴 |
| **欄位注入** | 程式碼簡潔 | 測試困難 | 不建議使用 |

### 依賴管理最佳實踐

1. **介面導向設計** - 依賴抽象而非具體實作
2. **單一職責原則** - 每個元件只負責一項功能
3. **依賴倒置原則** - 高層模組不依賴低層模組
4. **開放封閉原則** - 對擴展開放，對修改封閉

## 自動配置機制

### Spring Boot 自動配置特性

| 功能領域 | 自動配置內容 | 觸發條件 |
|----------|--------------|----------|
| **Web MVC** | 控制器、視圖解析器 | spring-boot-starter-web |
| **資料存取** | DataSource、JPA | spring-boot-starter-data-jpa |
| **安全性** | 認證、授權機制 | spring-boot-starter-security |
| **監控** | 健康檢查、指標收集 | spring-boot-starter-actuator |

### 配置覆寫策略

1. **條件化配置** - 根據環境自動啟用/停用功能
2. **屬性綁定** - 將配置屬性綁定到 Java 物件
3. **配置處理器** - 自訂配置邏輯和驗證
4. **外部化配置** - 支援多種配置來源

## 專案結構最佳實踐

### 套件組織原則
```
com.example.demo/
├── controller/          # 按層級分離
│   ├── api/            # API 控制器
│   └── web/            # Web 控制器
├── service/            # 業務服務
│   ├── impl/           # 服務實作
│   └── dto/            # 資料傳輸物件
├── repository/         # 資料存取
├── config/             # 配置類別
├── exception/          # 例外處理
└── util/              # 工具類別
```

### 命名規範建議

| 元件類型 | 命名規範 | 範例 |
|----------|----------|------|
| **Controller** | XxxController | UserController |
| **Service** | XxxService | UserService |
| **Repository** | XxxRepository | UserRepository |
| **Configuration** | XxxConfig | DatabaseConfig |
| **Exception** | XxxException | UserNotFoundException |

## 環境配置管理

### Profile 配置策略

| 環境 | Profile | 特性 | 用途 |
|------|---------|------|------|
| **開發環境** | dev | 詳細日誌、熱重載 | 本地開發 |
| **測試環境** | test | 記憶體資料庫、模擬服務 | 自動化測試 |
| **預發環境** | staging | 接近生產配置 | 上線前驗證 |
| **生產環境** | prod | 效能最佳化、安全強化 | 正式服務 |

### 配置外部化

1. **環境變數** - 容器化部署的首選方式
2. **配置中心** - 集中式配置管理
3. **命令列參數** - 啟動時動態配置
4. **配置檔案** - 傳統檔案式配置

## 📝 重點摘要

1. **分層架構是 Spring Boot 的核心設計模式**，確保職責分離和程式碼可維護性
2. **標準目錄結構有助於團隊協作**，新成員能快速理解專案組織
3. **配置管理支援多環境部署**，透過 Profile 機制適應不同運行環境
4. **自動配置簡化開發流程**，遵循約定優於配置原則
5. **依賴注入提供鬆耦合架構**，提高程式碼可測試性和可維护性
6. **外部化配置支援動態調整**，無需重新編譯即可修改應用行為

透過本章的學習，您已經掌握了 Spring Boot 專案架構的核心概念和配置管理策略。良好的架構設計是成功專案的基石，為後續的功能開發奠定了堅實的基礎。

---

## 💡 架構設計補充：Maven 專案結構與依賴管理

### Maven 標準目錄佈局

Maven 遵循「約定優於配置」的理念，定義了標準的專案目錄結構：

```
project-root/
├── pom.xml                    # 專案物件模型檔案
├── src/
│   ├── main/
│   │   ├── java/             # 主要 Java 原始碼
│   │   ├── resources/        # 主要資源檔案
│   │   └── webapp/           # Web 應用資源 (如適用)
│   └── test/
│       ├── java/             # 測試 Java 原始碼
│       └── resources/        # 測試資源檔案
├── target/                   # 編譯輸出目錄
└── README.md                 # 專案說明文件
```

### 依賴管理策略

| 依賴範圍 | 說明 | 使用時機 |
|----------|------|----------|
| **compile** | 編譯和運行時都需要 | 核心業務依賴 |
| **provided** | 編譯時需要，運行時由容器提供 | Servlet API |
| **runtime** | 運行時需要，編譯時不需要 | 資料庫驅動 |
| **test** | 僅測試時需要 | JUnit、Mockito |
| **system** | 系統路徑依賴 | 特殊情況使用 |

### Spring Boot Starter 架構

Spring Boot Starter 是預配置的依賴描述符，簡化了依賴管理：

| Starter | 功能領域 | 包含的主要依賴 |
|---------|----------|----------------|
| **spring-boot-starter-web** | Web 開發 | Spring MVC、Tomcat、Jackson |
| **spring-boot-starter-data-jpa** | JPA 資料存取 | Hibernate、Spring Data JPA |
| **spring-boot-starter-security** | 安全框架 | Spring Security |
| **spring-boot-starter-test** | 測試支援 | JUnit、Mockito、Spring Test |

### 建構生命週期

Maven 定義了標準的建構生命週期階段：

1. **validate** - 驗證專案結構和資訊
2. **compile** - 編譯主要原始碼
3. **test** - 執行單元測試
4. **package** - 打包編譯後的程式碼
5. **verify** - 執行整合測試和品質檢查
6. **install** - 安裝到本地儲存庫
7. **deploy** - 部署到遠端儲存庫

這種標準化的專案結構和建構流程，確保了不同開發者和環境之間的一致性，是現代 Java 專案開發的基礎架構。


\newpage

## 1.3 核心註解與依賴注入


> **本章重點**：掌握 Spring Boot 核心註解體系和依賴注入機制，為 Spring AI 應用開發建立堅實的技術基礎。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握核心註解**：熟練使用 @SpringBootApplication、@RestController、@Service 等基礎註解
- 🎯 **理解依賴注入**：掌握 @Autowired 和構造函數注入的使用方法
- 🎯 **實現組件管理**：使用 Spring 容器管理應用程式組件
- 🎯 **建立分層架構**：運用註解建立清晰的分層架構
- 🎯 **為 AI 服務做準備**：掌握 AI 應用開發所需的核心註解技能

---

## 1.3.1 Spring Boot 註解體系概覽

### 註解分類

Spring Boot 的註解可以分為以下幾個核心類別：

| 類別 | 用途 | 核心註解 | AI 應用重要性 |
|------|------|----------|---------------|
| **啟動註解** | 應用程式啟動 | `@SpringBootApplication` | ⭐⭐⭐ |
| **組件註解** | 定義和管理 Bean | `@Component`、`@Service`、`@RestController` | ⭐⭐⭐ |
| **依賴注入** | 處理依賴關係 | `@Autowired` | ⭐⭐⭐ |
| **Web 註解** | API 開發 | `@RequestMapping`、`@GetMapping`、`@PostMapping` | ⭐⭐⭐ |
| **配置註解** | 配置管理 | `@Value`、`@ConfigurationProperties` | ⭐⭐ |

---

## 1.3.2 核心啟動註解

### @SpringBootApplication

這是 Spring Boot 最重要的註解，它是一個**組合註解**：

```java
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

**@SpringBootApplication 等同於**：
```java
@SpringBootConfiguration  // 等同於 @Configuration
@EnableAutoConfiguration  // 啟用自動配置
@ComponentScan           // 啟用組件掃描
public class DemoApplication {
    // ...
}
```

**核心功能**：
- **自動配置**：根據 classpath 自動配置 Spring 應用
- **組件掃描**：自動掃描並註冊 Spring 組件
- **配置類別**：將主類別標記為配置類別

---

## 1.3.3 組件註解

### @Component 系列註解

**基礎組件註解**：
```java
// 通用組件
@Component
public class DataProcessor {
    public String process(String data) {
        return "Processed: " + data;
    }
}
```

**專用組件註解**：

**1. @Service - 業務邏輯層**
```java
@Service
public class UserService {
    
    public List<User> getAllUsers() {
        // 業務邏輯實現
        return Arrays.asList(
            new User(1L, "Alice", "alice@example.com"),
            new User(2L, "Bob", "bob@example.com")
        );
    }
    
    public User createUser(String name, String email) {
        // 建立使用者的業務邏輯
        return new User(System.currentTimeMillis(), name, email);
    }
}
```

**2. @RestController - API 控制器**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    // 構造函數注入（推薦方式）
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    @GetMapping
    public List<User> getUsers() {
        return userService.getAllUsers();
    }
    
    @PostMapping
    public User createUser(@RequestBody CreateUserRequest request) {
        return userService.createUser(request.getName(), request.getEmail());
    }
}
```

**3. @Repository - 資料存取層**
```java
@Repository
public class UserRepository {
    
    private final List<User> users = new ArrayList<>();
    
    public List<User> findAll() {
        return new ArrayList<>(users);
    }
    
    public User save(User user) {
        users.add(user);
        return user;
    }
    
    public Optional<User> findById(Long id) {
        return users.stream()
                .filter(user -> user.getId().equals(id))
                .findFirst();
    }
}
```

---

## 1.3.4 依賴注入

### 為什麼需要依賴注入？

**沒有依賴注入的問題**：
```java
// ❌ 緊密耦合的程式碼
public class UserController {
    private UserService userService = new UserService(); // 硬編碼依賴
    
    // 難以測試、難以擴展
}
```

**使用依賴注入的優勢**：
```java
// ✅ 鬆散耦合的程式碼
@RestController
public class UserController {
    private final UserService userService;
    
    // Spring 自動注入依賴
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    // 易於測試、易於擴展
}
```

### 依賴注入方式

**1. 構造函數注入（推薦）**
```java
@RestController
public class UserController {
    
    private final UserService userService;
    private final EmailService emailService;
    
    // 構造函數注入 - 推薦方式
    public UserController(UserService userService, EmailService emailService) {
        this.userService = userService;
        this.emailService = emailService;
    }
}
```

**優勢**：
- 確保依賴不為 null
- 支援 final 欄位
- 便於單元測試
- 明確表達依賴關係

**2. @Autowired 欄位注入**
```java
@RestController
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private EmailService emailService;
    
    // 簡潔但不推薦用於生產環境
}
```

**3. Setter 注入**
```java
@RestController
public class UserController {
    
    private UserService userService;
    
    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
}
```

---

## 1.3.5 Web 開發核心註解

### HTTP 方法註解

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    // GET 請求 - 獲取所有使用者
    @GetMapping
    public List<User> getAllUsers() {
        return userService.getAllUsers();
    }
    
    // GET 請求 - 根據 ID 獲取使用者
    @GetMapping("/{id}")
    public User getUserById(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    // POST 請求 - 建立新使用者
    @PostMapping
    public User createUser(@RequestBody CreateUserRequest request) {
        return userService.createUser(request);
    }
    
    // PUT 請求 - 更新使用者
    @PutMapping("/{id}")
    public User updateUser(@PathVariable Long id, @RequestBody UpdateUserRequest request) {
        return userService.updateUser(id, request);
    }
    
    // DELETE 請求 - 刪除使用者
    @DeleteMapping("/{id}")
    public void deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
    }
}
```

### 參數綁定註解

```java
@RestController
@RequestMapping("/api/search")
public class SearchController {
    
    // 路徑變數
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    // 查詢參數
    @GetMapping("/users")
    public List<User> searchUsers(
            @RequestParam(required = false) String name,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        return userService.search(name, page, size);
    }
    
    // 請求體
    @PostMapping("/users")
    public User createUser(@RequestBody CreateUserRequest request) {
        return userService.createUser(request);
    }
    
    // 請求標頭
    @GetMapping("/profile")
    public User getCurrentUser(@RequestHeader("Authorization") String token) {
        return userService.findByToken(token);
    }
}
```

---

## 1.3.6 配置相關註解

### @Value - 屬性注入

```java
@Service
public class ConfigService {
    
    @Value("${app.name:Default App}")
    private String appName;
    
    @Value("${app.version:1.0.0}")
    private String appVersion;
    
    @Value("${app.max-users:100}")
    private int maxUsers;
    
    public String getAppInfo() {
        return String.format("%s v%s (Max Users: %d)", appName, appVersion, maxUsers);
    }
}
```

### @ConfigurationProperties - 類型安全配置

```java
@ConfigurationProperties(prefix = "app")
@Component
public class AppProperties {
    
    private String name = "Default App";
    private String version = "1.0.0";
    private int maxUsers = 100;
    private Database database = new Database();
    
    // Getters and Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getVersion() { return version; }
    public void setVersion(String version) { this.version = version; }
    
    public int getMaxUsers() { return maxUsers; }
    public void setMaxUsers(int maxUsers) { this.maxUsers = maxUsers; }
    
    public Database getDatabase() { return database; }
    public void setDatabase(Database database) { this.database = database; }
    
    public static class Database {
        private String url = "jdbc:h2:mem:testdb";
        private String username = "sa";
        private String password = "";
        
        // Getters and Setters
        public String getUrl() { return url; }
        public void setUrl(String url) { this.url = url; }
        
        public String getUsername() { return username; }
        public void setUsername(String username) { this.username = username; }
        
        public String getPassword() { return password; }
        public void setPassword(String password) { this.password = password; }
    }
}
```

**對應的 application.yml**：
```yaml
app:
  name: Spring Boot Demo
  version: 2.0.0
  max-users: 500
  database:
    url: jdbc:mysql://localhost:3306/demo
    username: demo_user
    password: demo_pass
```

---

## 1.3.7 為 Spring AI 做準備

### AI 服務的註解模式

```java
// AI 服務層
@Service
public class AIService {
    
    @Value("${ai.openai.api-key}")
    private String apiKey;
    
    @Value("${ai.openai.model:gpt-3.5-turbo}")
    private String model;
    
    public String chat(String message) {
        // 預留給 Spring AI 整合
        return "AI Response: " + message;
    }
}

// AI 控制器
@RestController
@RequestMapping("/api/ai")
public class AIController {
    
    private final AIService aiService;
    
    public AIController(AIService aiService) {
        this.aiService = aiService;
    }
    
    @PostMapping("/chat")
    public ResponseEntity<String> chat(@RequestBody ChatRequest request) {
        String response = aiService.chat(request.getMessage());
        return ResponseEntity.ok(response);
    }
}

// AI 配置類別
@ConfigurationProperties(prefix = "ai")
@Component
public class AIProperties {
    
    private OpenAI openai = new OpenAI();
    
    public OpenAI getOpenai() { return openai; }
    public void setOpenai(OpenAI openai) { this.openai = openai; }
    
    public static class OpenAI {
        private String apiKey;
        private String model = "gpt-3.5-turbo";
        private int maxTokens = 1000;
        private double temperature = 0.7;
        
        // Getters and Setters
    }
}
```

### 實用的註解組合

```java
// 完整的 AI 應用範例
@RestController
@RequestMapping("/api/ai")
public class AIApplicationController {
    
    private final AIService aiService;
    private final UserService userService;
    
    // 構造函數注入多個服務
    public AIApplicationController(AIService aiService, UserService userService) {
        this.aiService = aiService;
        this.userService = userService;
    }
    
    @PostMapping("/analyze")
    public ResponseEntity<AnalysisResult> analyzeUserData(
            @PathVariable Long userId,
            @RequestBody AnalysisRequest request,
            @RequestHeader("Authorization") String token) {
        
        // 驗證使用者
        User user = userService.findById(userId);
        
        // AI 分析
        AnalysisResult result = aiService.analyze(user, request);
        
        return ResponseEntity.ok(result);
    }
}
```

---

## 📝 本章重點回顧

1. **核心註解掌握**：學會了 @SpringBootApplication、@RestController、@Service 等基礎註解
2. **依賴注入理解**：掌握了構造函數注入和 @Autowired 的使用方法
3. **Web 開發註解**：熟悉了 HTTP 方法註解和參數綁定註解
4. **配置管理**：學會了使用 @Value 和 @ConfigurationProperties 管理配置
5. **AI 整合準備**：為 Spring AI 應用開發建立了註解使用基礎

### 下一步學習方向

在下一章中，我們將建立第一個完整的 Spring Boot 應用，實際運用這些註解來開發一個使用者管理系統。

---

**參考資料：**
- [Spring Boot Annotations](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.auto-configuration)
- [Spring Framework Core](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html)
- [Dependency Injection](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies)


\newpage

## 1.7 第一支 Spring Boot 程式 - 使用者管理系統


![Spring Boot User Management](https://ithelp.ithome.com.tw/upload/images/20240801/20161290FirstSpringBootApp.jpg)

在前面的章節中，我們已經了解了 Spring Boot 的基本概念、專案架構和常用註解。現在讓我們來建立第一支完整的 Spring Boot 程式，實作一個使用者管理系統，展示 DTO 模式、資料驗證和 API 安全性的最佳實踐。

## 🎯 學習目標

完成本章學習後，您將能夠：

1. **建立完整的 Spring Boot 應用程式** - 從零開始建立可執行的專案
2. **實作 RESTful API** - 提供完整的 CRUD 操作端點
3. **使用 DTO 模式** - 控制資料輸入輸出，保護機密資料
4. **實作資料驗證** - 使用 Bean Validation 確保資料品質
5. **展示安全性考量** - Response DTO 不包含敏感資料

## 建立使用者管理專案

### 1. 使用 STS4 建立 Spring Boot 專案

#### 方法一：使用 STS4 內建的 Spring Starter Project

1. **開啟 STS4**，選擇 `File` → `New` → `Spring Starter Project`
2. **專案設定**：
   - **Name**: user-management-system
   - **Group**: com.example.demo
   - **Artifact**: user-management-system
   - **Package**: com.example.demo
   - **Java Version**: 17 或 21
   - **Packaging**: Jar
3. **選擇依賴**：
   - **Web** → Spring Web
   - **I/O** → Validation
   - **Developer Tools** → Lombok
4. **完成建立**，STS4 會自動下載依賴並建立專案結構

#### 方法二：使用 Spring Initializr 網站

訪問 [https://start.spring.io/](https://start.spring.io/) 並設定：

**專案設定：**
- **Project**: Maven
- **Language**: Java
- **Spring Boot**: 3.2.x (最新穩定版)
- **Group**: com.example.demo
- **Artifact**: user-management-system
- **Dependencies**: Spring Web, Validation, Lombok

```xml
<!-- pom.xml 主要依賴 -->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

### 2. 專案結構

建立完成後的專案結構如下：

```
user-management-system/
├── src/
│   └── main/
│       └── java/
│           └── com/example/demo/
│               ├── DemoApplication.java
│               ├── controller/
│               │   └── UserController.java
│               ├── service/
│               │   ├── UserService.java
│               │   └── UserServiceImpl.java
│               ├── model/
│               │   └── User.java
│               ├── request/
│               │   └── CreateUserRequest.java
│               └── response/
│                   └── UserResponse.java
│       └── resources/
│           └── application.yml
├── pom.xml
└── README.md
```

### 3. 主程式類別

```java
/**
 * Spring Boot 主程式類別
 * 使用者管理系統的入口點
 * @author Kevin Tsai
 * @version 1.0
 * @since 2024-01-01
 */
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
        System.out.println("🚀 使用者管理系統已啟動！");
        System.out.println("📖 API 文件: http://localhost:8080/api/users");
    }
}
```

## 核心程式碼實作

### 4. 資料模型（User）

```java
/**
 * 使用者實體類別
 * 使用 Lombok @Data 註解自動生成 getter/setter 方法
 * 包含完整的使用者資訊，包括機密的密碼欄位
 */
package com.example.demo.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private Long id;
    private String name;
    private String email;
    private String password;  // 機密資料，不應在 API 回應中暴露
    
    // 自訂建構函式（不包含 id）
    public User(String name, String email, String password) {
        this.name = name;
        this.email = email;
        this.password = password;
    }
}
```

### 5. 資料傳輸物件（DTO）

#### CreateUserRequest - 建立使用者請求 DTO

```java
/**
 * 建立使用者請求 DTO
 * 使用 Lombok @Data 註解自動生成 getter/setter 方法
 * 包含完整的資料驗證註解，確保輸入資料的品質
 */
package com.example.demo.request;

import lombok.Data;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

@Data
public class CreateUserRequest {
    
    @NotBlank(message = "姓名不能為空")
    @Size(min = 2, max = 50, message = "姓名長度必須在 2-50 字元之間")
    private String name;
    
    @Email(message = "電子郵件格式不正確")
    @NotBlank(message = "電子郵件不能為空")
    private String email;
    
    @NotBlank(message = "密碼不能為空")
    @Size(min = 6, max = 20, message = "密碼長度必須在 6-20 字元之間")
    private String password;
}
```

#### UserResponse - 使用者回應 DTO

```java
/**
 * 使用者回應 DTO
 * 使用 Lombok @Data 註解自動生成 getter/setter 方法
 * 重要：不包含 password 欄位，保護機密資料不被外洩
 */
package com.example.demo.response;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserResponse {
    private Long id;
    private String name;
    private String email;
    // 注意：刻意不包含 password 欄位，確保機密資料安全
}
```

### 6. 業務邏輯層（Service）

#### 服務介面定義
```java
/**
 * 使用者服務介面
 * 定義使用者管理的核心業務邏輯
 */
package com.example.demo.service;

import com.example.demo.request.CreateUserRequest;
import com.example.demo.response.UserResponse;
import java.util.List;

public interface UserService {
    List<UserResponse> findAllUsers();
    UserResponse findUserById(Long id);
    UserResponse createUser(CreateUserRequest request);
    UserResponse updateUser(Long id, CreateUserRequest request);
    void deleteUser(Long id);
}
```

#### UserServiceImpl 實作

```java
/**
 * 使用者服務實作
 * 使用記憶體儲存模擬資料庫操作
 */
package com.example.demo.service;

import com.example.demo.request.CreateUserRequest;
import com.example.demo.response.UserResponse;
import com.example.demo.model.User;
import org.springframework.stereotype.Service;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class UserServiceImpl implements UserService {
    
    // 使用記憶體中的資料模擬資料庫
    private final List<User> users = new ArrayList<>();
    private Long nextId = 1L;
    
    // 初始化一些測試資料
    public UserServiceImpl() {
        users.add(new User("張小明", "ming@example.com", "password123"));
        users.add(new User("李小華", "hua@example.com", "secret456"));
        users.get(0).setId(nextId++);
        users.get(1).setId(nextId++);
    }
    
    @Override
    public List<UserResponse> findAllUsers() {
        return users.stream()
            .map(this::convertToResponse)
            .collect(Collectors.toList());
    }
    
    @Override
    public UserResponse findUserById(Long id) {
        User user = users.stream()
            .filter(u -> u.getId().equals(id))
            .findFirst()
            .orElse(null);
        
        return user != null ? convertToResponse(user) : null;
    }
    
    @Override
    public UserResponse createUser(CreateUserRequest request) {
        User user = new User(request.getName(), request.getEmail(), request.getPassword());
        user.setId(nextId++);
        users.add(user);
        return convertToResponse(user);
    }
    
    @Override
    public UserResponse updateUser(Long id, CreateUserRequest request) {
        User existingUser = users.stream()
            .filter(u -> u.getId().equals(id))
            .findFirst()
            .orElse(null);
        
        if (existingUser != null) {
            existingUser.setName(request.getName());
            existingUser.setEmail(request.getEmail());
            existingUser.setPassword(request.getPassword());
            return convertToResponse(existingUser);
        }
        return null;
    }
    
    @Override
    public void deleteUser(Long id) {
        users.removeIf(user -> user.getId().equals(id));
    }
    
    /**
     * 私有方法：將 User 轉換為 UserResponse
     * 重要：這裡不包含 password 欄位，確保機密資料不外洩
     */
    private UserResponse convertToResponse(User user) {
        return new UserResponse(user.getId(), user.getName(), user.getEmail());
    }
}
```

### 7. 控制器層（Controller）

```java
/**
 * 使用者控制器
 * 提供完整的 RESTful API 端點
 * 展示 DTO 模式和資料驗證的最佳實踐
 */
package com.example.demo.controller;

import com.example.demo.request.CreateUserRequest;
import com.example.demo.response.UserResponse;
import com.example.demo.service.UserService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    // 建構函式注入
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    /**
     * 獲取所有使用者
     * GET /api/users
     */
    @GetMapping
    public ResponseEntity<List<UserResponse>> getAllUsers() {
        List<UserResponse> users = userService.findAllUsers();
        return ResponseEntity.ok(users);
    }
    
    /**
     * 根據 ID 獲取使用者
     * GET /api/users/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<UserResponse> getUserById(@PathVariable Long id) {
        UserResponse user = userService.findUserById(id);
        if (user != null) {
            return ResponseEntity.ok(user);
        }
        return ResponseEntity.notFound().build();
    }
    
    /**
     * 建立新使用者
     * POST /api/users
     * 使用 @Valid 啟用自動驗證
     */
    @PostMapping
    public ResponseEntity<UserResponse> createUser(@Valid @RequestBody CreateUserRequest request) {
        UserResponse user = userService.createUser(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }
    
    /**
     * 更新使用者
     * PUT /api/users/{id}
     */
    @PutMapping("/{id}")
    public ResponseEntity<UserResponse> updateUser(
            @PathVariable Long id, 
            @Valid @RequestBody CreateUserRequest request) {
        UserResponse user = userService.updateUser(id, request);
        if (user != null) {
            return ResponseEntity.ok(user);
        }
        return ResponseEntity.notFound().build();
    }
    
    /**
     * 刪除使用者
     * DELETE /api/users/{id}
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
```

## 設定檔案

### application.yml

```yaml
# 伺服器設定
server:
  port: 8080
  servlet:
    context-path: /

# Spring Boot 應用程式設定
spring:
  application:
    name: User Management System
  mvc:
    throw-exception-if-no-handler-found: true
  web:
    resources:
      add-mappings: false

# 日誌設定
logging:
  level:
    com.example.demo: DEBUG
    org.springframework.web: INFO
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"

# 應用程式資訊
management:
  info:
    env:
      enabled: true

info:
  app:
    name: User Management System
    description: 使用者管理系統 - 展示 DTO 模式和 API 安全性
    version: 1.0.0
```

## 執行應用程式

### 使用 STS4 執行
1. 在 STS4 中找到 `DemoApplication.java`
2. 右鍵點擊 → `Run As` → `Java Application`
3. 或者點擊主程式類別，按 `Ctrl + F11` 快速執行

### 簡易 API 測試

應用程式啟動後，可以使用 curl 命令測試 API 端點：

#### 獲取所有使用者
```bash
curl -X GET http://localhost:8080/api/users
```

#### 建立新使用者
```bash
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "user1",
    "email": "test@example.com",
    "password": "password123"
  }'
```

#### 根據 ID 獲取使用者
```bash
curl -X GET http://localhost:8080/api/users/1
```

💡 **重點提示**：注意 API 回應中不包含 `password` 欄位，展示了 DTO 模式的安全性設計。

## 應用程式啟動日誌

當應用程式成功啟動時，會看到類似以下的日誌輸出：

```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.2.0)

2024-01-15 10:30:00 [main] INFO  c.e.demo.DemoApplication - Starting DemoApplication using Java 17
2024-01-15 10:30:01 [main] INFO  o.s.b.w.embedded.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2024-01-15 10:30:01 [main] INFO  c.e.demo.DemoApplication - Started DemoApplication in 2.345 seconds
🚀 使用者管理系統已啟動！
📖 API 文件: http://localhost:8080/api/users
```

## 🔐 DTO 模式的安全性展示

### 分層架構流程圖

```
┌─────────────────────────────────────────────────────────────┐
│                    Web Service Layer                        │
│  ┌─────────────────┐ DTO ┌─────────────────┐              │
│  │   HTTP Request  │────▶│ CreateUserRequest│              │
│  │ {               │     │ + name: String  │              │
│  │   "name": "...",│     │ + email: String │              │
│  │   "email":"...",│     │ + password: Str │              │
│  │   "password":".."│     │ + @Valid 驗證    │              │
│  │ }               │     └─────────────────┘              │
│  └─────────────────┘                                      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Service Layer                            │
│  ┌─────────────────┐     ┌─────────────────┐              │
│  │   Controller    │     │    Service      │              │
│  │ @RestController │     │ @Service        │              │
│  │ @PostMapping    │────▶│ 業務邏輯處理      │              │
│  │ @Valid 驗證      │     │ 資料轉換         │              │
│  │ 請求處理         │     │ CRUD 操作       │              │
│  └─────────────────┘     └─────────────────┘              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Business Layer                           │
│  ┌─────────────────┐     ┌─────────────────┐              │
│  │  Business Logic │     │  Data Transform │              │
│  │                 │     │                 │              │
│  │ • 資料驗證       │     │ • DTO ↔ Model   │              │
│  │ • 業務規則       │────▶│ • 資料映射       │              │
│  │ • 流程控制       │     │ • 格式轉換       │              │
│  └─────────────────┘     └─────────────────┘              │
└─────────────────────────────────────────────────────────────┘
                              │ PO
                              ▼
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
│                         Model                               │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │                  Persistence Layer                      │ │
│ │  ┌─────────────────┐     ┌─────────────────┐          │ │
│ │  │   User Model    │     │  Memory Store   │          │ │
│ │  │ + id: Long      │────▶│ List<User>      │          │ │
│ │  │ + name: String  │     │ 記憶體模擬資料庫   │          │ │
│ │  │ + email: String │     │ 完整 User 物件   │          │ │
│ │  │ + password: Str │     │ 包含 password    │          │ │
│ │  └─────────────────┘     └─────────────────┘          │ │
│ └─────────────────────────────────────────────────────────┘ │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │                    Database Layer                       │ │
│ │  ┌─────────────────┐     ┌─────────────────┐          │ │
│ │  │   Data Access   │     │   Data Storage  │          │ │
│ │  │                 │     │                 │          │ │
│ │  │ • CRUD 操作     │────▶│ • 記憶體儲存     │          │ │
│ │  │ • 資料查詢       │     │ • 資料持久化     │          │ │
│ │  │ • 事務管理       │     │ • 資料完整性     │          │ │
│ │  └─────────────────┘     └─────────────────┘          │ │
│ └─────────────────────────────────────────────────────────┘ │
└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Response Flow                            │
│  ┌─────────────────┐     ┌─────────────────┐              │
│  │  UserResponse   │     │  HTTP Response  │              │
│  │ + id: Long      │────▶│ {               │              │
│  │ + name: String  │     │   "id": 1,      │              │
│  │ + email: String │     │   "name": "...",│              │
│  │ ❌ 無 password   │     │   "email":"..." │              │
│  └─────────────────┘     │ }               │              │
│                          └─────────────────┘              │
└─────────────────────────────────────────────────────────────┘
```

### 物件關聯架構圖

```
┌─────────────────────────────────────────────────────────────┐
│                   Web Service Layer                         │
│                                                             │
│  HTTP Request ──DTO──▶ CreateUserRequest                   │
│       │                      │                             │
│       │                      │ @Valid                      │
│       ▼                      ▼                             │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                    Service Layer                            │
│                                                             │
│  Controller ──────────────▶ Service                        │
│  @RestController            @Service                        │
│  • @PostMapping            • 業務邏輯                        │
│  • @Valid                  • 資料轉換                        │
│  • 請求路由                 • CRUD 操作                      │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                   Business Layer                            │
│                                                             │
│  Business Logic ──────────▶ Data Transform                 │
│  • 資料驗證                  • DTO ↔ Model                   │
│  • 業務規則                  • 資料映射                      │
│  • 流程控制                  • 格式轉換                      │
└─────────────────────────────────────────────────────────────┘
                               │ PO (Persistent Object)
                               ▼
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
│                          Model                              │
│                                                             │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │                 Persistence Layer                       │ │
│ │                                                         │ │
│ │  User Model ──────────────▶ Memory Store               │ │
│ │  • id: Long                 • List<User>               │ │
│ │  • name: String             • 記憶體模擬資料庫            │ │
│ │  • email: String            • 完整 User 物件            │ │
│ │  • password: String         • 包含 password             │ │
│ └─────────────────────────────────────────────────────────┘ │
│                               │                             │
│                               ▼                             │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │                  Database Layer                         │ │
│ │                                                         │ │
│ │  Data Access ──────────────▶ Data Storage              │ │
│ │  • CRUD 操作                • 記憶體儲存                 │ │
│ │  • 資料查詢                  • 資料持久化                 │ │
│ │  • 事務管理                  • 資料完整性                 │ │
│ └─────────────────────────────────────────────────────────┘ │
└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                    Response Flow                            │
│                                                             │
│  UserResponse ──────────────▶ HTTP Response                │
│  • id: Long                   • JSON 格式                   │
│  • name: String               • 安全資料                    │
│  • email: String              • 無機密欄位                  │
│  ❌ 無 password                                             │
└─────────────────────────────────────────────────────────────┘
```

**🏗️ 架構層級說明：**

1. **Web Service Layer**：處理 HTTP 請求和 DTO 轉換
2. **Service Layer**：包含 Controller 和 Service 組件
3. **Business Layer**：業務邏輯處理和資料轉換
4. **Model**（虛線框）：包含 Persistence Layer 和 Database Layer
   - **Persistence Layer**：資料模型和記憶體儲存
   - **Database Layer**：資料存取和儲存管理

**📊 資料物件對應：**
- **VO (Value Object)**：CreateUserRequest、UserResponse
- **DTO (Data Transfer Object)**：在各層間傳遞的資料物件
- **PO (Persistent Object)**：User Model（用於資料持久化）
- **Component**：Controller、Service（業務組件）
- **BO (Business Object)**：Business Logic、Data Transform
- **DAO (Data Access Object)**：Data Access（資料存取邏輯）

### 資料流程說明

1. **輸入階段（CreateUserRequest）**：
   - 客戶端發送包含 `name`、`email`、`password` 的完整資料
   - Bean Validation 自動驗證資料格式和長度
   - 密碼等機密資料在此階段是必要的

2. **處理階段（User 模型）**：
   - Service 層使用完整的 User 模型進行業務邏輯處理
   - 密碼儲存在記憶體中（實際應用中會加密儲存）

3. **輸出階段（UserResponse）**：
   - **關鍵安全特性**：Response DTO 刻意不包含 `password` 欄位
   - 確保機密資料不會透過 API 回應外洩
   - 客戶端只能看到安全的公開資訊

### 安全性對比

| 階段 | 包含密碼 | 用途 | 安全考量 |
|------|----------|------|----------|
| **CreateUserRequest** | ✅ 是 | 接收輸入資料 | 需要密碼進行帳戶建立 |
| **User 模型** | ✅ 是 | 內部資料處理 | 完整資料用於業務邏輯 |
| **UserResponse** | ❌ 否 | API 回應 | **保護機密資料不外洩** |

## 關鍵技術說明

### 1. @SpringBootApplication 註解

這是 Spring Boot 的核心註解，它包含了：
- `@Configuration` - 標示這是一個配置類別
- `@EnableAutoConfiguration` - 啟用自動配置
- `@ComponentScan` - 啟用元件掃描

### 2. @RestController 註解

結合了 `@Controller` 和 `@ResponseBody`，用於建立 RESTful Web 服務。

### 3. @Valid 註解

啟用 Bean Validation，自動驗證請求資料的格式和約束條件。

### 4. ResponseEntity 類別

提供完整的 HTTP 回應控制，包括狀態碼、標頭和回應體。

### 5. DTO 模式的優勢

- **資料驗證**：Request DTO 確保輸入資料品質
- **安全性**：Response DTO 保護機密資料
- **版本控制**：API 介面與內部模型分離
- **文件化**：清楚定義 API 的輸入輸出格式



## 📝 學習重點總結

透過這個完整的使用者管理系統範例，我們學會了：

### 核心技能
1. **建立完整的 Spring Boot 應用程式** - 從專案結構到執行部署
2. **實作三層架構** - Model、Service、Controller 的職責分離
3. **使用 DTO 模式** - 控制資料流向，提升 API 安全性
4. **實作資料驗證** - 使用 Bean Validation 確保資料品質
5. **RESTful API 設計** - 提供完整的 CRUD 操作端點

### 安全性最佳實踐
- ✅ **輸入驗證**：使用 `@Valid` 和驗證註解
- ✅ **資料保護**：Response DTO 不包含機密欄位
- ✅ **錯誤處理**：適當的 HTTP 狀態碼和錯誤訊息
- ✅ **API 設計**：清晰的端點命名和 RESTful 原則

### 開發效率提升
- 🚀 **自動配置**：Spring Boot 的約定優於配置
- 🚀 **依賴注入**：建構函式注入確保依賴不可變
- 🚀 **分層架構**：清晰的程式碼組織和職責分離
- 🚀 **測試友善**：記憶體資料儲存便於開發和測試

## 下一步學習方向

1. **資料庫整合** - 學習 Spring Data JPA
2. **安全性** - 實作 Spring Security
3. **測試** - 單元測試和整合測試
4. **部署** - Docker 容器化和雲端部署

這個範例展示了現代 Spring Boot 應用程式開發的最佳實踐，為後續的進階學習奠定了堅實的基礎。

---

**參考資料：**
- [Spring Boot Reference Guide](https://docs.spring.io/spring-boot/docs/current/reference/html/)
- [Spring Boot Starter Web](https://docs.spring.io/spring-boot/docs/current/reference/html/web.html)
- [Bean Validation Specification](https://beanvalidation.org/)
- [RESTful API Design Best Practices](https://restfulapi.net/)


\newpage


# 第二章：Spring MVC 與 API 開發 {.unnumbered .unlisted}


## 2.1 Spring MVC API 開發基礎


> **第二章導讀**：本章將帶您掌握 Spring MVC 在現代 API 開發中的核心技術，從基礎架構到實際應用，為 Spring AI 整合奠定堅實基礎。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解現代化 API 架構**：掌握從傳統 MVC 到 API 優先架構的演進脈絡
- 🎯 **精通 Spring MVC 開發**：熟練運用 Spring MVC 進行現代化 API 開發
- 🎯 **區分控制器註解差異**：深入了解 @RestController 與 @Controller 的本質區別
- 🎯 **掌握 JSON 自動處理機制**：理解 Spring MVC 如何自動處理 JSON 序列化和反序列化
- 🎯 **為 Spring AI 做準備**：建立適合 AI 服務整合的 API 架構基礎

---

## 2.1.1 現代化 API 架構概述

### 為什麼需要現代化 API 架構？

在數位轉型的浪潮中，傳統的單體應用架構已無法滿足現代業務需求。特別是在 AI 應用興起的今天，我們需要更靈活、可擴展的架構來支援複雜的 AI 服務整合。

**傳統架構的局限**：
- 前後端緊密耦合，開發效率受限
- 單一技術棧，無法採用最適合的技術
- 擴展性差，難以應對 AI 服務的高併發需求
- 維護成本高，系統複雜度隨業務增長而急劇上升

**現代化需求驅動**：
- 📱 **多端統一**：Web、手機 App、小程式、IoT 設備等多平台支援
- 🔗 **系統整合**：與第三方服務、微服務、雲端平台的無縫整合
- ⚡ **敏捷開發**：前後端團隊並行開發，縮短產品上市時間
- 🤖 **AI 就緒**：支援 AI 服務的特殊需求，如流式處理、大資料分析

### 現代化 API 架構的核心價值

**前後端分離**：
- 技術棧獨立選擇，前端可採用 React、Vue 等現代框架
- 開發團隊並行作業，提升整體開發效率
- 部署策略靈活，支援獨立擴展和版本管理

**API 優先設計**：
- 統一的資料介面，支援多種客戶端
- 標準化的通訊協定，降低整合成本
- 可重用的服務組件，提升開發效率

---

## 2.1.2 Spring MVC 在現代 API 開發中的定位

### 為什麼選擇 Spring MVC？

Spring MVC 作為 Java 生態系統中最成熟的 Web 框架，在現代 API 開發中扮演著關鍵角色，特別適合作為 Spring AI 應用的基礎架構：

**技術成熟度**：
- 經過十多年的發展和驗證，技術穩定可靠
- 豐富的社群資源和最佳實踐經驗
- 完整的生態系統支援，涵蓋安全、測試、監控等各個面向

**企業級特性**：
- 強大的依賴注入和 AOP 支援
- 完善的事務管理和資料存取抽象
- 內建安全框架整合，滿足企業安全需求

**AI 整合友好**：
- 支援異步處理，適合 AI 服務的長時間運算
- 靈活的資料格式處理，支援 AI 所需的多媒體內容
- 強大的攔截器機制，便於實現 AI 服務的監控和日誌

---

## 2.1.3 傳統 Web 開發 vs API 開發

讓我們先了解傳統 Web 開發與現代 API 開發的根本差異：

| 特性 | 傳統 Web 開發 | 現代 API 開發 |
|------|---------------|---------------|
| **回應格式** | HTML 頁面 | JSON/XML 資料 |
| **客戶端** | 瀏覽器 | 多種客戶端（Web、Mobile、AI） |
| **狀態管理** | 有狀態（Session） | 無狀態（Stateless） |
| **資料傳輸** | 表單提交 | JSON/XML 負載 |
| **錯誤處理** | 錯誤頁面 | 結構化錯誤回應 |
| **AI 支援** | 不適合 | 天然支援 AI 服務整合 |

---

## 2.1.4 Spring MVC 核心架構

### DispatcherServlet：API 請求的統一入口

在 API 開發中，DispatcherServlet 扮演著前端控制器的角色，負責接收所有 HTTP 請求並進行統一分發。

**DispatcherServlet 的核心功能**：
1. **請求接收**：接收所有進入應用程式的 HTTP 請求
2. **路由分發**：根據請求資訊找到對應的處理器
3. **結果處理**：處理控制器的執行結果並生成回應
4. **異常處理**：統一處理請求處理過程中的異常

### @RestController vs @Controller：API 開發的關鍵差異

這是 Spring MVC API 開發中最重要的概念之一：

| 特性 | @Controller | @RestController |
|------|-------------|------------------|
| **組成** | 單一註解 | `@Controller` + `@ResponseBody` |
| **回應類型** | 視圖名稱 | 直接資料 |
| **序列化** | 需手動處理 | 自動 JSON 序列化 |
| **適用場景** | 傳統 Web 應用 | RESTful API |
| **AI 整合** | 不適合 | 完美支援 |

**範例：基本 API 控制器**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    /**
     * 獲取使用者列表
     */
    @GetMapping
    public List<User> getUsers() {
        return userService.findAll();
    }
    
    /**
     * 根據 ID 獲取使用者
     */
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    /**
     * 建立新使用者
     */
    @PostMapping
    public User createUser(@RequestBody User user) {
        return userService.save(user);
    }
}
```

💡 **重點提示**：使用 `@RestController` 後，所有方法的返回值都會自動轉換為 JSON 格式，無需額外配置。

---

## 2.1.5 JSON 自動處理機制

### Spring MVC 的 JSON 序列化

Spring MVC 內建了強大的 JSON 處理機制，透過 Jackson 函式庫實現自動序列化和反序列化：

**自動序列化**：
- 控制器方法返回的 Java 物件自動轉換為 JSON
- 支援複雜的物件結構，包括巢狀物件和集合
- 可透過註解客製化序列化行為

**自動反序列化**：
- HTTP 請求體中的 JSON 自動轉換為 Java 物件
- 支援資料驗證和型別轉換
- 提供詳細的錯誤訊息

**範例：JSON 處理**
```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    /**
     * 接收 JSON 資料並自動轉換為 Product 物件
     */
    @PostMapping
    public Product createProduct(@RequestBody Product product) {
        // Spring MVC 自動將 JSON 轉換為 Product 物件
        return productService.save(product);
        // 返回的 Product 物件自動轉換為 JSON
    }
    
    /**
     * 返回複雜的 JSON 結構
     */
    @GetMapping("/summary")
    public Map<String, Object> getProductSummary() {
        Map<String, Object> summary = new HashMap<>();
        summary.put("totalProducts", productService.count());
        summary.put("categories", productService.getCategories());
        summary.put("topProducts", productService.getTopProducts());
        return summary; // 自動轉換為 JSON
    }
}
```

---

## 2.1.6 為 Spring AI 做準備

### AI 服務的特殊需求

在設計 API 架構時，我們需要考慮 Spring AI 的特殊需求：

**流式處理支援**：
- AI 對話服務通常需要流式回應
- 支援 Server-Sent Events (SSE)
- 異步處理長時間運算

**多媒體內容處理**：
- 支援圖片、音訊、影片等多媒體輸入
- 大型檔案上傳和處理
- 內容類型的自動識別

**錯誤處理和重試機制**：
- AI 服務可能出現暫時性錯誤
- 需要智能重試和降級策略
- 提供詳細的錯誤診斷資訊

### 架構設計考量

**可擴展性**：
```java
@RestController
@RequestMapping("/api/ai")
public class AIController {
    
    /**
     * 為未來的 AI 服務預留介面
     */
    @PostMapping("/chat")
    public ResponseEntity<String> chat(@RequestBody ChatRequest request) {
        // 預留給 Spring AI 整合
        return ResponseEntity.ok("準備整合 Spring AI");
    }
}
```

**異步處理準備**：
```java
@RestController
@RequestMapping("/api/async")
public class AsyncController {
    
    /**
     * 異步處理範例，適合 AI 長時間運算
     */
    @PostMapping("/process")
    public CompletableFuture<ProcessResult> processAsync(@RequestBody ProcessRequest request) {
        return CompletableFuture.supplyAsync(() -> {
            // 模擬長時間處理
            return new ProcessResult("處理完成");
        });
    }
}
```

---

## 📝 本章重點回顧

1. **現代化 API 架構**：理解了從傳統 MVC 到 API 優先架構的演進
2. **Spring MVC 優勢**：掌握了 Spring MVC 在 API 開發中的核心價值
3. **@RestController**：學會了使用 @RestController 建立 RESTful API
4. **JSON 處理**：理解了 Spring MVC 的自動 JSON 序列化機制
5. **AI 整合準備**：為後續 Spring AI 整合奠定了架構基礎

### 下一步學習方向

在下一章中，我們將學習 RESTful API 的設計原則和最佳實踐，進一步提升 API 的設計品質，為 Spring AI 的複雜應用場景做好準備。

---

**參考資料：**
- [Spring MVC Reference Guide](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html)
- [Spring Boot Web Development](https://docs.spring.io/spring-boot/docs/current/reference/html/web.html)
- [RESTful API Design Best Practices](https://restfulapi.net/)


\newpage

## 2.7 RESTful API 設計與實踐


## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 REST 架構原理**：深入掌握 REST 架構約束條件和設計理念
- 🎯 **設計資源導向 API**：運用資源導向思維設計清晰、直觀的 API 結構
- 🎯 **實現 HTTP 語義化**：正確使用 HTTP 方法、狀態碼和標頭進行 API 通信
- 🎯 **建立 URL 設計規範**：制定一致性、可預測的 URL 命名和結構標準
- 🎯 **應用現代化實踐**：整合版本控制、快取策略等進階技術

---

## REST 架構風格深度解析

### 為什麼需要 RESTful API？

在現代分散式系統中，不同的應用程式需要透過網路進行通信。您是否遇到過以下問題？

> **常見 API 設計問題**：
> - API 端點命名混亂，難以理解和記憶
> - HTTP 方法使用不當，語義不清
> - 狀態碼選擇隨意，錯誤處理不一致
> - 缺乏統一的設計標準，維護困難

RESTful API 透過統一的架構風格解決了這些問題，提供了一套標準化的設計原則。

### REST 架構約束條件

REST（Representational State Transfer）定義了六個核心約束條件：

| 約束條件 | 說明 | 優勢 |
|----------|------|------|
| **客戶端-伺服器** | 分離使用者介面和資料儲存關注點 | 提高可移植性和可擴展性 |
| **無狀態** | 每個請求包含處理所需的完整資訊 | 提高可見性、可靠性和可擴展性 |
| **可快取** | 回應資料可以被標記為可快取或不可快取 | 提高網路效率和使用者體驗 |
| **統一介面** | 使用統一的介面約束 | 簡化架構，提高可見性 |
| **分層系統** | 允許架構由分層組成 | 提高可擴展性和安全性 |
| **按需程式碼** | 可選約束，允許下載和執行程式碼 | 提高可擴展性 |

### 基礎 RESTful Controller 實現

```java
/**
 * 基礎 RESTful API 控制器
 * 展示標準的資源導向設計模式
 */
@RestController
@RequestMapping("/api/v1/users")
@Validated
public class UserRestController {
    
    private final UserService userService;
    private final UserMapper userMapper;
    
    public UserRestController(UserService userService, UserMapper userMapper) {
        this.userService = userService;
        this.userMapper = userMapper;
    }
    
    /**
     * 獲取使用者列表
     * GET /api/v1/users
     * 支援分頁和篩選參數
     */
    @GetMapping
    public ResponseEntity<PagedResponse<UserDto>> getUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(required = false) String name,
            @RequestParam(required = false) String email
    ) {
        // 建立查詢條件
        UserSearchCriteria criteria = UserSearchCriteria.builder()
                .name(name)
                .email(email)
                .build();
        
        // 執行分頁查詢
        Page<User> userPage = userService.findUsers(criteria, PageRequest.of(page, size));
        
        // 轉換為 DTO
        List<UserDto> userDtos = userPage.getContent().stream()
                .map(userMapper::toDto)
                .collect(Collectors.toList());
        
        // 建立分頁回應
        PagedResponse<UserDto> response = PagedResponse.<UserDto>builder()
                .content(userDtos)
                .page(page)
                .size(size)
                .totalElements(userPage.getTotalElements())
                .totalPages(userPage.getTotalPages())
                .first(userPage.isFirst())
                .last(userPage.isLast())
                .build();
        
        return ResponseEntity.ok()
                .header("X-Total-Count", String.valueOf(userPage.getTotalElements()))
                .body(response);
    }
    
    /**
     * 根據 ID 獲取單一使用者
     * GET /api/v1/users/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<UserDto> getUserById(@PathVariable Long id) {
        User user = userService.findById(id);
        UserDto userDto = userMapper.toDto(user);
        
        return ResponseEntity.ok()
                .cacheControl(CacheControl.maxAge(Duration.ofMinutes(5)))
                .body(userDto);
    }
}
```

---

## HTTP 方法語義化使用

### HTTP 方法對照表

| HTTP 方法 | 用途 | 冪等性 | 安全性 | 典型使用場景 |
|-----------|------|--------|--------|--------------|
| **GET** | 獲取資源 | ✅ | ✅ | 查詢資料、獲取列表 |
| **POST** | 建立資源 | ❌ | ❌ | 新增資料、提交表單 |
| **PUT** | 更新/替換資源 | ✅ | ❌ | 完整更新資源 |
| **PATCH** | 部分更新資源 | ❌ | ❌ | 部分欄位更新 |
| **DELETE** | 刪除資源 | ✅ | ❌ | 刪除資料 |
| **HEAD** | 獲取資源標頭 | ✅ | ✅ | 檢查資源存在性 |
| **OPTIONS** | 獲取支援的方法 | ✅ | ✅ | CORS 預檢請求 |

### 完整 CRUD 操作實現

```java
/**
 * 完整的 CRUD 操作實現
 * 展示各種 HTTP 方法的正確使用
 */
@RestController
@RequestMapping("/api/v1/products")
public class ProductRestController {
    
    private final ProductService productService;
    private final ProductMapper productMapper;
    
    public ProductRestController(ProductService productService, ProductMapper productMapper) {
        this.productService = productService;
        this.productMapper = productMapper;
    }
    
    /**
     * 建立新產品
     * POST /api/v1/products
     * 回傳 201 Created 和 Location 標頭
     */
    @PostMapping
    public ResponseEntity<ProductDto> createProduct(@RequestBody @Valid CreateProductRequest request) {
        // 轉換請求為實體
        Product product = productMapper.toEntity(request);
        
        // 儲存產品
        Product savedProduct = productService.save(product);
        
        // 轉換為 DTO
        ProductDto productDto = productMapper.toDto(savedProduct);
        
        // 建立資源位置 URI
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(savedProduct.getId())
                .toUri();
        
        return ResponseEntity.created(location)
                .body(productDto);
    }
    
    /**
     * 完整更新產品
     * PUT /api/v1/products/{id}
     * 冪等操作，完整替換資源
     */
    @PutMapping("/{id}")
    public ResponseEntity<ProductDto> updateProduct(
            @PathVariable Long id,
            @RequestBody @Valid UpdateProductRequest request
    ) {
        // 檢查產品是否存在
        if (!productService.existsById(id)) {
            throw new ProductNotFoundException("Product not found with id: " + id);
        }
        
        // 轉換請求為實體
        Product product = productMapper.toEntity(request);
        product.setId(id);
        
        // 更新產品
        Product updatedProduct = productService.update(product);
        
        // 轉換為 DTO
        ProductDto productDto = productMapper.toDto(updatedProduct);
        
        return ResponseEntity.ok(productDto);
    }
    
    /**
     * 部分更新產品
     * PATCH /api/v1/products/{id}
     * 只更新提供的欄位
     */
    @PatchMapping("/{id}")
    public ResponseEntity<ProductDto> patchProduct(
            @PathVariable Long id,
            @RequestBody Map<String, Object> updates
    ) {
        // 執行部分更新
        Product updatedProduct = productService.partialUpdate(id, updates);
        
        // 轉換為 DTO
        ProductDto productDto = productMapper.toDto(updatedProduct);
        
        return ResponseEntity.ok(productDto);
    }
    
    /**
     * 刪除產品
     * DELETE /api/v1/products/{id}
     * 冪等操作，重複刪除不會產生錯誤
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        // 檢查產品是否存在
        if (!productService.existsById(id)) {
            // 冪等性：即使資源不存在也回傳 204
            return ResponseEntity.noContent().build();
        }
        
        // 刪除產品
        productService.deleteById(id);
        
        return ResponseEntity.noContent().build();
    }
}
```

---

## RESTful URL 設計原則

### URL 設計最佳實踐

| 原則 | 說明 | 好的範例 | 不好的範例 |
|------|------|----------|------------|
| **使用名詞** | URL 應該表示資源，而非動作 | `/api/users` | `/api/getUsers` |
| **複數形式** | 集合資源使用複數名詞 | `/api/products` | `/api/product` |
| **階層結構** | 反映資源之間的關係 | `/api/users/123/orders` | `/api/getUserOrders?userId=123` |
| **小寫字母** | 統一使用小寫字母 | `/api/user-profiles` | `/api/UserProfiles` |
| **連字符分隔** | 使用連字符而非底線 | `/api/order-items` | `/api/order_items` |

### 資源關係設計

```java
/**
 * 巢狀資源關係的 RESTful 設計
 * 展示父子資源的 URL 結構
 */
@RestController
@RequestMapping("/api/v1/users/{userId}/orders")
public class UserOrderController {
    
    private final OrderService orderService;
    private final UserService userService;
    
    /**
     * 獲取使用者的所有訂單
     * GET /api/v1/users/{userId}/orders
     */
    @GetMapping
    public ResponseEntity<List<OrderDto>> getUserOrders(
            @PathVariable Long userId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(required = false) String status
    ) {
        // 驗證使用者存在
        userService.validateUserExists(userId);
        
        // 建立查詢條件
        OrderSearchCriteria criteria = OrderSearchCriteria.builder()
                .userId(userId)
                .status(status)
                .build();
        
        // 執行查詢
        Page<Order> orderPage = orderService.findOrders(criteria, PageRequest.of(page, size));
        
        // 轉換為 DTO
        List<OrderDto> orderDtos = orderPage.getContent().stream()
                .map(orderMapper::toDto)
                .collect(Collectors.toList());
        
        return ResponseEntity.ok(orderDtos);
    }
    
    /**
     * 為使用者建立新訂單
     * POST /api/v1/users/{userId}/orders
     */
    @PostMapping
    public ResponseEntity<OrderDto> createUserOrder(
            @PathVariable Long userId,
            @RequestBody @Valid CreateOrderRequest request
    ) {
        // 驗證使用者存在
        User user = userService.findById(userId);
        
        // 建立訂單
        Order order = orderMapper.toEntity(request);
        order.setUser(user);
        
        Order savedOrder = orderService.save(order);
        OrderDto orderDto = orderMapper.toDto(savedOrder);
        
        // 建立資源位置
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{orderId}")
                .buildAndExpand(savedOrder.getId())
                .toUri();
        
        return ResponseEntity.created(location).body(orderDto);
    }
}
```

---

## HTTP 狀態碼最佳實踐

### 常用狀態碼對照表

| 狀態碼 | 名稱 | 使用場景 | 範例 |
|--------|------|----------|------|
| **200** | OK | 請求成功 | GET、PUT、PATCH 成功 |
| **201** | Created | 資源建立成功 | POST 建立資源 |
| **204** | No Content | 請求成功但無內容回傳 | DELETE 成功 |
| **400** | Bad Request | 請求格式錯誤 | 驗證失敗 |
| **401** | Unauthorized | 未認證 | 缺少或無效的認證資訊 |
| **403** | Forbidden | 已認證但無權限 | 權限不足 |
| **404** | Not Found | 資源不存在 | 找不到指定資源 |
| **409** | Conflict | 資源衝突 | 重複建立、版本衝突 |
| **422** | Unprocessable Entity | 語義錯誤 | 業務邏輯驗證失敗 |
| **500** | Internal Server Error | 伺服器內部錯誤 | 未預期的系統錯誤 |

### 全域異常處理

```java
/**
 * 全域異常處理器
 * 統一處理各種異常並回傳適當的狀態碼
 */
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    /**
     * 處理驗證異常
     * 400 Bad Request
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException e) {
        List<FieldError> fieldErrors = e.getBindingResult().getFieldErrors();
        
        Map<String, String> errors = fieldErrors.stream()
                .collect(Collectors.toMap(
                        FieldError::getField,
                        FieldError::getDefaultMessage,
                        (existing, replacement) -> existing
                ));
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Validation Failed")
                .message("Request validation failed")
                .details(errors)
                .timestamp(Instant.now())
                .path(getCurrentPath())
                .build();
        
        return ResponseEntity.badRequest().body(errorResponse);
    }
    
    /**
     * 處理資源未找到異常
     * 404 Not Found
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFoundException(ResourceNotFoundException e) {
        ErrorResponse errorResponse = ErrorResponse.builder()
                .status(HttpStatus.NOT_FOUND.value())
                .error("Resource Not Found")
                .message(e.getMessage())
                .timestamp(Instant.now())
                .path(getCurrentPath())
                .build();
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
    }
    
    /**
     * 處理系統異常
     * 500 Internal Server Error
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception e) {
        logger.error("Unexpected error occurred", e);
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                .error("Internal Server Error")
                .message("An unexpected error occurred")
                .timestamp(Instant.now())
                .path(getCurrentPath())
                .build();
        
        return ResponseEntity.internalServerError().body(errorResponse);
    }
    
    private String getCurrentPath() {
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        if (requestAttributes instanceof ServletRequestAttributes) {
            HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
            return request.getRequestURI();
        }
        return "unknown";
    }
}
```

---

## API 版本控制策略

### 版本控制策略比較

| 策略 | 實現方式 | 優點 | 缺點 | 適用場景 |
|------|----------|------|------|----------|
| **URL 路徑** | `/api/v1/users` | 清晰明確、易於理解 | URL 較長、路由複雜 | 公開 API |
| **查詢參數** | `/api/users?version=1` | 靈活、易於實現 | 容易被忽略 | 內部 API |
| **標頭版本** | `Accept: application/vnd.api.v1+json` | 語義清晰、符合 HTTP 標準 | 實現複雜 | 企業級 API |

### URL 路徑版本控制實現

```java
/**
 * URL 路徑版本控制實現
 * 最常見和直觀的版本控制方式
 */
@RestController
public class VersionedUserController {
    
    private final UserService userService;
    private final UserMapperV1 userMapperV1;
    private final UserMapperV2 userMapperV2;
    
    /**
     * API v1 - 基礎使用者資訊
     * GET /api/v1/users/{id}
     */
    @GetMapping("/api/v1/users/{id}")
    public ResponseEntity<UserV1Dto> getUserV1(@PathVariable Long id) {
        User user = userService.findById(id);
        UserV1Dto userDto = userMapperV1.toDto(user);
        
        return ResponseEntity.ok()
                .header("API-Version", "1.0")
                .body(userDto);
    }
    
    /**
     * API v2 - 增強的使用者資訊（包含偏好設定）
     * GET /api/v2/users/{id}
     */
    @GetMapping("/api/v2/users/{id}")
    public ResponseEntity<UserV2Dto> getUserV2(@PathVariable Long id) {
        User user = userService.findById(id);
        UserV2Dto userDto = userMapperV2.toDto(user);
        
        return ResponseEntity.ok()
                .header("API-Version", "2.0")
                .body(userDto);
    }
}
```

---

## 快取策略設計

### HTTP 快取標頭對照表

| 標頭 | 類型 | 用途 | 範例 |
|------|------|------|------|
| **Cache-Control** | 回應/請求 | 控制快取行為 | `max-age=3600, public` |
| **ETag** | 回應 | 資源版本標識 | `"abc123"` |
| **Last-Modified** | 回應 | 最後修改時間 | `Wed, 21 Oct 2015 07:28:00 GMT` |
| **If-None-Match** | 請求 | 條件式請求（ETag） | `"abc123"` |
| **If-Modified-Since** | 請求 | 條件式請求（時間） | `Wed, 21 Oct 2015 07:28:00 GMT` |

### 快取策略實現

```java
/**
 * RESTful API 快取策略實現
 * 展示各種快取控制技術
 */
@RestController
@RequestMapping("/api/v1/articles")
public class ArticleCacheController {
    
    private final ArticleService articleService;
    
    /**
     * 獲取文章列表（公開快取）
     * GET /api/v1/articles
     */
    @GetMapping
    public ResponseEntity<List<ArticleDto>> getArticles() {
        List<Article> articles = articleService.findPublishedArticles();
        List<ArticleDto> articleDtos = articles.stream()
                .map(articleMapper::toDto)
                .collect(Collectors.toList());
        
        return ResponseEntity.ok()
                .cacheControl(CacheControl.maxAge(Duration.ofMinutes(15))
                        .cachePublic()
                        .mustRevalidate())
                .body(articleDtos);
    }
    
    /**
     * 獲取文章詳情（ETag 快取）
     * GET /api/v1/articles/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<ArticleDto> getArticle(
            @PathVariable Long id,
            HttpServletRequest request
    ) {
        Article article = articleService.findById(id);
        
        // 生成 ETag
        String etag = generateETag(article);
        
        // 檢查條件式請求
        String ifNoneMatch = request.getHeader("If-None-Match");
        if (etag.equals(ifNoneMatch)) {
            return ResponseEntity.status(HttpStatus.NOT_MODIFIED)
                    .eTag(etag)
                    .build();
        }
        
        ArticleDto articleDto = articleMapper.toDto(article);
        
        return ResponseEntity.ok()
                .eTag(etag)
                .cacheControl(CacheControl.maxAge(Duration.ofMinutes(30))
                        .cachePrivate())
                .body(articleDto);
    }
    
    /**
     * 生成 ETag
     */
    private String generateETag(Article article) {
        String content = article.getId() + ":" + 
                        article.getTitle() + ":" + 
                        article.getUpdatedAt().toString();
        
        return "\"" + DigestUtils.md5DigestAsHex(content.getBytes()) + "\"";
    }
}
```

---

## RESTful API 設計最佳實踐總結

### API 設計檢查清單

在設計 RESTful API 時，請參考以下檢查清單：

| 檢查項目 | 說明 | 範例 |
|---------|------|------|
| **資源導向** | 使用名詞而非動詞 | `/api/users` 而非 `/api/getUsers` |
| **HTTP 方法** | 正確使用 HTTP 動詞 | GET 查詢、POST 建立、PUT 更新、DELETE 刪除 |
| **狀態碼** | 語義化的 HTTP 狀態碼 | 201 Created、404 Not Found、409 Conflict |
| **統一格式** | 一致的回應結構 | 統一的錯誤格式和成功格式 |
| **版本控制** | 明確的版本策略 | `/api/v1/` 或標頭版本控制 |
| **快取支援** | 適當的快取控制 | ETag、Cache-Control、Last-Modified |

✅ **最佳實踐標記**：
- 使用資源導向的 URL 設計
- 正確運用 HTTP 方法語義
- 實現統一的錯誤處理機制
- 支援適當的快取策略
- 考慮 API 版本演進需求

⚠️ **常見陷阱**：
- URL 中使用動詞而非名詞
- 所有操作都使用 POST 方法
- 忽略 HTTP 狀態碼的語義
- 缺乏統一的錯誤處理
- 沒有考慮快取和效能

---

## 📝 重點摘要

本章深入探討了 RESTful API 設計與實踐的核心概念和最佳實踐。以下是關鍵要點：

### 🎯 核心概念回顧

1. **REST 架構約束**
   - 客戶端-伺服器分離
   - 無狀態通信
   - 統一介面設計
   - 分層系統架構

2. **HTTP 語義化使用**
   - GET：安全且冪等的資源獲取
   - POST：非冪等的資源建立
   - PUT：冪等的完整資源更新
   - DELETE：冪等的資源刪除

3. **URL 設計原則**
   - 使用名詞表示資源
   - 採用階層結構反映關係
   - 統一命名規範
   - 支援查詢參數篩選

### 💡 實踐技巧總結

| 技巧類別 | 關鍵要點 | 實際效益 |
|---------|---------|---------|
| **資源設計** | 名詞導向的 URL 結構 | 提升 API 可理解性 |
| **HTTP 語義** | 正確使用 HTTP 方法和狀態碼 | 符合 Web 標準，提升互操作性 |
| **錯誤處理** | 統一的異常處理機制 | 簡化客戶端錯誤處理邏輯 |
| **版本控制** | 明確的版本演進策略 | 支援 API 持續演進 |
| **效能優化** | 適當的快取控制策略 | 提升系統效能和使用者體驗 |

### ✅ 開發檢查清單

在實際開發中，請確保：

- [ ] **URL 設計**：使用資源導向的命名規範
- [ ] **HTTP 方法**：正確選擇和使用 HTTP 動詞
- [ ] **狀態碼**：回傳語義化的 HTTP 狀態碼
- [ ] **錯誤處理**：實現統一的異常處理機制
- [ ] **版本控制**：制定明確的版本管理策略
- [ ] **快取策略**：實現適當的快取控制機制

### 🚀 下一步學習方向

掌握了 RESTful API 設計後，建議您繼續學習：

1. **API 安全性**：實現認證授權和資料保護
2. **API 文件化**：使用 OpenAPI/Swagger 生成文件
3. **API 測試**：建立完整的 API 測試策略
4. **微服務架構**：在分散式系統中應用 RESTful 設計

💡 **學習提示**：RESTful API 設計是現代 Web 開發的基礎技能，良好的設計不僅提升開發效率，更能改善系統的可維護性和擴展性。

---

**恭喜您完成本章學習！** 🎉

您現在已經掌握了 RESTful API 設計與實踐的核心技能。這些知識將為您的 Web API 開發奠定堅實的基礎。在下一章中，我們將探討 Controller 的路徑匹配與方法註解，進一步提升您的 Spring MVC 開發能力。


\newpage

## 2.3 API 請求與回應處理


> **本章重點**：掌握 Spring MVC 中請求參數處理和回應格式設計的核心技術，建立完整的 API 資料交換體系，為 Spring AI 整合做好準備。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握參數註解體系**：理解 @PathVariable、@RequestParam、@RequestBody 等核心註解的使用場景
- 🎯 **設計統一回應格式**：建立標準化的 API 回應結構，提升介面一致性
- 🎯 **熟練運用 HTTP 狀態碼**：正確使用各種狀態碼表達不同的業務情境
- 🎯 **實現完善錯誤處理**：建構統一的錯誤回應機制和異常處理策略
- 🎯 **為 AI 服務做準備**：設計適合 AI 應用的請求回應模式

---

## 2.3.1 請求參數處理

### 為什麼需要理解請求參數處理？

在現代 Web 應用開發中，API 是前後端交互的橋樑。一個設計良好的 API 需要能夠靈活地處理各種類型的請求參數，特別是在 AI 應用中，我們需要處理複雜的輸入資料。

### Spring MVC 參數註解概覽

| 註解 | 用途 | 資料來源 | 適用場景 |
|------|------|----------|----------|
| **@PathVariable** | 路徑參數 | URL 路徑 | RESTful 資源識別 |
| **@RequestParam** | 查詢參數 | URL 查詢字串 | 搜尋條件、分頁參數 |
| **@RequestBody** | 請求體參數 | HTTP 請求體 | JSON 物件、複雜資料 |
| **@RequestHeader** | 請求標頭 | HTTP 標頭 | 認證資訊、客戶端資訊 |

### @PathVariable - 路徑參數處理

路徑參數是 RESTful API 設計的核心，用於標識特定的資源：

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    /**
     * 獲取單一使用者資訊
     * URL: GET /api/users/123
     */
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
    
    /**
     * 獲取使用者的特定訂單
     * URL: GET /api/users/123/orders/456
     */
    @GetMapping("/{userId}/orders/{orderId}")
    public ResponseEntity<Order> getUserOrder(
            @PathVariable Long userId,
            @PathVariable Long orderId) {
        Order order = orderService.findByUserIdAndOrderId(userId, orderId);
        return ResponseEntity.ok(order);
    }
}
```

### @RequestParam - 查詢參數處理

查詢參數適用於搜尋條件、分頁和排序等場景：

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    /**
     * 商品搜尋與分頁
     * URL: GET /api/products?keyword=手機&page=1&size=10&sort=price
     */
    @GetMapping
    public ResponseEntity<Page<Product>> searchProducts(
            @RequestParam(required = false) String keyword,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "id") String sort) {
        
        Pageable pageable = PageRequest.of(page, size, Sort.by(sort));
        Page<Product> products = productService.search(keyword, pageable);
        return ResponseEntity.ok(products);
    }
    
    /**
     * 複雜查詢條件
     * URL: GET /api/products?category=electronics&minPrice=100&maxPrice=1000
     */
    @GetMapping("/filter")
    public ResponseEntity<List<Product>> filterProducts(
            @RequestParam String category,
            @RequestParam(required = false) BigDecimal minPrice,
            @RequestParam(required = false) BigDecimal maxPrice) {
        
        List<Product> products = productService.filter(category, minPrice, maxPrice);
        return ResponseEntity.ok(products);
    }
}
```

### @RequestBody - 請求體參數處理

請求體參數適用於複雜的資料結構，特別是 JSON 物件：

```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    /**
     * 建立訂單
     * 接收複雜的 JSON 物件
     */
    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody CreateOrderRequest request) {
        Order order = orderService.createOrder(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(order);
    }
    
    /**
     * 批量更新商品
     * 處理陣列資料
     */
    @PutMapping("/batch")
    public ResponseEntity<List<Product>> batchUpdateProducts(
            @RequestBody List<UpdateProductRequest> requests) {
        List<Product> updatedProducts = productService.batchUpdate(requests);
        return ResponseEntity.ok(updatedProducts);
    }
}
```

---

## 2.3.2 統一回應格式設計

### 為什麼需要標準化的 API 回應格式？

統一的回應格式能夠：
- 提升前端處理的一致性
- 簡化錯誤處理邏輯
- 改善 API 的可維護性
- 為 AI 服務提供標準化的資料介面

### 基礎回應結構設計

```java
/**
 * 統一 API 回應格式
 * 適用於所有 API 端點，包括未來的 AI 服務
 */
public class ApiResponse<T> {
    
    /** 回應狀態碼 */
    private int code;
    
    /** 回應訊息 */
    private String message;
    
    /** 回應資料 */
    private T data;
    
    /** 時間戳記 */
    private long timestamp;
    
    /** 請求追蹤 ID */
    private String traceId;
    
    // 建構子
    private ApiResponse(int code, String message, T data) {
        this.code = code;
        this.message = message;
        this.data = data;
        this.timestamp = System.currentTimeMillis();
        this.traceId = UUID.randomUUID().toString();
    }
    
    /**
     * 建立成功回應
     */
    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(200, "操作成功", data);
    }
    
    public static <T> ApiResponse<T> success(String message, T data) {
        return new ApiResponse<>(200, message, data);
    }
    
    /**
     * 建立錯誤回應
     */
    public static <T> ApiResponse<T> error(int code, String message) {
        return new ApiResponse<>(code, message, null);
    }
    
    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>(500, message, null);
    }
    
    // Getters and Setters
    // ...
}
```

### 在控制器中使用統一回應格式

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    /**
     * 獲取使用者列表
     */
    @GetMapping
    public ApiResponse<List<User>> getUsers() {
        List<User> users = userService.findAll();
        return ApiResponse.success("獲取使用者列表成功", users);
    }
    
    /**
     * 建立使用者
     */
    @PostMapping
    public ApiResponse<User> createUser(@RequestBody CreateUserRequest request) {
        User user = userService.createUser(request);
        return ApiResponse.success("使用者建立成功", user);
    }
    
    /**
     * 刪除使用者
     */
    @DeleteMapping("/{id}")
    public ApiResponse<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ApiResponse.success("使用者刪除成功", null);
    }
}
```

---

## 2.3.3 HTTP 狀態碼最佳實踐

### 常用狀態碼及其應用場景

| 狀態碼 | 名稱 | 使用場景 | 範例 |
|--------|------|----------|------|
| **200** | OK | 成功獲取資源 | GET /api/users |
| **201** | Created | 成功建立資源 | POST /api/users |
| **204** | No Content | 成功但無回應內容 | DELETE /api/users/1 |
| **400** | Bad Request | 請求參數錯誤 | 缺少必要參數 |
| **401** | Unauthorized | 未認證 | 缺少認證資訊 |
| **403** | Forbidden | 無權限 | 權限不足 |
| **404** | Not Found | 資源不存在 | 使用者不存在 |
| **500** | Internal Server Error | 伺服器內部錯誤 | 系統異常 |

### ResponseEntity 的使用

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    /**
     * 獲取商品詳情
     */
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<Product>> getProduct(@PathVariable Long id) {
        try {
            Product product = productService.findById(id);
            ApiResponse<Product> response = ApiResponse.success(product);
            return ResponseEntity.ok(response);
        } catch (ProductNotFoundException e) {
            ApiResponse<Product> response = ApiResponse.error(404, "商品不存在");
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * 建立商品
     */
    @PostMapping
    public ResponseEntity<ApiResponse<Product>> createProduct(
            @RequestBody CreateProductRequest request) {
        Product product = productService.createProduct(request);
        ApiResponse<Product> response = ApiResponse.success("商品建立成功", product);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
}
```

---

## 2.3.4 全域異常處理

### 建立全域異常處理器

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    /**
     * 處理參數驗證異常
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Void>> handleValidationException(
            MethodArgumentNotValidException e) {
        
        StringBuilder message = new StringBuilder("參數驗證失敗：");
        e.getBindingResult().getFieldErrors().forEach(error -> 
            message.append(error.getField()).append(" ").append(error.getDefaultMessage()).append("; ")
        );
        
        ApiResponse<Void> response = ApiResponse.error(400, message.toString());
        return ResponseEntity.badRequest().body(response);
    }
    
    /**
     * 處理資源不存在異常
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse<Void>> handleResourceNotFoundException(
            ResourceNotFoundException e) {
        ApiResponse<Void> response = ApiResponse.error(404, e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }
    
    /**
     * 處理一般異常
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleGeneralException(Exception e) {
        ApiResponse<Void> response = ApiResponse.error(500, "系統內部錯誤");
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
    }
}
```

---

## 2.3.5 為 Spring AI 做準備

### AI 服務的特殊需求

在設計 API 請求回應格式時，我們需要考慮 Spring AI 的特殊需求：

**流式回應支援**：
```java
@RestController
@RequestMapping("/api/ai")
public class AIController {
    
    /**
     * 流式對話 API（為 Spring AI 預留）
     */
    @PostMapping(value = "/chat/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter chatStream(@RequestBody ChatRequest request) {
        SseEmitter emitter = new SseEmitter();
        // 預留給 Spring AI 流式處理
        return emitter;
    }
}
```

**多媒體內容處理**：
```java
/**
 * 多媒體請求格式（為 AI 視覺服務預留）
 */
public class MultimodalRequest {
    private String text;
    private String imageBase64;
    private String audioBase64;
    
    // Getters and Setters
}

@PostMapping("/analyze/multimodal")
public ResponseEntity<ApiResponse<AnalysisResult>> analyzeMultimodal(
        @RequestBody MultimodalRequest request) {
    // 預留給 Spring AI 多模態分析
    return ResponseEntity.ok(ApiResponse.success("分析完成", new AnalysisResult()));
}
```

**批量處理支援**：
```java
/**
 * 批量處理請求（適合 AI 批量推理）
 */
@PostMapping("/batch/process")
public ResponseEntity<ApiResponse<List<ProcessResult>>> batchProcess(
        @RequestBody List<ProcessRequest> requests) {
    // 預留給 Spring AI 批量處理
    List<ProcessResult> results = new ArrayList<>();
    return ResponseEntity.ok(ApiResponse.success("批量處理完成", results));
}
```

---

## 📝 本章重點回顧

1. **參數處理**：掌握了 @PathVariable、@RequestParam、@RequestBody 的使用
2. **統一回應格式**：建立了標準化的 API 回應結構
3. **HTTP 狀態碼**：學會了正確使用各種狀態碼
4. **異常處理**：實現了全域異常處理機制
5. **AI 整合準備**：為 Spring AI 的特殊需求做好了架構準備

### 下一步學習方向

在下一章中，我們將進入第三章的企業級功能開發，學習資料驗證、檔案處理等進階技術，進一步完善我們的 API 開發技能。

---

**參考資料：**
- [Spring MVC Request Mapping](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping)
- [HTTP Status Codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
- [Spring Boot Error Handling](https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc.error-handling)


\newpage


# 第三章：生產級 API 開發實踐 {.unnumbered .unlisted}


## 3.1 資料驗證與錯誤處理


> **第三章導讀**：本章將帶您進入生產級 API 開發實踐，掌握資料驗證、錯誤處理等核心技術，為 Spring AI 應用建立堅實的品質保證基礎。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解資料驗證的重要性**：掌握 Web 應用中資料驗證的核心概念和必要性
- 🎯 **掌握 Bean Validation**：熟練使用 Spring Boot 內建的資料驗證框架
- 🎯 **實現統一例外處理**：建立完善的全域錯誤處理機制
- 🎯 **設計友善的錯誤回應**：為使用者和開發者提供清晰的錯誤訊息
- 🎯 **為 AI 服務做準備**：建立適合 AI 應用的驗證和錯誤處理策略

---

## 3.1.1 為什麼需要資料驗證？

### 資料驗證的重要性

在 Web 應用開發中，資料驗證是確保系統安全性和資料完整性的第一道防線。特別是在 AI 應用中，輸入資料的品質直接影響 AI 模型的表現。

> **思考問題**：如果您的 AI 應用接收到以下資料，會發生什麼問題？
> - 使用者名稱為空字串
> - 電子郵件格式不正確
> - 上傳的圖片格式不支援
> - AI 提示詞包含惡意內容

### 常見的資料問題

**1. 資料完整性問題**
```java
// 沒有驗證的情況下可能出現的問題
public class User {
    private String name;     // 可能為 null 或空字串
    private String email;    // 可能格式不正確
    private Integer age;     // 可能為負數
    private String password; // 可能太短或太簡單
}
```

**2. 安全性問題**
- SQL 注入攻擊
- XSS 跨站腳本攻擊
- 檔案上傳漏洞
- AI 提示注入攻擊

**3. 業務邏輯問題**
- 不符合業務規則的資料
- 資料格式不一致
- 缺少必要的關聯資料

---

## 3.1.2 Spring Boot Bean Validation

### 基本驗證註解

Spring Boot 內建了 Bean Validation 支援，提供了豐富的驗證註解：

```java
/**
 * 使用者註冊請求 DTO
 * 展示基本的資料驗證註解使用
 */
public class UserRegistrationRequest {
    
    @NotBlank(message = "使用者名稱不能為空")
    @Size(min = 2, max = 50, message = "使用者名稱長度必須在 2-50 字元之間")
    private String username;
    
    @NotBlank(message = "電子郵件不能為空")
    @Email(message = "電子郵件格式不正確")
    private String email;
    
    @NotBlank(message = "密碼不能為空")
    @Size(min = 8, max = 128, message = "密碼長度必須在 8-128 字元之間")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).*$", 
             message = "密碼必須包含大小寫字母和數字")
    private String password;
    
    @NotNull(message = "年齡不能為空")
    @Min(value = 18, message = "年齡必須大於等於 18 歲")
    @Max(value = 120, message = "年齡必須小於等於 120 歲")
    private Integer age;
    
    @NotEmpty(message = "興趣愛好不能為空")
    @Size(max = 10, message = "興趣愛好最多 10 個")
    private List<String> hobbies;
    
    // Getters and Setters
}
```

### 常用驗證註解總覽

| 註解 | 適用類型 | 說明 | 範例 |
|------|----------|------|------|
| **@NotNull** | 任何類型 | 不能為 null | `@NotNull Integer age` |
| **@NotBlank** | String | 不能為 null、空字串或只有空白字元 | `@NotBlank String name` |
| **@NotEmpty** | Collection, Map, Array | 不能為 null 或空集合 | `@NotEmpty List<String> tags` |
| **@Size** | String, Collection, Map, Array | 長度或大小限制 | `@Size(min=2, max=50)` |
| **@Min/@Max** | 數值類型 | 數值範圍限制 | `@Min(18) @Max(120)` |
| **@Email** | String | 電子郵件格式驗證 | `@Email String email` |
| **@Pattern** | String | 正規表達式驗證 | `@Pattern(regexp="...")` |
| **@Valid** | 物件 | 巢狀物件驗證 | `@Valid Address address` |

### 在控制器中使用驗證

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    /**
     * 使用者註冊
     * @Valid 註解觸發驗證，BindingResult 接收驗證結果
     */
    @PostMapping("/register")
    public ResponseEntity<ApiResponse<User>> registerUser(
            @Valid @RequestBody UserRegistrationRequest request,
            BindingResult bindingResult) {
        
        // 手動檢查驗證結果
        if (bindingResult.hasErrors()) {
            StringBuilder errorMessage = new StringBuilder("驗證失敗：");
            bindingResult.getFieldErrors().forEach(error -> 
                errorMessage.append(error.getField())
                           .append(" ")
                           .append(error.getDefaultMessage())
                           .append("; ")
            );
            return ResponseEntity.badRequest()
                    .body(ApiResponse.error(400, errorMessage.toString()));
        }
        
        User user = userService.registerUser(request);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success("註冊成功", user));
    }
    
    /**
     * 更新使用者資訊
     * 使用全域異常處理，無需手動檢查 BindingResult
     */
    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<User>> updateUser(
            @PathVariable Long id,
            @Valid @RequestBody UserUpdateRequest request) {
        
        User user = userService.updateUser(id, request);
        return ResponseEntity.ok(ApiResponse.success("更新成功", user));
    }
}
```

---

## 3.1.3 自訂驗證註解

### 建立自訂驗證註解

有時候內建的驗證註解無法滿足特殊的業務需求，我們可以建立自訂的驗證註解：

```java
/**
 * 自訂驗證註解：檢查密碼強度
 */
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = StrongPasswordValidator.class)
@Documented
public @interface StrongPassword {
    
    String message() default "密碼強度不足";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
    
    /**
     * 是否要求包含特殊字元
     */
    boolean requireSpecialChar() default true;
    
    /**
     * 最小長度
     */
    int minLength() default 8;
}
```

### 實現驗證邏輯

```java
/**
 * 密碼強度驗證器
 */
public class StrongPasswordValidator implements ConstraintValidator<StrongPassword, String> {
    
    private boolean requireSpecialChar;
    private int minLength;
    
    @Override
    public void initialize(StrongPassword annotation) {
        this.requireSpecialChar = annotation.requireSpecialChar();
        this.minLength = annotation.minLength();
    }
    
    @Override
    public boolean isValid(String password, ConstraintValidatorContext context) {
        if (password == null) {
            return false;
        }
        
        // 檢查長度
        if (password.length() < minLength) {
            return false;
        }
        
        // 檢查是否包含大寫字母
        if (!password.matches(".*[A-Z].*")) {
            return false;
        }
        
        // 檢查是否包含小寫字母
        if (!password.matches(".*[a-z].*")) {
            return false;
        }
        
        // 檢查是否包含數字
        if (!password.matches(".*\\d.*")) {
            return false;
        }
        
        // 檢查是否包含特殊字元（如果需要）
        if (requireSpecialChar && !password.matches(".*[!@#$%^&*()_+\\-=\\[\\]{};':,.<>?].*")) {
            return false;
        }
        
        return true;
    }
}
```

### 使用自訂驗證註解

```java
public class ChangePasswordRequest {
    
    @NotBlank(message = "舊密碼不能為空")
    private String oldPassword;
    
    @StrongPassword(minLength = 10, requireSpecialChar = true, 
                   message = "新密碼必須至少 10 字元，包含大小寫字母、數字和特殊字元")
    private String newPassword;
    
    // Getters and Setters
}
```

---

## 3.1.4 全域異常處理

### 建立全域異常處理器

```java
/**
 * 全域異常處理器
 * 統一處理應用程式中的各種異常情況
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    /**
     * 處理參數驗證異常
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Void>> handleValidationException(
            MethodArgumentNotValidException e) {
        
        log.warn("參數驗證失敗：{}", e.getMessage());
        
        Map<String, String> errors = new HashMap<>();
        e.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        ApiResponse<Void> response = ApiResponse.error(400, "參數驗證失敗", errors);
        return ResponseEntity.badRequest().body(response);
    }
    
    /**
     * 處理請求參數綁定異常
     */
    @ExceptionHandler(BindException.class)
    public ResponseEntity<ApiResponse<Void>> handleBindException(BindException e) {
        log.warn("參數綁定失敗：{}", e.getMessage());
        
        Map<String, String> errors = new HashMap<>();
        e.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        ApiResponse<Void> response = ApiResponse.error(400, "參數綁定失敗", errors);
        return ResponseEntity.badRequest().body(response);
    }
    
    /**
     * 處理資源不存在異常
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse<Void>> handleResourceNotFoundException(
            ResourceNotFoundException e) {
        log.warn("資源不存在：{}", e.getMessage());
        
        ApiResponse<Void> response = ApiResponse.error(404, e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }
    
    /**
     * 處理業務邏輯異常
     */
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiResponse<Void>> handleBusinessException(
            BusinessException e) {
        log.warn("業務邏輯異常：{}", e.getMessage());
        
        ApiResponse<Void> response = ApiResponse.error(e.getCode(), e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }
    
    /**
     * 處理資料庫約束違反異常
     */
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiResponse<Void>> handleDataIntegrityViolationException(
            DataIntegrityViolationException e) {
        log.error("資料庫約束違反：{}", e.getMessage());
        
        String message = "資料操作失敗，可能存在重複資料或違反約束條件";
        ApiResponse<Void> response = ApiResponse.error(409, message);
        return ResponseEntity.status(HttpStatus.CONFLICT).body(response);
    }
    
    /**
     * 處理一般異常
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleGeneralException(Exception e) {
        log.error("系統異常：", e);
        
        ApiResponse<Void> response = ApiResponse.error(500, "系統內部錯誤，請稍後再試");
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
    }
}
```

### 自訂業務異常

```java
/**
 * 業務異常基類
 */
public class BusinessException extends RuntimeException {
    
    private final int code;
    
    public BusinessException(int code, String message) {
        super(message);
        this.code = code;
    }
    
    public BusinessException(String message) {
        this(400, message);
    }
    
    public int getCode() {
        return code;
    }
}

/**
 * 資源不存在異常
 */
public class ResourceNotFoundException extends BusinessException {
    
    public ResourceNotFoundException(String resource, Object id) {
        super(404, String.format("%s (ID: %s) 不存在", resource, id));
    }
}

/**
 * 使用者相關異常
 */
public class UserException {
    
    public static class UserAlreadyExistsException extends BusinessException {
        public UserAlreadyExistsException(String email) {
            super(409, "電子郵件 " + email + " 已被註冊");
        }
    }
    
    public static class InvalidCredentialsException extends BusinessException {
        public InvalidCredentialsException() {
            super(401, "帳號或密碼錯誤");
        }
    }
}
```

---

## 3.1.5 為 Spring AI 做準備

### AI 服務的特殊驗證需求

在 AI 應用中，我們需要考慮特殊的驗證需求：

```java
/**
 * AI 對話請求驗證
 */
public class ChatRequest {
    
    @NotBlank(message = "使用者訊息不能為空")
    @Size(max = 4000, message = "訊息長度不能超過 4000 字元")
    @SafeContent(message = "訊息包含不當內容")
    private String message;
    
    @Valid
    private ChatContext context;
    
    @Min(value = 0, message = "溫度值必須大於等於 0")
    @Max(value = 2, message = "溫度值必須小於等於 2")
    private Double temperature = 0.7;
    
    @Min(value = 1, message = "最大 token 數必須大於 0")
    @Max(value = 4096, message = "最大 token 數不能超過 4096")
    private Integer maxTokens = 1000;
    
    // Getters and Setters
}

/**
 * 安全內容驗證註解
 */
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = SafeContentValidator.class)
public @interface SafeContent {
    String message() default "內容包含不當資訊";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

/**
 * 安全內容驗證器
 */
public class SafeContentValidator implements ConstraintValidator<SafeContent, String> {
    
    private static final List<String> FORBIDDEN_KEYWORDS = Arrays.asList(
        "暴力", "色情", "政治敏感", "仇恨言論"
        // 實際應用中應該有更完整的關鍵詞庫
    );
    
    @Override
    public boolean isValid(String content, ConstraintValidatorContext context) {
        if (content == null) {
            return true;
        }
        
        // 簡單的關鍵詞檢查（實際應用中應該使用更sophisticated的方法）
        String lowerContent = content.toLowerCase();
        return FORBIDDEN_KEYWORDS.stream()
                .noneMatch(lowerContent::contains);
    }
}
```

### 多媒體內容驗證

```java
/**
 * 多媒體 AI 請求驗證
 */
public class MultimodalAIRequest {
    
    @NotBlank(message = "文字內容不能為空")
    private String text;
    
    @ValidImage(message = "圖片格式不支援或大小超限")
    private String imageBase64;
    
    @ValidAudio(message = "音訊格式不支援或大小超限")
    private String audioBase64;
    
    // Getters and Setters
}

/**
 * 圖片驗證註解
 */
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = ImageValidator.class)
public @interface ValidImage {
    String message() default "圖片格式不正確";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
    
    long maxSize() default 5 * 1024 * 1024; // 5MB
    String[] allowedFormats() default {"JPEG", "PNG", "GIF"};
}
```

### AI 服務異常處理

```java
/**
 * AI 服務異常處理
 */
@RestControllerAdvice
public class AIServiceExceptionHandler {
    
    /**
     * 處理 AI 服務超時異常
     */
    @ExceptionHandler(AIServiceTimeoutException.class)
    public ResponseEntity<ApiResponse<Void>> handleAIServiceTimeout(
            AIServiceTimeoutException e) {
        
        ApiResponse<Void> response = ApiResponse.error(408, 
            "AI 服務回應超時，請稍後再試");
        return ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT).body(response);
    }
    
    /**
     * 處理 AI 服務配額超限異常
     */
    @ExceptionHandler(AIQuotaExceededException.class)
    public ResponseEntity<ApiResponse<Void>> handleAIQuotaExceeded(
            AIQuotaExceededException e) {
        
        ApiResponse<Void> response = ApiResponse.error(429, 
            "AI 服務使用量已達上限，請稍後再試");
        return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).body(response);
    }
    
    /**
     * 處理內容安全檢查失敗異常
     */
    @ExceptionHandler(ContentSafetyException.class)
    public ResponseEntity<ApiResponse<Void>> handleContentSafety(
            ContentSafetyException e) {
        
        ApiResponse<Void> response = ApiResponse.error(400, 
            "內容未通過安全檢查，請修改後重試");
        return ResponseEntity.badRequest().body(response);
    }
}
```

---

## 📝 本章重點回顧

1. **資料驗證重要性**：理解了資料驗證在系統安全和資料品質中的關鍵作用
2. **Bean Validation**：掌握了 Spring Boot 內建驗證框架的使用方法
3. **自訂驗證註解**：學會了建立符合業務需求的自訂驗證邏輯
4. **全域異常處理**：建立了統一的錯誤處理機制
5. **AI 服務準備**：為 Spring AI 的特殊驗證需求做好了準備

### 下一步學習方向

在下一章中，我們將學習檔案處理與多媒體支援，這對於 Spring AI 的多模態應用至關重要。

---

**參考資料：**
- [Bean Validation Specification](https://beanvalidation.org/)
- [Spring Boot Validation](https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc.validation)
- [Spring MVC Exception Handling](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-exceptionhandlers)


\newpage

## 3.1 檔案上傳與下載基礎


## 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解檔案處理的重要性**：掌握 Web 應用中檔案處理的核心概念和應用場景
- 🎯 **掌握 Spring Boot 檔案配置**：學會配置檔案上傳的基本參數和限制
- 🎯 **實作檔案上傳功能**：使用 MultipartFile 處理單檔案和多檔案上傳
- 🎯 **實現檔案下載服務**：建立安全可靠的檔案下載機制
- 🎯 **處理常見問題**：了解檔案處理中的安全性和效能考量

---

## 3.1.1 為什麼需要檔案處理？

### 檔案處理在現代應用中的重要性

在現代 Web 應用程式中，檔案處理是一項基礎且重要的功能。無論是社群媒體的照片分享、企業系統的文件管理，還是電商平台的商品圖片上傳，都離不開檔案處理機制。

> **思考問題**：您在日常使用的應用程式中，有哪些功能涉及到檔案上傳或下載？
> - 社群媒體上傳照片和影片
> - 雲端硬碟儲存和分享檔案
> - 線上辦公系統的文件協作
> - 電商平台的商品圖片管理

### 常見的檔案處理場景

**1. 使用者內容管理**
- 個人頭像上傳
- 文件附件處理
- 多媒體內容分享

**2. 企業文件系統**
- 合約文件上傳
- 報表檔案下載
- 備份檔案管理

**3. 電商應用**
- 商品圖片上傳
- 產品目錄下載
- 訂單相關文件

💡 **重點提示**：良好的檔案處理機制不僅要考慮功能實現，還要重視安全性、效能和使用者體驗。

---

## 3.1.2 檔案上傳基礎概念

### HTTP 檔案上傳原理

檔案上傳是透過 HTTP 協定的 `multipart/form-data` 編碼方式實現的。這種編碼方式允許在單一請求中傳送文字資料和二進位檔案。

**傳統表單 vs 檔案上傳表單**：

```html
<!-- 傳統表單 -->
<form method="post" action="/submit">
    <input type="text" name="username" />
    <input type="submit" value="提交" />
</form>

<!-- 檔案上傳表單 -->
<form method="post" action="/upload" enctype="multipart/form-data">
    <input type="file" name="file" />
    <input type="submit" value="上傳" />
</form>
```

### Spring Boot 中的檔案處理

Spring Boot 透過 `MultipartFile` 介面提供了簡潔的檔案處理方式：

```java
// MultipartFile 的核心方法
public interface MultipartFile {
    String getName();           // 取得表單欄位名稱
    String getOriginalFilename(); // 取得原始檔案名稱
    String getContentType();    // 取得檔案類型
    long getSize();            // 取得檔案大小
    byte[] getBytes();         // 取得檔案內容
    InputStream getInputStream(); // 取得輸入串流
    void transferTo(File dest); // 儲存檔案到指定位置
}
```

⚠️ **注意事項**：
- `MultipartFile` 只在請求處理期間有效
- 檔案內容會暫存在記憶體或臨時檔案中
- 處理完成後應及時清理資源

---

## 3.1.3 基本檔案上傳實作

### 1. 檔案上傳配置

首先在 [`application.properties`](application.properties) 中配置檔案上傳參數：

```properties
# 檔案上傳配置
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=50MB
spring.servlet.multipart.file-size-threshold=2KB

# 檔案儲存路徑
app.upload.path=./uploads
```

**配置說明**：

| 配置項目 | 說明 | 預設值 | 建議值 |
|---------|------|--------|--------|
| `max-file-size` | 單檔案最大大小 | 1MB | 10MB |
| `max-request-size` | 請求最大大小 | 10MB | 50MB |
| `file-size-threshold` | 記憶體暫存閾值 | 0 | 2KB |

### 2. 簡單檔案上傳控制器

```java
/**
 * 檔案上傳控制器
 * 提供基本的檔案上傳功能
 */
@RestController
@RequestMapping("/api/files")
@Slf4j
public class FileUploadController {
    
    @Value("${app.upload.path:./uploads}")
    private String uploadPath;
    
    /**
     * 單檔案上傳
     * @param file 上傳的檔案
     * @return 上傳結果
     */
    @PostMapping("/upload")
    public ResponseEntity<String> uploadFile(@RequestParam("file") MultipartFile file) {
        
        // 檢查檔案是否為空
        if (file.isEmpty()) {
            return ResponseEntity.badRequest().body("請選擇要上傳的檔案");
        }
        
        try {
            // 建立上傳目錄
            Path uploadDir = Paths.get(uploadPath);
            if (!Files.exists(uploadDir)) {
                Files.createDirectories(uploadDir);
            }
            
            // 產生唯一檔案名稱
            String fileName = System.currentTimeMillis() + "_" + file.getOriginalFilename();
            Path filePath = uploadDir.resolve(fileName);
            
            // 儲存檔案
            file.transferTo(filePath.toFile());
            
            log.info("檔案上傳成功: {}", fileName);
            return ResponseEntity.ok("檔案上傳成功: " + fileName);
            
        } catch (IOException e) {
            log.error("檔案上傳失敗", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("檔案上傳失敗: " + e.getMessage());
        }
    }
}
```

### 3. 多檔案上傳處理

```java
/**
 * 多檔案上傳
 * @param files 上傳的檔案陣列
 * @return 上傳結果
 */
@PostMapping("/upload-multiple")
public ResponseEntity<List<String>> uploadMultipleFiles(
        @RequestParam("files") MultipartFile[] files) {
    
    List<String> uploadedFiles = new ArrayList<>();
    
    for (MultipartFile file : files) {
        if (!file.isEmpty()) {
            try {
                String fileName = System.currentTimeMillis() + "_" + file.getOriginalFilename();
                Path filePath = Paths.get(uploadPath).resolve(fileName);
                file.transferTo(filePath.toFile());
                uploadedFiles.add(fileName);
                
            } catch (IOException e) {
                log.error("檔案上傳失敗: {}", file.getOriginalFilename(), e);
            }
        }
    }
    
    return ResponseEntity.ok(uploadedFiles);
}
```

🚀 **實用技巧**：使用時間戳記前綴可以避免檔案名稱衝突，同時保持檔案的可追蹤性。

---

## 3.1.4 檔案下載基礎實作

### 1. 簡單檔案下載

```java
/**
 * 檔案下載
 * @param fileName 檔案名稱
 * @return 檔案內容
 */
@GetMapping("/download/{fileName}")
public ResponseEntity<Resource> downloadFile(@PathVariable String fileName) {
    
    try {
        Path filePath = Paths.get(uploadPath).resolve(fileName);
        Resource resource = new UrlResource(filePath.toUri());
        
        if (resource.exists() && resource.isReadable()) {
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, 
                           "attachment; filename=\"" + fileName + "\"")
                    .body(resource);
        } else {
            return ResponseEntity.notFound().build();
        }
        
    } catch (MalformedURLException e) {
        log.error("檔案下載失敗: {}", fileName, e);
        return ResponseEntity.badRequest().build();
    }
}
```

### 2. 檔案預覽功能

```java
/**
 * 檔案預覽（適用於圖片等媒體檔案）
 * @param fileName 檔案名稱
 * @return 檔案內容
 */
@GetMapping("/preview/{fileName}")
public ResponseEntity<Resource> previewFile(@PathVariable String fileName) {
    
    try {
        Path filePath = Paths.get(uploadPath).resolve(fileName);
        Resource resource = new UrlResource(filePath.toUri());
        
        if (resource.exists() && resource.isReadable()) {
            // 根據檔案副檔名設定 Content-Type
            String contentType = Files.probeContentType(filePath);
            
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_TYPE, contentType)
                    .body(resource);
        } else {
            return ResponseEntity.notFound().build();
        }
        
    } catch (Exception e) {
        log.error("檔案預覽失敗: {}", fileName, e);
        return ResponseEntity.badRequest().build();
    }
}
```

---

## 3.1.5 常見問題與注意事項

### 1. 檔案安全性考量

**檔案類型驗證**：
```java
/**
 * 檢查檔案類型是否允許
 * @param file 上傳的檔案
 * @return 是否允許
 */
private boolean isAllowedFileType(MultipartFile file) {
    String contentType = file.getContentType();
    return contentType != null && (
        contentType.startsWith("image/") ||
        contentType.equals("application/pdf") ||
        contentType.equals("text/plain")
    );
}
```

**檔案大小限制**：
```java
/**
 * 檢查檔案大小
 * @param file 上傳的檔案
 * @return 是否符合大小限制
 */
private boolean isValidFileSize(MultipartFile file) {
    long maxSize = 10 * 1024 * 1024; // 10MB
    return file.getSize() <= maxSize;
}
```

### 2. 效能最佳化建議

✅ **最佳實踐**：
- 使用串流處理大檔案，避免記憶體溢位
- 實作檔案類型和大小驗證
- 使用唯一檔案名稱避免衝突
- 定期清理暫存檔案

⚠️ **常見陷阱**：
- 未驗證檔案類型可能導致安全風險
- 檔案名稱未處理可能造成路徑遍歷攻擊
- 缺乏檔案大小限制可能導致磁碟空間耗盡

### 3. 錯誤處理策略

```java
/**
 * 全域檔案處理異常處理器
 */
@ControllerAdvice
public class FileExceptionHandler {
    
    @ExceptionHandler(MaxUploadSizeExceededException.class)
    public ResponseEntity<String> handleMaxSizeException(MaxUploadSizeExceededException e) {
        return ResponseEntity.status(HttpStatus.PAYLOAD_TOO_LARGE)
                .body("檔案大小超過限制");
    }
    
    @ExceptionHandler(MultipartException.class)
    public ResponseEntity<String> handleMultipartException(MultipartException e) {
        return ResponseEntity.badRequest()
                .body("檔案上傳格式錯誤");
    }
}
```

---

## 重點摘要

### 🎯 核心概念回顧

1. **檔案處理的重要性**：
   - 現代 Web 應用的基礎功能
   - 涵蓋使用者內容、企業文件、電商應用等場景
   - 需要考慮安全性、效能和使用者體驗

2. **Spring Boot 檔案處理機制**：
   - 使用 `MultipartFile` 介面處理檔案上傳
   - 透過 `multipart/form-data` 編碼傳輸檔案
   - 支援單檔案和多檔案上傳

3. **基本實作要點**：
   - 正確配置檔案上傳參數
   - 實作檔案類型和大小驗證
   - 提供安全的檔案下載機制

### 💡 學習要點

- 檔案處理不僅是技術實作，更要重視安全性考量
- `MultipartFile` 提供了簡潔易用的檔案處理 API
- 適當的配置和驗證是檔案處理系統的基礎
- 錯誤處理和異常管理同樣重要

### 🚀 下一步行動

在下一章中，我們將學習更進階的檔案處理技術，包括：
- 檔案類型檢測和安全掃描
- 大檔案分塊上傳處理
- 檔案快取和 CDN 整合
- 檔案處理的監控和日誌記錄

---

> **章節總結**：檔案上傳與下載是 Web 應用程式中的基礎功能，Spring Boot 透過 MultipartFile 介面提供了簡潔而強大的檔案處理能力。掌握基本的檔案上傳下載實作，並重視安全性和效能考量，是建構可靠檔案處理系統的關鍵。在實際開發中，除了功能實現外，更要注重使用者體驗和系統穩定性。


\newpage

## 3.3 API 測試與文件化


> **本章重點**：掌握 API 測試工具和文件自動生成技術，建立完整的 API 品質保證體系，為生產級應用和 Spring AI 服務提供可靠的測試和文件化支援。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 API 測試的重要性**：掌握 API 測試在開發流程中的核心價值
- 🎯 **熟練使用測試工具**：掌握 Postman、curl 等 API 測試工具的使用
- 🎯 **實現 API 文件自動生成**：使用 Swagger/OpenAPI 建立完整的 API 文件
- 🎯 **建立測試最佳實踐**：設計有效的 API 測試策略和流程
- 🎯 **為 AI 服務做準備**：建立適合 AI 應用的測試和文件化方案

---

## 3.3.1 為什麼需要 API 測試？

### API 測試的核心價值

在現代 Web 開發中，API 是前後端溝通的橋樑，也是 AI 服務的重要介面。想像一下，如果您正在開發一個 AI 驅動的應用程式：

> **實際場景**：當用戶上傳圖片要求 AI 分析時，前端需要向後端 API 發送請求，AI 服務處理後回傳結果。如果這個 API 有問題，整個 AI 功能就無法正常運作。

**API 測試的核心價值**：
- ✅ **驗證功能正確性**：確保 API 按預期工作
- ✅ **提早發現問題**：在用戶使用前就發現並修復錯誤
- ✅ **提升開發效率**：快速測試不同情境，無需每次都透過前端介面
- ✅ **改善團隊協作**：前後端開發者可以用統一的方式驗證 API
- ✅ **支援 AI 服務測試**：驗證複雜的 AI 推理和多模態處理

### 不同類型的 API 測試

| 測試類型 | 目的 | 測試範圍 | 適用場景 |
|----------|------|----------|----------|
| **功能測試** | 驗證 API 功能正確性 | 單一 API 端點 | 基本 CRUD 操作 |
| **整合測試** | 驗證系統間協作 | 多個 API 端點 | 業務流程測試 |
| **效能測試** | 驗證回應時間和吞吐量 | 系統負載能力 | 高併發場景 |
| **安全測試** | 驗證安全機制 | 認證授權機制 | 敏感資料保護 |
| **AI 服務測試** | 驗證 AI 模型回應 | AI 推理準確性 | 智能功能驗證 |

---

## 3.3.2 使用 Postman 進行 API 測試

### Postman 基礎操作

**安裝和設定**：
1. 下載並安裝 Postman
2. 建立工作區（Workspace）
3. 建立集合（Collection）來組織 API 測試

**基本 HTTP 請求測試**：

```http
### 1. 獲取使用者列表
GET http://localhost:8080/api/users
Content-Type: application/json

### 2. 根據 ID 獲取使用者
GET http://localhost:8080/api/users/1
Content-Type: application/json

### 3. 建立新使用者
POST http://localhost:8080/api/users
Content-Type: application/json

{
  "name": "張小明",
  "email": "ming@example.com",
  "password": "securePassword123"
}

### 4. 更新使用者資訊
PUT http://localhost:8080/api/users/1
Content-Type: application/json

{
  "name": "張小明（已更新）",
  "email": "ming.updated@example.com"
}

### 5. 刪除使用者
DELETE http://localhost:8080/api/users/1
```

### 進階測試功能

**1. 環境變數設定**
```javascript
// 在 Postman 的 Pre-request Script 中設定
pm.environment.set("baseUrl", "http://localhost:8080");
pm.environment.set("userId", "1");

// 在請求 URL 中使用
{{baseUrl}}/api/users/{{userId}}
```

**2. 自動化測試腳本**
```javascript
// 在 Postman 的 Tests 標籤中編寫
pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

pm.test("Response has user data", function () {
    const jsonData = pm.response.json();
    pm.expect(jsonData).to.have.property('data');
    pm.expect(jsonData.data).to.have.property('id');
    pm.expect(jsonData.data).to.have.property('name');
});

pm.test("Response time is less than 500ms", function () {
    pm.expect(pm.response.responseTime).to.be.below(500);
});
```

**3. 資料驅動測試**
```csv
# users.csv
name,email,expectedStatus
張小明,ming@example.com,201
李小華,hua@example.com,201
王小美,invalid-email,400
```

---

## 3.3.3 使用 curl 進行命令列測試

### 基本 curl 命令

```bash
# GET 請求
curl -X GET "http://localhost:8080/api/users" \
     -H "Content-Type: application/json"

# POST 請求
curl -X POST "http://localhost:8080/api/users" \
     -H "Content-Type: application/json" \
     -d '{
       "name": "測試使用者",
       "email": "test@example.com",
       "password": "password123"
     }'

# PUT 請求
curl -X PUT "http://localhost:8080/api/users/1" \
     -H "Content-Type: application/json" \
     -d '{
       "name": "更新的使用者",
       "email": "updated@example.com"
     }'

# DELETE 請求
curl -X DELETE "http://localhost:8080/api/users/1" \
     -H "Content-Type: application/json"
```

### 進階 curl 功能

```bash
# 顯示詳細資訊
curl -v -X GET "http://localhost:8080/api/users"

# 儲存回應到檔案
curl -X GET "http://localhost:8080/api/users" -o users.json

# 包含認證標頭
curl -X GET "http://localhost:8080/api/users" \
     -H "Authorization: Bearer your-jwt-token"

# 上傳檔案
curl -X POST "http://localhost:8080/api/upload" \
     -F "file=@/path/to/your/file.jpg" \
     -F "description=測試圖片"

# 測試效能（顯示時間資訊）
curl -w "@curl-format.txt" -X GET "http://localhost:8080/api/users"
```

**curl-format.txt 內容**：
```
     time_namelookup:  %{time_namelookup}\n
        time_connect:  %{time_connect}\n
     time_appconnect:  %{time_appconnect}\n
    time_pretransfer:  %{time_pretransfer}\n
       time_redirect:  %{time_redirect}\n
  time_starttransfer:  %{time_starttransfer}\n
                     ----------\n
          time_total:  %{time_total}\n
```

---

## 3.3.4 API 文件自動生成

### 為什麼需要 API 文件？

API 文件就像是「使用指南」，對於開發團隊協作和第三方整合至關重要：

**沒有文件的痛點**：
```java
// 沒有文件的 API - 讓人困惑
@GetMapping("/users/{id}")
public ResponseEntity<?> getUser(@PathVariable String id) {
    // 這個 API 做什麼？
    // 參數格式是什麼？
    // 回傳什麼資料？
    // 可能的錯誤碼有哪些？
}
```

### 整合 Swagger/OpenAPI

**1. 添加依賴**
```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.2.0</version>
</dependency>
```

**2. 基本配置**
```java
@Configuration
public class OpenApiConfig {
    
    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("使用者管理系統 API")
                        .version("1.0.0")
                        .description("生產級 API 開發實踐範例")
                        .contact(new Contact()
                                .name("開發團隊")
                                .email("dev@example.com")
                                .url("https://example.com"))
                        .license(new License()
                                .name("MIT License")
                                .url("https://opensource.org/licenses/MIT")))
                .servers(Arrays.asList(
                        new Server().url("http://localhost:8080").description("開發環境"),
                        new Server().url("https://api.example.com").description("生產環境")
                ));
    }
}
```

### 使用 Swagger 註解

```java
@RestController
@RequestMapping("/api/users")
@Tag(name = "使用者管理", description = "使用者相關的 CRUD 操作")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    @Operation(
        summary = "獲取所有使用者",
        description = "獲取系統中所有使用者的列表，支援分頁和排序"
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "成功獲取使用者列表",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = ApiResponse.class)
            )
        ),
        @ApiResponse(
            responseCode = "500",
            description = "伺服器內部錯誤"
        )
    })
    @GetMapping
    public ResponseEntity<ApiResponse<List<User>>> getAllUsers(
            @Parameter(description = "頁碼，從 0 開始", example = "0")
            @RequestParam(defaultValue = "0") int page,
            
            @Parameter(description = "每頁大小", example = "10")
            @RequestParam(defaultValue = "10") int size) {
        
        Pageable pageable = PageRequest.of(page, size);
        Page<User> users = userService.findAll(pageable);
        return ResponseEntity.ok(ApiResponse.success("獲取成功", users.getContent()));
    }
    
    @Operation(
        summary = "根據 ID 獲取使用者",
        description = "根據使用者 ID 獲取特定使用者的詳細資訊"
    )
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<User>> getUserById(
            @Parameter(description = "使用者 ID", required = true, example = "1")
            @PathVariable Long id) {
        
        User user = userService.findById(id);
        return ResponseEntity.ok(ApiResponse.success("獲取成功", user));
    }
    
    @Operation(
        summary = "建立新使用者",
        description = "建立一個新的使用者帳號"
    )
    @PostMapping
    public ResponseEntity<ApiResponse<User>> createUser(
            @Parameter(description = "使用者建立請求", required = true)
            @Valid @RequestBody CreateUserRequest request) {
        
        User user = userService.createUser(request);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success("建立成功", user));
    }
}
```

### 為資料模型添加文件

```java
@Schema(description = "使用者資訊")
public class User {
    
    @Schema(description = "使用者 ID", example = "1", accessMode = Schema.AccessMode.READ_ONLY)
    private Long id;
    
    @Schema(description = "使用者名稱", example = "張小明", requiredMode = Schema.RequiredMode.REQUIRED)
    private String name;
    
    @Schema(description = "電子郵件地址", example = "ming@example.com", requiredMode = Schema.RequiredMode.REQUIRED)
    private String email;
    
    @Schema(description = "建立時間", example = "2024-01-15T10:30:00Z", accessMode = Schema.AccessMode.READ_ONLY)
    private LocalDateTime createdAt;
    
    // Getters and Setters
}

@Schema(description = "建立使用者請求")
public class CreateUserRequest {
    
    @Schema(description = "使用者名稱", example = "張小明", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotBlank(message = "使用者名稱不能為空")
    private String name;
    
    @Schema(description = "電子郵件地址", example = "ming@example.com", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotBlank(message = "電子郵件不能為空")
    @Email(message = "電子郵件格式不正確")
    private String email;
    
    @Schema(description = "密碼", example = "securePassword123", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotBlank(message = "密碼不能為空")
    @Size(min = 8, message = "密碼長度至少 8 字元")
    private String password;
    
    // Getters and Setters
}
```

---

## 3.3.5 為 Spring AI 做準備

### AI 服務的特殊測試需求

**1. 流式回應測試**
```bash
# 測試 AI 流式對話
curl -N -X POST "http://localhost:8080/api/ai/chat/stream" \
     -H "Content-Type: application/json" \
     -H "Accept: text/event-stream" \
     -d '{
       "message": "請介紹一下 Spring Boot",
       "temperature": 0.7
     }'
```

**2. 多媒體內容測試**
```bash
# 測試圖片分析 API
curl -X POST "http://localhost:8080/api/ai/analyze/image" \
     -F "image=@test-image.jpg" \
     -F "prompt=描述這張圖片的內容"

# 測試音訊轉文字 API
curl -X POST "http://localhost:8080/api/ai/transcribe" \
     -F "audio=@test-audio.wav" \
     -F "language=zh-TW"
```

### AI API 文件化範例

```java
@RestController
@RequestMapping("/api/ai")
@Tag(name = "AI 服務", description = "人工智慧相關的 API 服務")
public class AIController {
    
    @Operation(
        summary = "AI 對話服務",
        description = "與 AI 模型進行對話，支援上下文記憶"
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "對話成功",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = ChatResponse.class)
            )
        ),
        @ApiResponse(
            responseCode = "400",
            description = "請求參數錯誤"
        ),
        @ApiResponse(
            responseCode = "429",
            description = "請求頻率過高"
        )
    })
    @PostMapping("/chat")
    public ResponseEntity<ApiResponse<ChatResponse>> chat(
            @Parameter(description = "對話請求", required = true)
            @Valid @RequestBody ChatRequest request) {
        
        // 預留給 Spring AI 整合
        ChatResponse response = new ChatResponse("這是 AI 的回應");
        return ResponseEntity.ok(ApiResponse.success("對話成功", response));
    }
    
    @Operation(
        summary = "流式對話服務",
        description = "與 AI 模型進行流式對話，即時獲取回應"
    )
    @PostMapping(value = "/chat/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter chatStream(
            @Parameter(description = "流式對話請求", required = true)
            @Valid @RequestBody ChatRequest request) {
        
        SseEmitter emitter = new SseEmitter();
        // 預留給 Spring AI 流式處理
        return emitter;
    }
}

@Schema(description = "AI 對話請求")
public class ChatRequest {
    
    @Schema(description = "使用者訊息", example = "請介紹一下 Spring Boot", requiredMode = Schema.RequiredMode.REQUIRED)
    @NotBlank(message = "訊息不能為空")
    private String message;
    
    @Schema(description = "溫度參數，控制回應的隨機性", example = "0.7", minimum = "0", maximum = "2")
    @DecimalMin(value = "0.0", message = "溫度值必須大於等於 0")
    @DecimalMax(value = "2.0", message = "溫度值必須小於等於 2")
    private Double temperature = 0.7;
    
    @Schema(description = "最大 token 數", example = "1000", minimum = "1", maximum = "4096")
    @Min(value = 1, message = "最大 token 數必須大於 0")
    @Max(value = 4096, message = "最大 token 數不能超過 4096")
    private Integer maxTokens = 1000;
    
    // Getters and Setters
}
```

### 效能測試準備

```bash
# 使用 Apache Bench 進行壓力測試
ab -n 1000 -c 10 -H "Content-Type: application/json" \
   -p chat-request.json \
   http://localhost:8080/api/ai/chat

# 使用 wrk 進行更進階的效能測試
wrk -t12 -c400 -d30s --script=chat-test.lua \
    http://localhost:8080/api/ai/chat
```

**chat-test.lua 腳本**：
```lua
wrk.method = "POST"
wrk.body   = '{"message": "測試訊息", "temperature": 0.7}'
wrk.headers["Content-Type"] = "application/json"

function response(status, headers, body)
    if status ~= 200 then
        print("Error: " .. status .. " " .. body)
    end
end
```

---

## 📝 本章重點回顧

1. **API 測試重要性**：理解了 API 測試在開發流程中的核心價值
2. **測試工具使用**：掌握了 Postman 和 curl 的基本和進階功能
3. **API 文件化**：學會了使用 Swagger/OpenAPI 自動生成完整的 API 文件
4. **測試最佳實踐**：建立了有效的 API 測試策略和流程
5. **AI 服務準備**：為 Spring AI 的特殊測試需求做好了準備

### 下一步學習方向

完成第三章的學習後，我們已經建立了完整的生產級 API 開發技能。在第四章中，我們將正式進入 Spring AI 的世界，學習如何整合和使用 AI 服務。

---

**參考資料：**
- [Postman Documentation](https://learning.postman.com/docs/)
- [OpenAPI Specification](https://swagger.io/specification/)
- [SpringDoc OpenAPI](https://springdoc.org/)
- [curl Manual](https://curl.se/docs/manual.html)


\newpage


# 第四章：Spring AI 的誕生與價值 {.unnumbered .unlisted}


## 第四章前言：Spring AI 的誕生與價值


> **進入 AI 世界的準備**：在正式開始學習 Spring AI 之前，讓我們先了解這個革命性框架的誕生背景、核心價值，以及它為 Java 開發者帶來的無限可能。

---

## 🌱 Java 在 AI 領域看到了春天

![Spring AI](https://ithelp.ithome.com.tw/upload/images/20240810/20161290cAV3EcKpVN.jpg)

Spring AI 在2024年2月推出了0.8版本，經過一年多的快速迭代，於**2025年5月20日正式發佈了1.0.0 GA穩定版**。從早期的 Milestone 版本（1.0.0-M1到M8）到 RC1 版本，最終迎來了正式的 GA 版本，如同 AI 的發展一樣迅速。實際使用後，會發現它與 **LangChain4j** 有幾分相似。

### Spring AI 的官方定位

讓我們看看 Spring AI 官網是如何詮釋自己的使命：

> Spring AI 創建的目的在簡化開發 AI 功能的應用程式，同時避免不必要的複雜性。專案汲取了 LangChain 和 LlamaIndex 等知名 Python 專案的靈感，但 Spring AI 並不是這些專案的直接移植。我們相信，下一波生成式人工智慧應用程式不僅適用於 Python 開發人員，還將廣泛適用於許多程式設計語言。
>
> **Spring AI 的核心在於解決 AI 整合的根本挑戰，即將企業數據 / API / AI 串聯起來。**
>
> ![Spring AI 架構](https://ithelp.ithome.com.tw/upload/images/20240801/20161290yEyOlVWozQ.png)
>
> (以上由 [Spring AI官網](https://docs.spring.io/spring-ai/reference/index.html) 翻譯而來)

### 為什麼 Spring AI 如此重要？

原來 Spring AI 是跟 LangChain 致敬，Spring 框架能發展到這麼龐大，最關鍵的就是其**整合以及簡化的能力**。面對這麼龐大的模型以及種類，雖然跟 Python 比起來起步較慢，不過能與 Spring 其他框架整合在一起，讓憋了好久的 Java 開發人員也能大展身手了。

---

## 🚀 Java AI 框架的雙雄對決

既然是參考 LangChain 的概念，Java 開發人員該使用 LangChain4j 還是 Spring AI 做為開發框架？以下是詳細比較：

### 框架對比表 (2025年更新版)

|  | **Spring AI** | **LangChain4j** |
| --- | --- | --- |
| **推出時間** | 2024年二月推出0.8版，2025年5月正式發佈1.0.0 GA | 2023年六月推出0.1版 |
| **適用Java版本** | JDK 17+ | JDK 8+ |
| **當前版本** | 1.0.0 GA (穩定版) | 持續更新中，已有80+版本 |
| **功能性** | 整合性更佳，支援20+個AI模型，統一的ChatClient API，支援多模態輸入輸出 | 個別功能較強，部分功能針對不同大語言模型特性開發 |
| **整合性** | 原生支援Spring Boot 3.4.x，完美的自動配置和依賴注入 | 雖然也能在Spring中使用，但整合性不如Spring原生 |
| **核心特色** | ChatClient API、Advisor攔截器鏈、強化版LLM能力 | 豐富的工具生態、活躍的社群支援 |
| **向量資料庫支援** | 支援20+種向量資料庫（Chroma、PGVector、Redis等） | 支援多種向量資料庫 |
| **相關資料** | 官方文檔完整，1.0 GA版本文檔齊全 | 發展時間較長，社群資源豐富 |

### 選擇建議 (2025年更新)

- ✅ **如果公司還在使用 Java 8**：LangChain4j 是不二選擇
- ✅ **如果公司已使用 Spring Boot 3.4+**：當然就直接使用 Spring AI 1.0 GA
- ✅ **如果使用 Java 17+ 卻沒使用 Spring Boot**：建議你趕快學 Spring Boot
- ✅ **想嘗試最新功能或單純開發 AI 程式**：可使用 LangChain4j
- ✅ **要將 AI 結合企業內部其他資訊系統**：建議使用 Spring AI，因為開發企業使用的程式往往需要更高的穩定性以及精準的內容
- 🎯 **2025年重點**：Spring AI 1.0 GA 已經達到生產就緒標準，適合企業級應用開發

---

## 🎯 Spring AI 1.0 GA 的革命性特色

### 1. ChatClient - 統一的核心API

Spring AI 的核心是 **ChatClient**，這是一個可攜式且易於使用的 API，是與 AI 模型互動的主要介面。Spring AI 的 ChatClient 支援調用 **20+ 個 AI 模型**，從 Anthropic 到智譜AI。它支援多模態輸入和輸出（當底層模型支援時）以及結構化回應。

**特色**：
- 🔄 **統一介面**：一套 API 支援所有主流 AI 模型
- 🎨 **多模態支援**：文字、圖片、音訊的綜合處理
- 📊 **結構化輸出**：自動將 AI 回應轉換為 Java 物件
- 🚀 **流暢 API**：類似 WebClient 的鏈式調用風格

### 2. 增強版LLM功能

增強版LLM的概念是在基本模型互動的基礎上增加功能，如**資料檢索、對話記憶和工具調用**。這些功能讓您可以直接將自己的資料和外部API帶入模型的推理過程中。

**核心能力**：
- 🧠 **記憶管理**：讓 AI 記住對話歷史
- 🔍 **資料檢索**：整合企業內部資料庫
- 🛠️ **工具調用**：讓 AI 主動調用外部 API
- 📚 **知識增強**：RAG（檢索增強生成）技術

### 3. Advisor API - 攔截器鏈

Spring AI ChatClient 的一個關鍵特色是 **Advisor API**。這是一個攔截器鏈，允許您透過注入檢索到的資料和對話記憶來修改傳入的提示詞。

**應用場景**：
- 🔒 **安全控制**：在請求前後進行安全檢查
- 📝 **內容增強**：自動添加上下文資訊
- 📊 **監控記錄**：追蹤 AI 使用情況
- 🎯 **個性化**：根據用戶特徵調整回應

---

## 🏗️ Spring AI 與 Spring 生態系統的完美融合

### 架構基礎的天然優勢

Spring AI 並非憑空而生，而是深深植根於 Spring 生態系統之中：

- 🏗️ **架構基礎**：Spring AI 完全建構在 Spring Boot 之上，繼承了其所有核心特性和設計理念
- 🔧 **配置方式**：採用相同的自動配置（Auto Configuration）和「約定優於配置」（Convention over Configuration）原則
- 📦 **依賴管理**：透過 Spring Boot Starter 的方式提供各種 AI 功能模組
- 🚀 **部署模式**：使用 Spring Boot 的內嵌伺服器和 JAR 打包方式進行部署
- 🔄 **生命週期管理**：依賴 Spring 的 IoC 容器進行 Bean 管理和依賴注入

### API 開發在 Spring AI 中的核心地位

更重要的是，Spring AI 的許多核心功能都需要透過 **RESTful API** 來實現和整合：

- 🔗 **Function Calling**：AI 模型需要透過 REST API 呼叫外部工具和服務，實現與真實世界的互動
- 🖥️ **MCP Server**：模型控制協議（Model Context Protocol）伺服器需要 HTTP 端點來處理各種請求
- 🌐 **系統整合**：企業級 AI 應用通常需要與現有系統透過 API 進行整合
- 📊 **資料交換**：RAG（檢索增強生成）系統需要透過 API 獲取和處理各種資料來源
- 🔄 **即時互動**：聊天機器人和對話系統需要透過 WebSocket 或 Server-Sent Events 提供即時回應

---

## 🎓 學習路徑的戰略意義

### 為什麼要先學習 Spring Boot 和 Spring MVC？

在正式進入 Spring AI 的精彩世界之前，您可能會疑問：「為什麼需要先了解 Spring Boot 和 Spring MVC？」這是一個非常好的問題。

### 本書的學習架構

基於以上考量，本書採用循序漸進的學習方式：

**第一部分：Spring Boot 基礎**
- 建立堅實的 Spring Boot 開發基礎
- 掌握現代 Java 企業級開發的核心技能
- 理解 Spring AI 所依賴的核心框架特性

**第二部分：Spring MVC 與 API 開發**
- 學習如何建立和配置 RESTful API
- 掌握請求處理、回應格式化和錯誤處理
- 熟悉企業級 API 開發的最佳實踐
- 為 Spring AI 的 Function Calling 和 MCP Server 奠定基礎

**第三部分：生產級 API 開發實踐**
- 深入學習資料驗證、錯誤處理和檔案上傳
- 掌握 API 測試和文件自動生成
- 建立完整的生產級 API 開發技能

**第四部分：Spring AI 實戰**
- 在前三部分的基礎上，深入學習 Spring AI
- 建構實際的企業級 RAG 知識庫系統
- 整合各種 AI 服務和工具

### 學習建議

> 💡 **給有經驗的開發者**：如果您對 Spring Boot 和 Spring MVC 已經非常熟悉，可以快速瀏覽前三部分，或直接跳至第四章開始學習 Spring AI。

> 🎯 **給初學者**：強烈建議按照順序學習。紮實的基礎將讓您在後續的 Spring AI 學習中事半功倍，更能理解框架設計的精妙之處。

> 🚀 **給企業開發者**：本書不僅教授技術實現，更注重企業級應用的實際需求，包括安全性、效能優化、監控和維護等方面。

---

## 🌟 Spring AI 的未來展望

### 企業級 AI 應用的新紀元

Spring AI 1.0 GA 的發布標誌著 Java 生態系統在 AI 領域的正式崛起。它不僅僅是一個技術框架，更是企業數位轉型的重要工具：

- 🏢 **企業就緒**：生產級的穩定性和可靠性
- 🔧 **開發友好**：熟悉的 Spring 開發模式
- 🌐 **生態完整**：與 Spring 全家桶的無縫整合
- 🚀 **創新驅動**：持續的功能更新和社群支援

### 技術趨勢的引領者

Spring AI 正在引領以下技術趨勢：

1. **統一化 AI 介面**：一套 API 支援所有主流 AI 模型
2. **企業級 AI 整合**：將 AI 能力深度整合到企業系統中
3. **多模態應用開發**：支援文字、圖片、音訊的綜合處理
4. **智能化工具調用**：讓 AI 主動與外部系統互動
5. **記憶增強對話**：建立具有長期記憶的智能助手

---

## 🎯 準備開始您的 Spring AI 之旅

現在，您已經了解了 Spring AI 的誕生背景、核心價值和技術優勢。接下來，我們將正式進入第四章「認識 Spring AI」，開始這趟精彩的學習之旅。

在第四章中，您將學習到：
- 如何取得和配置 AI 服務的 API Key
- 建立第一個 Spring AI 應用程式
- 實現像 ChatGPT 一樣的流式輸出
- 深入理解 ChatModel 和 ChatClient 的架構
- 掌握前端處理流式輸出的技巧

讓我們開始這趟精彩的學習之旅，從 Spring Boot 的基礎開始，一步步建構您的 AI 應用開發能力！

---

**🚀 下一步：進入第四章「認識 Spring AI」，開始您的 AI 開發實戰！**


\newpage

## 4.1 取得 AI 入門鑰匙 API key


> **第四章導讀**：歡迎進入 Spring AI 的世界！本章將帶您從零開始學習 Spring AI 的核心概念和基礎應用，為後續的企業級 RAG 知識庫開發奠定堅實基礎。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **取得 AI 服務 API Key**：學會申請和配置各種 AI 服務的 API 金鑰
- 🎯 **理解 AI 服務成本**：掌握不同 AI 模型的定價策略和成本控制
- 🎯 **配置開發環境**：為 Spring AI 開發準備必要的認證資訊
- 🎯 **選擇合適的 AI 服務**：了解各種 AI 服務提供商的特點和適用場景
- 🎯 **建立安全的配置管理**：學會安全地管理 API 金鑰和敏感資訊

---

## 4.1.1 為什麼需要 API Key？

### 開啟 AI 的鑰匙

![AI API Key](https://ithelp.ithome.com.tw/upload/images/20240810/20161290sQLWvAdoDT.jpg)

平常使用 ChatGPT 或其他類似的對話 AI 都可直接使用，大不了額度沒了會降為效果比較差的模型，不過要進行程式開發就需要先申請 API key，除非使用本地的 LLM。

**API Key 的重要性**：
- 🔐 **身份認證**：證明您有權限使用 AI 服務
- 💰 **計費管理**：追蹤和控制 API 使用成本
- 🚦 **流量控制**：管理 API 呼叫頻率和配額
- 📊 **使用統計**：監控 API 使用情況和效能
- 🛡️ **安全保護**：防止未授權的 API 存取

### AI 服務成本革命

原本凱文大叔測試 AI 都以本地 LLM 或是一些免費的服務為主，不過 2025 年 8 月 [OpenAI 正式發布 GPT-5](https://openai.com/index/introducing-gpt-5/) 系列模型後就完全改觀了：

**GPT-5 革命性優勢**：
- 🚀 **統一系統**：結合推理和快速回應的統一 AI 模型
- 💡 **超強性能**：數學能力 94.6%，編程能力 74.9%，減少 45% 錯誤率
- 💰 **彈性定價**：GPT-5 Nano 只需 $0.05/百萬 Token，超低成本入門
- ⚡ **多層選擇**：從 Nano 到完整版 GPT-5，滿足不同需求
- 🎯 **降低門檻**：讓原本猶豫不決的開發人員一起加入 AI 的賽道

---

## 4.1.2 主要 AI 服務提供商

### OpenAI - 業界標竿

**申請步驟**：
1. **註冊帳號**：前往 [OpenAI Platform](https://platform.openai.com/)
2. **驗證身份**：提供手機號碼進行驗證
3. **建立 API Key**：
   - 點擊右上角個人頭像
   - 選擇「View API keys」
   - 點擊「Create new secret key」
   - 為 Key 命名（如：spring-ai-demo）
   - 複製並安全保存 API Key

**重要提醒**：
```
⚠️ API Key 只會顯示一次，請務必立即複製並安全保存！
```

**OpenAI 模型選擇**：

| 模型 | 適用場景 | 成本 | 特點 | 定價 (每百萬 Token) |
|------|----------|------|------|-------------------|
| **GPT-5** | 最複雜任務、專業級應用 | 極高 | 🚀 2025最新旗艦，統一推理系統 | 輸入$1.25 / 輸出$10 |
| **GPT-5 Mini** | 平衡型選擇、商業應用 | 中高 | ⚡ 中等性能，支援推理功能 | 輸入$0.25 / 輸出$2 |
| **GPT-5 Nano** | 開發測試、輕量應用 | 低 | 💡 輕量高效，入門推薦 | 輸入$0.05 / 輸出$0.40 |
| **o1** | 複雜推理、數學、編程 | 極高 | 🧠 深度思考推理專家 | - |
| **GPT-4o mini** | 舊版輕量選擇 | 低 | 📊 經典性價比選擇 | - |

### Groq - 高速推理

**特色**：
- ⚡ **超高速度**：推理速度極快
- 🆓 **免費使用**：目前提供免費服務
- 🎯 **開發友好**：適合開發和測試階段

**申請步驟**：
1. 前往 [Groq Console](https://console.groq.com/)
2. 使用 Google 或 GitHub 帳號登入
3. 在 API Keys 頁面建立新的 API Key
4. 複製並保存 API Key

### Anthropic Claude - 最新智能選擇

**2025 年最強寫程式 AI**：
- 🧠 **Claude 4 系列**：業界最新的智能模型
- 🎯 **多模態能力**：支援文字、圖片、PDF 處理
- 💡 **思考功能**：Claude Opus 4.1 具備透明推理過程
- 🔧 **工具整合**：完整支援函數調用和工具使用
- 💰 **彈性定價**：從便宜的 Haiku 到強大的 Opus

**申請步驟**：
1. **註冊帳號**：前往 [Anthropic Console](https://console.anthropic.com/)
2. **建立 API Key**：
   - 登入後進入 [API Keys](https://console.anthropic.com/settings/keys)
   - 點擊「Create Key」
   - 為 Key 命名並設定權限
   - 複製並安全保存 API Key

**Claude 模型選擇**：

| 模型 | 適用場景 | 成本 | 特點 |
|------|----------|------|------|
| **Claude Opus 4.1** | 最複雜的推理任務 | 極高 | 最強智能，編碼專家 |
| **Claude Sonnet 4** | 平衡型選擇 | 高 | 高效能，100萬 Token 語境 |

---

## 4.1.3 API Key 配置與管理

### Spring Boot 配置方式

**1. application.yml 配置**
```yaml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      base-url: https://api.openai.com
      chat:
        options:
          model: gpt-5-nano
    
    # Anthropic Claude 配置
    anthropic:
      api-key: ${ANTHROPIC_API_KEY}
      chat:
        options:
          model: claude-sonnet-4-0
    
    # Groq 配置範例
    groq:
      api-key: ${GROQ_API_KEY}
      chat:
        options:
          model: llama-3.1-70b-versatile
```

**2. 環境變數設定**
```bash
# Windows PowerShell
$env:OPENAI_API_KEY="your-openai-api-key-here"
$env:ANTHROPIC_API_KEY="your-anthropic-api-key-here"
$env:GROQ_API_KEY="your-groq-api-key-here"

# Linux/macOS
export OPENAI_API_KEY="your-openai-api-key-here"
export ANTHROPIC_API_KEY="your-anthropic-api-key-here"
export GROQ_API_KEY="your-groq-api-key-here"
```

**3. IDE 環境變數配置**

在 STS4 中配置環境變數：
1. 右鍵點擊專案 → Run As → Run Configurations
2. 選擇 Spring Boot App
3. 切換到 Environment 標籤
4. 新增環境變數：
   - Name: `OPENAI_API_KEY`
   - Value: `your-api-key-here`

### 安全最佳實踐

**1. 絕不將 API Key 寫入程式碼**
```java
// ❌ 錯誤做法 - 硬編碼 API Key
public class BadExample {
    private static final String API_KEY = "sk-1234567890abcdef"; // 危險！
}

// ✅ 正確做法 - 使用環境變數或注入 OpenAiApi
@Value("${spring.ai.openai.api-key}")
private String apiKey;

// 或者使用官方推薦的方式
@Autowired
private OpenAiApi openAiApi;
```

**2. 使用 .env 檔案（開發環境）**
```properties
# .env 檔案
OPENAI_API_KEY=your-openai-api-key-here
GROQ_API_KEY=your-groq-api-key-here
```

**重要提醒**：
```
⚠️ 務必將 .env 檔案加入 .gitignore，避免意外提交到版本控制系統！
```

---

## 4.1.4 成本控制與監控

### OpenAI 成本管理

**1. 設定使用限制**
- 在 OpenAI Platform 設定月度預算上限
- 配置使用量警告通知
- 監控 API 呼叫統計

**2. 模型選擇策略**
```java
@Service
public class AIModelSelector {
    
    // 開發環境使用便宜的模型
    @Profile("dev")
    @Bean
    public OpenAiChatModel devChatModel(OpenAiApi openAiApi) {
        return OpenAiChatModel.builder()
            .openAiApi(openAiApi)
            .options(OpenAiChatOptions.builder()
                .model("gpt-5-nano") // 最便宜的選項
                .build())
            .build();
    }
    
    // 生產環境使用高性能模型
    @Profile("prod")
    @Bean
    public OpenAiChatModel prodChatModel(OpenAiApi openAiApi) {
        return OpenAiChatModel.builder()
            .openAiApi(openAiApi)
            .options(OpenAiChatOptions.builder()
                .model("gpt-5") // 最強統一系統
                .build())
            .build();
    }
}
```

### 使用量監控

**1. 建立使用統計**
```java
@Component
public class AIUsageTracker {
    
    private final MeterRegistry meterRegistry;
    private final Counter apiCallCounter;
    private final Timer responseTimer;
    
    public AIUsageTracker(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.apiCallCounter = Counter.builder("ai.api.calls")
            .description("AI API calls count")
            .register(meterRegistry);
        this.responseTimer = Timer.builder("ai.api.response.time")
            .description("AI API response time")
            .register(meterRegistry);
    }
    
    public void recordApiCall(String model, Duration responseTime) {
        apiCallCounter.increment(Tags.of("model", model));
        responseTimer.record(responseTime);
    }
}
```

**2. 成本預估工具**
```java
@Service
public class CostEstimator {
    
    // GPT-5 nano 定價（每 1M tokens）- 2025年8月最新
    private static final double INPUT_COST_PER_MILLION = 0.05;  // $0.05
    private static final double OUTPUT_COST_PER_MILLION = 0.40; // $0.40
    
    public double estimateCost(int inputTokens, int outputTokens) {
        double inputCost = (inputTokens / 1_000_000.0) * INPUT_COST_PER_MILLION;
        double outputCost = (outputTokens / 1_000_000.0) * OUTPUT_COST_PER_MILLION;
        return inputCost + outputCost;
    }
}
```

---

## 4.1.5 多服務提供商配置

### 彈性切換策略

```java
@Configuration
public class MultiAIProviderConfig {
    
    @Value("${app.ai.provider:openai}")
    private String aiProvider;
    
    @Bean
    @Primary
    public ChatModel primaryChatModel(
            @Qualifier("openaiChatModel") ChatModel openaiModel,
            @Qualifier("anthropicChatModel") ChatModel anthropicModel,
            @Qualifier("groqChatModel") ChatModel groqModel) {
        
        return switch (aiProvider.toLowerCase()) {
            case "anthropic", "claude" -> anthropicModel;
            case "groq" -> groqModel;
            case "openai" -> openaiModel;
            default -> openaiModel;
        };
    }
    
    @Bean("openaiChatModel")
    public OpenAiChatModel openaiChatModel(OpenAiApi openAiApi) {
        return OpenAiChatModel.builder()
            .openAiApi(openAiApi)
            .options(OpenAiChatOptions.builder()
                .model("gpt-5-nano")
                .build())
            .build();
    }
    
    @Bean("anthropicChatModel")
    public AnthropicChatModel anthropicChatModel() {
        var anthropicApi = new AnthropicApi(anthropicApiKey);
        return AnthropicChatModel.builder()
            .anthropicApi(anthropicApi)
            .defaultOptions(AnthropicChatOptions.builder()
                .model("claude-sonnet-4-0")
                .temperature(0.7)
                .maxTokens(1000)
                .build())
            .build();
    }
    
    @Bean("groqChatModel")
    public OpenAiChatModel groqChatModel() {
        // Groq 使用 OpenAI 相容 API
        var groqApi = OpenAiApi.builder()
            .apiKey(groqApiKey)
            .baseUrl("https://api.groq.com/openai/v1")
            .build();
        
        return OpenAiChatModel.builder()
            .openAiApi(groqApi)
            .options(OpenAiChatOptions.builder()
                .model("llama-3.1-70b-versatile")
                .build())
            .build();
    }
}
```

### 容錯機制

```java
@Service
public class ResilientAIService {
    
    private final List<ChatModel> chatModels;
    
    public ResilientAIService(
            @Qualifier("openaiChatModel") ChatModel openaiModel,
            @Qualifier("anthropicChatModel") ChatModel anthropicModel,
            @Qualifier("groqChatModel") ChatModel groqModel) {
        this.chatModels = List.of(openaiModel, anthropicModel, groqModel);
    }
    
    public String chat(String message) {
        for (ChatModel model : chatModels) {
            try {
                return model.call(message);
            } catch (Exception e) {
                log.warn("AI service failed, trying next provider: {}", e.getMessage());
            }
        }
        throw new RuntimeException("All AI services are unavailable");
    }
}
```

---

## 📝 本章重點回顧

1. **API Key 重要性**：理解了 API Key 在 AI 服務中的關鍵作用
2. **服務提供商選擇**：掌握了 OpenAI、Groq、Azure 等主要服務商的特點
3. **安全配置管理**：學會了安全地管理和配置 API 金鑰
4. **成本控制策略**：了解了如何監控和控制 AI 服務使用成本
5. **多服務商整合**：建立了彈性的多服務商切換機制

### 下一步學習方向

在下一章中，我們將使用取得的 API Key 建立第一個 Spring AI 應用程式，體驗「Hello AI World」的魅力。

---

**參考資料：**
- [OpenAI Platform Documentation](https://platform.openai.com/docs)
- [Groq API Documentation](https://console.groq.com/docs)
- [Azure OpenAI Service](https://azure.microsoft.com/en-us/products/ai-services/openai-service)
- [Spring AI Reference Guide](https://docs.spring.io/spring-ai/reference/)


\newpage

## 4.2 Hello AI World


> **本章重點**：建立第一個 Spring AI 應用程式，體驗 AI 對話的魅力，掌握 ChatClient 和 ChatModel 的基本使用方法。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **建立第一個 Spring AI 應用**：使用 Spring Boot 整合 AI 服務
- 🎯 **理解 ChatClient 與 ChatModel**：掌握兩種 AI 介面的差異和使用場景
- 🎯 **實現基本 AI 對話功能**：建立可與 AI 互動的 RESTful API
- 🎯 **配置 Spring AI 環境**：正確設定依賴和配置檔案
- 🎯 **測試 AI 應用程式**：驗證 AI 功能的正確性

---

## 4.2.1 Spring AI 架構概述

### Hello AI World

![Hello AI World](https://ithelp.ithome.com.tw/upload/images/20240810/201612902bf1GgYwyV.jpg)

寫程式不免俗要來個 Hello World，依據開發 Spring Boot 程式的經驗，我們只需定義變數，並透過自動注入的機制就能開始使用，為了測試方便直接寫個 API。

### Spring AI 1.0 GA 架構說明

在 Spring AI 1.0 正式版中，ChatClient 和 ChatModel 的關係如下：

```
┌─────────────────────────────────────────────────┐
│                  ChatClient                     │
│  ┌─────────────────────────────────────────┐    │
│  │            Fluent API                   │    │
│  │  .prompt().user().call().content()      │    │
│  └─────────────────────────────────────────┘    │
│                     │                           │
│                     ▼                           │
│  ┌─────────────────────────────────────────┐    │
│  │              ChatModel                  │    │
│  │     (OpenAI, Azure, Google, etc.)       │    │
│  └─────────────────────────────────────────┘    │
└─────────────────────────────────────────────────┘
```

**核心組件說明**：
- **ChatModel**: 提供底層的 AI 模型介面，是與各種 AI 提供商（OpenAI、Azure、Google 等）溝通的核心抽象層
- **ChatClient**: 提供更高級的 Fluent API，類似於 Spring 生態系統中的 RestClient、WebClient 和 JdbcClient，內部依賴 ChatModel 來執行實際的 AI 呼叫

---

## 4.2.2 專案建立與依賴配置

### Maven 依賴配置

首先確保使用最新的 Spring AI 版本。在 `pom.xml` 中加入：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>spring-ai-hello-world</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>spring-ai-hello-world</name>
    <description>Spring AI Hello World Demo</description>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <!-- 使用 Spring AI BOM 管理版本 -->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.ai</groupId>
                <artifactId>spring-ai-bom</artifactId>
                <version>1.0.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <dependencies>
        <!-- Spring AI OpenAI Starter -->
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-starter-model-openai</artifactId>
        </dependency>
        
        <!-- Spring Boot Web Starter -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Lombok for cleaner code -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Spring Boot Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### 配置檔案設定

在 `application.yml` 中設定 AI 服務配置：

```yaml
spring:
  application:
    name: spring-ai-hello-world
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      base-url: https://api.openai.com
      chat:
        options:
          model: gpt-5-nano
          temperature: 0.7
          maxCompletionTokens: 1000

# 應用程式配置
server:
  port: 8080

# 日誌配置
logging:
  level:
    org.springframework.ai: DEBUG
    com.example: DEBUG
```

---

## 4.2.3 使用 ChatClient 實現 AI 對話

### 基本 AI 控制器

使用現代化的 ChatClient Fluent API：

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/ai")
@RequiredArgsConstructor
@Slf4j
public class AiController {
    
    private final ChatClient chatClient;

    /**
     * 基本 AI 對話端點
     * @param prompt 使用者輸入的提示詞
     * @return AI 的回應
     */
    @GetMapping("/chat")
    public String chat(@RequestParam String prompt) {
        log.info("收到 AI 對話請求：{}", prompt);
        
        String response = chatClient.prompt()
                .user(prompt)
                .call()
                .content();
        
        log.info("AI 回應：{}", response);
        return response;
    }
    
    /**
     * 帶有系統提示詞的 AI 對話
     * @param prompt 使用者輸入
     * @return AI 回應
     */
    @PostMapping("/chat/system")
    public String chatWithSystem(@RequestBody ChatRequest request) {
        return chatClient.prompt()
                .system(request.getSystemMessage())
                .user(request.getUserMessage())
                .call()
                .content();
    }
    
    /**
     * Hello World 專用端點
     * @return AI 生成的 Hello World 程式
     */
    @GetMapping("/hello-world")
    public String helloWorld() {
        String prompt = "請用 Java Spring Boot 寫一個 Hello World 程式，" +
                       "包含一個簡單的 REST API 端點";
        
        return chatClient.prompt()
                .system("你是一個專業的 Java 開發專家，" +
                       "請提供清晰、可執行的程式碼範例")
                .user(prompt)
                .call()
                .content();
    }
}
```

### 請求 DTO 類別

```java
package com.example.dto;

import lombok.Data;

@Data
public class ChatRequest {
    private String systemMessage;
    private String userMessage;
}
```

### 程式碼重點說明

**核心註解**：
- **@RestController**: 專門用來開發 API 的標註
- **@RequiredArgsConstructor**: Lombok 提供的快速標註，可幫我們寫一個建構子並將 final 變數當作參數
- **@Slf4j**: Lombok 提供的日誌標註

**ChatClient Fluent API**：
- **chatClient.prompt()**: 開始建立聊天請求的 Fluent API
- **system()**: 設定系統提示詞（定義 AI 的角色和行為）
- **user()**: 設定使用者訊息
- **call()**: 執行同步請求
- **content()**: 取得回應內容

---

## 4.2.4 ChatClient 自動配置與客製化

### 預設自動配置

Spring Boot 會自動為我們配置 ChatClient，但我們也可以自定義配置：

```java
package com.example.config;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AiConfig {
    
    /**
     * 自定義 ChatClient 配置
     * @param builder ChatClient 建構器
     * @return 配置好的 ChatClient
     */
    @Bean
    public ChatClient chatClient(ChatClient.Builder builder) {
        return builder
                .defaultSystem("你是一個友善且專業的 AI 助手，" +
                             "專門協助 Java Spring Boot 開發。" +
                             "請用繁體中文回答，並提供實用的程式碼範例。")
                .build();
    }
    
    /**
     * 專門用於程式碼生成的 ChatClient
     * @param builder ChatClient 建構器
     * @return 程式碼生成專用的 ChatClient
     */
    @Bean("codeChatClient")
    public ChatClient codeChatClient(ChatClient.Builder builder) {
        return builder
                .defaultSystem("你是一個資深的 Java 開發專家。" +
                             "請提供高品質、可執行的程式碼，" +
                             "包含適當的註解和最佳實踐。")
                .build();
    }
}
```

### 使用特定的 ChatClient

```java
@RestController
@RequestMapping("/api/code")
@RequiredArgsConstructor
public class CodeGeneratorController {
    
    @Qualifier("codeChatClient")
    private final ChatClient codeChatClient;
    
    @GetMapping("/generate")
    public String generateCode(@RequestParam String description) {
        return codeChatClient.prompt()
                .user("請根據以下描述生成 Java 程式碼：" + description)
                .call()
                .content();
    }
}
```

---

## 4.2.5 ChatModel 直接使用方式

### 底層 API 使用

如果需要更直接的控制，也可以直接使用 ChatModel：

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.chat.prompt.PromptTemplate;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/model")
@RequiredArgsConstructor
public class AiModelController {
    
    private final ChatModel chatModel;

    /**
     * 使用 ChatModel 的簡單對話
     * @param prompt 使用者輸入
     * @return AI 回應
     */
    @GetMapping("/chat")
    public String chatWithModel(@RequestParam String prompt) {
        return chatModel.call(prompt);
    }
    
    /**
     * 使用 PromptTemplate 的進階對話
     * @param topic 話題
     * @param style 風格
     * @return AI 回應
     */
    @GetMapping("/chat/template")
    public String chatWithTemplate(
            @RequestParam String topic,
            @RequestParam(defaultValue = "專業") String style) {
        
        String template = "請以{style}的風格，詳細說明{topic}的相關知識";
        
        PromptTemplate promptTemplate = new PromptTemplate(template);
        Prompt prompt = promptTemplate.create(Map.of(
            "topic", topic,
            "style", style
        ));
        
        return chatModel.call(prompt).getResult().getOutput().getContent();
    }
}
```

---

## 4.2.6 測試 AI 應用程式

### 使用 Postman 測試

**1. 基本對話測試**
```
GET http://localhost:8080/api/ai/chat?prompt=你好，請介紹一下Spring AI
```

**2. Hello World 測試**
```
GET http://localhost:8080/api/ai/hello-world
```

**3. 系統提示詞測試**
```
POST http://localhost:8080/api/ai/chat/system
Content-Type: application/json

{
    "systemMessage": "你是一個幽默的程式設計師",
    "userMessage": "解釋什麼是遞迴"
}
```

### 使用 curl 測試

```bash
# 基本對話
curl -X GET "http://localhost:8080/api/ai/chat?prompt=使用Spring AI寫一個Hello World程式"

# Hello World 專用端點
curl -X GET "http://localhost:8080/api/ai/hello-world"

# 帶系統提示詞的對話
curl -X POST "http://localhost:8080/api/ai/chat/system" \
     -H "Content-Type: application/json" \
     -d '{
       "systemMessage": "你是一個資深的Java開發專家",
       "userMessage": "請解釋Spring Boot的自動配置原理"
     }'
```

### 單元測試

```java
package com.example.controller;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureWebMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureWebMvc
class AiControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    void testChatEndpoint() throws Exception {
        mockMvc.perform(get("/api/ai/chat")
                .param("prompt", "Hello"))
                .andExpect(status().isOk())
                .andExpect(content().string(org.hamcrest.Matchers.not(org.hamcrest.Matchers.emptyString())));
    }
    
    @Test
    void testHelloWorldEndpoint() throws Exception {
        mockMvc.perform(get("/api/ai/hello-world"))
                .andExpect(status().isOk())
                .andExpect(content().string(org.hamcrest.Matchers.containsString("Spring Boot")));
    }
}
```

---

## 4.2.7 ChatClient vs ChatModel 使用時機

### 選擇指南

**使用 ChatClient 當你需要**：
- ✅ 複雜的提示詞組合
- ✅ 系統提示詞設定
- ✅ 流式輸出（下一章介紹）
- ✅ 更豐富的 API 功能
- ✅ 現代化的 Fluent API 體驗

**使用 ChatModel 當你需要**：
- ✅ 簡單直接的 AI 呼叫
- ✅ 更底層的控制
- ✅ 原始的 Prompt 物件操作
- ✅ 自定義複雜的提示詞模板

### 效能比較

```java
@Service
public class PerformanceComparisonService {
    
    private final ChatClient chatClient;
    private final ChatModel chatModel;
    
    // ChatClient 方式（推薦）
    public String useChatClient(String message) {
        return chatClient.prompt()
                .user(message)
                .call()
                .content();
    }
    
    // ChatModel 方式（底層）
    public String useChatModel(String message) {
        return chatModel.call(message);
    }
}
```

---

## 📝 本章重點回顧

1. **Spring AI 架構理解**：掌握了 ChatClient 與 ChatModel 的關係和差異
2. **專案建立**：學會了配置 Spring AI 依賴和基本設定
3. **ChatClient 使用**：熟練使用現代化的 Fluent API 進行 AI 對話
4. **自定義配置**：了解如何客製化 ChatClient 的行為
5. **測試方法**：掌握了多種測試 AI 應用的方法

### 下一步學習方向

在下一章中，我們將學習如何實現流式輸出，讓 AI 回應像 ChatGPT 一樣即時顯示，大幅提升使用者體驗。

---

**參考資料：**
- [Spring AI ChatClient Documentation](https://docs.spring.io/spring-ai/reference/api/chatclient.html)
- [Spring AI ChatModel Documentation](https://docs.spring.io/spring-ai/reference/api/chatmodel.html)
- [OpenAI Spring Boot Starter](https://docs.spring.io/spring-ai/reference/api/chat/openai-chat.html)


\newpage

## 4.3 如何像 ChatGPT 產生流式輸出


> **本章重點**：學習實現 AI 流式輸出功能，讓使用者體驗如同 ChatGPT 般的即時回應效果，大幅提升應用程式的互動性和使用者滿意度。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解流式輸出原理**：掌握 Server-Sent Events (SSE) 的工作機制
- 🎯 **實現 AI 流式回應**：使用 ChatClient 建立流式 AI 對話功能
- 🎯 **優化使用者體驗**：讓 AI 回應即時顯示，避免長時間等待
- 🎯 **處理流式資料**：掌握 Reactive Streams 和背壓處理
- 🎯 **前端整合技術**：學會使用 EventSource 接收流式資料

---

## 4.3.1 為什麼需要流式輸出？

### 使用者體驗的革命

![流式輸出](https://ithelp.ithome.com.tw/upload/images/20240810/20161290gaE6Faz85x.jpg)

由於 AI 產生內容得靠伺服器運算後產生結果，資料多的話得等不少時間，若能產生資料後馬上分段送出，可大大提升使用者感受。

**傳統同步回應 vs 流式輸出**：

```
傳統方式：
使用者提問 → [等待 10 秒] → 完整回應顯示

流式輸出：
使用者提問 → [0.5秒] 開始顯示 → [持續更新] → 完整回應
```

**流式輸出的優勢**：
- ⚡ **即時反饋**：使用者立即看到 AI 開始回應
- 🎯 **降低焦慮**：避免長時間等待造成的不確定感
- 📱 **更好的互動性**：類似真人對話的體驗
- 🚀 **感知效能提升**：雖然總時間相同，但感覺更快
- 💡 **早期中斷**：使用者可以提前判斷回應品質

### Server-Sent Events (SSE) 技術

要達到這種效果主要靠的是 **Server-Sent Events (SSE)** 伺服器主動推播協定：

**SSE 特點**：
- 📡 **單向通訊**：伺服器向客戶端推送資料
- 🔄 **自動重連**：連線中斷時自動重新連接
- 🌐 **標準協定**：基於 HTTP，廣泛支援
- 💻 **瀏覽器原生支援**：使用 EventSource API

---

## 4.3.2 ChatClient 流式輸出實作

### 基本流式輸出

Spring AI 1.0 GA 的 ChatClient 提供了優雅的流式輸出 API：

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;

@RestController
@RequestMapping("/api/ai")
@RequiredArgsConstructor
@Slf4j
public class StreamingAiController {
    
    private final ChatClient chatClient;

    /**
     * 基本流式 AI 對話
     * @param prompt 使用者輸入的提示詞
     * @return 流式字串回應
     */
    @GetMapping(value = "/chat/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> chatStream(@RequestParam String prompt) {
        log.info("開始流式對話：{}", prompt);
        
        return chatClient.prompt()
                .user(prompt)
                .stream()
                .content();
    }
    
    /**
     * 帶系統提示詞的流式對話
     * @param prompt 使用者輸入
     * @param system 系統提示詞
     * @return 流式回應
     */
    @GetMapping(value = "/chat/stream/system", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> chatStreamWithSystem(
            @RequestParam String prompt,
            @RequestParam(defaultValue = "你是一個友善且專業的 AI 助手") String system) {
        
        return chatClient.prompt()
                .system(system)
                .user(prompt)
                .stream()
                .content()
                .doOnSubscribe(subscription -> 
                    log.info("開始流式對話 - 系統：{}, 使用者：{}", system, prompt))
                .doOnComplete(() -> 
                    log.info("流式對話完成"));
    }
}
```

### 程式碼重點說明

**核心 API**：
- **`stream()`**: 替代 `call()` 來啟用流式輸出
- **`content()`**: 返回 `Flux<String>` 流式字串內容
- **`produces = MediaType.TEXT_EVENT_STREAM_VALUE`**: 指定回應格式為 SSE

**Reactive 操作符**：
- **`doOnSubscribe()`**: 訂閱時執行的動作
- **`doOnComplete()`**: 完成時執行的動作
- **`doOnNext()`**: 每個元素發出時執行的動作

---

## 4.3.3 進階流式輸出控制

### 完整 ChatResponse 流

如果需要更多控制選項，可以使用完整的 ChatResponse 流：

```java
@GetMapping(value = "/chat/stream/response", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<ChatResponse> chatStreamResponse(@RequestParam String prompt) {
    return chatClient.prompt()
            .user(prompt)
            .stream()
            .chatResponse()
            .doOnNext(response -> {
                // 可以存取完整的回應資訊
                log.debug("收到回應片段：{}", response.getResult().getOutput().getContent());
                log.debug("使用的模型：{}", response.getMetadata().getModel());
            });
}
```

### 自定義流式輸出處理

```java
@GetMapping(value = "/chat/stream/custom", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<String> chatStreamCustom(@RequestParam String prompt) {
    return chatClient.prompt()
            .user(prompt)
            .stream()
            .content()
            .map(content -> {
                // 自定義處理每個流式片段
                return "🤖 AI: " + content;
            })
            .filter(content -> {
                // 過濾空內容
                return content != null && !content.trim().isEmpty();
            })
            .doOnNext(content -> {
                // 記錄每個片段
                log.debug("流式內容：{}", content);
            })
            .onErrorResume(error -> {
                log.error("流式輸出錯誤", error);
                return Flux.just("❌ 抱歉，發生錯誤：" + error.getMessage());
            });
}
```

### 結構化流式回應

```java
@Data
public class StreamChunk {
    private String content;
    private String timestamp;
    private String model;
    private boolean isComplete;
    
    public static StreamChunk of(String content, String model) {
        StreamChunk chunk = new StreamChunk();
        chunk.setContent(content);
        chunk.setTimestamp(Instant.now().toString());
        chunk.setModel(model);
        chunk.setComplete(false);
        return chunk;
    }
}

@GetMapping(value = "/chat/stream/structured", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<StreamChunk> chatStreamStructured(@RequestParam String prompt) {
    return chatClient.prompt()
            .user(prompt)
            .stream()
            .chatResponse()
            .map(response -> StreamChunk.of(
                response.getResult().getOutput().getContent(),
                response.getMetadata().getModel()
            ))
            .concatWith(Flux.just(new StreamChunk() {{
                setContent("");
                setComplete(true);
            }}));
}
```

---

## 4.3.4 使用 ChatModel 的流式輸出

### 底層 API 實現

如果直接使用 ChatModel，也可以實現流式輸出：

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.model.StreamingChatModel;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.chat.prompt.PromptTemplate;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;

import java.util.Map;

@RestController
@RequestMapping("/api/model")
@RequiredArgsConstructor
public class StreamingModelController {
    
    private final StreamingChatModel streamingChatModel;

    /**
     * 使用 ChatModel 的基本流式輸出
     * @param prompt 使用者輸入
     * @return 流式回應
     */
    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> modelStream(@RequestParam String prompt) {
        return streamingChatModel.stream(prompt)
                .map(chatResponse -> 
                    chatResponse.getResult().getOutput().getContent())
                .filter(content -> content != null && !content.isEmpty());
    }
    
    /**
     * 使用 PromptTemplate 的流式輸出
     * @param topic 話題
     * @param style 風格
     * @return 流式回應
     */
    @GetMapping(value = "/stream/template", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> modelStreamWithTemplate(
            @RequestParam String topic,
            @RequestParam(defaultValue = "專業") String style) {
        
        String template = "請以{style}的風格，詳細說明{topic}的相關知識";
        
        PromptTemplate promptTemplate = new PromptTemplate(template);
        Prompt prompt = promptTemplate.create(Map.of(
            "topic", topic,
            "style", style
        ));
        
        return streamingChatModel.stream(prompt)
                .map(chatResponse -> 
                    chatResponse.getResult().getOutput().getContent())
                .filter(content -> content != null && !content.isEmpty());
    }
}
```

---

## 4.3.5 應用程式配置

### 必要依賴

要使用 Spring AI 的流式輸出功能，必須包含 WebFlux 依賴：

```xml
<!-- 必須包含 WebFlux 以支援流式輸出 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>

<!-- Spring AI OpenAI Starter -->
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
</dependency>
```

> **重要提醒**：流式輸出僅支援 Reactive 架構。即使是命令式應用程式，也必須包含 Reactive 依賴才能使用此功能。

### Spring Boot 配置

確保在 `application.yml` 中正確設定字元編碼和流式選項：

```yaml
server:
  port: 8080
  servlet:
    encoding:
      charset: UTF-8
      enabled: true
      force: true

spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      base-url: https://api.openai.com
      chat:
        options:
          model: gpt-4o-mini
          temperature: 0.7
          max-completion-tokens: 1000
          stream-usage: true  # 在流式回應中包含使用量統計

# 日誌配置
logging:
  level:
    org.springframework.ai: DEBUG
    reactor.netty: INFO
    com.example: DEBUG
```

### 跨域配置（如需要）

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:3000", "http://localhost:8081")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}
```

---

## 4.3.6 完整的聊天服務實作

### 聊天服務層

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;

import java.time.Duration;

@Service
@RequiredArgsConstructor
@Slf4j
public class ChatService {
    
    private final ChatClient chatClient;
    
    /**
     * 流式聊天服務
     * @param userMessage 使用者訊息
     * @param systemPrompt 系統提示詞
     * @return 流式回應
     */
    public Flux<String> streamChat(String userMessage, String systemPrompt) {
        String defaultSystem = "你是一個友善且專業的 AI 助手，" +
                              "請用繁體中文回答，並提供有用的資訊。";
        
        return chatClient.prompt()
                .system(systemPrompt != null ? systemPrompt : defaultSystem)
                .user(userMessage)
                .stream()
                .content()
                .timeout(Duration.ofSeconds(30))  // 設定超時
                .retry(2)  // 重試機制
                .onErrorResume(error -> {
                    log.error("聊天流式輸出錯誤", error);
                    return Flux.just("❌ 抱歉，發生錯誤，請稍後再試。錯誤訊息：" + error.getMessage());
                })
                .doOnSubscribe(subscription -> 
                    log.info("開始流式聊天 - 使用者：{}", userMessage))
                .doOnComplete(() -> 
                    log.info("流式聊天完成"))
                .doOnError(error -> 
                    log.error("流式聊天發生錯誤：{}", error.getMessage()));
    }
    
    /**
     * 程式碼生成專用流式服務
     * @param description 程式需求描述
     * @param language 程式語言
     * @return 流式程式碼回應
     */
    public Flux<String> streamCodeGeneration(String description, String language) {
        String systemPrompt = String.format(
            "你是一個資深的 %s 開發專家。" +
            "請根據需求描述生成高品質、可執行的程式碼，" +
            "包含適當的註解和最佳實踐。" +
            "請只回傳程式碼，不要額外的說明文字。",
            language
        );
        
        return streamChat(description, systemPrompt);
    }
}
```

### 控制器整合

```java
package com.example.controller;

import com.example.service.ChatService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;

@RestController
@RequestMapping("/api/chat")
@RequiredArgsConstructor
public class ChatController {
    
    private final ChatService chatService;

    /**
     * 通用流式聊天端點
     * @param prompt 使用者輸入
     * @param system 系統提示詞（可選）
     * @return 流式回應
     */
    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> chat(
            @RequestParam String prompt,
            @RequestParam(required = false) String system) {
        return chatService.streamChat(prompt, system);
    }
    
    /**
     * 程式碼生成流式端點
     * @param description 程式需求描述
     * @param language 程式語言
     * @return 流式程式碼
     */
    @GetMapping(value = "/code/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> generateCode(
            @RequestParam String description,
            @RequestParam(defaultValue = "Java") String language) {
        return chatService.streamCodeGeneration(description, language);
    }
    
    /**
     * POST 方式的流式聊天（支援複雜請求）
     * @param request 聊天請求
     * @return 流式回應
     */
    @PostMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> chatPost(@RequestBody ChatStreamRequest request) {
        return chatService.streamChat(request.getMessage(), request.getSystemPrompt());
    }
}
```

### 請求 DTO

```java
package com.example.dto;

import lombok.Data;

@Data
public class ChatStreamRequest {
    private String message;
    private String systemPrompt;
    private Double temperature;
    private Integer maxTokens;
}
```

---

## 4.3.7 前端整合技術

### JavaScript EventSource 整合

前端可以使用 EventSource 來接收流式資料：

```javascript
/**
 * 流式聊天功能
 * @param {string} prompt - 使用者輸入
 * @param {string} containerId - 顯示容器 ID
 */
function streamChat(prompt, containerId = 'chat-response') {
    const chatContainer = document.getElementById(containerId);
    const encodedPrompt = encodeURIComponent(prompt);
    const eventSource = new EventSource(`/api/chat/stream?prompt=${encodedPrompt}`);
    
    // 清空之前的內容
    chatContainer.innerHTML = '';
    
    // 接收流式資料
    eventSource.onmessage = function(event) {
        const content = event.data;
        if (content && content.trim() !== '') {
            chatContainer.innerHTML += content;
            // 自動滾動到底部
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
    };
    
    // 錯誤處理
    eventSource.onerror = function(event) {
        console.error('Stream error:', event);
        chatContainer.innerHTML += '<br><span style="color: red;">❌ 連線錯誤，請重新嘗試</span>';
        eventSource.close();
    };
    
    // 連線關閉處理
    eventSource.addEventListener('close', function() {
        console.log('Stream completed');
        eventSource.close();
    });
    
    // 返回 EventSource 實例，以便外部控制
    return eventSource;
}

/**
 * 進階流式聊天（支援取消）
 */
class StreamingChat {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.eventSource = null;
    }
    
    start(prompt, systemPrompt = null) {
        this.stop(); // 停止之前的連線
        
        let url = `/api/chat/stream?prompt=${encodeURIComponent(prompt)}`;
        if (systemPrompt) {
            url += `&system=${encodeURIComponent(systemPrompt)}`;
        }
        
        this.eventSource = new EventSource(url);
        this.container.innerHTML = '';
        
        this.eventSource.onmessage = (event) => {
            this.container.innerHTML += event.data;
            this.container.scrollTop = this.container.scrollHeight;
        };
        
        this.eventSource.onerror = (event) => {
            console.error('Stream error:', event);
            this.container.innerHTML += '<br><span class="error">❌ 發生錯誤</span>';
            this.stop();
        };
    }
    
    stop() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
    }
}

// 使用範例
const chat = new StreamingChat('chat-response');
chat.start('請介紹 Spring AI 的主要功能');
```

### React 整合範例

```jsx
import React, { useState, useEffect, useRef } from 'react';

function StreamingChat() {
    const [message, setMessage] = useState('');
    const [response, setResponse] = useState('');
    const [isStreaming, setIsStreaming] = useState(false);
    const eventSourceRef = useRef(null);
    
    const startStreaming = () => {
        if (!message.trim()) return;
        
        setResponse('');
        setIsStreaming(true);
        
        const encodedMessage = encodeURIComponent(message);
        eventSourceRef.current = new EventSource(
            `/api/chat/stream?prompt=${encodedMessage}`
        );
        
        eventSourceRef.current.onmessage = (event) => {
            setResponse(prev => prev + event.data);
        };
        
        eventSourceRef.current.onerror = (error) => {
            console.error('Stream error:', error);
            setIsStreaming(false);
            eventSourceRef.current?.close();
        };
        
        eventSourceRef.current.addEventListener('close', () => {
            setIsStreaming(false);
            eventSourceRef.current?.close();
        });
    };
    
    const stopStreaming = () => {
        eventSourceRef.current?.close();
        setIsStreaming(false);
    };
    
    useEffect(() => {
        return () => {
            eventSourceRef.current?.close();
        };
    }, []);
    
    return (
        <div className="streaming-chat">
            <div className="input-section">
                <textarea
                    value={message}
                    onChange={(e) => setMessage(e.target.value)}
                    placeholder="輸入您的問題..."
                    disabled={isStreaming}
                />
                <button 
                    onClick={startStreaming} 
                    disabled={isStreaming || !message.trim()}
                >
                    {isStreaming ? '生成中...' : '發送'}
                </button>
                {isStreaming && (
                    <button onClick={stopStreaming}>停止</button>
                )}
            </div>
            
            <div className="response-section">
                <h3>AI 回應：</h3>
                <div className="response-content">
                    {response || (isStreaming ? '正在思考中...' : '等待您的問題')}
                </div>
            </div>
        </div>
    );
}

export default StreamingChat;
```

---

## 4.3.8 測試與除錯

### 使用 Postman 測試

**基本流式測試**：
```
GET http://localhost:8080/api/chat/stream?prompt=解釋什麼是Spring AI
```

在 Postman 中你會看到：
- Response Type 顯示為 `text/event-stream`
- 內容會分段即時顯示
- 不會等待完整回應才顯示

**帶系統提示詞的測試**：
```
GET http://localhost:8080/api/chat/stream?prompt=寫一個Hello World程式&system=你是一個Java專家
```

### 使用 curl 測試

```bash
# 基本流式測試
curl -N "http://localhost:8080/api/chat/stream?prompt=介紹Spring框架"

# 程式碼生成測試
curl -N "http://localhost:8080/api/chat/code/stream?description=建立一個簡單的REST API&language=Java"

# POST 方式測試
curl -N -X POST "http://localhost:8080/api/chat/stream" \
     -H "Content-Type: application/json" \
     -d '{
       "message": "請解釋什麼是微服務架構",
       "systemPrompt": "你是一個架構師專家"
     }'
```

**重要參數**：
- `-N`: 確保不緩衝輸出，能即時看到流式結果

### 效能測試

```bash
# 使用 Apache Bench 測試併發流式請求
ab -n 10 -c 2 "http://localhost:8080/api/chat/stream?prompt=Hello"

# 使用 wrk 進行壓力測試
wrk -t4 -c10 -d30s "http://localhost:8080/api/chat/stream?prompt=測試"
```

---

## 4.3.9 效能優化與最佳實踐

### 連線池與資源管理

```yaml
# application.yml
spring:
  ai:
    openai:
      chat:
        options:
          max-completion-tokens: 1000  # 限制輸出長度
          stream-usage: true  # 取得流式回應中的使用量統計
```

### 背壓處理

```java
@GetMapping(value = "/chat/stream/backpressure", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<String> chatStreamWithBackpressure(@RequestParam String prompt) {
    return chatClient.prompt()
            .user(prompt)
            .stream()
            .content()
            .onBackpressureBuffer(1000)  // 設定緩衝區大小
            .publishOn(Schedulers.boundedElastic())  // 使用彈性執行緒池
            .delayElements(Duration.ofMillis(10));  // 控制發送頻率
}
```

### 記憶體優化

```java
@Service
public class OptimizedChatService {
    
    private final ChatClient chatClient;
    private final Scheduler scheduler = Schedulers.newBoundedElastic(
        10, 100, "chat-stream", 60, true
    );
    
    public Flux<String> streamChatOptimized(String prompt) {
        return chatClient.prompt()
                .user(prompt)
                .stream()
                .content()
                .subscribeOn(scheduler)  // 使用專用執行緒池
                .doFinally(signalType -> {
                    // 清理資源
                    log.debug("Stream finished with signal: {}", signalType);
                });
    }
}
```

### 錯誤處理與重試

```java
@GetMapping(value = "/chat/stream/resilient", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<String> chatStreamResilient(@RequestParam String prompt) {
    return chatClient.prompt()
            .user(prompt)
            .stream()
            .content()
            .timeout(Duration.ofSeconds(30))  // 設定超時
            .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))  // 指數退避重試
                .filter(throwable -> !(throwable instanceof IllegalArgumentException)))
            .onErrorResume(TimeoutException.class, error -> 
                Flux.just("⏰ 請求超時，請稍後再試"))
            .onErrorResume(Exception.class, error -> 
                Flux.just("❌ 服務暫時不可用：" + error.getMessage()));
}
```

---

## 📝 本章重點回顧

1. **流式輸出原理**：理解了 SSE 技術和流式輸出的優勢
2. **ChatClient 流式 API**：掌握了使用 `stream()` 方法實現流式輸出
3. **Reactive Streams**：學會了使用 Flux 處理流式資料
4. **前端整合**：了解如何使用 EventSource 接收流式資料
5. **效能優化**：掌握了背壓處理、錯誤處理等最佳實踐

### 新舊版本對比

| 功能 | 舊版本 (pre-1.0) | 新版本 (1.0 GA) |
|------|------------------|----------------|
| **API 風格** | `chatModel.stream(prompt)` | `chatClient.prompt().user(prompt).stream().content()` |
| **可讀性** | 較低 | 高（Fluent API） |
| **功能豐富度** | 基礎 | 豐富（系統提示詞、選項配置等） |
| **錯誤處理** | 需手動實作 | 內建支援 |
| **效能優化** | 有限 | 完整的 Reactive 支援 |

### 下一步學習方向

在下一章中，我們將深入探討 ChatModel 的內部機制，了解不同 AI 模型的特性和選擇策略，為企業級應用做好準備。

---

**參考資料：**
- [Server-Sent Events Specification](https://html.spec.whatwg.org/multipage/server-sent-events.html)
- [Spring WebFlux Reactive Streams](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html)
- [Project Reactor Documentation](https://projectreactor.io/docs/core/release/reference/)
- [Spring AI Streaming Documentation](https://docs.spring.io/spring-ai/reference/api/chatclient.html#streaming)


\newpage

## 4.4 深入瞭解 ChatModel


> **本章重點**：深入探討 Spring AI 的核心架構，理解 ChatModel 與 ChatClient 的關係，掌握不同 AI 模型的特性和企業級應用策略。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 Spring AI 架構**：掌握 ChatModel 和 ChatClient 的完整架構關係
- 🎯 **選擇合適的 AI 模型**：了解不同模型的特性和適用場景
- 🎯 **配置模型參數**：學會調整溫度、token 限制等關鍵參數
- 🎯 **實現模型切換**：建立彈性的多模型支援架構
- 🎯 **優化模型效能**：掌握快取、連線池等效能優化技術

---

## 4.4.1 Spring AI 架構全貌

### ChatModel vs ChatClient 關係圖

![ChatModel 架構](https://ithelp.ithome.com.tw/upload/images/20240810/20161290nfq1H0dDoW.jpg)

到目前為止我們做得比直接上 ChatGPT 發問還不如，ChatGPT 起碼還能記住你是誰（不信自己去問），今天我們就來深入了解 Spring AI 1.0 GA 中 ChatClient 和 ChatModel 的完整架構與功能。

```
┌─────────────────────────────────────────────────┐
│                  ChatClient                     │
│  ┌─────────────────────────────────────────┐    │
│  │            Fluent API Layer             │    │
│  │  • prompt()                             │    │
│  │  • system() / user()                    │    │
│  │  • call() / stream()                    │    │
│  │  • content() / chatResponse()           │    │
│  └─────────────────────────────────────────┘    │
│                     │                           │
│                     ▼                           │
│  ┌─────────────────────────────────────────┐    │
│  │              ChatModel                  │    │
│  │  ┌─────────────────────────────────┐    │    │
│  │  │        Model Abstraction        │    │    │
│  │  │  • call(String)                 │    │    │
│  │  │  • call(Prompt)                 │    │    │
│  │  │  • stream(Prompt)               │    │    │
│  │  └─────────────────────────────────┘    │    │
│  └─────────────────────────────────────────┘    │
│                     │                           │
│                     ▼                           │
│  ┌─────────────────────────────────────────┐    │
│  │           Provider Implementations      │    │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐    │    │
│  │  │ OpenAI  │ │  Azure  │ │  Groq   │    │    │
│  │  │ ChatModel│ │ChatModel│ │ChatModel│    │    │
│  │  └─────────┘ └─────────┘ └─────────┘    │    │
│  └─────────────────────────────────────────┘    │
└─────────────────────────────────────────────────┘
```

### 架構層級說明

**1. ChatClient（高級 API 層）**
- 提供現代化的 Fluent API 介面
- 類似於 Spring 生態系統中的 RestClient、WebClient
- 內建常用功能：系統提示詞、流式輸出、錯誤處理
- 推薦用於大部分應用場景

**2. ChatModel（抽象層）**
- 定義與 AI 模型互動的核心介面
- 提供統一的 API 抽象，隱藏不同提供商的差異
- 支援同步和異步（流式）呼叫
- 適合需要底層控制的場景

**3. Provider Implementations（實現層）**
- 各 AI 服務提供商的具體實現
- 處理特定提供商的 API 協定和認證
- 負責請求轉換和回應解析

---

## 4.4.2 ChatModel 核心介面

### 基本介面定義

```java
public interface ChatModel extends Model<Prompt, ChatResponse>, StreamingChatModel {
    
    /**
     * 簡單字串呼叫
     * @param message 使用者訊息
     * @return AI 回應內容
     */
    default String call(String message) {
        Prompt prompt = new Prompt(new UserMessage(message));
        return call(prompt).getResult().getOutput().getContent();
    }
    
    /**
     * 完整 Prompt 呼叫
     * @param prompt 完整的提示詞物件
     * @return 完整的聊天回應
     */
    @Override
    ChatResponse call(Prompt prompt);
}

public interface StreamingChatModel extends StreamingModel<Prompt, ChatResponse> {
    
    /**
     * 流式呼叫
     * @param prompt 提示詞物件
     * @return 流式聊天回應
     */
    @Override
    Flux<ChatResponse> stream(Prompt prompt);
    
    /**
     * 簡單流式呼叫
     * @param message 使用者訊息
     * @return 流式回應內容
     */
    default Flux<String> stream(String message) {
        return stream(new Prompt(new UserMessage(message)))
                .map(response -> response.getResult().getOutput().getContent());
    }
}
```

### 實際使用範例

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.ai.chat.model.StreamingChatModel;
import org.springframework.ai.chat.prompt.*;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;

import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
@Slf4j
public class ChatModelService {
    
    private final ChatModel chatModel;
    private final StreamingChatModel streamingChatModel;
    
    /**
     * 簡單字串呼叫
     */
    public String simpleCall(String message) {
        return chatModel.call(message);
    }
    
    /**
     * 使用 Prompt 物件的完整呼叫
     */
    public ChatResponse fullCall(String systemMessage, String userMessage) {
        Prompt prompt = new Prompt(List.of(
            new SystemMessage(systemMessage),
            new UserMessage(userMessage)
        ));
        
        return chatModel.call(prompt);
    }
    
    /**
     * 使用 PromptTemplate 的動態呼叫
     */
    public String templateCall(String template, Map<String, Object> variables) {
        PromptTemplate promptTemplate = new PromptTemplate(template);
        Prompt prompt = promptTemplate.create(variables);
        
        ChatResponse response = chatModel.call(prompt);
        return response.getResult().getOutput().getContent();
    }
    
    /**
     * 流式呼叫
     */
    public Flux<String> streamCall(String message) {
        return streamingChatModel.stream(message);
    }
    
    /**
     * 帶選項的流式呼叫
     */
    public Flux<String> streamCallWithOptions(String message, ChatOptions options) {
        Prompt prompt = new Prompt(new UserMessage(message), options);
        return streamingChatModel.stream(prompt)
                .map(response -> response.getResult().getOutput().getContent());
    }
}
```

---

## 4.4.3 AI 模型參數配置

### 核心參數說明

```java
package com.example.config;

import org.springframework.ai.openai.OpenAiChatOptions;
import org.springframework.ai.openai.api.OpenAiApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ChatModelConfig {
    
    /**
     * 預設聊天選項配置
     */
    @Bean
    public OpenAiChatOptions defaultChatOptions() {
        return OpenAiChatOptions.builder()
                .model("gpt-4o-mini")        // 模型選擇
                .temperature(0.7F)           // 創意度：0.0-2.0
                .maxTokens(1000)             // 最大輸出 token 數
                .topP(1.0F)                  // 核心採樣：0.0-1.0
                .frequencyPenalty(0.0F)      // 頻率懲罰：-2.0-2.0
                .presencePenalty(0.0F)       // 存在懲罰：-2.0-2.0
                .build();
    }
    
    /**
     * 創意寫作專用配置
     */
    @Bean("creativeChatOptions")
    public OpenAiChatOptions creativeChatOptions() {
        return OpenAiChatOptions.builder()
                .model("gpt-4o")
                .temperature(1.2F)           // 高創意度
                .maxTokens(2000)             // 較長輸出
                .topP(0.9F)                  // 稍微限制選擇範圍
                .frequencyPenalty(0.5F)      // 避免重複
                .presencePenalty(0.3F)       // 鼓勵新話題
                .build();
    }
    
    /**
     * 程式碼生成專用配置
     */
    @Bean("codeChatOptions")
    public OpenAiChatOptions codeChatOptions() {
        return OpenAiChatOptions.builder()
                .model("gpt-4o")
                .temperature(0.2F)           // 低創意度，更精確
                .maxTokens(1500)             // 適中輸出長度
                .topP(0.95F)                 // 較保守的選擇
                .frequencyPenalty(0.0F)      // 不懲罰重複（程式碼可能需要重複結構）
                .presencePenalty(0.0F)
                .build();
    }
}
```

### 參數詳細說明

| 參數 | 範圍 | 說明 | 使用建議 |
|------|------|------|----------|
| **Temperature** | 0.0-2.0 | 控制回應的隨機性和創意度 | 0.2（精確）、0.7（平衡）、1.2（創意） |
| **Max Tokens** | 1-4096+ | 限制回應的最大長度 | 根據需求設定，注意成本控制 |
| **Top P** | 0.0-1.0 | 核心採樣，控制詞彙選擇範圍 | 0.9-1.0 較常用 |
| **Frequency Penalty** | -2.0-2.0 | 懲罰重複出現的詞彙 | 0.0-0.5 避免過度重複 |
| **Presence Penalty** | -2.0-2.0 | 鼓勵談論新話題 | 0.0-0.3 增加話題多樣性 |

### 動態參數調整

```java
@Service
public class AdaptiveChatService {
    
    private final ChatModel chatModel;
    
    /**
     * 根據內容類型動態調整參數
     */
    public String adaptiveChat(String message, ContentType contentType) {
        OpenAiChatOptions options = switch (contentType) {
            case CREATIVE_WRITING -> OpenAiChatOptions.builder()
                .temperature(1.2F)
                .maxTokens(2000)
                .build();
                
            case CODE_GENERATION -> OpenAiChatOptions.builder()
                .temperature(0.2F)
                .maxTokens(1500)
                .build();
                
            case TECHNICAL_EXPLANATION -> OpenAiChatOptions.builder()
                .temperature(0.5F)
                .maxTokens(1200)
                .build();
                
            case CASUAL_CHAT -> OpenAiChatOptions.builder()
                .temperature(0.8F)
                .maxTokens(800)
                .build();
        };
        
        Prompt prompt = new Prompt(new UserMessage(message), options);
        return chatModel.call(prompt).getResult().getOutput().getContent();
    }
    
    public enum ContentType {
        CREATIVE_WRITING, CODE_GENERATION, TECHNICAL_EXPLANATION, CASUAL_CHAT
    }
}
```

---

## 4.4.4 多模型支援架構

### 模型選擇策略

```java
package com.example.config;

import org.springframework.ai.chat.model.ChatModel;
import org.springframework.ai.openai.OpenAiChatModel;
import org.springframework.ai.openai.api.OpenAiApi;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

@Configuration
public class MultiModelConfig {
    
    @Value("${spring.ai.openai.api-key}")
    private String openaiApiKey;
    
    @Value("${spring.ai.groq.api-key:}")
    private String groqApiKey;
    
    /**
     * 高性能模型 - GPT-4o
     */
    @Bean("highPerformanceModel")
    public ChatModel highPerformanceModel() {
        var openAiApi = new OpenAiApi(openaiApiKey);
        var options = OpenAiChatOptions.builder()
            .model("gpt-4o")
            .temperature(0.7F)
            .maxTokens(2000)
            .build();
        return new OpenAiChatModel(openAiApi, options);
    }
    
    /**
     * 經濟型模型 - GPT-4o mini
     */
    @Bean("economicModel")
    @Primary
    public ChatModel economicModel() {
        var openAiApi = new OpenAiApi(openaiApiKey);
        var options = OpenAiChatOptions.builder()
            .model("gpt-4o-mini")
            .temperature(0.7F)
            .maxTokens(1000)
            .build();
        return new OpenAiChatModel(openAiApi, options);
    }
    
    /**
     * 高速模型 - Groq
     */
    @Bean("speedModel")
    public ChatModel speedModel() {
        if (groqApiKey == null || groqApiKey.isEmpty()) {
            return economicModel(); // 降級到經濟型模型
        }
        
        var groqApi = new OpenAiApi("https://api.groq.com/openai/v1", groqApiKey);
        var options = OpenAiChatOptions.builder()
            .model("llama-3.1-70b-versatile")
            .temperature(0.7F)
            .maxTokens(1000)
            .build();
        return new OpenAiChatModel(groqApi, options);
    }
}
```

### 智能模型路由

```java
@Service
public class ModelRouterService {
    
    private final ChatModel highPerformanceModel;
    private final ChatModel economicModel;
    private final ChatModel speedModel;
    
    public ModelRouterService(
            @Qualifier("highPerformanceModel") ChatModel highPerformanceModel,
            @Qualifier("economicModel") ChatModel economicModel,
            @Qualifier("speedModel") ChatModel speedModel) {
        this.highPerformanceModel = highPerformanceModel;
        this.economicModel = economicModel;
        this.speedModel = speedModel;
    }
    
    /**
     * 根據任務複雜度選擇模型
     */
    public String routeByComplexity(String message, TaskComplexity complexity) {
        ChatModel selectedModel = switch (complexity) {
            case HIGH -> {
                log.info("使用高性能模型處理複雜任務");
                yield highPerformanceModel;
            }
            case MEDIUM -> {
                log.info("使用經濟型模型處理中等任務");
                yield economicModel;
            }
            case LOW -> {
                log.info("使用高速模型處理簡單任務");
                yield speedModel;
            }
        };
        
        return selectedModel.call(message);
    }
    
    /**
     * 根據使用者等級選擇模型
     */
    public String routeByUserTier(String message, UserTier userTier) {
        ChatModel selectedModel = switch (userTier) {
            case PREMIUM -> highPerformanceModel;
            case STANDARD -> economicModel;
            case FREE -> speedModel;
        };
        
        return selectedModel.call(message);
    }
    
    /**
     * 容錯路由 - 自動降級
     */
    public String routeWithFallback(String message) {
        List<ChatModel> models = List.of(
            highPerformanceModel,
            economicModel,
            speedModel
        );
        
        for (ChatModel model : models) {
            try {
                return model.call(message);
            } catch (Exception e) {
                log.warn("模型呼叫失敗，嘗試下一個模型：{}", e.getMessage());
            }
        }
        
        throw new RuntimeException("所有 AI 模型都不可用");
    }
    
    public enum TaskComplexity {
        HIGH, MEDIUM, LOW
    }
    
    public enum UserTier {
        PREMIUM, STANDARD, FREE
    }
}
```

---

## 4.4.5 效能優化與快取

### 回應快取機制

```java
package com.example.service;

import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import java.security.MessageDigest;
import java.nio.charset.StandardCharsets;

@Service
public class CachedChatService {
    
    private final ChatModel chatModel;
    
    /**
     * 快取常見問題的回應
     */
    @Cacheable(value = "chatResponses", key = "#root.methodName + '_' + T(java.util.Objects).hash(#message)")
    public String getCachedResponse(String message) {
        log.info("快取未命中，呼叫 AI 模型：{}", message);
        return chatModel.call(message);
    }
    
    /**
     * 根據內容雜湊快取
     */
    @Cacheable(value = "chatResponses", key = "#root.target.generateCacheKey(#message, #systemPrompt)")
    public String getCachedResponseWithSystem(String message, String systemPrompt) {
        Prompt prompt = new Prompt(List.of(
            new SystemMessage(systemPrompt),
            new UserMessage(message)
        ));
        
        return chatModel.call(prompt).getResult().getOutput().getContent();
    }
    
    /**
     * 生成快取鍵
     */
    public String generateCacheKey(String message, String systemPrompt) {
        try {
            String combined = (systemPrompt != null ? systemPrompt : "") + "|" + message;
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(combined.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(hash).substring(0, 16); // 取前16字元
        } catch (Exception e) {
            return String.valueOf(Objects.hash(message, systemPrompt));
        }
    }
    
    private String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }
}
```

### 快取配置

```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(1000)  // 最大快取條目數
            .expireAfterWrite(Duration.ofHours(1))  // 1小時後過期
            .recordStats());  // 啟用統計
        return cacheManager;
    }
}
```

### 連線池優化

```yaml
# application.yml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      base-url: https://api.openai.com
      chat:
        options:
          model: gpt-4o-mini
          temperature: 0.7
      # 連線池配置
      client:
        connect-timeout: 10s
        read-timeout: 60s
        max-connections: 20
        max-connections-per-route: 10

# 快取配置
cache:
  caffeine:
    spec: maximumSize=1000,expireAfterWrite=1h
```

---

## 4.4.6 監控與診斷

### 模型使用統計

```java
@Component
public class ChatModelMetrics {
    
    private final MeterRegistry meterRegistry;
    private final Counter requestCounter;
    private final Timer responseTimer;
    private final Gauge activeConnections;
    
    public ChatModelMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.requestCounter = Counter.builder("ai.chat.requests")
            .description("AI chat requests count")
            .register(meterRegistry);
        this.responseTimer = Timer.builder("ai.chat.response.time")
            .description("AI chat response time")
            .register(meterRegistry);
        this.activeConnections = Gauge.builder("ai.chat.connections.active")
            .description("Active AI chat connections")
            .register(meterRegistry, this, ChatModelMetrics::getActiveConnections);
    }
    
    public void recordRequest(String model, Duration responseTime, boolean success) {
        requestCounter.increment(
            Tags.of(
                "model", model,
                "status", success ? "success" : "error"
            )
        );
        responseTimer.record(responseTime, Tags.of("model", model));
    }
    
    private double getActiveConnections() {
        // 實際實現需要根據連線池狀態
        return 0.0;
    }
}
```

### 健康檢查

```java
@Component
public class ChatModelHealthIndicator implements HealthIndicator {
    
    private final ChatModel chatModel;
    
    @Override
    public Health health() {
        try {
            // 簡單的健康檢查
            String response = chatModel.call("Hello");
            
            if (response != null && !response.isEmpty()) {
                return Health.up()
                    .withDetail("model", "available")
                    .withDetail("response_length", response.length())
                    .build();
            } else {
                return Health.down()
                    .withDetail("model", "no_response")
                    .build();
            }
        } catch (Exception e) {
            return Health.down()
                .withDetail("model", "error")
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}
```

---

## 4.4.7 實際應用範例

### 企業級聊天服務

```java
@Service
@Transactional
public class EnterpriseChatService {
    
    private final ModelRouterService modelRouter;
    private final CachedChatService cachedChat;
    private final ChatModelMetrics metrics;
    
    /**
     * 企業級聊天處理
     */
    public ChatResult processChat(ChatRequest request) {
        Instant startTime = Instant.now();
        String model = "unknown";
        boolean success = false;
        
        try {
            // 1. 內容安全檢查
            if (!isContentSafe(request.getMessage())) {
                throw new ContentSafetyException("內容包含不當資訊");
            }
            
            // 2. 使用者權限檢查
            UserTier userTier = getUserTier(request.getUserId());
            
            // 3. 選擇合適的模型
            TaskComplexity complexity = analyzeComplexity(request.getMessage());
            
            // 4. 嘗試快取
            String cacheKey = generateCacheKey(request);
            String cachedResponse = getCachedResponse(cacheKey);
            if (cachedResponse != null) {
                return ChatResult.fromCache(cachedResponse);
            }
            
            // 5. 呼叫 AI 模型
            String response = modelRouter.routeByComplexity(
                request.getMessage(), complexity
            );
            
            // 6. 儲存快取
            saveCachedResponse(cacheKey, response);
            
            // 7. 記錄使用統計
            recordUsage(request.getUserId(), model, response.length());
            
            success = true;
            return ChatResult.success(response, model);
            
        } catch (Exception e) {
            log.error("聊天處理失敗", e);
            return ChatResult.error(e.getMessage());
        } finally {
            Duration responseTime = Duration.between(startTime, Instant.now());
            metrics.recordRequest(model, responseTime, success);
        }
    }
    
    private boolean isContentSafe(String message) {
        // 實現內容安全檢查邏輯
        return !message.toLowerCase().contains("不當內容");
    }
    
    private TaskComplexity analyzeComplexity(String message) {
        // 簡單的複雜度分析
        if (message.length() > 500 || message.contains("複雜") || message.contains("詳細")) {
            return TaskComplexity.HIGH;
        } else if (message.length() > 100) {
            return TaskComplexity.MEDIUM;
        } else {
            return TaskComplexity.LOW;
        }
    }
}

@Data
public class ChatResult {
    private String response;
    private String model;
    private boolean fromCache;
    private boolean success;
    private String error;
    
    public static ChatResult success(String response, String model) {
        ChatResult result = new ChatResult();
        result.setResponse(response);
        result.setModel(model);
        result.setSuccess(true);
        result.setFromCache(false);
        return result;
    }
    
    public static ChatResult fromCache(String response) {
        ChatResult result = new ChatResult();
        result.setResponse(response);
        result.setSuccess(true);
        result.setFromCache(true);
        return result;
    }
    
    public static ChatResult error(String error) {
        ChatResult result = new ChatResult();
        result.setError(error);
        result.setSuccess(false);
        return result;
    }
}
```

---

## 📝 本章重點回顧

1. **Spring AI 架構**：深入理解了 ChatClient 和 ChatModel 的分層架構
2. **模型參數配置**：掌握了溫度、token 限制等關鍵參數的調整
3. **多模型支援**：學會了建立彈性的模型選擇和路由機制
4. **效能優化**：了解了快取、連線池等效能優化技術
5. **企業級應用**：建立了完整的企業級聊天服務架構

### ChatClient vs ChatModel 選擇指南

| 場景 | 推薦選擇 | 理由 |
|------|----------|------|
| **一般應用開發** | ChatClient | Fluent API，易用性高 |
| **複雜提示詞組合** | ChatClient | 內建系統提示詞支援 |
| **流式輸出** | ChatClient | 更簡潔的流式 API |
| **底層控制** | ChatModel | 直接存取 Prompt 物件 |
| **自定義模板** | ChatModel | 完整的 PromptTemplate 支援 |
| **效能關鍵場景** | ChatModel | 更少的抽象層級 |

### 下一步學習方向

在下一章中，我們將學習前端如何處理流式輸出，建立完整的前後端整合方案，為使用者提供最佳的 AI 互動體驗。

---

**參考資料：**
- [Spring AI ChatModel Documentation](https://docs.spring.io/spring-ai/reference/api/chatmodel.html)
- [OpenAI API Parameters](https://platform.openai.com/docs/api-reference/chat/create)
- [Spring Boot Caching](https://docs.spring.io/spring-boot/docs/current/reference/html/io.html#io.caching)
- [Micrometer Metrics](https://micrometer.io/docs)


\newpage

## 4.5 前端該如何處理流式輸出


> **本章重點**：深入探討前端如何優雅地處理 AI 流式輸出，建立完整的前後端整合方案，為使用者提供如同 ChatGPT 般的流暢互動體驗。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握 EventSource API**：熟練使用瀏覽器原生的 SSE 接收技術
- 🎯 **實現流式 UI 更新**：建立即時更新的聊天介面
- 🎯 **處理連線管理**：掌握連線建立、維護和錯誤處理
- 🎯 **優化使用者體驗**：實現打字效果、載入狀態等互動細節
- 🎯 **整合現代前端框架**：在 React、Vue 等框架中實現流式功能

---

## 4.5.1 EventSource API 基礎

### 什麼是 Server-Sent Events (SSE)？

Server-Sent Events 是 HTML5 標準的一部分，允許伺服器向瀏覽器推送資料。與 WebSocket 不同，SSE 是單向的（僅伺服器到客戶端），但對於 AI 流式輸出來說已經足夠。

**SSE vs WebSocket vs 輪詢**：

| 特性 | SSE | WebSocket | 輪詢 |
|------|-----|-----------|------|
| **複雜度** | 低 | 中 | 低 |
| **即時性** | 高 | 高 | 低 |
| **資源消耗** | 低 | 中 | 高 |
| **瀏覽器支援** | 廣泛 | 廣泛 | 全部 |
| **自動重連** | 是 | 否 | 否 |
| **適用場景** | 單向推送 | 雙向通訊 | 簡單查詢 |

### EventSource 基本用法

```javascript
/**
 * 基本的 EventSource 使用範例
 */
function basicEventSourceExample() {
    // 建立 EventSource 連線
    const eventSource = new EventSource('/api/ai/chat/stream?prompt=Hello');
    
    // 監聽訊息事件
    eventSource.onmessage = function(event) {
        console.log('收到資料:', event.data);
    };
    
    // 監聽開啟事件
    eventSource.onopen = function(event) {
        console.log('連線已建立');
    };
    
    // 監聽錯誤事件
    eventSource.onerror = function(event) {
        console.error('連線錯誤:', event);
        
        // 根據錯誤狀態決定是否重連
        if (event.target.readyState === EventSource.CLOSED) {
            console.log('連線已關閉');
        }
    };
    
    // 手動關閉連線
    setTimeout(() => {
        eventSource.close();
        console.log('連線已手動關閉');
    }, 30000); // 30秒後關閉
}
```

### EventSource 狀態管理

```javascript
/**
 * EventSource 狀態常數
 */
const SSE_STATE = {
    CONNECTING: 0,  // 正在連線
    OPEN: 1,        // 連線已開啟
    CLOSED: 2       // 連線已關閉
};

/**
 * 監控 EventSource 狀態
 */
function monitorEventSourceState(eventSource) {
    const checkState = () => {
        switch (eventSource.readyState) {
            case SSE_STATE.CONNECTING:
                console.log('狀態：正在連線...');
                break;
            case SSE_STATE.OPEN:
                console.log('狀態：連線已開啟');
                break;
            case SSE_STATE.CLOSED:
                console.log('狀態：連線已關閉');
                break;
        }
    };
    
    // 定期檢查狀態
    const stateChecker = setInterval(checkState, 1000);
    
    // 連線關閉時停止檢查
    eventSource.addEventListener('close', () => {
        clearInterval(stateChecker);
    });
}
```

---

## 4.5.2 建立流式聊天介面

### HTML 結構設計

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 流式聊天</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="chat-container">
        <!-- 聊天標題 -->
        <div class="chat-header">
            <h1>🤖 AI 助手</h1>
            <div class="connection-status" id="connectionStatus">
                <span class="status-indicator"></span>
                <span class="status-text">就緒</span>
            </div>
        </div>
        
        <!-- 聊天訊息區域 -->
        <div class="chat-messages" id="chatMessages">
            <div class="message system">
                <div class="message-content">
                    👋 您好！我是 AI 助手，有什麼可以幫助您的嗎？
                </div>
                <div class="message-time">剛剛</div>
            </div>
        </div>
        
        <!-- 輸入區域 -->
        <div class="chat-input">
            <div class="input-container">
                <textarea 
                    id="messageInput" 
                    placeholder="輸入您的問題..." 
                    rows="1"
                    maxlength="2000"></textarea>
                <button id="sendButton" class="send-button">
                    <span class="send-icon">📤</span>
                    <span class="send-text">發送</span>
                </button>
                <button id="stopButton" class="stop-button" style="display: none;">
                    <span class="stop-icon">⏹️</span>
                    <span class="stop-text">停止</span>
                </button>
            </div>
            <div class="input-info">
                <span id="charCount">0/2000</span>
                <span class="tips">按 Ctrl+Enter 快速發送</span>
            </div>
        </div>
    </div>
    
    <script src="chat.js"></script>
</body>
</html>
```

### CSS 樣式設計

```css
/* styles.css */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

.chat-container {
    width: 90%;
    max-width: 800px;
    height: 90vh;
    background: white;
    border-radius: 20px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* 聊天標題 */
.chat-header {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.chat-header h1 {
    font-size: 1.5rem;
    font-weight: 600;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
}

.status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #4ade80;
    animation: pulse 2s infinite;
}

.status-indicator.connecting {
    background: #fbbf24;
}

.status-indicator.error {
    background: #ef4444;
    animation: none;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

/* 聊天訊息區域 */
.chat-messages {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    scroll-behavior: smooth;
}

.message {
    margin-bottom: 20px;
    display: flex;
    flex-direction: column;
}

.message.user {
    align-items: flex-end;
}

.message.ai {
    align-items: flex-start;
}

.message.system {
    align-items: center;
}

.message-content {
    max-width: 80%;
    padding: 12px 16px;
    border-radius: 18px;
    line-height: 1.5;
    word-wrap: break-word;
    position: relative;
}

.message.user .message-content {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
    border-bottom-right-radius: 4px;
}

.message.ai .message-content {
    background: #f1f5f9;
    color: #334155;
    border-bottom-left-radius: 4px;
    border: 1px solid #e2e8f0;
}

.message.system .message-content {
    background: #fef3c7;
    color: #92400e;
    border: 1px solid #fcd34d;
    font-size: 0.9rem;
}

.message-time {
    font-size: 0.75rem;
    color: #64748b;
    margin-top: 4px;
    padding: 0 8px;
}

/* 打字效果 */
.typing-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #64748b;
    animation: typing 1.4s infinite ease-in-out;
    margin-left: 2px;
}

.typing-indicator:nth-child(1) { animation-delay: -0.32s; }
.typing-indicator:nth-child(2) { animation-delay: -0.16s; }

@keyframes typing {
    0%, 80%, 100% {
        transform: scale(0);
        opacity: 0.5;
    }
    40% {
        transform: scale(1);
        opacity: 1;
    }
}

/* 輸入區域 */
.chat-input {
    padding: 20px;
    background: #f8fafc;
    border-top: 1px solid #e2e8f0;
}

.input-container {
    display: flex;
    gap: 12px;
    align-items: flex-end;
}

#messageInput {
    flex: 1;
    padding: 12px 16px;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    font-size: 1rem;
    line-height: 1.5;
    resize: none;
    outline: none;
    transition: all 0.2s ease;
    max-height: 120px;
}

#messageInput:focus {
    border-color: #4facfe;
    box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
}

.send-button, .stop-button {
    padding: 12px 20px;
    border: none;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 100px;
    justify-content: center;
}

.send-button {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
}

.send-button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(79, 172, 254, 0.3);
}

.send-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
}

.stop-button {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    color: white;
}

.stop-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(239, 68, 68, 0.3);
}

.input-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
    font-size: 0.8rem;
    color: #64748b;
}

.tips {
    font-style: italic;
}

/* 響應式設計 */
@media (max-width: 768px) {
    .chat-container {
        width: 100%;
        height: 100vh;
        border-radius: 0;
    }
    
    .message-content {
        max-width: 90%;
    }
    
    .input-container {
        flex-direction: column;
    }
    
    .send-button, .stop-button {
        width: 100%;
    }
}
```

---

## 4.5.3 JavaScript 流式聊天實現

### 核心聊天類別

```javascript
// chat.js

/**
 * 流式聊天管理類別
 */
class StreamingChat {
    constructor() {
        this.eventSource = null;
        this.isStreaming = false;
        this.currentMessageElement = null;
        
        // DOM 元素
        this.messagesContainer = document.getElementById('chatMessages');
        this.messageInput = document.getElementById('messageInput');
        this.sendButton = document.getElementById('sendButton');
        this.stopButton = document.getElementById('stopButton');
        this.connectionStatus = document.getElementById('connectionStatus');
        this.charCount = document.getElementById('charCount');
        
        this.initializeEventListeners();
        this.updateConnectionStatus('ready', '就緒');
    }
    
    /**
     * 初始化事件監聽器
     */
    initializeEventListeners() {
        // 發送按鈕點擊
        this.sendButton.addEventListener('click', () => {
            this.sendMessage();
        });
        
        // 停止按鈕點擊
        this.stopButton.addEventListener('click', () => {
            this.stopStreaming();
        });
        
        // 輸入框事件
        this.messageInput.addEventListener('input', (e) => {
            this.updateCharCount();
            this.autoResize(e.target);
        });
        
        // 快捷鍵支援
        this.messageInput.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                this.sendMessage();
            }
        });
        
        // 防止頁面關閉時連線未關閉（避免資源洩漏）
        window.addEventListener('beforeunload', () => {
            this.cleanup();
        });
    }
    
    /**
     * 發送訊息
     */
    async sendMessage() {
        const message = this.messageInput.value.trim();
        if (!message || this.isStreaming) return;
        
        try {
            // 顯示使用者訊息
            this.addMessage('user', message);
            
            // 清空輸入框
            this.messageInput.value = '';
            this.updateCharCount();
            this.autoResize(this.messageInput);
            
            // 開始流式接收
            await this.startStreaming(message);
            
        } catch (error) {
            console.error('發送訊息失敗:', error);
            this.addMessage('system', '❌ 發送失敗，請稍後再試');
        }
    }
    
    /**
     * 開始流式接收
     */
    async startStreaming(message) {
        this.isStreaming = true;
        this.updateUI(true);
        this.updateConnectionStatus('connecting', '連線中...');
        
        // 建立 AI 訊息容器
        this.currentMessageElement = this.addMessage('ai', '', true);
        
        // 建立 EventSource 連線
        const encodedMessage = encodeURIComponent(message);
        const url = `/api/ai/chat/stream?prompt=${encodedMessage}`;
        
        this.eventSource = new EventSource(url);
        
        // 設定事件監聽器
        this.setupEventSourceListeners();
    }
    
    /**
     * 設定 EventSource 事件監聽器
     */
    setupEventSourceListeners() {
        // 接收訊息
        this.eventSource.onmessage = (event) => {
            const content = event.data;
            if (content && content.trim() !== '') {
                this.appendToCurrentMessage(content);
            }
        };
        
        // 連線開啟
        this.eventSource.onopen = () => {
            console.log('EventSource 連線已建立');
            this.updateConnectionStatus('connected', '已連線');
        };
        
        // 連線錯誤
        this.eventSource.onerror = (event) => {
            console.error('EventSource 錯誤:', event);
            
            if (event.target.readyState === EventSource.CLOSED) {
                console.log('EventSource 連線已關閉');
                this.handleStreamComplete();
            } else {
                this.updateConnectionStatus('error', '連線錯誤');
                this.addMessage('system', '❌ 連線發生錯誤，請重新嘗試');
                this.stopStreaming();
            }
        };
        
        // 自定義事件：流式完成
        this.eventSource.addEventListener('complete', () => {
            console.log('流式輸出完成');
            this.handleStreamComplete();
        });
    }
    
    /**
     * 停止流式接收
     */
    stopStreaming() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
        
        this.handleStreamComplete();
    }
    
    /**
     * 處理流式完成
     */
    handleStreamComplete() {
        this.isStreaming = false;
        this.updateUI(false);
        this.updateConnectionStatus('ready', '就緒');
        
        // 移除打字指示器
        if (this.currentMessageElement) {
            const typingIndicator = this.currentMessageElement.querySelector('.typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }
        
        this.currentMessageElement = null;
    }
    
    /**
     * 添加訊息到聊天區域
     */
    addMessage(type, content, isStreaming = false) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        
        if (isStreaming) {
            // 添加打字指示器
            contentDiv.innerHTML = `
                <span class="typing-indicator"></span>
                <span class="typing-indicator"></span>
                <span class="typing-indicator"></span>
            `;
        } else {
            contentDiv.textContent = content;
        }
        
        const timeDiv = document.createElement('div');
        timeDiv.className = 'message-time';
        timeDiv.textContent = this.formatTime(new Date());
        
        messageDiv.appendChild(contentDiv);
        messageDiv.appendChild(timeDiv);
        
        this.messagesContainer.appendChild(messageDiv);
        this.scrollToBottom();
        
        return contentDiv;
    }
    
    /**
     * 追加內容到當前訊息
     */
    appendToCurrentMessage(content) {
        if (!this.currentMessageElement) return;
        
        // 移除打字指示器（如果存在）
        const typingIndicators = this.currentMessageElement.querySelectorAll('.typing-indicator');
        typingIndicators.forEach(indicator => indicator.remove());
        
        // 使用 createTextNode 以避免 XSS 攻擊並提升效能
        const textNode = document.createTextNode(content);
        this.currentMessageElement.appendChild(textNode);
        
        // 滾動到底部
        this.scrollToBottom();
    }
    
    /**
     * 更新 UI 狀態
     */
    updateUI(isStreaming) {
        this.sendButton.style.display = isStreaming ? 'none' : 'flex';
        this.stopButton.style.display = isStreaming ? 'flex' : 'none';
        this.messageInput.disabled = isStreaming;
        
        if (isStreaming) {
            this.messageInput.placeholder = 'AI 正在回應中...';
        } else {
            this.messageInput.placeholder = '輸入您的問題...';
        }
    }
    
    /**
     * 更新連線狀態
     */
    updateConnectionStatus(status, text) {
        const indicator = this.connectionStatus.querySelector('.status-indicator');
        const statusText = this.connectionStatus.querySelector('.status-text');
        
        // 移除所有狀態類別
        indicator.className = 'status-indicator';
        
        // 添加對應狀態類別
        if (status !== 'ready') {
            indicator.classList.add(status);
        }
        
        statusText.textContent = text;
    }
    
    /**
     * 更新字元計數
     */
    updateCharCount() {
        const count = this.messageInput.value.length;
        const maxLength = this.messageInput.maxLength;
        this.charCount.textContent = `${count}/${maxLength}`;
        
        // 接近上限時變色警告
        if (count > maxLength * 0.9) {
            this.charCount.style.color = '#ef4444';
        } else {
            this.charCount.style.color = '#64748b';
        }
    }
    
    /**
     * 自動調整輸入框高度
     */
    autoResize(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }
    
    /**
     * 滾動到底部
     */
    scrollToBottom() {
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }
    
    /**
     * 格式化時間
     */
    formatTime(date) {
        const now = new Date();
        const diff = now - date;
        
        if (diff < 60000) { // 1分鐘內
            return '剛剛';
        } else if (diff < 3600000) { // 1小時內
            return `${Math.floor(diff / 60000)} 分鐘前`;
        } else if (date.toDateString() === now.toDateString()) { // 今天
            return date.toLocaleTimeString('zh-TW', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
        } else { // 其他日期
            return date.toLocaleDateString('zh-TW', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }
    }
    
    /**
     * 清理資源
     */
    cleanup() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
    }
}

// 初始化聊天應用
document.addEventListener('DOMContentLoaded', () => {
    const chat = new StreamingChat();
    
    // 全域錯誤處理
    window.addEventListener('error', (event) => {
        console.error('全域錯誤:', event.error);
    });
    
    // 全域未處理的 Promise 拒絕
    window.addEventListener('unhandledrejection', (event) => {
        console.error('未處理的 Promise 拒絕:', event.reason);
    });
});
```

---

## 4.5.4 進階功能實現

### 訊息歷史管理

```javascript
/**
 * 訊息歷史管理器
 */
class MessageHistory {
    constructor(maxSize = 100) {
        this.messages = [];
        this.maxSize = maxSize;
        this.currentIndex = -1;
        
        this.loadFromStorage();
    }
    
    /**
     * 添加訊息到歷史
     */
    add(message) {
        // 避免重複添加相同訊息
        if (this.messages[this.messages.length - 1] !== message) {
            this.messages.push(message);
            
            // 限制歷史大小
            if (this.messages.length > this.maxSize) {
                this.messages.shift();
            }
            
            this.currentIndex = this.messages.length;
            this.saveToStorage();
        }
    }
    
    /**
     * 獲取上一條訊息
     */
    getPrevious() {
        if (this.currentIndex > 0) {
            this.currentIndex--;
            return this.messages[this.currentIndex];
        }
        return null;
    }
    
    /**
     * 獲取下一條訊息
     */
    getNext() {
        if (this.currentIndex < this.messages.length - 1) {
            this.currentIndex++;
            return this.messages[this.currentIndex];
        } else if (this.currentIndex === this.messages.length - 1) {
            this.currentIndex = this.messages.length;
            return '';
        }
        return null;
    }
    
    /**
     * 重置索引
     */
    resetIndex() {
        this.currentIndex = this.messages.length;
    }
    
    /**
     * 儲存到本地存儲
     */
    saveToStorage() {
        try {
            localStorage.setItem('chatHistory', JSON.stringify(this.messages));
        } catch (error) {
            console.warn('無法儲存聊天歷史:', error);
        }
    }
    
    /**
     * 從本地存儲載入
     */
    loadFromStorage() {
        try {
            const stored = localStorage.getItem('chatHistory');
            if (stored) {
                this.messages = JSON.parse(stored);
                this.currentIndex = this.messages.length;
            }
        } catch (error) {
            console.warn('無法載入聊天歷史:', error);
            this.messages = [];
        }
    }
    
    /**
     * 清除歷史
     */
    clear() {
        this.messages = [];
        this.currentIndex = -1;
        localStorage.removeItem('chatHistory');
    }
}
```

### 打字效果增強

```javascript
/**
 * 打字效果管理器
 */
class TypingEffect {
    constructor(element, speed = 50) {
        this.element = element;
        this.speed = speed;
        this.isTyping = false;
        this.queue = [];
    }
    
    /**
     * 添加文字到打字佇列
     */
    addText(text) {
        this.queue.push(text);
        if (!this.isTyping) {
            this.processQueue();
        }
    }
    
    /**
     * 處理打字佇列
     */
    async processQueue() {
        this.isTyping = true;
        
        while (this.queue.length > 0) {
            const text = this.queue.shift();
            await this.typeText(text);
        }
        
        this.isTyping = false;
    }
    
    /**
     * 打字效果
     */
    async typeText(text) {
        for (let i = 0; i < text.length; i++) {
            this.element.textContent += text[i];
            
            // 滾動到底部
            this.element.scrollIntoView({ behavior: 'smooth', block: 'end' });
            
            // 等待
            await this.delay(this.speed);
        }
    }
    
    /**
     * 延遲函數
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    /**
     * 停止打字效果
     */
    stop() {
        this.queue = [];
        this.isTyping = false;
    }
}
```

### 重連機制

```javascript
/**
 * 自動重連管理器
 */
class ReconnectionManager {
    constructor(maxRetries = 3, baseDelay = 1000) {
        this.maxRetries = maxRetries;
        this.baseDelay = baseDelay;
        this.retryCount = 0;
        this.isReconnecting = false;
    }
    
    /**
     * 嘗試重連
     */
    async attemptReconnection(reconnectFunction) {
        if (this.isReconnecting || this.retryCount >= this.maxRetries) {
            return false;
        }
        
        this.isReconnecting = true;
        
        try {
            // 指數退避延遲 + 隨機抖動（避免雷擊效應）
            const jitter = Math.random() * 0.1 + 0.95; // 0.95-1.05
            const delay = this.baseDelay * Math.pow(2, this.retryCount) * jitter;
            console.log(`嘗試重連 (${this.retryCount + 1}/${this.maxRetries})，延遲 ${Math.round(delay)}ms`);
            
            await this.delay(delay);
            
            // 執行重連函數
            await reconnectFunction();
            
            // 重連成功，重置計數器
            this.retryCount = 0;
            this.isReconnecting = false;
            
            console.log('重連成功');
            return true;
            
        } catch (error) {
            this.retryCount++;
            this.isReconnecting = false;
            
            console.error(`重連失敗 (${this.retryCount}/${this.maxRetries}):`, error);
            
            if (this.retryCount >= this.maxRetries) {
                console.error('已達到最大重連次數，停止重連');
                return false;
            }
            
            // 遞迴重試
            return this.attemptReconnection(reconnectFunction);
        }
    }
    
    /**
     * 重置重連計數器
     */
    reset() {
        this.retryCount = 0;
        this.isReconnecting = false;
    }
    
    /**
     * 延遲函數
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
```

---

## 4.5.5 React 整合範例

### React Hook 實現

```jsx
import React, { useState, useEffect, useRef, useCallback } from 'react';

/**
 * 流式聊天 Hook
 */
function useStreamingChat() {
    const [messages, setMessages] = useState([]);
    const [isStreaming, setIsStreaming] = useState(false);
    const [connectionStatus, setConnectionStatus] = useState('ready');
    const eventSourceRef = useRef(null);
    const currentMessageRef = useRef('');
    
    /**
     * 發送訊息
     */
    const sendMessage = useCallback(async (message, systemPrompt = null) => {
        if (!message.trim() || isStreaming) return;
        
        // 添加使用者訊息
        const userMessage = {
            id: Date.now(),
            type: 'user',
            content: message,
            timestamp: new Date()
        };
        
        setMessages(prev => [...prev, userMessage]);
        setIsStreaming(true);
        setConnectionStatus('connecting');
        
        // 準備 AI 訊息
        const aiMessage = {
            id: Date.now() + 1,
            type: 'ai',
            content: '',
            timestamp: new Date(),
            isStreaming: true
        };
        
        setMessages(prev => [...prev, aiMessage]);
        currentMessageRef.current = '';
        
        try {
            // 建立 EventSource
            let url = `/api/ai/chat/stream?prompt=${encodeURIComponent(message)}`;
            if (systemPrompt) {
                url += `&system=${encodeURIComponent(systemPrompt)}`;
            }
            
            eventSourceRef.current = new EventSource(url);
            
            // 設定事件監聽器
            eventSourceRef.current.onmessage = (event) => {
                const content = event.data;
                if (content) {
                    currentMessageRef.current += content;
                    
                    setMessages(prev => 
                        prev.map(msg => 
                            msg.id === aiMessage.id 
                                ? { ...msg, content: currentMessageRef.current }
                                : msg
                        )
                    );
                }
            };
            
            eventSourceRef.current.onopen = () => {
                setConnectionStatus('connected');
            };
            
            eventSourceRef.current.onerror = (error) => {
                console.error('EventSource 錯誤:', error);
                handleStreamComplete();
                
                if (eventSourceRef.current?.readyState === EventSource.CLOSED) {
                    setConnectionStatus('ready');
                } else {
                    setConnectionStatus('error');
                }
            };
            
        } catch (error) {
            console.error('發送訊息失敗:', error);
            handleStreamComplete();
            setConnectionStatus('error');
        }
    }, [isStreaming]);
    
    /**
     * 停止流式接收
     */
    const stopStreaming = useCallback(() => {
        if (eventSourceRef.current) {
            eventSourceRef.current.close();
            eventSourceRef.current = null;
        }
        handleStreamComplete();
    }, []);
    
    /**
     * 處理流式完成
     */
    const handleStreamComplete = useCallback(() => {
        setIsStreaming(false);
        setConnectionStatus('ready');
        
        // 更新最後一條 AI 訊息狀態
        setMessages(prev => 
            prev.map(msg => 
                msg.isStreaming 
                    ? { ...msg, isStreaming: false }
                    : msg
            )
        );
    }, []);
    
    /**
     * 清除聊天記錄
     */
    const clearMessages = useCallback(() => {
        setMessages([]);
        stopStreaming();
    }, [stopStreaming]);
    
    // 清理效果
    useEffect(() => {
        return () => {
            if (eventSourceRef.current) {
                eventSourceRef.current.close();
                eventSourceRef.current = null;
            }
        };
    }, []);
    
    return {
        messages,
        isStreaming,
        connectionStatus,
        sendMessage,
        stopStreaming,
        clearMessages
    };
}

/**
 * 流式聊天組件
 */
function StreamingChatComponent() {
    const {
        messages,
        isStreaming,
        connectionStatus,
        sendMessage,
        stopStreaming,
        clearMessages
    } = useStreamingChat();
    
    const [inputMessage, setInputMessage] = useState('');
    const messagesEndRef = useRef(null);
    
    // 自動滾動到底部
    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);
    
    const handleSend = () => {
        if (inputMessage.trim()) {
            sendMessage(inputMessage);
            setInputMessage('');
        }
    };
    
    const handleKeyPress = (e) => {
        if (e.key === 'Enter' && e.ctrlKey) {
            handleSend();
        }
    };
    
    return (
        <div className="streaming-chat">
            {/* 聊天標題 */}
            <div className="chat-header">
                <h1>🤖 AI 助手</h1>
                <div className="connection-status">
                    <span className={`status-indicator ${connectionStatus}`}></span>
                    <span>{getStatusText(connectionStatus)}</span>
                </div>
            </div>
            
            {/* 訊息列表 */}
            <div className="messages-container">
                {messages.map((message) => (
                    <MessageComponent key={message.id} message={message} />
                ))}
                <div ref={messagesEndRef} />
            </div>
            
            {/* 輸入區域 */}
            <div className="input-container">
                <textarea
                    value={inputMessage}
                    onChange={(e) => setInputMessage(e.target.value)}
                    onKeyPress={handleKeyPress}
                    placeholder={isStreaming ? 'AI 正在回應中...' : '輸入您的問題...'}
                    disabled={isStreaming}
                    rows={1}
                />
                
                {isStreaming ? (
                    <button onClick={stopStreaming} className="stop-button">
                        ⏹️ 停止
                    </button>
                ) : (
                    <button 
                        onClick={handleSend} 
                        disabled={!inputMessage.trim()}
                        className="send-button"
                    >
                        📤 發送
                    </button>
                )}
                
                <button onClick={clearMessages} className="clear-button">
                    🗑️ 清除
                </button>
            </div>
        </div>
    );
}

/**
 * 訊息組件
 */
function MessageComponent({ message }) {
    return (
        <div className={`message ${message.type}`}>
            <div className="message-content">
                {message.isStreaming && !message.content ? (
                    <TypingIndicator />
                ) : (
                    <MessageContent content={message.content} />
                )}
            </div>
            <div className="message-time">
                {formatTime(message.timestamp)}
            </div>
        </div>
    );
}

/**
 * 打字指示器組件
 */
function TypingIndicator() {
    return (
        <div className="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
        </div>
    );
}

/**
 * 訊息內容組件（支援 Markdown）
 */
function MessageContent({ content }) {
    // 這裡可以整合 Markdown 渲染器
    return <div className="content">{content}</div>;
}

/**
 * 獲取狀態文字
 */
function getStatusText(status) {
    switch (status) {
        case 'connecting': return '連線中...';
        case 'connected': return '已連線';
        case 'error': return '連線錯誤';
        default: return '就緒';
    }
}

/**
 * 格式化時間
 */
function formatTime(date) {
    return date.toLocaleTimeString('zh-TW', {
        hour: '2-digit',
        minute: '2-digit'
    });
}

export default StreamingChatComponent;
```

---

## 4.5.6 效能優化與最佳實踐

### 記憶體管理

```javascript
/**
 * 記憶體優化的聊天管理器
 */
class OptimizedChatManager {
    constructor(maxMessages = 50) {
        this.maxMessages = maxMessages;
        this.messages = [];
        this.observers = new Set();
    }
    
    /**
     * 添加訊息（自動清理舊訊息）
     */
    addMessage(message) {
        this.messages.push(message);
        
        // 限制訊息數量，避免記憶體洩漏
        if (this.messages.length > this.maxMessages) {
            const removed = this.messages.splice(0, this.messages.length - this.maxMessages);
            
            // 清理 DOM 元素
            removed.forEach(msg => {
                if (msg.element && msg.element.parentNode) {
                    msg.element.parentNode.removeChild(msg.element);
                }
            });
        }
        
        this.notifyObservers('messageAdded', message);
    }
    
    /**
     * 訂閱變更通知
     */
    subscribe(callback) {
        this.observers.add(callback);
        
        // 返回取消訂閱函數
        return () => {
            this.observers.delete(callback);
        };
    }
    
    /**
     * 通知觀察者
     */
    notifyObservers(event, data) {
        this.observers.forEach(callback => {
            try {
                callback(event, data);
            } catch (error) {
                console.error('觀察者回調錯誤:', error);
            }
        });
    }
    
    /**
     * 清理資源
     */
    cleanup() {
        this.messages = [];
        this.observers.clear();
    }
}
```

### 節流與防抖

```javascript
/**
 * 工具函數：節流
 */
function throttle(func, limit) {
    let inThrottle;
    return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

/**
 * 工具函數：防抖
 */
function debounce(func, wait, immediate) {
    let timeout;
    return function() {
        const context = this;
        const args = arguments;
        const later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
}

// 使用範例
const throttledScrollHandler = throttle(() => {
    // 處理滾動事件
}, 100);

const debouncedInputHandler = debounce((value) => {
    // 處理輸入變更
}, 300);
```

### 錯誤邊界處理

```javascript
/**
 * 錯誤邊界管理器
 */
class ErrorBoundary {
    constructor() {
        this.errorHandlers = new Map();
        this.setupGlobalErrorHandling();
    }
    
    /**
     * 設定全域錯誤處理
     */
    setupGlobalErrorHandling() {
        // 捕獲 JavaScript 錯誤
        window.addEventListener('error', (event) => {
            this.handleError('javascript', event.error, {
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        });
        
        // 捕獲 Promise 拒絕
        window.addEventListener('unhandledrejection', (event) => {
            this.handleError('promise', event.reason);
        });
        
        // 捕獲 EventSource 錯誤
        this.registerErrorHandler('eventsource', (error, context) => {
            console.error('EventSource 錯誤:', error);
            
            // 嘗試重連
            if (context && context.reconnect) {
                setTimeout(() => {
                    context.reconnect();
                }, 5000);
            }
        });
    }
    
    /**
     * 註冊錯誤處理器
     */
    registerErrorHandler(type, handler) {
        this.errorHandlers.set(type, handler);
    }
    
    /**
     * 處理錯誤
     */
    handleError(type, error, context = null) {
        const handler = this.errorHandlers.get(type);
        if (handler) {
            handler(error, context);
        } else {
            console.error(`未處理的 ${type} 錯誤:`, error);
        }
    }
}

// 全域錯誤邊界實例
const errorBoundary = new ErrorBoundary();
```

---

## 📝 本章重點回顧

1. **EventSource API 掌握**：學會了使用瀏覽器原生的 SSE 技術接收流式資料
2. **流式 UI 實現**：建立了完整的聊天介面，包含即時更新和互動效果
3. **連線管理**：掌握了連線建立、維護、錯誤處理和自動重連機制
4. **使用者體驗優化**：實現了打字效果、載入狀態、歷史管理等細節
5. **現代框架整合**：學會了在 React 等框架中整合流式功能

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **EventSource API** | ⭐⭐⭐ | 低 | 所有流式應用 |
| **連線管理** | ⭐⭐⭐ | 中 | 生產環境必需 |
| **錯誤處理** | ⭐⭐⭐ | 中 | 穩定性保證 |
| **UI 即時更新** | ⭐⭐ | 低 | 使用者體驗 |
| **記憶體優化** | ⭐⭐ | 中 | 長時間使用 |
| **自動重連** | ⭐⭐ | 高 | 網路不穩定環境 |

### 最佳實踐建議

1. **始終處理錯誤**：EventSource 連線可能因各種原因中斷
2. **限制訊息數量**：避免長時間使用造成的記憶體洩漏
3. **提供使用者控制**：允許使用者停止流式接收
4. **優雅降級**：在不支援 SSE 的環境中提供替代方案
5. **效能監控**：監控連線狀態和資源使用情況
6. **安全性考量**：使用 createTextNode 避免 XSS 攻擊
7. **重連優化**：加入隨機抖動避免雷擊效應
8. **資源清理**：確保組件卸載時正確關閉連線

### 下一步學習方向

完成第四章的學習後，我們已經掌握了 Spring AI 的基礎知識和流式輸出技術。在第五章中，我們將進入更進階的主題，學習如何建立個性化的 ChatBot，包括提示詞範本、多模態處理等高級功能。

---

## 🔧 本章程式碼優化摘要

本章實現的程式碼已根據最佳實踐進行了以下關鍵優化：

### 安全性增強
- ✅ 使用 `createTextNode` 替代 `textContent +=` 防止 XSS 攻擊
- ✅ 適當的輸入驗證和清理機制

### 效能優化
- ✅ 重連機制加入隨機抖動避免雷擊效應
- ✅ React Hook 中正確設置 ref 為 null 防止記憶體洩漏
- ✅ 訊息數量限制和舊訊息自動清理

### 穩定性提升
- ✅ 完善的錯誤邊界處理
- ✅ 資源清理和連線關閉機制
- ✅ 防抖節流機制避免過度請求

這些優化確保了代碼在生產環境中的穩定性、安全性和效能表現。

---

**參考資料：**
- [Server-Sent Events - MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)
- [EventSource API - MDN](https://developer.mozilla.org/en-US/docs/Web/API/EventSource)
- [React Hooks Documentation](https://reactjs.org/docs/hooks-intro.html)
- [Web Performance Best Practices](https://web.dev/performance/)


\newpage


# 第五章：Spring AI 進階功能 {.unnumbered .unlisted}


## 5.1 懶得打字問 AI？用提示詞範本吧


> **本章重點**：學習使用提示詞範本（Prompt Template）來標準化和優化 AI 互動，提升提示詞的品質和一致性，為個性化 ChatBot 奠定基礎。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解提示詞範本的重要性**：掌握「Garbage in, Garbage out」原則在 AI 中的應用
- 🎯 **使用 PromptTemplate 類別**：學會建立和使用動態提示詞範本
- 🎯 **整合 ChatClient API**：將範本與現代化的 ChatClient 流暢 API 結合
- 🎯 **建立範本庫**：設計可重複使用的提示詞範本系統
- 🎯 **優化提示詞品質**：掌握提示詞設計的最佳實踐

---

## 5.1.1 為什麼需要提示詞範本？

### Garbage in, Garbage out

![提示詞範本](https://ithelp.ithome.com.tw/upload/images/20240810/201612907PBWefpaFK.jpg)

**Garbage in, Garbage out** 也適用在 AI 領域。有些人就是不知如何問 AI，得到的解答自然也不具參考價值，這時提示詞範本就派上用場了。

### 提示詞範本的核心價值

**1. 標準化互動模式**
```
❌ 不良提示詞：
"告訴我關於 Spring Boot"

✅ 優質提示詞範本：
"作為一個資深的 Java 開發專家，請詳細說明 {topic} 的核心概念、
主要特性、使用場景，並提供一個實際的程式碼範例。
請用繁體中文回答，並確保內容適合 {experience_level} 開發者。"
```

**2. 提升回應品質**
- 🎯 **明確的角色設定**：讓 AI 扮演特定專業角色
- 📋 **結構化要求**：指定回應的格式和內容結構
- 🌍 **語言和風格**：統一回應的語言和表達風格
- 🎚️ **難度控制**：根據使用者程度調整內容深度

**3. 提高開發效率**
- 🔄 **可重複使用**：一次設計，多次使用
- 🛠️ **參數化設計**：透過變數動態調整內容
- 📚 **範本庫管理**：建立企業級提示詞資產
- 🚀 **快速部署**：減少重複的提示詞設計工作

---

## 5.1.2 PromptTemplate 基礎使用

### 基本範本語法

```java
package com.example.service;

import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.chat.prompt.PromptTemplate;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
public class PromptTemplateService {
    
    /**
     * 基本範本使用範例
     */
    public Prompt createBasicPrompt(String topic, String level) {
        // 定義範本字串，使用 {變數名} 作為佔位符
        String template = """
            作為一個資深的技術專家，請詳細說明 {topic} 的相關知識。
            
            請包含以下內容：
            1. 核心概念和定義
            2. 主要特性和優勢
            3. 實際應用場景
            4. 簡單的程式碼範例
            
            目標受眾：{level} 開發者
            回答語言：繁體中文
            回答風格：專業且易懂
            """;
        
        // 建立 PromptTemplate 實例
        PromptTemplate promptTemplate = new PromptTemplate(template);
        
        // 提供變數值
        Map<String, Object> variables = Map.of(
            "topic", topic,
            "level", level
        );
        
        // 生成最終的 Prompt
        return promptTemplate.create(variables);
    }
}
```

### 與 ChatClient 整合

```java
package com.example.controller;

import com.example.service.PromptTemplateService;
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/template")
@RequiredArgsConstructor
public class TemplateController {
    
    private final ChatClient chatClient;
    private final PromptTemplateService promptTemplateService;
    
    /**
     * 使用範本進行 AI 對話
     * @param topic 主題
     * @param level 程度（初級/中級/高級）
     * @return AI 回應
     */
    @GetMapping("/explain")
    public String explainTopic(
            @RequestParam String topic,
            @RequestParam(defaultValue = "中級") String level) {
        
        // 使用範本服務建立 Prompt
        Prompt prompt = promptTemplateService.createBasicPrompt(topic, level);
        
        // 使用 ChatClient 執行對話
        return chatClient.prompt(prompt)
                .call()
                .content();
    }
    
    /**
     * 簡化的範本使用方式
     * @param framework 框架名稱
     * @return AI 回應
     */
    @GetMapping("/framework")
    public String explainFramework(@RequestParam String framework) {
        return chatClient.prompt("請問 {framework} 目前有哪些版本，各有什麼特殊能力和改進？")
                .user(Map.of("framework", framework))
                .call()
                .content();
    }
}
```

---

## 5.1.3 進階範本設計

### 多參數範本

```java
@Service
public class AdvancedPromptService {
    
    /**
     * 程式碼生成範本
     */
    public Prompt createCodeGenerationPrompt(String language, String functionality) {
        String template = """
            你是 {language} 開發專家。
            
            請生成 {functionality} 的程式碼：
            1. 完整程式碼實現
            2. 簡單使用說明
            """;
        
        PromptTemplate promptTemplate = new PromptTemplate(template);
        return promptTemplate.create(Map.of(
            "language", language,
            "functionality", functionality
        ));
    }
    
    /**
     * 錯誤診斷範本
     */
    public Prompt createDiagnosisPrompt(String technology, String errorMessage) {
        String template = """
            你是 {technology} 專家，請分析錯誤：
            
            錯誤訊息：{errorMessage}
            
            請提供：
            1. 錯誤原因
            2. 解決方法
            """;
        
        PromptTemplate promptTemplate = new PromptTemplate(template);
        return promptTemplate.create(Map.of(
            "technology", technology,
            "errorMessage", errorMessage
        ));
    }
}
```

### 條件式範本

```java
@Service
public class ConditionalPromptService {
    
    public Prompt createUserSpecificPrompt(String topic, String level) {
        String template = switch (level) {
            case "初級" -> """
                你是耐心的導師。請用簡單語言說明 {topic}：
                1. 基本概念
                2. 為什麼重要
                3. 學習建議
                """;
            case "中級" -> """
                你是技術專家。請說明 {topic}：
                1. 核心原理
                2. 應用場景
                3. 程式碼範例
                """;
            default -> """
                你是資深架構師。請深度分析 {topic}：
                1. 實現原理
                2. 架構設計
                3. 最佳實踐
                """;
        };
        
        return new PromptTemplate(template).create(Map.of("topic", topic));
    }
}
```

---

## 5.1.4 範本庫管理系統

### 範本配置類

```java
package com.example.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.Map;

@Data
@Component
@ConfigurationProperties(prefix = "app.prompt.templates")
public class PromptTemplateConfig {
    
    /**
     * 預定義範本庫
     */
    private Map<String, String> library = Map.of(
        "explain", """
            作為一個 {role} 專家，請詳細說明 {topic}。
            
            請包含：
            1. 核心概念
            2. 主要特性
            3. 使用場景
            4. 實際範例
            
            目標受眾：{audience}
            回答語言：{language}
            """,
            
        "code-review", """
            你是一個資深的 {language} 程式碼審查專家。
            
            請審查以下程式碼：
            ```{language}
            {code}
            ```
            
            請提供：
            1. 程式碼品質評估
            2. 潛在問題識別
            3. 改進建議
            4. 最佳實踐建議
            
            請用 {language} 回答。
            """,
            
        "troubleshoot", """
            你是一個 {technology} 故障排除專家。
            
            **問題描述**：{problem}
            **錯誤訊息**：{error}
            **環境資訊**：{environment}
            
            請提供：
            ## 🔍 問題診斷
            ## 🛠️ 解決步驟
            ## 🚀 預防措施
            
            請提供具體可執行的解決方案。
            """
    );
    
    /**
     * 預設參數值
     */
    private Map<String, String> defaults = Map.of(
        "language", "繁體中文",
        "role", "技術專家",
        "audience", "中級開發者"
    );
}
```

### 範本管理服務

```java
package com.example.service;

import com.example.config.PromptTemplateConfig;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.chat.prompt.PromptTemplate;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;

@Service
@RequiredArgsConstructor
@Slf4j
public class PromptTemplateManager {
    
    private final PromptTemplateConfig config;
    
    /**
     * 根據範本名稱建立 Prompt
     * @param templateName 範本名稱
     * @param variables 變數值
     * @return 建立的 Prompt
     */
    public Prompt createPrompt(String templateName, Map<String, Object> variables) {
        String template = config.getLibrary().get(templateName);
        if (template == null) {
            throw new IllegalArgumentException("範本不存在: " + templateName);
        }
        
        // 合併預設值和使用者提供的變數
        Map<String, Object> mergedVariables = new HashMap<>(config.getDefaults());
        mergedVariables.putAll(variables);
        
        log.debug("使用範本 '{}' 建立 Prompt，變數：{}", templateName, mergedVariables);
        
        PromptTemplate promptTemplate = new PromptTemplate(template);
        return promptTemplate.create(mergedVariables);
    }
    
    /**
     * 動態註冊新範本
     * @param name 範本名稱
     * @param template 範本內容
     */
    public void registerTemplate(String name, String template) {
        config.getLibrary().put(name, template);
        log.info("註冊新範本：{}", name);
    }
    
    /**
     * 獲取所有可用範本名稱
     * @return 範本名稱列表
     */
    public Set<String> getAvailableTemplates() {
        return config.getLibrary().keySet();
    }
    
    /**
     * 驗證範本語法
     * @param template 範本內容
     * @param variables 測試變數
     * @return 是否有效
     */
    public boolean validateTemplate(String template, Map<String, Object> variables) {
        try {
            PromptTemplate promptTemplate = new PromptTemplate(template);
            promptTemplate.create(variables);
            return true;
        } catch (Exception e) {
            log.warn("範本驗證失敗：{}", e.getMessage());
            return false;
        }
    }
}
```

---

## 5.1.5 實際應用範例

### 智能客服範本系統

```java
package com.example.controller;

import com.example.service.PromptTemplateManager;
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/customer-service")
@RequiredArgsConstructor
public class CustomerServiceController {
    
    private final ChatClient chatClient;
    private final PromptTemplateManager templateManager;
    
    /**
     * 技術支援
     * @param product 產品名稱
     * @param issue 問題描述
     * @param severity 嚴重程度
     * @return 支援回應
     */
    @PostMapping("/technical-support")
    public String technicalSupport(
            @RequestParam String product,
            @RequestParam String issue,
            @RequestParam(defaultValue = "medium") String severity) {
        
        // 註冊技術支援範本（如果尚未存在）
        String supportTemplate = """
            你是 {product} 的資深技術支援專家。
            
            **客戶問題**：{issue}
            **嚴重程度**：{severity}
            
            請提供專業的技術支援回應：
            
            ## 🔍 問題理解
            重述並確認問題的核心
            
            ## 🛠️ 解決方案
            提供具體的解決步驟
            
            ## 📋 後續追蹤
            建議的後續行動
            
            請保持專業、友善的語調，用繁體中文回答。
            """;
        
        templateManager.registerTemplate("technical-support", supportTemplate);
        
        // 建立 Prompt
        Prompt prompt = templateManager.createPrompt("technical-support", Map.of(
            "product", product,
            "issue", issue,
            "severity", severity
        ));
        
        return chatClient.prompt(prompt)
                .call()
                .content();
    }
    
    /**
     * 產品諮詢
     * @param category 產品類別
     * @param budget 預算範圍
     * @param requirements 需求描述
     * @return 諮詢回應
     */
    @PostMapping("/product-consultation")
    public String productConsultation(
            @RequestParam String category,
            @RequestParam String budget,
            @RequestParam String requirements) {
        
        String consultationTemplate = """
            你是一個專業的 {category} 產品顧問。
            
            **客戶需求**：{requirements}
            **預算範圍**：{budget}
            
            請提供個人化的產品建議：
            
            ## 🎯 需求分析
            分析客戶的核心需求
            
            ## 💡 產品推薦
            推薦最適合的產品方案
            
            ## 💰 價值說明
            說明推薦產品的價值和優勢
            
            ## 📞 下一步行動
            建議客戶的下一步行動
            
            請用專業且親切的語調回答。
            """;
        
        templateManager.registerTemplate("product-consultation", consultationTemplate);
        
        Prompt prompt = templateManager.createPrompt("product-consultation", Map.of(
            "category", category,
            "budget", budget,
            "requirements", requirements
        ));
        
        return chatClient.prompt(prompt)
                .call()
                .content();
    }
}
```

### 教育訓練範本系統

```java
@RestController
@RequestMapping("/api/education")
@RequiredArgsConstructor
public class EducationController {
    
    private final ChatClient chatClient;
    private final PromptTemplateManager templateManager;
    
    /**
     * 課程內容生成
     * @param subject 科目
     * @param level 程度
     * @param duration 時長（分鐘）
     * @return 課程內容
     */
    @PostMapping("/generate-lesson")
    public String generateLesson(
            @RequestParam String subject,
            @RequestParam String level,
            @RequestParam int duration) {
        
        String lessonTemplate = """
            你是一個經驗豐富的 {subject} 教師。
            
            請為 {level} 學生設計一堂 {duration} 分鐘的課程：
            
            ## 📚 課程目標
            明確的學習目標（3-5個）
            
            ## 🕐 課程大綱
            詳細的時間分配和內容安排
            
            ## 💡 教學活動
            互動式的教學活動設計
            
            ## 📝 評量方式
            檢驗學習成效的方法
            
            ## 🏠 課後作業
            鞏固學習的練習題目
            
            請確保內容適合目標學生程度，並具有實用性。
            """;
        
        templateManager.registerTemplate("lesson-plan", lessonTemplate);
        
        Prompt prompt = templateManager.createPrompt("lesson-plan", Map.of(
            "subject", subject,
            "level", level,
            "duration", String.valueOf(duration)
        ));
        
        return chatClient.prompt(prompt)
                .call()
                .content();
    }
}
```

---

## 5.1.6 範本設計最佳實踐

### 設計原則

**1. 清晰的角色定義**
```java
// ✅ 好的範本
String template = """
    你是一個擁有10年經驗的 Spring Boot 架構師，
    專精於微服務架構設計和效能優化。
    
    請針對 {question} 提供專業建議...
    """;

// ❌ 不好的範本
String template = "請回答 {question}";
```

**2. 結構化輸出格式**
```java
String template = """
    請按照以下格式回答：
    
    ## 🎯 核心概念
    [簡潔的概念說明]
    
    ## 🔧 實作方法
    [具體的實作步驟]
    
    ## 💡 最佳實踐
    [相關的最佳實踐建議]
    
    ## ⚠️ 注意事項
    [重要的注意事項]
    """;
```

**3. 參數驗證和預設值**
```java
@Service
public class ValidatedPromptService {
    
    public Prompt createValidatedPrompt(String template, Map<String, Object> variables) {
        // 驗證必要參數
        validateRequiredParameters(template, variables);
        
        // 設定預設值
        Map<String, Object> mergedVariables = applyDefaults(variables);
        
        // 清理和格式化參數
        Map<String, Object> cleanedVariables = cleanParameters(mergedVariables);
        
        PromptTemplate promptTemplate = new PromptTemplate(template);
        return promptTemplate.create(cleanedVariables);
    }
    
    private void validateRequiredParameters(String template, Map<String, Object> variables) {
        // 提取範本中的所有變數
        Set<String> templateVariables = extractTemplateVariables(template);
        
        // 檢查必要參數是否存在
        for (String var : templateVariables) {
            if (!variables.containsKey(var) || variables.get(var) == null) {
                throw new IllegalArgumentException("缺少必要參數: " + var);
            }
        }
    }
    
    private Map<String, Object> applyDefaults(Map<String, Object> variables) {
        Map<String, Object> result = new HashMap<>(variables);
        
        // 設定預設值
        result.putIfAbsent("language", "繁體中文");
        result.putIfAbsent("style", "專業且友善");
        result.putIfAbsent("format", "結構化");
        
        return result;
    }
    
    private Map<String, Object> cleanParameters(Map<String, Object> variables) {
        return variables.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                entry -> cleanParameterValue(entry.getValue())
            ));
    }
    
    private Object cleanParameterValue(Object value) {
        if (value instanceof String str) {
            // 清理字串：移除多餘空白、特殊字元等
            return str.trim().replaceAll("\\s+", " ");
        }
        return value;
    }
}
```

### 效能優化

```java
@Service
@Slf4j
public class OptimizedPromptService {
    
    // 快取編譯後的範本
    private final Map<String, PromptTemplate> templateCache = new ConcurrentHashMap<>();
    
    /**
     * 快取範本以提升效能
     */
    public Prompt createCachedPrompt(String templateKey, String templateContent, Map<String, Object> variables) {
        PromptTemplate template = templateCache.computeIfAbsent(templateKey, key -> {
            log.debug("編譯並快取範本：{}", key);
            return new PromptTemplate(templateContent);
        });
        
        return template.create(variables);
    }
    
    /**
     * 批次處理多個範本
     */
    public List<Prompt> createBatchPrompts(String templateContent, List<Map<String, Object>> variablesList) {
        PromptTemplate template = new PromptTemplate(templateContent);
        
        return variablesList.parallelStream()
            .map(template::create)
            .collect(Collectors.toList());
    }
    
    /**
     * 清理快取
     */
    @EventListener
    public void clearCache() {
        templateCache.clear();
        log.info("範本快取已清理");
    }
}
```

---

## 📝 本章重點回顧

1. **提示詞範本的價值**：理解了「Garbage in, Garbage out」原則和範本的重要性
2. **PromptTemplate 使用**：掌握了基本和進階的範本建立方法
3. **ChatClient 整合**：學會了將範本與現代化的 ChatClient API 結合
4. **範本庫管理**：建立了企業級的範本管理系統
5. **最佳實踐**：掌握了範本設計、驗證和優化的最佳實踐

### 關鍵技術要點

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **基礎範本** | ⭐⭐⭐ | 低 | 所有 AI 應用 |
| **參數化設計** | ⭐⭐⭐ | 中 | 動態內容生成 |
| **範本庫管理** | ⭐⭐ | 中 | 企業級應用 |
| **條件式範本** | ⭐⭐ | 高 | 複雜業務邏輯 |
| **效能優化** | ⭐ | 中 | 高併發場景 |

### 下一步學習方向

在下一章中，我們將學習如何處理多模態資料，讓 AI 不僅能理解文字，還能處理圖片、音訊等多種媒體格式，進一步提升 ChatBot 的智能化程度。

---

**參考資料：**
- [Spring AI Prompt Template Documentation](https://docs.spring.io/spring-ai/reference/api/prompt.html)
- [ChatClient API Reference](https://docs.spring.io/spring-ai/reference/api/chatclient.html)
- [Prompt Engineering Best Practices](https://platform.openai.com/docs/guides/prompt-engineering)


\newpage

## 5.2 如何跟 ChatGPT 一樣處理多模態資料


> **本章重點**：學習使用 Spring AI 處理多模態資料，讓 AI 不僅能理解文字，還能分析圖片、音訊、影片等多種媒體格式，實現如同 ChatGPT 般的多模態互動體驗。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解多模態概念**：掌握多模態 AI 的核心原理和應用場景
- 🎯 **選擇合適的 AI 模型**：了解各種 AI 模型的多模態能力和限制
- 🎯 **實現圖片分析功能**：建立圖片上傳和分析的完整功能
- 🎯 **處理多種媒體格式**：支援圖片、音訊、影片等多種媒體類型
- 🎯 **優化多模態應用**：掌握效能優化和錯誤處理的最佳實踐

---

## 5.2.1 什麼是多模態 AI？

### 多模態就是同時提供兩種以上資料源

![多模態 AI](https://ithelp.ithome.com.tw/upload/images/20240810/201612905TZ6mYSAy1.jpg)

**多模態（Multimodality）** 是指 AI 系統能夠同時處理和理解多種不同類型的資料輸入，如文字、圖片、音訊、影片等。這種能力讓 AI 更接近人類的感知方式，能夠綜合多種感官資訊來理解和回應。

### Spring AI 中的多模態架構

還記得 Message 這張 UML 圖片嗎？在 UserMessage 中其實是可以包含多媒體檔案的：

![Spring AI Message 架構](https://ithelp.ithome.com.tw/upload/images/20240806/2016129049tSDbXBcM.jpg)

**重要說明**：雖然 UserMessage 類別支援直接傳入 Media 物件，但在實際開發中，**建議使用 ChatClient 的 fluent API**，因為它提供了更好的開發體驗和錯誤處理。

```java
// Spring AI 的多模態實現方式 - 使用 ChatClient fluent API
String response = chatClient.prompt()
    .user(u -> u.text("請分析這張圖片的內容")  // 文字部分
        .media(MimeTypeUtils.IMAGE_JPEG, imageResource))   // 圖片
    .call()
    .content();

// 也可以添加多個媒體檔案
String response = chatClient.prompt()
    .user(u -> u.text("請分析這些檔案")
        .media(MimeTypeUtils.IMAGE_JPEG, imageResource)
        .media(MimeTypeUtils.parseMediaType("audio/mp3"), audioResource))
    .call()
    .content();

// 💡 最佳實踐：建議將 Resource 和 MimeType 分開宣告，便於錯誤處理
Resource imageResource = new ClassPathResource("image.jpg");
MimeType mimeType = MimeTypeUtils.IMAGE_JPEG;

String response = chatClient.prompt()
    .user(u -> u.text("分析這張圖片")
        .media(mimeType, imageResource))
    .call()
    .content();
```

### 多模態的核心價值

**1. 更豐富的互動體驗**
- 📸 **視覺理解**：分析圖片內容、識別物體、理解場景
- 🎵 **聽覺處理**：語音轉文字、音樂分析、聲音識別
- 🎬 **影片分析**：動作識別、場景理解、內容摘要
- 📄 **文件處理**：OCR 文字識別、表格分析、版面理解

**2. 更準確的理解能力**
- 🔍 **上下文增強**：結合多種資訊源提供更準確的分析
- 🧠 **語義理解**：透過視覺和文字的結合提升理解深度
- 🎯 **精確回應**：基於多模態資訊提供更精確的答案

**3. 更廣泛的應用場景**
- 🏥 **醫療診斷**：結合影像和病歷資料進行輔助診斷
- 🛒 **電商應用**：商品圖片分析和推薦
- 📚 **教育培訓**：多媒體教材的智能分析和問答
- 🏭 **工業檢測**：設備圖片分析和故障診斷

---

## 5.2.2 支援多模態的 AI 模型

### 主流模型能力對比

目前有支援多模態的模型如下，其他模型送出多媒體檔案時可是會出現錯誤的：

| 模型提供商 | 模型名稱 | 圖像 | 音頻 | 視頻 | 文件 | 成本效益 | 推薦場景 |
|-----------|---------|------|------|------|------|----------|----------|
| **OpenAI** | GPT-4o | ✅ | ✅ | ✅ | ✅ | 高 | 全方位多模態應用 |
| **OpenAI** | GPT-4o mini | ✅ | ❌ | ❌ | ✅ | 極高 | 圖片分析、文件處理 |
| **OpenAI** | GPT-4 Vision | ✅ | ❌ | ❌ | ✅ | 中 | 圖片分析專用 |
| **Anthropic** | Claude 3.5 Sonnet | ✅ | ❌ | ❌ | ✅ | 高 | 圖片+文字分析 |
| **Anthropic** | Claude 3 Opus | ✅ | ❌ | ❌ | ✅ | 中 | 複雜圖片理解 |
| **Google** | Gemini 1.5 Pro | ✅ | ✅ | ✅ | ✅ | 中 | 多媒體內容分析 |
| **Google** | Gemini Pro Vision | ✅ | ❌ | ❌ | ✅ | 高 | 圖片識別 |
| **Ollama** | LlaVa | ✅ | ❌ | ❌ | ❌ | 極高(本地) | 本地圖片分析 |
| **Ollama** | Bakllava | ✅ | ❌ | ❌ | ❌ | 極高(本地) | 本地多模態 |

### 輸入輸出格式支援表

| Input | Output | Examples | 適用場景 |
|-------|--------|----------|----------|
| **Language/Code/Images** | Language/Code | GPT-4o, Gemini 1.5 Pro | 多模態問答、程式碼分析 |
| **Language/Code** | Language/Code | GPT-3.5, Claude 3 Haiku | 純文字對話 |
| **Language** | Image | DALL-E 3, Midjourney | 文字生成圖片 |
| **Language/Image** | Image | Stable Diffusion | 圖片編輯、風格轉換 |
| **Language** | Audio | OpenAI TTS, ElevenLabs | 文字轉語音 |
| **Audio** | Language | OpenAI Whisper | 語音轉文字 |
| **Text** | Numbers | Embedding Models | 向量化、相似度計算 |

### 模型選擇建議

```java
@Configuration
public class MultimodalModelConfig {
    
    @Value("${spring.ai.openai.api-key}")
    private String openaiApiKey;
    
    /**
     * 根據使用場景選擇合適的模型
     */
    @Bean
    @Primary
    public ChatModel primaryMultimodalModel() {
        // GPT-4o mini：性價比最高的圖片分析模型
        return OpenAiChatModel.builder()
            .apiKey(openaiApiKey)
            .modelName("gpt-4o-mini")
            .temperature(0.3)  // 較低溫度確保分析準確性
            .maxTokens(1500)
            .build();
    }
    
    /**
     * 高精度圖片分析模型
     */
    @Bean("highAccuracyModel")
    public ChatModel highAccuracyModel() {
        // GPT-4o：最強多模態能力
        return OpenAiChatModel.builder()
            .apiKey(openaiApiKey)
            .modelName("gpt-4o")
            .temperature(0.2)
            .maxTokens(2000)
            .build();
    }
    
    /**
     * 本地多模態模型（節省成本）
     */
    @Bean("localModel")
    @ConditionalOnProperty(name = "app.ai.local.enabled", havingValue = "true")
    public ChatModel localMultimodalModel() {
        // Ollama LlaVa：本地免費方案
        return OllamaChatModel.builder()
            .baseUrl("http://localhost:11434")
            .model("llava")
            .build();
    }
}
```

---

## 5.2.3 圖片分析功能實現

### 基礎圖片上傳和分析

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.core.io.Resource;
import org.springframework.http.MediaType;
import org.springframework.util.MimeType;
import org.springframework.util.MimeTypeUtils;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

@RestController
@RequestMapping("/api/multimodal")
@RequiredArgsConstructor
@Slf4j
public class MultimodalController {
    
    private final ChatClient chatClient;
    
    /**
     * 基礎圖片分析
     * @param file 上傳的圖片檔案
     * @param message 分析要求
     * @return AI 分析結果
     */
    @PostMapping(value = "/image-analysis", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public String analyzeImage(
            @RequestParam("file") MultipartFile file,
            @RequestParam("message") String message) {
        
        try {
            // 驗證檔案類型
            if (!isValidImageFile(file)) {
                return "❌ 不支援的圖片格式，請上傳 JPG、PNG、GIF 或 WebP 格式的圖片";
            }
            
            // 驗證檔案大小（限制 10MB）
            if (file.getSize() > 10 * 1024 * 1024) {
                return "❌ 圖片檔案過大，請上傳小於 10MB 的圖片";
            }
            
            log.info("開始分析圖片：{}，大小：{} bytes", file.getOriginalFilename(), file.getSize());
            
            // 創建 Spring Resource
            Resource imageResource = file.getResource();
            MimeType mimeType = MimeTypeUtils.parseMimeType(file.getContentType());
            
            // 使用 ChatClient 進行圖片分析
            String response = chatClient.prompt()
                    .user(u -> u.text(message)
                            .media(mimeType, imageResource))
                    .call()
                    .content();
            
            log.info("圖片分析完成");
            return response;
            
        } catch (IOException e) {
            log.error("圖片處理失敗", e);
            return "❌ 圖片處理失敗：" + e.getMessage();
        } catch (Exception e) {
            log.error("AI 分析失敗", e);
            return "❌ AI 分析失敗，請稍後再試：" + e.getMessage();
        }
    }
    
    /**
     * 驗證圖片檔案格式
     */
    private boolean isValidImageFile(MultipartFile file) {
        String contentType = file.getContentType();
        return contentType != null && (
            contentType.equals("image/jpeg") ||
            contentType.equals("image/png") ||
            contentType.equals("image/gif") ||
            contentType.equals("image/webp")
        );
    }
}
```

### 進階圖片分析功能

```java
@RestController
@RequestMapping("/api/advanced-multimodal")
@RequiredArgsConstructor
public class AdvancedMultimodalController {
    
    private final ChatClient chatClient;
    
    /**
     * 結構化圖片分析
     * @param file 圖片檔案
     * @param analysisType 分析類型
     * @return 結構化分析結果
     */
    @PostMapping("/structured-analysis")
    public ImageAnalysisResult structuredImageAnalysis(
            @RequestParam("file") MultipartFile file,
            @RequestParam("type") AnalysisType analysisType) {
        
        try {
            String prompt = buildAnalysisPrompt(analysisType);
            
            Resource fileResource = file.getResource();
            MimeType mimeType = MimeTypeUtils.parseMimeType(file.getContentType());
            
            String response = chatClient.prompt()
                    .user(u -> u.text(prompt)
                            .media(mimeType, fileResource))
                    .call()
                    .content();
            
            return parseAnalysisResult(response, analysisType);
            
        } catch (Exception e) {
            log.error("結構化分析失敗", e);
            return ImageAnalysisResult.error("分析失敗：" + e.getMessage());
        }
    }
    
    /**
     * 批次圖片分析
     * @param files 多個圖片檔案
     * @param message 分析要求
     * @return 批次分析結果
     */
    @PostMapping("/batch-analysis")
    public List<BatchAnalysisResult> batchImageAnalysis(
            @RequestParam("files") MultipartFile[] files,
            @RequestParam("message") String message) {
        
        return Arrays.stream(files)
                .parallel()
                .map(file -> processSingleImage(file, message))
                .collect(Collectors.toList());
    }
    
    /**
     * 圖片比較分析
     * @param file1 第一張圖片
     * @param file2 第二張圖片
     * @param comparisonType 比較類型
     * @return 比較結果
     */
    @PostMapping("/compare-images")
    public String compareImages(
            @RequestParam("file1") MultipartFile file1,
            @RequestParam("file2") MultipartFile file2,
            @RequestParam("type") ComparisonType comparisonType) {
        
        try {
            String prompt = buildComparisonPrompt(comparisonType);
            
            Resource resource1 = file1.getResource();
            Resource resource2 = file2.getResource();
            MimeType mimeType1 = MimeTypeUtils.parseMimeType(file1.getContentType());
            MimeType mimeType2 = MimeTypeUtils.parseMimeType(file2.getContentType());
            
            return chatClient.prompt()
                    .user(u -> u.text(prompt)
                            .media(mimeType1, resource1)
                            .media(mimeType2, resource2))
                    .call()
                    .content();
            
        } catch (Exception e) {
            log.error("圖片比較失敗", e);
            return "❌ 圖片比較失敗：" + e.getMessage();
        }
    }
    
    private String buildAnalysisPrompt(AnalysisType type) {
        return switch (type) {
            case OBJECT_DETECTION -> """
                請分析這張圖片中的所有物體，並按照以下格式回答：
                
                ## 🔍 物體識別
                - 物體名稱：[位置描述]
                
                ## 📊 統計資訊
                - 總物體數量：
                - 主要類別：
                
                ## 💡 場景描述
                [整體場景的描述]
                """;
                
            case TEXT_EXTRACTION -> """
                請提取這張圖片中的所有文字內容，並按照以下格式整理：
                
                ## 📝 文字內容
                [按照在圖片中的位置順序列出所有文字]
                
                ## 🏷️ 文字分類
                - 標題：
                - 正文：
                - 其他：
                
                ## 📋 結構化資訊
                [如果有表格、清單等結構化內容，請整理出來]
                """;
                
            case SCENE_ANALYSIS -> """
                請詳細分析這張圖片的場景，包含：
                
                ## 🌍 場景類型
                [室內/室外，具體場所]
                
                ## 🎨 視覺元素
                - 色彩：
                - 光線：
                - 構圖：
                
                ## 👥 人物活動
                [如果有人物，描述他們在做什麼]
                
                ## 🎯 整體氛圍
                [場景給人的感受和氛圍]
                """;
                
            case QUALITY_ASSESSMENT -> """
                請評估這張圖片的品質，包含：
                
                ## 📸 技術品質
                - 清晰度：[1-10分]
                - 曝光：[過曝/正常/欠曝]
                - 色彩：[1-10分]
                
                ## 🎨 藝術品質
                - 構圖：[1-10分]
                - 美感：[1-10分]
                
                ## 💡 改進建議
                [如何提升圖片品質的具體建議]
                """;
        };
    }
    
    private String buildComparisonPrompt(ComparisonType type) {
        return switch (type) {
            case SIMILARITY -> """
                請比較這兩張圖片的相似性：
                
                ## 🔍 相似點
                [列出兩張圖片的相似之處]
                
                ## 🆚 差異點
                [列出兩張圖片的不同之處]
                
                ## 📊 相似度評分
                整體相似度：[0-100%]
                
                ## 💡 總結
                [簡要總結比較結果]
                """;
                
            case QUALITY -> """
                請比較這兩張圖片的品質：
                
                ## 📸 技術品質比較
                - 清晰度：圖片1 vs 圖片2
                - 色彩：圖片1 vs 圖片2
                - 曝光：圖片1 vs 圖片2
                
                ## 🏆 推薦結果
                推薦圖片：[1/2]
                推薦理由：[具體說明]
                """;
                
            case CONTENT -> """
                請比較這兩張圖片的內容：
                
                ## 📋 內容對比
                - 主題：
                - 物體：
                - 場景：
                
                ## 🎯 用途建議
                - 圖片1適合：
                - 圖片2適合：
                """;
        };
    }
    
    public enum AnalysisType {
        OBJECT_DETECTION, TEXT_EXTRACTION, SCENE_ANALYSIS, QUALITY_ASSESSMENT
    }
    
    public enum ComparisonType {
        SIMILARITY, QUALITY, CONTENT
    }
}
```

---

## 5.2.4 多媒體檔案處理

### 音訊檔案分析

```java
@RestController
@RequestMapping("/api/audio")
@RequiredArgsConstructor
public class AudioAnalysisController {
    
    private final ChatClient chatClient;
    
    /**
     * 音訊內容分析（需要支援音訊的模型如 GPT-4o）
     * @param file 音訊檔案
     * @param analysisType 分析類型
     * @return 分析結果
     */
    @PostMapping("/analyze")
    public String analyzeAudio(
            @RequestParam("file") MultipartFile file,
            @RequestParam("type") AudioAnalysisType analysisType) {
        
        try {
            // 驗證音訊檔案格式
            if (!isValidAudioFile(file)) {
                return "❌ 不支援的音訊格式，請上傳 MP3、WAV、M4A 或 OGG 格式";
            }
            
            // 檔案大小限制（25MB）
            if (file.getSize() > 25 * 1024 * 1024) {
                return "❌ 音訊檔案過大，請上傳小於 25MB 的檔案";
            }
            
            String prompt = buildAudioAnalysisPrompt(analysisType);
            
            Resource audioResource = file.getResource();
            MimeType mimeType = MimeTypeUtils.parseMimeType(file.getContentType());
            
            return chatClient.prompt()
                    .user(u -> u.text(prompt)
                            .media(mimeType, audioResource))
                    .call()
                    .content();
            
        } catch (Exception e) {
            log.error("音訊分析失敗", e);
            return "❌ 音訊分析失敗：" + e.getMessage();
        }
    }
    
    private boolean isValidAudioFile(MultipartFile file) {
        String contentType = file.getContentType();
        return contentType != null && (
            contentType.equals("audio/mpeg") ||     // MP3
            contentType.equals("audio/wav") ||      // WAV
            contentType.equals("audio/mp4") ||      // M4A
            contentType.equals("audio/ogg")        // OGG
        );
    }
    
    private String buildAudioAnalysisPrompt(AudioAnalysisType type) {
        return switch (type) {
            case TRANSCRIPTION -> """
                請將這個音訊檔案轉換為文字，並按照以下格式輸出：
                
                ## 📝 轉錄內容
                [完整的語音轉文字內容]
                
                ## 🎤 音訊資訊
                - 語言：
                - 說話者數量：
                - 音訊品質：
                
                ## ⏱️ 時間資訊
                - 總時長：
                - 語速：
                """;
                
            case SENTIMENT -> """
                請分析這個音訊的情感和語調：
                
                ## 😊 情感分析
                - 整體情感：[正面/中性/負面]
                - 情感強度：[1-10]
                
                ## 🎵 語調特徵
                - 語速：[快/中/慢]
                - 音調：[高/中/低]
                - 語氣：[描述具體語氣]
                
                ## 💡 內容摘要
                [音訊內容的簡要摘要]
                """;
                
            case MUSIC_ANALYSIS -> """
                請分析這個音樂檔案：
                
                ## 🎵 音樂特徵
                - 風格/類型：
                - 節拍：
                - 調性：
                
                ## 🎼 樂器識別
                [識別出的樂器]
                
                ## 🎭 情緒氛圍
                [音樂給人的感受]
                
                ## 🎯 適用場景
                [這首音樂適合的使用場景]
                """;
        };
    }
    
    public enum AudioAnalysisType {
        TRANSCRIPTION, SENTIMENT, MUSIC_ANALYSIS
    }
}
```

### 影片檔案分析

```java
@RestController
@RequestMapping("/api/video")
@RequiredArgsConstructor
public class VideoAnalysisController {
    
    private final ChatClient chatClient;
    
    /**
     * 影片內容分析（需要支援影片的模型如 GPT-4o、Gemini 1.5 Pro）
     * @param file 影片檔案
     * @param analysisType 分析類型
     * @return 分析結果
     */
    @PostMapping("/analyze")
    public String analyzeVideo(
            @RequestParam("file") MultipartFile file,
            @RequestParam("type") VideoAnalysisType analysisType) {
        
        try {
            // 驗證影片檔案格式
            if (!isValidVideoFile(file)) {
                return "❌ 不支援的影片格式，請上傳 MP4、AVI、MOV 或 WebM 格式";
            }
            
            // 檔案大小限制（100MB）
            if (file.getSize() > 100 * 1024 * 1024) {
                return "❌ 影片檔案過大，請上傳小於 100MB 的檔案";
            }
            
            String prompt = buildVideoAnalysisPrompt(analysisType);
            
            Resource videoResource = file.getResource();
            MimeType mimeType = MimeTypeUtils.parseMimeType(file.getContentType());
            
            return chatClient.prompt()
                    .user(u -> u.text(prompt)
                            .media(mimeType, videoResource))
                    .call()
                    .content();
            
        } catch (Exception e) {
            log.error("影片分析失敗", e);
            return "❌ 影片分析失敗：" + e.getMessage();
        }
    }
    
    private boolean isValidVideoFile(MultipartFile file) {
        String contentType = file.getContentType();
        return contentType != null && (
            contentType.equals("video/mp4") ||      // MP4
            contentType.equals("video/avi") ||      // AVI
            contentType.equals("video/quicktime") || // MOV
            contentType.equals("video/webm")       // WebM
        );
    }
    
    private String buildVideoAnalysisPrompt(VideoAnalysisType type) {
        return switch (type) {
            case CONTENT_SUMMARY -> """
                請分析這個影片的內容並提供摘要：
                
                ## 📹 影片概述
                - 主題：
                - 類型：[教學/娛樂/新聞/其他]
                - 時長：
                
                ## 🎬 內容摘要
                [影片的主要內容摘要]
                
                ## 👥 人物活動
                [影片中的人物和他們的活動]
                
                ## 🎯 關鍵時刻
                [重要的場景或時間點]
                """;
                
            case SCENE_DETECTION -> """
                請分析這個影片的場景變化：
                
                ## 🎬 場景分析
                [按時間順序描述主要場景]
                
                ## 🔄 場景轉換
                [場景之間的轉換方式]
                
                ## 📍 拍攝地點
                [識別出的拍攝地點或環境]
                
                ## 🎨 視覺風格
                [影片的視覺風格和特色]
                """;
                
            case ACTION_RECOGNITION -> """
                請識別影片中的動作和活動：
                
                ## 🏃 動作識別
                [識別出的具體動作]
                
                ## 👥 互動分析
                [人物之間的互動]
                
                ## ⚽ 運動/活動
                [如果是運動影片，分析運動類型和技巧]
                
                ## 📊 活動統計
                [動作的頻率和持續時間]
                """;
        };
    }
    
    public enum VideoAnalysisType {
        CONTENT_SUMMARY, SCENE_DETECTION, ACTION_RECOGNITION
    }
}
```

---

## 5.2.5 企業級多模態應用

### 文件智能分析系統

```java
@Service
@RequiredArgsConstructor
public class DocumentAnalysisService {
    
    private final ChatClient chatClient;
    
    /**
     * 智能文件分析
     * @param file 文件檔案（PDF、圖片等）
     * @param analysisRequest 分析需求
     * @return 分析結果
     */
    public DocumentAnalysisResult analyzeDocument(
            MultipartFile file, 
            DocumentAnalysisRequest analysisRequest) {
        
        try {
            String prompt = buildDocumentAnalysisPrompt(analysisRequest);
            
            Resource fileResource = file.getResource();
            MimeType mimeType = MimeTypeUtils.parseMimeType(file.getContentType());
            
            String response = chatClient.prompt()
                    .user(u -> u.text(prompt)
                            .media(mimeType, fileResource))
                    .call()
                    .content();
            
            return DocumentAnalysisResult.builder()
                    .fileName(file.getOriginalFilename())
                    .fileSize(file.getSize())
                    .analysisType(analysisRequest.getType())
                    .result(response)
                    .timestamp(LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("文件分析失敗：{}", file.getOriginalFilename(), e);
            return DocumentAnalysisResult.error(e.getMessage());
        }
    }
    
    /**
     * 批次文件處理
     * @param files 多個文件
     * @param analysisRequest 分析需求
     * @return 批次處理結果
     */
    public List<DocumentAnalysisResult> batchAnalyzeDocuments(
            List<MultipartFile> files,
            DocumentAnalysisRequest analysisRequest) {
        
        return files.parallelStream()
                .map(file -> analyzeDocument(file, analysisRequest))
                .collect(Collectors.toList());
    }
    
    private String buildDocumentAnalysisPrompt(DocumentAnalysisRequest request) {
        String basePrompt = switch (request.getType()) {
            case OCR_EXTRACTION -> """
                請提取這個文件中的所有文字內容，並按照原始格式整理：
                
                ## 📄 文字內容
                [保持原始格式的文字內容]
                
                ## 📊 文件結構
                - 標題：
                - 段落數：
                - 表格：[如果有]
                - 清單：[如果有]
                
                ## 🔍 關鍵資訊
                [提取出的重要資訊，如日期、金額、姓名等]
                """;
                
            case FORM_ANALYSIS -> """
                請分析這個表單文件，提取所有欄位和值：
                
                ## 📋 表單資訊
                - 表單類型：
                - 表單標題：
                
                ## 📝 欄位內容
                [以「欄位名稱：值」的格式列出所有欄位]
                
                ## ✅ 完整性檢查
                - 已填寫欄位：
                - 空白欄位：
                - 必填欄位狀態：
                """;
                
            case CONTRACT_REVIEW -> """
                請分析這份合約文件的關鍵內容：
                
                ## 📜 合約基本資訊
                - 合約類型：
                - 當事人：
                - 簽署日期：
                - 有效期限：
                
                ## 💰 財務條款
                - 金額：
                - 付款方式：
                - 付款期限：
                
                ## ⚖️ 重要條款
                [列出重要的權利義務條款]
                
                ## ⚠️ 風險提醒
                [識別出的潛在風險點]
                """;
                
            case INVOICE_PROCESSING -> """
                請處理這張發票，提取所有相關資訊：
                
                ## 🧾 發票基本資訊
                - 發票號碼：
                - 開立日期：
                - 賣方：
                - 買方：
                
                ## 💵 金額明細
                - 小計：
                - 稅額：
                - 總計：
                
                ## 📦 商品/服務明細
                [列出所有商品或服務項目]
                
                ## ✅ 驗證狀態
                [檢查發票資訊的完整性和合理性]
                """;
        };
        
        // 加入客製化要求
        if (request.getCustomRequirements() != null && !request.getCustomRequirements().isEmpty()) {
            basePrompt += "\n\n## 🎯 特殊要求\n" + request.getCustomRequirements();
        }
        
        return basePrompt;
    }
}

@Data
@Builder
public class DocumentAnalysisRequest {
    private DocumentType type;
    private String customRequirements;
    private boolean extractTables;
    private boolean detectSignatures;
    private String targetLanguage;
    
    public enum DocumentType {
        OCR_EXTRACTION, FORM_ANALYSIS, CONTRACT_REVIEW, INVOICE_PROCESSING
    }
}

@Data
@Builder
public class DocumentAnalysisResult {
    private String fileName;
    private Long fileSize;
    private DocumentAnalysisRequest.DocumentType analysisType;
    private String result;
    private LocalDateTime timestamp;
    private boolean success;
    private String errorMessage;
    
    public static DocumentAnalysisResult error(String errorMessage) {
        return DocumentAnalysisResult.builder()
                .success(false)
                .errorMessage(errorMessage)
                .timestamp(LocalDateTime.now())
                .build();
    }
}
```

---

## 5.2.6 效能優化與最佳實踐

### 檔案處理優化

```java
@Service
@RequiredArgsConstructor
public class OptimizedMultimodalService {
    
    private final ChatClient chatClient;
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 帶快取的圖片分析
     */
    @Cacheable(value = "imageAnalysis", key = "#file.originalFilename + '_' + #message.hashCode()")
    public String analyzeImageWithCache(MultipartFile file, String message) {
        // 生成檔案雜湊值作為快取鍵
        String fileHash = generateFileHash(file);
        String cacheKey = "image_analysis:" + fileHash + ":" + message.hashCode();
        
        // 檢查快取
        String cachedResult = (String) redisTemplate.opsForValue().get(cacheKey);
        if (cachedResult != null) {
            log.info("從快取返回分析結果：{}", file.getOriginalFilename());
            return cachedResult;
        }
        
        // 執行分析
        String result = performImageAnalysis(file, message);
        
        // 儲存到快取（24小時）
        redisTemplate.opsForValue().set(cacheKey, result, Duration.ofHours(24));
        
        return result;
    }
    
    /**
     * 非同步批次處理
     */
    @Async
    public CompletableFuture<List<String>> batchAnalyzeAsync(
            List<MultipartFile> files, 
            String message) {
        
        List<CompletableFuture<String>> futures = files.stream()
                .map(file -> CompletableFuture.supplyAsync(() -> 
                    analyzeImageWithCache(file, message)))
                .collect(Collectors.toList());
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApply(v -> futures.stream()
                        .map(CompletableFuture::join)
                        .collect(Collectors.toList()));
    }
    
    /**
     * 圖片壓縮和優化
     */
    public MultipartFile optimizeImage(MultipartFile originalFile) {
        try {
            BufferedImage originalImage = ImageIO.read(originalFile.getInputStream());
            
            // 如果圖片太大，進行壓縮
            if (originalFile.getSize() > 5 * 1024 * 1024) { // 5MB
                BufferedImage resizedImage = resizeImage(originalImage, 1920, 1080);
                return convertToMultipartFile(resizedImage, originalFile.getOriginalFilename());
            }
            
            return originalFile;
            
        } catch (IOException e) {
            log.warn("圖片優化失敗，使用原始檔案：{}", e.getMessage());
            return originalFile;
        }
    }
    
    private BufferedImage resizeImage(BufferedImage original, int maxWidth, int maxHeight) {
        int originalWidth = original.getWidth();
        int originalHeight = original.getHeight();
        
        // 計算縮放比例
        double scaleX = (double) maxWidth / originalWidth;
        double scaleY = (double) maxHeight / originalHeight;
        double scale = Math.min(scaleX, scaleY);
        
        if (scale >= 1.0) {
            return original; // 不需要縮放
        }
        
        int newWidth = (int) (originalWidth * scale);
        int newHeight = (int) (originalHeight * scale);
        
        BufferedImage resized = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_RGB);
        Graphics2D g2d = resized.createGraphics();
        g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        g2d.drawImage(original, 0, 0, newWidth, newHeight, null);
        g2d.dispose();
        
        return resized;
    }
    
    private String generateFileHash(MultipartFile file) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] hash = md.digest(file.getBytes());
            return DatatypeConverter.printHexBinary(hash).toLowerCase();
        } catch (Exception e) {
            return String.valueOf(file.getOriginalFilename().hashCode());
        }
    }
}
```

### 錯誤處理和監控

```java
@Component
@Slf4j
public class MultimodalErrorHandler {
    
    private final MeterRegistry meterRegistry;
    private final Counter successCounter;
    private final Counter errorCounter;
    private final Timer processingTimer;
    
    public MultimodalErrorHandler(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.successCounter = Counter.builder("multimodal.analysis.success")
                .description("Successful multimodal analysis count")
                .register(meterRegistry);
        this.errorCounter = Counter.builder("multimodal.analysis.error")
                .description("Failed multimodal analysis count")
                .register(meterRegistry);
        this.processingTimer = Timer.builder("multimodal.analysis.duration")
                .description("Multimodal analysis processing time")
                .register(meterRegistry);
    }
    
    public <T> T executeWithMonitoring(
            String operation, 
            Supplier<T> supplier, 
            Function<Exception, T> errorHandler) {
        
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            T result = supplier.get();
            successCounter.increment(Tags.of("operation", operation));
            return result;
            
        } catch (Exception e) {
            errorCounter.increment(Tags.of(
                "operation", operation,
                "error_type", e.getClass().getSimpleName()
            ));
            
            log.error("多模態操作失敗：{}", operation, e);
            return errorHandler.apply(e);
            
        } finally {
            sample.stop(processingTimer.tag("operation", operation));
        }
    }
}
```

---

## 📝 本章重點回顧

1. **多模態概念理解**：掌握了多模態 AI 的核心價值和應用場景
2. **模型選擇策略**：了解了各種 AI 模型的多模態能力和適用場景
3. **圖片分析實現**：建立了完整的圖片上傳、分析和批次處理功能
4. **多媒體處理**：實現了音訊、影片等多種媒體格式的分析功能
5. **企業級應用**：設計了文件智能分析等實際業務場景的解決方案

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **圖片分析** | ⭐⭐⭐ | 中 | 所有視覺 AI 應用 |
| **文件 OCR** | ⭐⭐⭐ | 中 | 企業文件處理 |
| **音訊處理** | ⭐⭐ | 高 | 語音應用、內容分析 |
| **影片分析** | ⭐⭐ | 高 | 影片內容理解 |
| **批次處理** | ⭐⭐ | 中 | 大量檔案處理 |
| **效能優化** | ⭐⭐ | 高 | 生產環境部署 |

### 最佳實踐建議

1. **檔案驗證**：始終驗證檔案格式、大小和內容
2. **錯誤處理**：提供友善的錯誤訊息和降級方案
3. **效能優化**：使用快取、壓縮和非同步處理
4. **成本控制**：監控 API 使用量，特別是多模態請求成本較高
5. **安全考量**：注意檔案上傳的安全性和隱私保護

### 下一步學習方向

在下一章中，我們將學習如何使用 Spring AI 生成圖片，探索 AI 的創作能力，建立完整的圖片生成和編輯功能。

---

**參考資料：**
- [Spring AI Multimodality Documentation](https://docs.spring.io/spring-ai/reference/api/multimodality.html)
- [OpenAI Vision API](https://platform.openai.com/docs/guides/vision)
- [Anthropic Claude Vision](https://docs.anthropic.com/claude/docs/vision)
- [Google Gemini Multimodal](https://ai.google.dev/docs/multimodal_concepts)


\newpage

## 5.3 透過 Spring AI 生成美女圖


> **本章重點**：學習使用 Spring AI 的圖片生成功能，掌握文字轉圖片（Text-to-Image）技術，建立完整的 AI 圖片生成應用，探索 AI 的創作能力。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解圖片生成技術**：掌握文字轉圖片的核心原理和應用場景
- 🎯 **選擇合適的生成模型**：了解各種圖片生成 AI 模型的特點和成本
- 🎯 **實現圖片生成功能**：建立完整的圖片生成 API 和管理系統
- 🎯 **優化生成品質**：掌握提示詞工程和參數調整技巧
- 🎯 **企業級應用設計**：建立可商用的圖片生成服務架構

---

## 5.3.1 AI 圖片生成的革命性影響

### 文生圖 AI 將會是最大圖庫

![AI 圖片生成](https://ithelp.ithome.com.tw/upload/images/20240810/20161290xVSyazJmHj.png)

昨天學了如何上傳圖片給 AI 辨識，今天我們讓 AI 來產生圖片吧！AI 圖片生成技術正在徹底改變創意產業，從概念設計到商業插圖，AI 都能在幾秒鐘內生成高品質的圖片。

### AI 圖片生成的核心價值

**1. 創意無限制**
- 🎨 **即時創作**：從文字描述到視覺呈現，幾秒鐘完成
- 🌈 **風格多樣**：支援寫實、卡通、油畫、水彩等各種風格
- 🔄 **快速迭代**：輕鬆調整和優化創作內容
- 💡 **靈感激發**：AI 能提供意想不到的創意組合

**2. 成本效益顯著**
- 💰 **降低成本**：無需聘請專業設計師或購買版權圖片
- ⏰ **節省時間**：從數天的設計週期縮短到幾分鐘
- 📈 **規模化生產**：批次生成大量圖片內容
- 🎯 **客製化程度高**：精確符合特定需求

**3. 應用場景廣泛**
- 🛒 **電商應用**：商品展示圖、廣告素材、品牌視覺
- 📚 **內容創作**：部落格配圖、社群媒體素材、簡報圖片
- 🎮 **遊戲開發**：角色設計、場景概念圖、道具素材
- 🏢 **企業應用**：行銷素材、產品原型、視覺化報告

---

## 5.3.2 Spring AI 支援的圖片生成模型

### 主要支援的 AI 服務商

| 服務商 | 模型 | 特色 | 成本 | 推薦度 | 適用場景 |
|--------|------|------|------|--------|----------|
| **OpenAI** | DALL-E 3 | 高品質、理解複雜指令 | 高 | ⭐⭐⭐⭐⭐ | 專業設計、商業用途 |
| **Stability AI** | Stable Diffusion | 開源、可本地部署 | 中 | ⭐⭐⭐⭐ | 自主控制、客製化 |
| **ZhiPu AI** | CogView-3 | 中文友善、便宜 | 低 | ⭐⭐⭐ | 學習測試、中文內容 |
| **QianFan** | 文心一言 | 百度服務、本土化 | 低 | ⭐⭐ | 大陸市場應用 |
| **Midjourney** | V6 | 藝術性強、社群活躍 | 中 | ⭐⭐⭐⭐ | 藝術創作、概念設計 |

### 成本效益分析

根據最新測試數據，以下是各服務商的成本對比：

```
💰 成本排序（每張圖片）：
1. ZhiPu AI: 免費額度 + ¥0.01-0.05
2. Stability AI: $0.002-0.01
3. QianFan: ¥0.02-0.08
4. Midjourney: $0.05-0.15
5. OpenAI DALL-E 3: $0.040-0.080

🎯 推薦策略：
- 學習測試：ZhiPu AI（免費額度充足）
- 商業應用：OpenAI DALL-E 3（品質最佳）
- 大量生成：Stability AI（成本最低）
- 藝術創作：Midjourney（風格獨特）
```

### 模型能力對比

| 能力維度 | DALL-E 3 | Stable Diffusion | CogView-3 | 文心一言 |
|----------|----------|------------------|-----------|----------|
| **圖片品質** | 9/10 | 8/10 | 7/10 | 6/10 |
| **指令理解** | 9/10 | 7/10 | 8/10 | 7/10 |
| **中文支援** | 7/10 | 6/10 | 9/10 | 9/10 |
| **生成速度** | 8/10 | 9/10 | 8/10 | 7/10 |
| **風格多樣性** | 8/10 | 9/10 | 7/10 | 6/10 |
| **成本效益** | 6/10 | 9/10 | 9/10 | 8/10 |

---

## 5.3.3 ZhiPu AI 整合實戰

### 申請和配置

**1. 申請 API Key**

前往 ZhiPu AI 官網 [https://open.bigmodel.cn/](https://open.bigmodel.cn/) 註冊後，在 API 密鑰頁面取得你的 API Key。

![ZhiPu AI API Key](https://ithelp.ithome.com.tw/upload/images/20240806/20161290qkPNJ0Ho4Y.png)

**2. 引入依賴**

在 `pom.xml` 中添加 ZhiPu AI 依賴：

```xml
<!-- 使用 Spring AI BOM 管理版本 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-bom</artifactId>
            <version>1.0.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <!-- Spring AI ZhiPu AI Starter -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-zhipuai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Spring Boot Validation -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    
    <!-- Lombok -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

**3. 設定專案參數**

在 `application.yml` 中配置：

```yaml
spring:
  application:
    name: ai-image-generator
  ai:
    zhipuai:
      api-key: ${ZHIPUAI_API_KEY}
      base-url: https://open.bigmodel.cn/api/paas/v4
      image:
        options:
          model: cogview-3
          width: 1024
          height: 1024
          quality: standard
          style: vivid

# 應用程式配置
app:
  image:
    generation:
      max-batch-size: 5
      default-timeout: 30s
      cache-enabled: true
      output-directory: ./generated-images

# 日誌配置
logging:
  level:
    org.springframework.ai: DEBUG
    com.example: DEBUG
```

---

## 5.3.4 基礎圖片生成功能

### 簡單圖片生成 API

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.image.Image;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.image.ImagePrompt;
import org.springframework.ai.image.ImageResponse;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/image")
@RequiredArgsConstructor
@Slf4j
public class ImageGenerationController {
    
    private final ImageModel imageModel;
    
    /**
     * 基礎圖片生成
     * @param prompt 圖片描述
     * @return HTML 格式的圖片展示頁面
     */
    @GetMapping("/generate")
    public ResponseEntity<String> generateImage(@RequestParam String prompt) {
        try {
            log.info("開始生成圖片，提示詞：{}", prompt);
            
            // 建立圖片生成請求
            ImagePrompt imagePrompt = new ImagePrompt(prompt);
            
            // 呼叫 AI 模型生成圖片
            ImageResponse response = imageModel.call(imagePrompt);
            Image image = response.getResult().getOutput();
            
            // 建立 HTML 回應
            String htmlResponse = String.format("""
                <!DOCTYPE html>
                <html lang="zh-TW">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>AI 圖片生成結果</title>
                    <style>
                        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
                        .container { text-align: center; }
                        .image-container { margin: 20px 0; }
                        .generated-image { max-width: 100%%; height: auto; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
                        .prompt { background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 20px 0; }
                        .info { color: #666; font-size: 14px; }
                    </style>
                </head>
                <body>
                    <div class="container">
                        <h1>🎨 AI 圖片生成結果</h1>
                        <div class="prompt">
                            <h3>📝 提示詞</h3>
                            <p><strong>%s</strong></p>
                        </div>
                        <div class="image-container">
                            <img src="%s" alt="%s" class="generated-image">
                        </div>
                        <div class="info">
                            <p>🤖 由 Spring AI + ZhiPu AI 生成</p>
                            <p>⏰ 生成時間：%s</p>
                        </div>
                    </div>
                </body>
                </html>
                """, 
                prompt, 
                image.getUrl(), 
                prompt,
                java.time.LocalDateTime.now().format(
                    java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
                )
            );
            
            log.info("圖片生成成功，URL：{}", image.getUrl());
            
            return ResponseEntity.ok()
                    .contentType(MediaType.TEXT_HTML)
                    .body(htmlResponse);
            
        } catch (Exception e) {
            log.error("圖片生成失敗", e);
            
            String errorHtml = String.format("""
                <!DOCTYPE html>
                <html lang="zh-TW">
                <head>
                    <meta charset="UTF-8">
                    <title>生成失敗</title>
                    <style>body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }</style>
                </head>
                <body>
                    <h1>❌ 圖片生成失敗</h1>
                    <p>錯誤訊息：%s</p>
                    <p><a href="javascript:history.back()">返回重試</a></p>
                </body>
                </html>
                """, e.getMessage());
            
            return ResponseEntity.badRequest()
                    .contentType(MediaType.TEXT_HTML)
                    .body(errorHtml);
        }
    }
    
    /**
     * JSON 格式的圖片生成 API
     * @param request 生成請求
     * @return JSON 格式的回應
     */
    @PostMapping("/generate-json")
    public ResponseEntity<ImageGenerationResponse> generateImageJson(
            @RequestBody @Valid ImageGenerationRequest request) {
        
        try {
            log.info("JSON API 圖片生成請求：{}", request.getPrompt());
            
            ImagePrompt imagePrompt = new ImagePrompt(request.getPrompt());
            ImageResponse response = imageModel.call(imagePrompt);
            Image image = response.getResult().getOutput();
            
            ImageGenerationResponse result = ImageGenerationResponse.builder()
                    .success(true)
                    .imageUrl(image.getUrl())
                    .prompt(request.getPrompt())
                    .model("cogview-3")
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
            return ResponseEntity.ok(result);
            
        } catch (Exception e) {
            log.error("JSON API 圖片生成失敗", e);
            
            ImageGenerationResponse errorResult = ImageGenerationResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .prompt(request.getPrompt())
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResult);
        }
    }
}
```

### 請求和回應 DTO

```java
package com.example.dto;

import lombok.Data;
import lombok.Builder;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import java.time.LocalDateTime;

@Data
public class ImageGenerationRequest {
    
    @NotBlank(message = "提示詞不能為空")
    @Size(max = 1000, message = "提示詞長度不能超過 1000 字元")
    private String prompt;
    
    private String style = "vivid";  // vivid, natural
    private String quality = "standard";  // standard, hd
    private Integer width = 1024;
    private Integer height = 1024;
    private String model = "cogview-3";
}

@Data
@Builder
public class ImageGenerationResponse {
    private boolean success;
    private String imageUrl;
    private String prompt;
    private String model;
    private String style;
    private String quality;
    private Integer width;
    private Integer height;
    private String error;
    private LocalDateTime timestamp;
}
```

---

## 5.3.5 進階圖片生成功能

### 批次圖片生成

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.image.Image;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.image.ImagePrompt;
import org.springframework.ai.image.ImageResponse;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class BatchImageGenerationService {
    
    private final ImageModel imageModel;
    
    /**
     * 批次生成圖片
     * @param prompts 提示詞列表
     * @return 生成結果列表
     */
    public List<BatchImageResult> batchGenerate(List<String> prompts) {
        log.info("開始批次生成 {} 張圖片", prompts.size());
        
        List<CompletableFuture<BatchImageResult>> futures = prompts.stream()
                .map(this::generateImageAsync)
                .collect(Collectors.toList());
        
        // 等待所有任務完成
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(
                futures.toArray(new CompletableFuture[0])
        );
        
        return allFutures.thenApply(v -> 
                futures.stream()
                        .map(CompletableFuture::join)
                        .collect(Collectors.toList())
        ).join();
    }
    
    /**
     * 非同步生成單張圖片
     */
    private CompletableFuture<BatchImageResult> generateImageAsync(String prompt) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                ImagePrompt imagePrompt = new ImagePrompt(prompt);
                ImageResponse response = imageModel.call(imagePrompt);
                Image image = response.getResult().getOutput();
                
                return BatchImageResult.builder()
                        .prompt(prompt)
                        .imageUrl(image.getUrl())
                        .success(true)
                        .timestamp(java.time.LocalDateTime.now())
                        .build();
                
            } catch (Exception e) {
                log.error("批次生成失敗：{}", prompt, e);
                
                return BatchImageResult.builder()
                        .prompt(prompt)
                        .success(false)
                        .error(e.getMessage())
                        .timestamp(java.time.LocalDateTime.now())
                        .build();
            }
        });
    }
    
    @Data
    @Builder
    public static class BatchImageResult {
        private String prompt;
        private String imageUrl;
        private boolean success;
        private String error;
        private java.time.LocalDateTime timestamp;
    }
}
```

### 圖片風格和品質控制

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.image.ImageOptions;
import org.springframework.ai.image.ImagePrompt;
import org.springframework.ai.zhipuai.ZhiPuAiImageOptions;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AdvancedImageGenerationService {
    
    private final ImageModel imageModel;
    
    /**
     * 生成美女圖片（高品質）
     * @param description 美女描述
     * @param style 風格選擇
     * @return 圖片 URL
     */
    public String generateBeautyImage(String description, BeautyStyle style) {
        // 建構專業的美女圖片提示詞
        String enhancedPrompt = buildBeautyPrompt(description, style);
        
        // 設定高品質選項
        ZhiPuAiImageOptions options = ZhiPuAiImageOptions.builder()
                .withModel("cogview-3")
                .withWidth(1024)
                .withHeight(1024)
                .withQuality("hd")
                .withStyle("vivid")
                .build();
        
        ImagePrompt imagePrompt = new ImagePrompt(enhancedPrompt, options);
        return imageModel.call(imagePrompt).getResult().getOutput().getUrl();
    }
    
    /**
     * 建構美女圖片提示詞
     */
    private String buildBeautyPrompt(String description, BeautyStyle style) {
        String basePrompt = "A beautiful woman, " + description;
        
        String stylePrompt = switch (style) {
            case REALISTIC -> ", photorealistic, high quality, professional photography, natural lighting, detailed features";
            case ANIME -> ", anime style, manga art, beautiful anime girl, detailed anime artwork, vibrant colors";
            case PORTRAIT -> ", professional portrait, studio lighting, elegant pose, high-end fashion photography";
            case ARTISTIC -> ", artistic style, oil painting, renaissance art, classical beauty, masterpiece quality";
            case MODERN -> ", modern style, contemporary fashion, urban setting, trendy outfit, stylish appearance";
        };
        
        String qualityPrompt = ", 8k resolution, ultra detailed, masterpiece, best quality, highly detailed";
        
        return basePrompt + stylePrompt + qualityPrompt;
    }
    
    /**
     * 生成商業用途圖片
     * @param productDescription 產品描述
     * @param businessType 商業類型
     * @return 圖片 URL
     */
    public String generateBusinessImage(String productDescription, BusinessType businessType) {
        String businessPrompt = buildBusinessPrompt(productDescription, businessType);
        
        ZhiPuAiImageOptions options = ZhiPuAiImageOptions.builder()
                .withModel("cogview-3")
                .withWidth(1024)
                .withHeight(768)  // 商業圖片常用比例
                .withQuality("hd")
                .withStyle("natural")
                .build();
        
        ImagePrompt imagePrompt = new ImagePrompt(businessPrompt, options);
        return imageModel.call(imagePrompt).getResult().getOutput().getUrl();
    }
    
    private String buildBusinessPrompt(String description, BusinessType type) {
        String basePrompt = description;
        
        String businessStyle = switch (type) {
            case ECOMMERCE -> ", product photography, white background, professional lighting, commercial quality";
            case MARKETING -> ", marketing material, eye-catching design, professional layout, brand-focused";
            case SOCIAL_MEDIA -> ", social media post, engaging visual, trendy design, shareable content";
            case PRESENTATION -> ", business presentation, clean design, professional appearance, corporate style";
            case ADVERTISEMENT -> ", advertisement design, compelling visual, marketing appeal, brand promotion";
        };
        
        return basePrompt + businessStyle + ", high quality, professional, commercial use";
    }
    
    public enum BeautyStyle {
        REALISTIC, ANIME, PORTRAIT, ARTISTIC, MODERN
    }
    
    public enum BusinessType {
        ECOMMERCE, MARKETING, SOCIAL_MEDIA, PRESENTATION, ADVERTISEMENT
    }
}
```

---

## 5.3.6 OpenAI DALL-E 3 整合

### DALL-E 3 配置

```java
package com.example.config;

import org.springframework.ai.image.ImageModel;
import org.springframework.ai.openai.OpenAiImageModel;
import org.springframework.ai.openai.api.OpenAiImageApi;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;

@Configuration
public class ImageModelConfig {
    
    @Value("${spring.ai.openai.api-key}")
    private String openaiApiKey;
    
    /**
     * OpenAI DALL-E 3 模型配置（高品質）
     */
    @Bean("dalleImageModel")
    @Profile("dalle")
    public ImageModel dalleImageModel() {
        return new OpenAiImageModel(
            new OpenAiImageApi(openaiApiKey),
            org.springframework.ai.openai.OpenAiImageOptions.builder()
                .withModel("dall-e-3")
                .withQuality("hd")
                .withStyle("vivid")
                .withSize("1024x1024")
                .build()
        );
    }
    
    /**
     * 多模型路由服務
     */
    @Bean
    public MultiModelImageService multiModelImageService(
            @Qualifier("zhipuImageModel") ImageModel zhipuModel,
            @Qualifier("dalleImageModel") ImageModel dalleModel) {
        return new MultiModelImageService(zhipuModel, dalleModel);
    }
}
```

### 多模型路由服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.image.ImagePrompt;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class MultiModelImageService {
    
    private final ImageModel zhipuModel;
    private final ImageModel dalleModel;
    
    /**
     * 智能模型選擇
     * @param prompt 提示詞
     * @param quality 品質要求
     * @return 圖片 URL
     */
    public String generateWithBestModel(String prompt, QualityLevel quality) {
        ImageModel selectedModel = selectModel(quality, prompt);
        
        try {
            ImagePrompt imagePrompt = new ImagePrompt(prompt);
            return selectedModel.call(imagePrompt).getResult().getOutput().getUrl();
            
        } catch (Exception e) {
            log.warn("主要模型失敗，嘗試備用模型：{}", e.getMessage());
            
            // 降級到備用模型
            ImageModel fallbackModel = (selectedModel == dalleModel) ? zhipuModel : dalleModel;
            ImagePrompt imagePrompt = new ImagePrompt(prompt);
            return fallbackModel.call(imagePrompt).getResult().getOutput().getUrl();
        }
    }
    
    private ImageModel selectModel(QualityLevel quality, String prompt) {
        // 根據品質要求和內容複雜度選擇模型
        if (quality == QualityLevel.PREMIUM || isComplexPrompt(prompt)) {
            log.info("選擇 DALL-E 3 模型（高品質）");
            return dalleModel;
        } else {
            log.info("選擇 ZhiPu AI 模型（經濟型）");
            return zhipuModel;
        }
    }
    
    private boolean isComplexPrompt(String prompt) {
        // 判斷提示詞複雜度
        return prompt.length() > 100 || 
               prompt.contains("detailed") || 
               prompt.contains("professional") ||
               prompt.contains("high quality");
    }
    
    public enum QualityLevel {
        BASIC, STANDARD, PREMIUM
    }
}
```

---

## 5.3.7 企業級圖片管理系統

### 圖片儲存和管理

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class ImageStorageService {
    
    @Value("${app.image.output-directory:./generated-images}")
    private String outputDirectory;
    
    private final RestTemplate restTemplate = new RestTemplate();
    
    /**
     * 下載並儲存圖片
     * @param imageUrl 圖片 URL
     * @param prompt 原始提示詞
     * @return 本地檔案路徑
     */
    public String downloadAndSaveImage(String imageUrl, String prompt) {
        try {
            // 建立輸出目錄
            Path outputPath = Paths.get(outputDirectory);
            if (!Files.exists(outputPath)) {
                Files.createDirectories(outputPath);
            }
            
            // 生成檔案名稱
            String fileName = generateFileName(prompt);
            Path filePath = outputPath.resolve(fileName);
            
            // 下載圖片
            byte[] imageBytes = restTemplate.getForObject(imageUrl, byte[].class);
            if (imageBytes != null) {
                Files.write(filePath, imageBytes);
                log.info("圖片已儲存：{}", filePath.toString());
                return filePath.toString();
            }
            
            throw new RuntimeException("無法下載圖片");
            
        } catch (IOException e) {
            log.error("圖片儲存失敗", e);
            throw new RuntimeException("圖片儲存失敗：" + e.getMessage());
        }
    }
    
    /**
     * 生成檔案名稱
     */
    private String generateFileName(String prompt) {
        String timestamp = LocalDateTime.now().format(
            DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")
        );
        String uuid = UUID.randomUUID().toString().substring(0, 8);
        String sanitizedPrompt = sanitizePrompt(prompt);
        
        return String.format("%s_%s_%s.png", timestamp, uuid, sanitizedPrompt);
    }
    
    /**
     * 清理提示詞作為檔案名稱
     */
    private String sanitizePrompt(String prompt) {
        return prompt.replaceAll("[^a-zA-Z0-9\u4e00-\u9fa5]", "_")
                    .substring(0, Math.min(prompt.length(), 20));
    }
    
    /**
     * 批次下載圖片
     */
    public List<String> batchDownloadImages(List<BatchImageGenerationService.BatchImageResult> results) {
        return results.stream()
                .filter(BatchImageGenerationService.BatchImageResult::isSuccess)
                .map(result -> downloadAndSaveImage(result.getImageUrl(), result.getPrompt()))
                .collect(java.util.stream.Collectors.toList());
    }
}
```

### 圖片快取系統

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.security.MessageDigest;
import java.time.Duration;

@Service
@RequiredArgsConstructor
@Slf4j
public class ImageCacheService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final ImageModel imageModel;
    
    /**
     * 帶快取的圖片生成
     */
    @Cacheable(value = "generatedImages", key = "#root.target.generateCacheKey(#prompt, #options)")
    public String generateImageWithCache(String prompt, ImageGenerationOptions options) {
        String cacheKey = generateCacheKey(prompt, options);
        
        // 檢查快取
        String cachedUrl = (String) redisTemplate.opsForValue().get(cacheKey);
        if (cachedUrl != null) {
            log.info("從快取返回圖片：{}", prompt);
            return cachedUrl;
        }
        
        // 生成新圖片
        String imageUrl = generateImage(prompt, options);
        
        // 儲存到快取（24小時）
        redisTemplate.opsForValue().set(cacheKey, imageUrl, Duration.ofHours(24));
        
        return imageUrl;
    }
    
    /**
     * 生成快取鍵
     */
    public String generateCacheKey(String prompt, ImageGenerationOptions options) {
        try {
            String combined = prompt + "|" + options.toString();
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] hash = md.digest(combined.getBytes());
            
            StringBuilder sb = new StringBuilder();
            for (byte b : hash) {
                sb.append(String.format("%02x", b));
            }
            return "image:" + sb.toString();
            
        } catch (Exception e) {
            return "image:" + Math.abs(prompt.hashCode());
        }
    }
    
    private String generateImage(String prompt, ImageGenerationOptions options) {
        // 實際的圖片生成邏輯
        ImagePrompt imagePrompt = new ImagePrompt(prompt);
        return imageModel.call(imagePrompt).getResult().getOutput().getUrl();
    }
}
```

---

## 5.3.8 實際應用場景

### 電商商品圖片生成

```java
@RestController
@RequestMapping("/api/ecommerce")
@RequiredArgsConstructor
public class EcommerceImageController {
    
    private final AdvancedImageGenerationService imageService;
    
    /**
     * 生成商品展示圖
     * @param productName 商品名稱
     * @param category 商品類別
     * @param style 展示風格
     * @return 商品圖片 URL
     */
    @PostMapping("/product-image")
    public ResponseEntity<ProductImageResponse> generateProductImage(
            @RequestBody ProductImageRequest request) {
        
        try {
            String prompt = buildProductPrompt(request);
            String imageUrl = imageService.generateBusinessImage(
                prompt, 
                AdvancedImageGenerationService.BusinessType.ECOMMERCE
            );
            
            ProductImageResponse response = ProductImageResponse.builder()
                    .success(true)
                    .imageUrl(imageUrl)
                    .productName(request.getProductName())
                    .category(request.getCategory())
                    .style(request.getStyle())
                    .timestamp(LocalDateTime.now())
                    .build();
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("商品圖片生成失敗", e);
            
            ProductImageResponse errorResponse = ProductImageResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    private String buildProductPrompt(ProductImageRequest request) {
        return String.format(
            "%s, %s category, %s style, product photography, white background, " +
            "professional lighting, high quality, commercial use, detailed, 4k resolution",
            request.getProductName(),
            request.getCategory(),
            request.getStyle()
        );
    }
}

@Data
public class ProductImageRequest {
    private String productName;
    private String category;
    private String style;
    private String description;
    private List<String> features;
}

@Data
@Builder
public class ProductImageResponse {
    private boolean success;
    private String imageUrl;
    private String productName;
    private String category;
    private String style;
    private String error;
    private LocalDateTime timestamp;
}
```

### 社群媒體內容生成

```java
@RestController
@RequestMapping("/api/social-media")
@RequiredArgsConstructor
public class SocialMediaController {
    
    private final AdvancedImageGenerationService imageService;
    
    /**
     * 生成社群媒體貼文圖片
     */
    @PostMapping("/post-image")
    public ResponseEntity<SocialMediaImageResponse> generatePostImage(
            @RequestBody SocialMediaRequest request) {
        
        try {
            String prompt = buildSocialMediaPrompt(request);
            String imageUrl = imageService.generateBusinessImage(
                prompt,
                AdvancedImageGenerationService.BusinessType.SOCIAL_MEDIA
            );
            
            return ResponseEntity.ok(
                SocialMediaImageResponse.builder()
                    .success(true)
                    .imageUrl(imageUrl)
                    .platform(request.getPlatform())
                    .theme(request.getTheme())
                    .build()
            );
            
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(
                SocialMediaImageResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .build()
            );
        }
    }
    
    private String buildSocialMediaPrompt(SocialMediaRequest request) {
        String platformStyle = switch (request.getPlatform().toLowerCase()) {
            case "instagram" -> "Instagram post, square format, trendy, aesthetic";
            case "facebook" -> "Facebook post, engaging, social media friendly";
            case "twitter" -> "Twitter header, professional, clean design";
            case "linkedin" -> "LinkedIn post, professional, business-oriented";
            default -> "social media post, engaging visual";
        };
        
        return String.format(
            "%s, %s theme, %s, high quality, eye-catching, shareable content",
            request.getContent(),
            request.getTheme(),
            platformStyle
        );
    }
}
```

---

## 📝 本章重點回顧

1. **圖片生成技術理解**：掌握了文字轉圖片的核心原理和應用價值
2. **多模型整合**：學會了 ZhiPu AI、OpenAI DALL-E 3 等多種模型的使用
3. **企業級功能**：建立了完整的圖片生成、儲存和管理系統
4. **實際應用場景**：實現了電商、社群媒體等商業應用
5. **效能優化**：掌握了快取、批次處理等優化技術

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **基礎圖片生成** | ⭐⭐⭐ | 低 | 所有圖片生成應用 |
| **多模型整合** | ⭐⭐⭐ | 中 | 企業級應用 |
| **批次處理** | ⭐⭐ | 中 | 大量內容生成 |
| **快取系統** | ⭐⭐ | 中 | 效能優化 |
| **圖片管理** | ⭐⭐ | 高 | 生產環境部署 |
| **商業應用** | ⭐⭐⭐ | 高 | 實際業務場景 |

### 成本控制建議

1. **模型選擇策略**：根據品質需求選擇合適的模型
2. **快取機制**：避免重複生成相同內容
3. **批次處理**：提高生成效率，降低單位成本
4. **品質控制**：平衡品質和成本的關係

### 下一步學習方向

在下一章中，我們將學習如何建立字幕產生器，探索音訊轉文字技術，為多媒體內容處理提供完整的解決方案。

---

**參考資料：**
- [Spring AI Image Generation Documentation](https://docs.spring.io/spring-ai/reference/api/imageclient.html)
- [OpenAI DALL-E 3 API](https://platform.openai.com/docs/guides/images)
- [ZhiPu AI CogView Documentation](https://open.bigmodel.cn/dev/api#cogview)
- [Stability AI API Reference](https://platform.stability.ai/docs/api-reference)


\newpage

## 5.3 透過 Spring AI 整合 Google Gemini 2.5 Flash Image (Nano Banana)


> **本章重點**：學習使用 Spring AI 整合 Google Gemini 2.5 Flash Image（代號：Nano Banana）圖片生成和編輯功能，掌握先進的圖片生成與編輯技術，建立完整的 AI 圖片處理應用，探索 Google 最新圖片 AI 模型的強大能力。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 Gemini 2.5 Flash Image**：掌握 Google 最新圖片 AI 模型的核心原理和優勢
- 🎯 **選擇合適的圖片模型**：了解 Gemini 2.5 Flash Image 與其他圖片 AI 模型的差異
- 🎯 **實現圖片生成與編輯**：建立完整的圖片生成、編輯和處理 API 系統
- 🎯 **優化編輯品質**：掌握圖片編輯一致性和多輪對話編輯技巧
- 🎯 **企業級應用設計**：建立可商用的圖片生成與編輯服務架構

---

## 5.3.1 Gemini 2.5 Flash Image：Google 的圖片 AI 新里程碑

### 什麼是 Nano Banana？

![Gemini 2.5 Flash Image 示例](https://ithelp.ithome.com.tw/upload/images/20240810/20161290xVSyazJmHj.png)

**Nano Banana** 是 Google Gemini 2.5 Flash Image 的神秘代號，在 2025 年 LMArena 圖片編輯排行榜上以神秘身份登頂後，才被 Google 官方揭露其真實身份。這個「香蕉」圖示的模型以其卓越的**圖片編輯一致性**和**多輪對話編輯能力**震撼業界，成為目前世界排名第一的圖片編輯模型。

### Gemini 2.5 Flash Image 的突破性優勢

**1. 革命性的圖片編輯一致性**
- 🎭 **角色保持性**：編輯人物照片時保持角色特徵的完美一致性
- 👥 **細節敏感度**：特別關注人臉和身體特徵的微妙差異
- 🔄 **多輪編輯**：支援連續多次編輯而不失去原始特徵
- 📚 **自然語言控制**：使用自然語言進行精確的局部編輯

**2. 先進的圖片融合技術**
- 🖼️ **多圖混合**：將多張圖片無縫融合成單一圖片
- 📱 **智能組合**：利用 Gemini 的世界知識進行智能圖片組合
- 🎨 **風格轉換**：將一張圖片的風格或質感應用到另一張圖片
- 📊 **語義理解**：深度理解圖片內容和編輯意圖

**3. 企業級安全與品質**
- 💰 **SynthID 浮水印**：所有生成和編輯的圖片都包含不可見的 AI 識別標記
- 📖 **LMArena 認證**：在權威評測平台獲得第一名的優異表現
- 🎮 **Google 生態整合**：與 Google AI Studio 和 Vertex AI 完美整合
- 📺 **專業級品質**：提供最先進的圖片生成和編輯品質

---

## 5.3.2 Gemini 2.5 Flash Image vs 其他 AI 模型比較

### 主要 AI 圖片模型對比

| 模型 | 圖片編輯 | 多圖融合 | 特色 | 成本 | 推薦度 | 適用場景 |
|------|-----------|----------|------|------|--------|----------|
| **Gemini 2.5 Flash Image** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 編輯一致性、自然語言控制 | $0.039/圖 | ⭐⭐⭐⭐⭐ | 圖片編輯、專業設計 |
| **OpenAI DALL-E 3** | ⭐⭐⭐ | ⭐⭐⭐ | 高品質、理解複雜指令 | $0.040-0.080 | ⭐⭐⭐⭐ | 專業設計、商業用途 |
| **Stable Diffusion** | ⭐⭐ | ⭐⭐ | 開源、可本地部署 | 中 | ⭐⭐⭐ | 自主控制、客製化 |
| **Midjourney** | ⭐⭐⭐ | ⭐⭐ | 藝術性強、社群活躍 | 中 | ⭐⭐⭐⭐ | 藝術創作、概念設計 |
| **ZhiPu AI** | ⭐⭐ | ⭐⭐ | 中文友善、便宜 | 低 | ⭐⭐⭐ | 學習測試、中文內容 |

### Gemini 2.5 Flash Image 的核心優勢

```
🏆 Gemini 2.5 Flash Image 獨特功能：

1. 精準圖片編輯系統：
   - 自然語言控制：使用對話方式進行精確的圖片編輯
   - 局部修改能力：針對圖片特定區域進行精準編輯
   - 編輯一致性：保持人物特徵在編輯過程中的完美一致性

2. 多圖融合引擎：
   - 智能混合：將多張圖片的元素無縫融合
   - 風格轉移：將一張圖片的風格應用到另一張圖片
   - 語義理解：利用 Gemini 的世界知識進行智能組合

3. 企業級安全功能：
   - SynthID 浮水印：所有生成圖片包含不可見的 AI 識別標記
   - Google 生態整合：與 Google AI Studio 和 Vertex AI 完美配合
   - 專業級品質：LMArena 排名第一的圖片編輯能力
```

---

## 5.3.3 Spring AI 整合 Gemini 2.5 Flash Image

### 申請和配置

**1. 申請 OpenAI 相容 API Key**

由於 Gemini 2.5 Flash Image 透過多個第三方平台提供 OpenAI 相容的 API 服務，你可以選擇以下任一方式：
- **OpenRouter**: [https://openrouter.ai/](https://openrouter.ai/) - 提供 Gemini 2.5 Flash Image 的 OpenAI 相容 API
- **Fal.ai**: [https://fal.ai/](https://fal.ai/) - Google 官方合作夥伴，提供 Gemini 模型存取
- **其他 OpenAI 相容服務商**：支援 Gemini 2.5 Flash Image 的第三方平台

**2. 引入依賴**

在 `pom.xml` 中添加 OpenAI 整合依賴：

```xml
<!-- Spring AI BOM 管理版本 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-bom</artifactId>
            <version>1.0.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <!-- Spring AI OpenAI Starter -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Spring Boot Validation -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    
    <!-- Lombok -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

**3. 設定專案參數**

在 `application.yml` 中配置：

```yaml
spring:
  application:
    name: gemini-image-generator
  ai:
    openai:
      # 使用支援 Gemini 2.5 Flash Image 的 OpenAI 相容服務
      base-url: ${OPENAI_BASE_URL:https://openrouter.ai/api/v1}  # 或其他支援的服務商
      api-key: ${OPENAI_API_KEY}  # 你的 API Key
      image:
        options:
          model: google/gemini-2.5-flash-image  # Gemini 2.5 Flash Image 模型名稱
          quality: hd
          size: 1024x1024
          response-format: url
          user: spring-ai-user

# Gemini 圖片模型特殊配置
gemini:
  image:
    editing:
      max-input-images: 3        # 單次最多輸入圖片數量
      support-formats: ["jpeg", "png", "webp", "heic", "heif"]
      max-file-size: 20MB        # 單一圖片最大尺寸
    generation:
      include-synthid: true      # 包含 SynthID 浮水印
      safety-settings: medium    # 安全設定等級

# 應用程式配置
app:
  image:
    processing:
      max-batch-size: 5
      default-timeout: 45s
      cache-enabled: true
      output-directory: ./gemini-images

# 日誌配置
logging:
  level:
    org.springframework.ai: DEBUG
    com.example: DEBUG

# 環境變數設定範例
# OPENAI_API_KEY=your-openrouter-api-key
# OPENAI_BASE_URL=https://openrouter.ai/api/v1
```

**重要設定說明：**

1. **OpenRouter 設定**：
   - 在 OpenRouter 申請帳號並取得 API Key
   - 設定環境變數：`OPENAI_API_KEY=your-openrouter-key`
   - 使用 OpenRouter 的 base URL：`https://openrouter.ai/api/v1`
   - 模型名稱：`google/gemini-2.5-flash-image`

2. **其他支援的服務商**：
   - **Fal.ai**: `https://fal.run/fal-ai/gemini-2-5-flash-image`
   - **其他提供商**: 請查閱各自的 API 文檔取得正確的 base URL 和模型名稱

3. **注意事項**：
   - 不同服務商的模型名稱可能不同
   - 話費和使用限制請參考各服務商的定價
   - 確保使用支援 Gemini 2.5 Flash Image 的服務

---

## 5.3.4 簡單使用範例

### 基本圖片生成 API

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.image.ImagePrompt;
import org.springframework.ai.image.ImageResponse;
import org.springframework.ai.openai.OpenAiImageOptions;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/simple-image")
@RequiredArgsConstructor
@Slf4j
public class SimpleImageController {
    
    private final ImageModel imageModel;
    
    /**
     * 簡單的圖片生成 API
     */
    @GetMapping("/generate")
    public ResponseEntity<String> generateImage(@RequestParam String prompt) {
        try {
            log.info("生成圖片：{}", prompt);
            
            // 使用 OpenAI 相容的 Gemini 2.5 Flash Image
            OpenAiImageOptions options = OpenAiImageOptions.builder()
                    .withModel("google/gemini-2.5-flash-image")
                    .withQuality("hd")
                    .withSize("1024x1024")
                    .withResponseFormat("url")
                    .build();
            
            ImagePrompt imagePrompt = new ImagePrompt(prompt, options);
            ImageResponse response = imageModel.call(imagePrompt);
            
            String imageUrl = response.getResult().getOutput().getUrl();
            
            // 返回 HTML 頁面展示圖片
            String html = String.format("""
                <!DOCTYPE html>
                <html lang="zh-TW">
                <head>
                    <meta charset="UTF-8">
                    <title>Gemini 2.5 Flash Image 生成結果</title>
                    <style>
                        body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
                        img { max-width: 100%%; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
                        .info { margin: 20px 0; padding: 15px; background: #f5f5f5; border-radius: 5px; }
                    </style>
                </head>
                <body>
                    <h1>🍌 Gemini 2.5 Flash Image (Nano Banana)</h1>
                    <div class="info">
                        <p><strong>提示詞:</strong> %s</p>
                    </div>
                    <img src="%s" alt="生成的圖片">
                    <p><small>由 Spring AI + Gemini 2.5 Flash Image 生成</small></p>
                </body>
                </html>
                """, prompt, imageUrl);
            
            return ResponseEntity.ok()
                    .header("Content-Type", "text/html; charset=utf-8")
                    .body(html);
            
        } catch (Exception e) {
            log.error("圖片生成失敗", e);
            return ResponseEntity.badRequest()
                    .body("圖片生成失敗: " + e.getMessage());
        }
    }
}
```

### 使用方式

啟動應用後，訪問：
```
http://localhost:8080/api/simple-image/generate?prompt=一隻可愛的小貓在花園裡玩耀
```

---

## 5.3.5 Gemini 2.5 Flash Image 的進階功能

### 角色管理服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.openai.OpenAiImageOptions;
import org.springframework.ai.image.ImagePrompt;
import org.springframework.ai.image.ImageResponse;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class NanoBananaCharacterService {
    
    private final ImageModel geminiImageModel;
    private final Map<String, CharacterProfile> characterRegistry = new HashMap<>();
    
    /**
     * 創建新角色
     * @param characterName 角色名稱
     * @param description 角色描述
     * @param initialPrompt 初始生成提示詞
     * @return 角色ID
     */
    public String createCharacter(String characterName, String description, String initialPrompt) {
        try {
            log.info("創建新角色：{}", characterName);
            
            // 生成角色的初始圖片，建立角色DNA
            OpenAiImageOptions options = OpenAiImageOptions.builder()
                    .withModel("google/gemini-2.5-flash-image")
                    .withQuality("hd")
                    .withSize("1024x1024")
                    .withResponseFormat("url")
                    .build();
            
            String enhancedPrompt = enhanceCharacterPrompt(initialPrompt, description);
            ImagePrompt imagePrompt = new ImagePrompt(enhancedPrompt, options);
            
            ImageResponse response = geminiImageModel.call(imagePrompt);
            String imageUrl = response.getResult().getOutput().getUrl();
            
            // 創建角色檔案
            String characterId = UUID.randomUUID().toString();
            CharacterProfile profile = CharacterProfile.builder()
                    .characterId(characterId)
                    .characterName(characterName)
                    .description(description)
                    .dnaCode(response.getMetadata().get("character_dna"))  // Nano Banana 特有的角色DNA
                    .initialImageUrl(imageUrl)
                    .createdAt(java.time.LocalDateTime.now())
                    .build();
            
            characterRegistry.put(characterId, profile);
            
            log.info("角色創建成功，ID：{}，DNA：{}", characterId, profile.getDnaCode());
            return characterId;
            
        } catch (Exception e) {
            log.error("角色創建失敗：{}", characterName, e);
            throw new RuntimeException("角色創建失敗：" + e.getMessage());
        }
    }
    
    /**
     * 使用已存在角色生成圖片
     * @param characterId 角色ID
     * @param scenario 場景描述
     * @param pose 姿態描述
     * @return 圖片URL
     */
    public String generateWithCharacter(String characterId, String scenario, String pose) {
        CharacterProfile character = characterRegistry.get(characterId);
        if (character == null) {
            throw new IllegalArgumentException("角色不存在：" + characterId);
        }
        
        try {
            log.info("使用角色 {} 生成圖片：{}", character.getCharacterName(), scenario);
            
            OpenAiImageOptions options = OpenAiImageOptions.builder()
                    .withModel("google/gemini-2.5-flash-image")
                    .withQuality("hd")
                    .withSize("1024x1024")
                    .withResponseFormat("url")
                    .build();
            
            String prompt = buildCharacterScenePrompt(character, scenario, pose);
            ImagePrompt imagePrompt = new ImagePrompt(prompt, options);
            
            ImageResponse response = geminiImageModel.call(imagePrompt);
            String imageUrl = response.getResult().getOutput().getUrl();
            
            log.info("角色圖片生成成功：{}", imageUrl);
            return imageUrl;
            
        } catch (Exception e) {
            log.error("角色圖片生成失敗", e);
            throw new RuntimeException("角色圖片生成失敗：" + e.getMessage());
        }
    }
    
    /**
     * 建構角色場景提示詞
     */
    private String buildCharacterScenePrompt(CharacterProfile character, String scenario, String pose) {
        return String.format(
            "Character: %s, %s. Scene: %s. Pose: %s. " +
            "Maintain character consistency, high quality, detailed, 4k resolution",
            character.getCharacterName(),
            character.getDescription(),
            scenario,
            pose
        );
    }
    
    /**
     * 增強角色創建提示詞
     */
    private String enhanceCharacterPrompt(String prompt, String description) {
        return String.format(
            "%s, %s, character design, distinctive features, memorable appearance, " +
            "high quality, detailed character sheet, 4k resolution",
            prompt,
            description
        );
    }
    
    /**
     * 獲取角色資訊
     */
    public CharacterProfile getCharacter(String characterId) {
        return characterRegistry.get(characterId);
    }
    
    /**
     * 列出所有編輯對話
     */
    public Map<String, EditSession> getAllEditSessions() {
        return new HashMap<>(editSessionRegistry);
    }
    
    /**
     * 多圖融合功能
     * @param imageUrls 要融合的圖片 URL 列表
     * @param fusionDescription 融合描述
     * @return 融合後的圖片 URL
     */
    public String fuseMultipleImages(List<String> imageUrls, String fusionDescription) {
        if (imageUrls.size() > 3) {
            throw new IllegalArgumentException("Gemini 2.5 Flash Image 最多支援 3 張圖片融合");
        }
        
        try {
            OpenAiImageOptions options = OpenAiImageOptions.builder()
                    .withModel("google/gemini-2.5-flash-image")
                    .withQuality("hd")
                    .withSize("1024x1024")
                    .withResponseFormat("url")
                    .build();
            
            String fusionPrompt = buildImageFusionPrompt(imageUrls, fusionDescription);
            ImagePrompt imagePrompt = new ImagePrompt(fusionPrompt, options);
            
            ImageResponse response = geminiImageModel.call(imagePrompt);
            return response.getResult().getOutput().getUrl();
            
        } catch (Exception e) {
            log.error("多圖融合失敗", e);
            throw new RuntimeException("多圖融合失敗：" + e.getMessage());
        }
    }
    
    /**
     * 建構多圖融合提示詞
     */
    private String buildImageFusionPrompt(List<String> imageUrls, String description) {
        StringBuilder prompt = new StringBuilder();
        prompt.append("Fuse these images together: ");
        
        for (int i = 0; i < imageUrls.size(); i++) {
            prompt.append(String.format("Image %d: %s; ", i + 1, imageUrls.get(i)));
        }
        
        prompt.append(String.format(
            "Fusion instruction: %s. Create a cohesive, high-quality result that " +
            "combines elements from all images harmoniously.",
            description
        ));
        
        return prompt.toString();
    }
}
```

### 數據模型定義

```java
package com.example.model;

import lombok.Builder;
import lombok.Data;
import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
public class EditSession {
    private String sessionId;
    private String sessionName;
    private String baseImageUrl;
    private String currentImageUrl;
    private String description;
    private List<EditStep> editHistory;
    private LocalDateTime createdAt;
    private LocalDateTime lastModified;
}

@Data
@Builder
public class EditStep {
    private int stepNumber;
    private String description;
    private String resultImageUrl;
    private LocalDateTime timestamp;
    private Map<String, Object> metadata;
}
```

### 多圖融合服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.image.ImageModel;
import org.springframework.ai.openai.OpenAiImageOptions;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class GeminiImageFusionService {
    
    private final ImageModel geminiImageModel;
    private final GeminiImageEditingService editingService;
    
    /**
     * 創建多圖融合專案
     * @param fusionRequest 融合請求
     * @return 融合結果
     */
    public ImageFusionResult createImageFusion(ImageFusionRequest fusionRequest) {
        try {
            log.info("創建圖片融合專案：{}", fusionRequest.getProjectName());
            
            if (fusionRequest.getSourceImages().size() > 3) {
                throw new IllegalArgumentException("Gemini 2.5 Flash Image 最多支援 3 張圖片融合");
            }
            
            // 準備融合選項
            OpenAiImageOptions options = OpenAiImageOptions.builder()
                    .withModel("google/gemini-2.5-flash-image")
                    .withQuality("hd")
                    .withSize("1024x1024")
                    .withResponseFormat("url")
                    .build();
            
            // 建構融合提示詞
            String fusionPrompt = buildAdvancedFusionPrompt(fusionRequest);
            ImagePrompt imagePrompt = new ImagePrompt(fusionPrompt, options);
            
            // 執行融合
            ImageResponse response = geminiImageModel.call(imagePrompt);
            String fusedImageUrl = response.getResult().getOutput().getUrl();
            
            return ImageFusionResult.builder()
                    .projectName(fusionRequest.getProjectName())
                    .sourceImages(fusionRequest.getSourceImages())
                    .fusionStyle(fusionRequest.getFusionStyle())
                    .description(fusionRequest.getDescription())
                    .resultImageUrl(fusedImageUrl)
                    .success(true)
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("圖片融合失敗", e);
            throw new RuntimeException("圖片融合失敗：" + e.getMessage());
        }
    }
    
    /**
     * 風格轉移功能
     * @param sourceImageUrl 原始圖片
     * @param styleImageUrl 風格參考圖片
     * @param transferDescription 轉移描述
     * @return 轉移後的圖片 URL
     */
    public String performStyleTransfer(String sourceImageUrl, String styleImageUrl, String transferDescription) {
        try {
            log.info("執行風格轉移：{}", transferDescription);
            
            OpenAiImageOptions options = OpenAiImageOptions.builder()
                    .withModel("google/gemini-2.5-flash-image")
                    .withQuality("hd")
                    .withSize("1024x1024")
                    .withResponseFormat("url")
                    .build();
            
            String styleTransferPrompt = buildStyleTransferPrompt(
                sourceImageUrl, 
                styleImageUrl, 
                transferDescription
            );
            
            ImagePrompt imagePrompt = new ImagePrompt(styleTransferPrompt, options);
            ImageResponse response = geminiImageModel.call(imagePrompt);
            
            return response.getResult().getOutput().getUrl();
            
        } catch (Exception e) {
            log.error("風格轉移失敗", e);
            throw new RuntimeException("風格轉移失敗：" + e.getMessage());
        }
    }
    
    /**
     * 建構進階融合提示詞
     */
    private String buildAdvancedFusionPrompt(ImageFusionRequest request) {
        StringBuilder prompt = new StringBuilder();
        
        prompt.append("Fuse these images with advanced composition: ");
        for (int i = 0; i < request.getSourceImages().size(); i++) {
            prompt.append(String.format("Image %d: %s; ", i + 1, request.getSourceImages().get(i)));
        }
        
        prompt.append(String.format(
            "Fusion style: %s. Description: %s. " +
            "Create a harmonious blend that combines the best elements from each image. " +
            "Maintain visual coherence, apply %s aesthetic, ensure high quality output.",
            request.getFusionStyle(),
            request.getDescription(),
            request.getFusionStyle()
        ));
        
        return prompt.toString();
    }
    
    /**
     * 建構風格轉移提示詞
     */
    private String buildStyleTransferPrompt(String sourceUrl, String styleUrl, String description) {
        return String.format(
            "Apply style transfer: Take the content from this image: %s, " +
            "and apply the artistic style from this reference: %s. " +
            "Transfer instruction: %s. " +
            "Preserve the main content and composition while adopting the visual style, " +
            "colors, and artistic techniques from the style reference.",
            sourceUrl,
            styleUrl,
            description
        );
    }
    
    /**
     * 批次圖片處理
     * @param batchRequest 批次處理請求
     * @return 批次處理結果
     */
    public BatchProcessingResult processBatch(BatchImageRequest batchRequest) {
        try {
            log.info("批次處理 {} 張圖片", batchRequest.getImageRequests().size());
            
            List<CompletableFuture<BatchImageResult>> futures = batchRequest.getImageRequests().stream()
                    .map(this::processImageAsync)
                    .collect(Collectors.toList());
            
            CompletableFuture<Void> allFutures = CompletableFuture.allOf(
                    futures.toArray(new CompletableFuture[0])
            );
            
            List<BatchImageResult> results = allFutures.thenApply(v -> 
                    futures.stream()
                            .map(CompletableFuture::join)
                            .collect(Collectors.toList())
            ).join();
            
            return BatchProcessingResult.builder()
                    .batchId(UUID.randomUUID().toString())
                    .totalRequests(batchRequest.getImageRequests().size())
                    .successfulResults(results.stream().filter(r -> r.isSuccess()).collect(Collectors.toList()))
                    .failedResults(results.stream().filter(r -> !r.isSuccess()).collect(Collectors.toList()))
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("批次處理失敗", e);
            throw new RuntimeException("批次處理失敗：" + e.getMessage());
        }
    }
    
    /**
     * 非同步處理單張圖片
     */
    private CompletableFuture<BatchImageResult> processImageAsync(ImageProcessingRequest request) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                String resultUrl = switch (request.getProcessingType()) {
                    case EDIT -> editingService.continueEditing(request.getSessionId(), request.getInstruction());
                    case STYLE_TRANSFER -> performStyleTransfer(
                        request.getSourceImageUrl(), 
                        request.getStyleImageUrl(), 
                        request.getInstruction()
                    );
                    case FUSION -> editingService.fuseMultipleImages(
                        request.getSourceImageUrls(), 
                        request.getInstruction()
                    );
                    default -> throw new IllegalArgumentException("不支援的處理類型: " + request.getProcessingType());
                };
                
                return BatchImageResult.builder()
                        .requestId(request.getRequestId())
                        .resultImageUrl(resultUrl)
                        .success(true)
                        .build();
                
            } catch (Exception e) {
                log.error("單張圖片處理失敗: {}", request.getRequestId(), e);
                
                return BatchImageResult.builder()
                        .requestId(request.getRequestId())
                        .success(false)
                        .error(e.getMessage())
                        .build();
            }
        });
    }
}
```

---

## 5.3.6 實際應用：圖片編輯與融合系統

### 圖片處理 API 控制器

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequestMapping("/api/image-processing")
@RequiredArgsConstructor
@Slf4j
public class ImageProcessingController {
    
    private final GeminiImageEditingService editingService;
    private final GeminiImageFusionService fusionService;
    
    /**
     * 創建圖片編輯對話
     */
    @PostMapping("/edit-session")
    public ResponseEntity<EditSessionResponse> createEditSession(
            @RequestParam("image") MultipartFile imageFile,
            @RequestParam("sessionName") String sessionName,
            @RequestParam("description") String description) {
        
        try {
            log.info("創建編輯對話：{}", sessionName);
            
            // 上傳圖片並取得 URL
            String imageUrl = uploadImageAndGetUrl(imageFile);
            
            String sessionId = editingService.createEditSession(
                    sessionName,
                    imageUrl,
                    description
            );
            
            EditSessionResponse response = EditSessionResponse.builder()
                    .success(true)
                    .sessionId(sessionId)
                    .sessionName(sessionName)
                    .baseImageUrl(imageUrl)
                    .message("編輯對話創建成功")
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("編輯對話創建失敗", e);
            
            EditSessionResponse errorResponse = EditSessionResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 繼續編輯圖片
     */
    @PostMapping("/edit-session/{sessionId}/continue")
    public ResponseEntity<EditStepResponse> continueEditing(
            @PathVariable String sessionId,
            @RequestBody @Valid ContinueEditRequest request) {
        
        try {
            log.info("繼續編輯對話：{}", sessionId);
            
            String newImageUrl = editingService.continueEditing(
                    sessionId,
                    request.getEditInstruction()
            );
            
            EditSession session = editingService.getEditSession(sessionId);
            EditStep latestStep = session.getEditHistory().get(session.getEditHistory().size() - 1);
            
            EditStepResponse response = EditStepResponse.builder()
                    .success(true)
                    .sessionId(sessionId)
                    .stepNumber(latestStep.getStepNumber())
                    .instruction(request.getEditInstruction())
                    .resultImageUrl(newImageUrl)
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("繼續編輯失敗", e);
            
            EditStepResponse errorResponse = EditStepResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 多圖融合
     */
    @PostMapping("/fusion")
    public ResponseEntity<ImageFusionResponse> fuseImages(
            @RequestParam("images") List<MultipartFile> imageFiles,
            @RequestBody @Valid ImageFusionRequest request) {
        
        try {
            log.info("多圖融合專案：{}", request.getProjectName());
            
            if (imageFiles.size() > 3) {
                throw new IllegalArgumentException("最多支援 3 張圖片融合");
            }
            
            // 上傳所有圖片並取得 URL
            List<String> imageUrls = imageFiles.stream()
                    .map(this::uploadImageAndGetUrl)
                    .collect(Collectors.toList());
            
            request.setSourceImages(imageUrls);
            
            ImageFusionResult result = fusionService.createImageFusion(request);
            
            ImageFusionResponse response = ImageFusionResponse.builder()
                    .success(true)
                    .projectName(result.getProjectName())
                    .fusionStyle(result.getFusionStyle())
                    .sourceImageUrls(result.getSourceImages())
                    .resultImageUrl(result.getResultImageUrl())
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("多圖融合失敗", e);
            
            ImageFusionResponse errorResponse = ImageFusionResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 風格轉移
     */
    @PostMapping("/style-transfer")
    public ResponseEntity<StyleTransferResponse> performStyleTransfer(
            @RequestParam("sourceImage") MultipartFile sourceImage,
            @RequestParam("styleImage") MultipartFile styleImage,
            @RequestBody @Valid StyleTransferRequest request) {
        
        try {
            log.info("風格轉移：{}", request.getDescription());
            
            String sourceImageUrl = uploadImageAndGetUrl(sourceImage);
            String styleImageUrl = uploadImageAndGetUrl(styleImage);
            
            String resultImageUrl = fusionService.performStyleTransfer(
                    sourceImageUrl,
                    styleImageUrl,
                    request.getDescription()
            );
            
            StyleTransferResponse response = StyleTransferResponse.builder()
                    .success(true)
                    .sourceImageUrl(sourceImageUrl)
                    .styleImageUrl(styleImageUrl)
                    .resultImageUrl(resultImageUrl)
                    .description(request.getDescription())
                    .timestamp(java.time.LocalDateTime.now())
                    .build();
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("風格轉移失敗", e);
            
            StyleTransferResponse errorResponse = StyleTransferResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 上傳圖片並取得 URL
     */
    private String uploadImageAndGetUrl(MultipartFile imageFile) {
        // 實作圖片上傳邏輯，這裡只是示例
        try {
            // 儲存圖片到本地或雲端儲存
            String fileName = UUID.randomUUID().toString() + "_" + imageFile.getOriginalFilename();
            Path uploadPath = Paths.get("uploads", fileName);
            Files.createDirectories(uploadPath.getParent());
            Files.copy(imageFile.getInputStream(), uploadPath, StandardCopyOption.REPLACE_EXISTING);
            
            // 返回可訪問的 URL
            return "http://localhost:8080/uploads/" + fileName;
            
        } catch (IOException e) {
            throw new RuntimeException("圖片上傳失敗", e);
        }
    }
}
```

---

## 📝 本章重點回顧

1. **Gemini 2.5 Flash Image 技術理解**：掌握了 Google 最新圖片 AI 模型的核心優勢
2. **圖片編輯一致性**：學會了如何使用多輪對話編輯保持角色特徵
3. **多圖融合功能**：實現了進階圖片融合和風格轉移功能
4. **企業級功能**：建立了完整的圖片處理和編輯管理系統
5. **商業應用場景**：掌握了圖片編輯、內容創作等實際應用

### Gemini 2.5 Flash Image 技術要點總結

| 技術點 | 重要性 | 實現難度 | 獨特優勢 |
|--------|--------|----------|----------|
| **圖片編輯一致性** | ⭐⭐⭐⭐⭐ | 中 | 世界第一 |
| **多輪對話編輯** | ⭐⭐⭐⭐⭐ | 高 | 業界領先 |
| **多圖融合** | ⭐⭐⭐⭐ | 高 | 先進技術 |
| **自然語言控制** | ⭐⭐⭐⭐ | 中 | 直覺易用 |
| **SynthID 水印** | ⭐⭐⭐ | 低 | 安全保障 |

### Gemini 2.5 Flash Image 最佳實踐

1. **圖片編輯策略**：
   - 使用明確、具體的編輯指令
   - 充分利用多輪對話逐步精化結果
   - 保存編輯歷程以便追蹤和回溯

2. **多圖融合技巧**：
   - 選擇視覺風格相容的圖片進行融合
   - 提供清晰的融合意圖和期望結果
   - 利用 Gemini 的世界知識進行智能融合

3. **商業應用建議**：
   - 善用 SynthID 水印功能保障內容安全
   - 建立圖片處理流程和品質控制標準
   - 整合 Google 生態系統提高工作效率

### 下一步學習方向

在下一章中，我們將學習如何建立語音轉文字系統，探索多媒體內容處理的另一個重要領域，與 Gemini 2.5 Flash Image 的視覺處理能力形成完整的多媒體 AI 解決方案。

---

**參考資料：**
- [Gemini 2.5 Flash Image 官方文檔](https://ai.google.dev/gemini-api/docs/image-generation)
- [Google Developers Blog - Introducing Gemini 2.5 Flash Image](https://developers.googleblog.com/en/introducing-gemini-2-5-flash-image/)
- [Spring AI Image Generation Documentation](https://docs.spring.io/spring-ai/reference/api/imageclient.html)
- [OpenRouter API Documentation](https://openrouter.ai/docs)
- [OpenAI API Compatibility Guide](https://platform.openai.com/docs/api-reference)


\newpage

## 5.4 做一個字幕產生器


> **本章重點**：學習使用 Spring AI 的語音轉文字功能，建立完整的字幕產生系統，掌握音訊處理和多格式字幕輸出技術，為多媒體內容處理提供專業解決方案。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解語音轉文字技術**：掌握 Whisper 模型的工作原理和應用場景
- 🎯 **實現音訊檔案處理**：建立完整的音訊上傳和轉譯功能
- 🎯 **生成多格式字幕**：支援 SRT、VTT、JSON 等多種字幕格式
- 🎯 **優化轉譯品質**：掌握語言設定、溫度調整等優化技巧
- 🎯 **企業級應用設計**：建立可商用的字幕生成服務系統

---

## 5.4.1 語音轉文字技術革命

### 上字幕不再痛苦

![字幕產生器](https://ithelp.ithome.com.tw/upload/images/20240810/20161290jCx3iLQjtI.jpg)

相信很多人知道 OpenAI 開源了 Whisper 模型，網路上也很多人製作本機端的字幕產生程式，凱文大叔試過，只能說慘不忍睹，由於電腦沒有獨立顯卡，不到 30 分鐘的影片竟然一個小時還沒完成。

這時就很適合用平台的算力來協助了！

### 雲端 vs 本地處理對比

| 處理方式 | 優勢 | 劣勢 | 適用場景 |
|----------|------|------|----------|
| **雲端處理** | 速度快、品質高、無硬體要求 | 需要網路、有使用成本 | 商業應用、大量處理 |
| **本地處理** | 隱私保護、無網路依賴 | 速度慢、硬體要求高 | 敏感內容、離線環境 |

**成本效益分析**：
- 🕐 **時間成本**：雲端處理 30 分鐘影片約 2-3 分鐘，本地可能需要 1-2 小時
- 💰 **金錢成本**：OpenAI Whisper 約 $0.006/分鐘，22MB 四分多鐘影片約 $0.03
- 🔧 **硬體成本**：雲端無需投資 GPU，本地需要高階顯卡

### Spring AI 音訊轉譯支援

![Spring AI 音訊支援](https://ithelp.ithome.com.tw/upload/images/20240807/201612904zZn4fPMwh.png)

音頻轉譯在 Spring AI 的文件中主要支援：
- **OpenAI Whisper**：功能完整，支援時間戳記
- **Azure OpenAI**：企業級部署，合規性佳
- **Groq**：速度快但功能受限（無時間戳記）

**重要提醒**：原本想說可以用 Groq 省錢，不過凱文大叔實際測試發現 Groq 閹割了很多功能，只能產生純文字，字幕最重要的時間戳記卻無法產生，若單純產生文字稿還是能用，需要時間戳記就只能花點小錢了。

---

## 5.4.2 專案建立與配置

### Maven 依賴配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>subtitle-generator</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>subtitle-generator</name>
    <description>AI-powered subtitle generator using Spring AI</description>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <!-- 使用 Spring AI BOM 管理版本 -->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.ai</groupId>
                <artifactId>spring-ai-bom</artifactId>
                <version>1.0.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <dependencies>
        <!-- Spring AI OpenAI Starter -->
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-starter-model-openai</artifactId>
        </dependency>
        
        <!-- Spring Boot Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Spring Boot Validation -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <!-- File Processing -->
        <dependency>
            <groupId>org.apache.tika</groupId>
            <artifactId>tika-core</artifactId>
            <version>2.9.1</version>
        </dependency>
        
        <!-- JSON Processing -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

### 應用程式配置

```yaml
# application.yml
spring:
  application:
    name: subtitle-generator
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      base-url: https://api.openai.com
      audio:
        transcription:
          options:
            model: whisper-1
            response-format: verbose_json  # 包含時間戳記的詳細格式
            temperature: 0.0  # 最確定的結果
            language: zh  # 指定中文可提升準確度
            # timestamp-granularities 參數需在程式碼中設定
  
  # 檔案上傳配置
  servlet:
    multipart:
      max-file-size: 25MB  # Whisper 的檔案大小限制
      max-request-size: 25MB
      enabled: true

# 應用程式配置
app:
  subtitle:
    output-directory: ./subtitles
    supported-formats: ["srt", "vtt", "json", "txt"]
    max-duration: 3600  # 最大處理時長（秒）
    default-language: zh

# 伺服器配置
server:
  port: 8080
  servlet:
    context-path: /api

# 日誌配置
logging:
  level:
    org.springframework.ai: DEBUG
    com.example: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

---

## 5.4.3 基礎字幕生成功能

### 音訊轉譯控制器

```java
package com.example.controller;

import com.example.dto.SubtitleRequest;
import com.example.dto.SubtitleResponse;
import com.example.service.SubtitleGenerationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.Arrays;
import java.util.List;

@RestController
@RequestMapping("/subtitle")
@RequiredArgsConstructor
@Slf4j
public class SubtitleController {
    
    private final SubtitleGenerationService subtitleService;
    
    /**
     * 基礎字幕生成
     * @param file 音訊或影片檔案
     * @param format 輸出格式（srt, vtt, json, txt）
     * @param language 語言代碼（可選）
     * @return 字幕內容
     */
    @PostMapping(value = "/generate", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<SubtitleResponse> generateSubtitle(
            @RequestParam("file") MultipartFile file,
            @RequestParam(value = "format", defaultValue = "srt") String format,
            @RequestParam(value = "language", required = false) String language) {
        
        try {
            // 驗證檔案
            validateAudioFile(file);
            
            log.info("開始處理字幕生成：檔案={}, 格式={}, 語言={}", 
                    file.getOriginalFilename(), format, language);
            
            // 生成字幕
            SubtitleResponse response = subtitleService.generateSubtitle(
                    file, format, language
            );
            
            log.info("字幕生成完成：{}", file.getOriginalFilename());
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("字幕生成失敗：{}", file.getOriginalFilename(), e);
            
            SubtitleResponse errorResponse = SubtitleResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .fileName(file.getOriginalFilename())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 進階字幕生成（支援更多選項）
     * @param file 音訊檔案
     * @param request 生成選項
     * @return 字幕回應
     */
    @PostMapping(value = "/generate-advanced", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<SubtitleResponse> generateAdvancedSubtitle(
            @RequestParam("file") MultipartFile file,
            @ModelAttribute SubtitleRequest request) {
        
        try {
            validateAudioFile(file);
            
            log.info("開始進階字幕生成：{}", request);
            
            SubtitleResponse response = subtitleService.generateAdvancedSubtitle(
                    file, request
            );
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("進階字幕生成失敗", e);
            
            SubtitleResponse errorResponse = SubtitleResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .fileName(file.getOriginalFilename())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 批次字幕生成
     * @param files 多個音訊檔案
     * @param format 輸出格式
     * @return 批次處理結果
     */
    @PostMapping(value = "/batch-generate", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<List<SubtitleResponse>> batchGenerateSubtitles(
            @RequestParam("files") MultipartFile[] files,
            @RequestParam(value = "format", defaultValue = "srt") String format) {
        
        try {
            log.info("開始批次字幕生成：{} 個檔案", files.length);
            
            List<SubtitleResponse> responses = subtitleService.batchGenerateSubtitles(
                    Arrays.asList(files), format
            );
            
            return ResponseEntity.ok(responses);
            
        } catch (Exception e) {
            log.error("批次字幕生成失敗", e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 驗證音訊檔案
     */
    private void validateAudioFile(MultipartFile file) {
        if (file.isEmpty()) {
            throw new IllegalArgumentException("檔案不能為空");
        }
        
        // 檢查檔案大小（25MB 限制）
        if (file.getSize() > 25 * 1024 * 1024) {
            throw new IllegalArgumentException("檔案大小不能超過 25MB");
        }
        
        // 檢查檔案格式
        String contentType = file.getContentType();
        if (contentType == null || !isValidAudioFormat(contentType)) {
            throw new IllegalArgumentException(
                "不支援的檔案格式，請上傳 MP3、WAV、M4A、MP4 或 WEBM 格式"
            );
        }
    }
    
    private boolean isValidAudioFormat(String contentType) {
        return contentType.startsWith("audio/") || 
               contentType.equals("video/mp4") ||
               contentType.equals("video/webm");
    }
}
```

### 字幕生成服務

```java
package com.example.service;

import com.example.dto.SubtitleRequest;
import com.example.dto.SubtitleResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.audio.transcription.AudioTranscriptionModel;
import org.springframework.ai.audio.transcription.AudioTranscriptionPrompt;
import org.springframework.ai.audio.transcription.AudioTranscriptionResponse;
import org.springframework.ai.openai.OpenAiAudioTranscriptionOptions;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class SubtitleGenerationService {
    
    private final AudioTranscriptionModel transcriptionModel;
    private final SubtitleFormatterService formatterService;
    
    /**
     * 基礎字幕生成
     * @param file 音訊檔案
     * @param format 輸出格式
     * @param language 語言（可選）
     * @return 字幕回應
     */
    public SubtitleResponse generateSubtitle(
            MultipartFile file, 
            String format, 
            String language) {
        
        try {
            // 建立轉譯選項
            OpenAiAudioTranscriptionOptions options = OpenAiAudioTranscriptionOptions.builder()
                    .withModel("whisper-1")
                    .withResponseFormat("verbose_json")  // 包含時間戳記
                    .withTemperature(0.0f)
                    .withLanguage(language != null ? language : "zh")
                    .withTimestampGranularities(List.of("word", "segment"))
                    .build();
            
            // 建立音訊資源
            Resource audioResource = createAudioResource(file);
            
            // 建立轉譯請求
            AudioTranscriptionPrompt prompt = new AudioTranscriptionPrompt(
                    audioResource, options
            );
            
            // 執行轉譯
            AudioTranscriptionResponse response = transcriptionModel.call(prompt);
            String transcriptionResult = response.getResult().getOutput();
            
            // 格式化字幕
            String formattedSubtitle = formatterService.formatSubtitle(
                    transcriptionResult, format
            );
            
            return SubtitleResponse.builder()
                    .success(true)
                    .fileName(file.getOriginalFilename())
                    .format(format)
                    .language(language != null ? language : "zh")
                    .content(formattedSubtitle)
                    .fileSize(file.getSize())
                    .processingTime(calculateProcessingTime())
                    .timestamp(LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("字幕生成失敗：{}", file.getOriginalFilename(), e);
            throw new RuntimeException("字幕生成失敗：" + e.getMessage(), e);
        }
    }
    
    /**
     * 進階字幕生成
     * @param file 音訊檔案
     * @param request 生成選項
     * @return 字幕回應
     */
    public SubtitleResponse generateAdvancedSubtitle(
            MultipartFile file, 
            SubtitleRequest request) {
        
        try {
            // 建立進階轉譯選項
            OpenAiAudioTranscriptionOptions options = OpenAiAudioTranscriptionOptions.builder()
                    .withModel("whisper-1")
                    .withResponseFormat("verbose_json")
                    .withTemperature(request.getTemperature())
                    .withLanguage(request.getLanguage())
                    .withTimestampGranularities(request.getTimestampGranularities())
                    .build();
            
            // 如果有提示詞，加入提示
            if (request.getPrompt() != null && !request.getPrompt().isEmpty()) {
                options = options.toBuilder()
                        .withPrompt(request.getPrompt())
                        .build();
            }
            
            // 建立音訊資源
            Resource audioResource = createAudioResource(file);
            
            AudioTranscriptionPrompt prompt = new AudioTranscriptionPrompt(
                    audioResource, options
            );
            
            AudioTranscriptionResponse response = transcriptionModel.call(prompt);
            String transcriptionResult = response.getResult().getOutput();
            
            // 格式化字幕
            String formattedSubtitle = formatterService.formatSubtitle(
                    transcriptionResult, request.getFormat()
            );
            
            return SubtitleResponse.builder()
                    .success(true)
                    .fileName(file.getOriginalFilename())
                    .format(request.getFormat())
                    .language(request.getLanguage())
                    .content(formattedSubtitle)
                    .fileSize(file.getSize())
                    .temperature(request.getTemperature())
                    .prompt(request.getPrompt())
                    .processingTime(calculateProcessingTime())
                    .timestamp(LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("進階字幕生成失敗：{}", file.getOriginalFilename(), e);
            throw new RuntimeException("進階字幕生成失敗：" + e.getMessage(), e);
        }
    }
    
    /**
     * 批次字幕生成
     * @param files 檔案列表
     * @param format 輸出格式
     * @return 批次處理結果
     */
    public List<SubtitleResponse> batchGenerateSubtitles(
            List<MultipartFile> files, 
            String format) {
        
        log.info("開始批次處理 {} 個檔案", files.size());
        
        List<CompletableFuture<SubtitleResponse>> futures = files.stream()
                .map(file -> CompletableFuture.supplyAsync(() -> {
                    try {
                        return generateSubtitle(file, format, null);
                    } catch (Exception e) {
                        log.error("批次處理失敗：{}", file.getOriginalFilename(), e);
                        return SubtitleResponse.builder()
                                .success(false)
                                .fileName(file.getOriginalFilename())
                                .error(e.getMessage())
                                .build();
                    }
                }))
                .collect(Collectors.toList());
        
        // 等待所有任務完成
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(
                futures.toArray(new CompletableFuture[0])
        );
        
        return allFutures.thenApply(v -> 
                futures.stream()
                        .map(CompletableFuture::join)
                        .collect(Collectors.toList())
        ).join();
    }
    
    private long calculateProcessingTime() {
        // 實際實現中應該記錄開始時間並計算差值
        return System.currentTimeMillis();
    }
    
    /**
     * 建立音訊資源
     * @param file MultipartFile 檔案
     * @return Resource 音訊資源
     */
    private Resource createAudioResource(MultipartFile file) {
        try {
            return new ByteArrayResource(file.getBytes()) {
                @Override
                public String getFilename() {
                    return file.getOriginalFilename();
                }
            };
        } catch (IOException e) {
            throw new RuntimeException("建立音訊資源失敗：" + e.getMessage(), e);
        }
    }
}
```

---

## 5.4.4 多格式字幕輸出

### 字幕格式化服務

```java
package com.example.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class SubtitleFormatterService {
    
    private final ObjectMapper objectMapper;
    
    /**
     * 格式化字幕為指定格式
     * @param transcriptionJson Whisper 回傳的 JSON 結果
     * @param format 目標格式
     * @return 格式化後的字幕內容
     */
    public String formatSubtitle(String transcriptionJson, String format) {
        try {
            JsonNode jsonNode = objectMapper.readTree(transcriptionJson);
            
            return switch (format.toLowerCase()) {
                case "srt" -> formatToSRT(jsonNode);
                case "vtt" -> formatToVTT(jsonNode);
                case "json" -> formatToJSON(jsonNode);
                case "txt" -> formatToTXT(jsonNode);
                default -> throw new IllegalArgumentException("不支援的格式：" + format);
            };
            
        } catch (Exception e) {
            log.error("字幕格式化失敗", e);
            throw new RuntimeException("字幕格式化失敗：" + e.getMessage(), e);
        }
    }
    
    /**
     * 格式化為 SRT 格式
     */
    private String formatToSRT(JsonNode jsonNode) {
        StringBuilder srt = new StringBuilder();
        JsonNode segments = jsonNode.get("segments");
        
        if (segments != null && segments.isArray()) {
            int index = 1;
            for (JsonNode segment : segments) {
                double start = segment.get("start").asDouble();
                double end = segment.get("end").asDouble();
                String text = segment.get("text").asText().trim();
                
                if (!text.isEmpty()) {
                    srt.append(index++).append("\n");
                    srt.append(formatTime(start)).append(" --> ").append(formatTime(end)).append("\n");
                    srt.append(text).append("\n\n");
                }
            }
        }
        
        return srt.toString();
    }
    
    /**
     * 格式化為 VTT 格式
     */
    private String formatToVTT(JsonNode jsonNode) {
        StringBuilder vtt = new StringBuilder();
        vtt.append("WEBVTT\n\n");
        
        JsonNode segments = jsonNode.get("segments");
        
        if (segments != null && segments.isArray()) {
            for (JsonNode segment : segments) {
                double start = segment.get("start").asDouble();
                double end = segment.get("end").asDouble();
                String text = segment.get("text").asText().trim();
                
                if (!text.isEmpty()) {
                    vtt.append(formatTimeVTT(start)).append(" --> ").append(formatTimeVTT(end)).append("\n");
                    vtt.append(text).append("\n\n");
                }
            }
        }
        
        return vtt.toString();
    }
    
    /**
     * 格式化為 JSON 格式（結構化）
     */
    private String formatToJSON(JsonNode jsonNode) {
        try {
            // 建立結構化的字幕 JSON
            SubtitleData subtitleData = new SubtitleData();
            subtitleData.setLanguage(jsonNode.get("language").asText());
            subtitleData.setDuration(jsonNode.get("duration").asDouble());
            
            JsonNode segments = jsonNode.get("segments");
            if (segments != null && segments.isArray()) {
                for (JsonNode segment : segments) {
                    SubtitleSegment subtitleSegment = new SubtitleSegment();
                    subtitleSegment.setStart(segment.get("start").asDouble());
                    subtitleSegment.setEnd(segment.get("end").asDouble());
                    subtitleSegment.setText(segment.get("text").asText().trim());
                    
                    // 如果有詞級時間戳記
                    JsonNode words = segment.get("words");
                    if (words != null && words.isArray()) {
                        for (JsonNode word : words) {
                            SubtitleWord subtitleWord = new SubtitleWord();
                            subtitleWord.setWord(word.get("word").asText());
                            subtitleWord.setStart(word.get("start").asDouble());
                            subtitleWord.setEnd(word.get("end").asDouble());
                            subtitleSegment.getWords().add(subtitleWord);
                        }
                    }
                    
                    subtitleData.getSegments().add(subtitleSegment);
                }
            }
            
            return objectMapper.writerWithDefaultPrettyPrinter()
                    .writeValueAsString(subtitleData);
            
        } catch (Exception e) {
            log.error("JSON 格式化失敗", e);
            return jsonNode.toPrettyString();
        }
    }
    
    /**
     * 格式化為純文字格式
     */
    private String formatToTXT(JsonNode jsonNode) {
        StringBuilder txt = new StringBuilder();
        JsonNode segments = jsonNode.get("segments");
        
        if (segments != null && segments.isArray()) {
            for (JsonNode segment : segments) {
                String text = segment.get("text").asText().trim();
                if (!text.isEmpty()) {
                    txt.append(text).append(" ");
                }
            }
        }
        
        return txt.toString().trim();
    }
    
    /**
     * 格式化時間為 SRT 格式 (HH:MM:SS,mmm)
     */
    private String formatTime(double seconds) {
        Duration duration = Duration.ofMillis((long) (seconds * 1000));
        long hours = duration.toHours();
        long minutes = duration.toMinutesPart();
        long secs = duration.toSecondsPart();
        long millis = duration.toMillisPart();
        
        return String.format("%02d:%02d:%02d,%03d", hours, minutes, secs, millis);
    }
    
    /**
     * 格式化時間為 VTT 格式 (HH:MM:SS.mmm)
     */
    private String formatTimeVTT(double seconds) {
        Duration duration = Duration.ofMillis((long) (seconds * 1000));
        long hours = duration.toHours();
        long minutes = duration.toMinutesPart();
        long secs = duration.toSecondsPart();
        long millis = duration.toMillisPart();
        
        return String.format("%02d:%02d:%02d.%03d", hours, minutes, secs, millis);
    }
}
```

### 字幕資料結構

```java
package com.example.dto;

import lombok.Data;
import java.util.ArrayList;
import java.util.List;

@Data
public class SubtitleData {
    private String language;
    private Double duration;
    private List<SubtitleSegment> segments = new ArrayList<>();
}

@Data
public class SubtitleSegment {
    private Double start;
    private Double end;
    private String text;
    private List<SubtitleWord> words = new ArrayList<>();
}

@Data
public class SubtitleWord {
    private String word;
    private Double start;
    private Double end;
}
```

---

## 5.4.5 請求和回應 DTO

### 字幕請求 DTO

```java
package com.example.dto;

import lombok.Data;
import javax.validation.constraints.*;
import java.util.List;

@Data
public class SubtitleRequest {
    
    @NotBlank(message = "輸出格式不能為空")
    @Pattern(regexp = "^(srt|vtt|json|txt)$", message = "格式必須是 srt、vtt、json 或 txt")
    private String format = "srt";
    
    @Pattern(regexp = "^[a-z]{2}$", message = "語言代碼必須是兩位字母")
    private String language = "zh";
    
    @DecimalMin(value = "0.0", message = "溫度值必須大於等於 0")
    @DecimalMax(value = "1.0", message = "溫度值必須小於等於 1")
    private Float temperature = 0.0f;
    
    @Size(max = 224, message = "提示詞不能超過 224 個字元")
    private String prompt;
    
    private List<String> timestampGranularities = List.of("segment");
    
    private Boolean includeWordTimestamps = false;
    
    private String model = "whisper-1";
}
```

### 字幕回應 DTO

```java
package com.example.dto;

import lombok.Builder;
import lombok.Data;
import java.time.LocalDateTime;

@Data
@Builder
public class SubtitleResponse {
    
    private boolean success;
    private String fileName;
    private String format;
    private String language;
    private String content;
    private Long fileSize;
    private Float temperature;
    private String prompt;
    private String model;
    private Long processingTime;
    private String error;
    private LocalDateTime timestamp;
    
    // 統計資訊
    private Integer segmentCount;
    private Integer wordCount;
    private Double audioDuration;
    
    /**
     * 建立成功回應
     */
    public static SubtitleResponse success(String fileName, String format, String content) {
        return SubtitleResponse.builder()
                .success(true)
                .fileName(fileName)
                .format(format)
                .content(content)
                .timestamp(LocalDateTime.now())
                .build();
    }
    
    /**
     * 建立錯誤回應
     */
    public static SubtitleResponse error(String fileName, String error) {
        return SubtitleResponse.builder()
                .success(false)
                .fileName(fileName)
                .error(error)
                .timestamp(LocalDateTime.now())
                .build();
    }
}
```

---

## 5.4.6 進階功能實現

### 字幕檔案下載服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Service
@RequiredArgsConstructor
@Slf4j
public class SubtitleDownloadService {
    
    @Value("${app.subtitle.output-directory:./subtitles}")
    private String outputDirectory;
    
    /**
     * 建立字幕檔案下載回應
     * @param content 字幕內容
     * @param fileName 原始檔案名稱
     * @param format 字幕格式
     * @return 下載回應
     */
    public ResponseEntity<Resource> createDownloadResponse(
            String content, 
            String fileName, 
            String format) {
        
        try {
            // 生成下載檔案名稱
            String downloadFileName = generateDownloadFileName(fileName, format);
            
            // 建立資源
            ByteArrayResource resource = new ByteArrayResource(
                    content.getBytes(StandardCharsets.UTF_8)
            );
            
            // 設定 Content-Type
            MediaType mediaType = getMediaTypeForFormat(format);
            
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, 
                           "attachment; filename=\"" + downloadFileName + "\"")
                    .contentType(mediaType)
                    .contentLength(resource.contentLength())
                    .body(resource);
            
        } catch (Exception e) {
            log.error("建立下載回應失敗", e);
            throw new RuntimeException("建立下載回應失敗：" + e.getMessage(), e);
        }
    }
    
    /**
     * 生成下載檔案名稱
     */
    private String generateDownloadFileName(String originalFileName, String format) {
        String baseName = originalFileName;
        
        // 移除原始副檔名
        int lastDotIndex = baseName.lastIndexOf('.');
        if (lastDotIndex > 0) {
            baseName = baseName.substring(0, lastDotIndex);
        }
        
        // 添加時間戳記
        String timestamp = LocalDateTime.now().format(
                DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")
        );
        
        return String.format("%s_字幕_%s.%s", baseName, timestamp, format);
    }
    
    /**
     * 根據格式獲取 MediaType
     */
    private MediaType getMediaTypeForFormat(String format) {
        return switch (format.toLowerCase()) {
            case "srt" -> MediaType.parseMediaType("application/x-subrip");
            case "vtt" -> MediaType.parseMediaType("text/vtt");
            case "json" -> MediaType.APPLICATION_JSON;
            case "txt" -> MediaType.TEXT_PLAIN;
            default -> MediaType.APPLICATION_OCTET_STREAM;
        };
    }
}
```

### 字幕品質優化服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.regex.Pattern;

@Service
@RequiredArgsConstructor
@Slf4j
public class SubtitleOptimizationService {
    
    /**
     * 優化字幕內容
     * @param content 原始字幕內容
     * @param language 語言
     * @return 優化後的字幕內容
     */
    public String optimizeSubtitleContent(String content, String language) {
        String optimized = content;
        
        // 移除多餘空白
        optimized = removeExtraWhitespace(optimized);
        
        // 修正標點符號
        optimized = fixPunctuation(optimized, language);
        
        // 合併短句
        optimized = mergeShortSentences(optimized);
        
        // 分割長句
        optimized = splitLongSentences(optimized);
        
        return optimized;
    }
    
    /**
     * 移除多餘空白
     */
    private String removeExtraWhitespace(String content) {
        return content.replaceAll("\\s+", " ").trim();
    }
    
    /**
     * 修正標點符號
     */
    private String fixPunctuation(String content, String language) {
        if ("zh".equals(language)) {
            // 中文標點符號修正
            content = content.replaceAll("\\s*,\\s*", "，");
            content = content.replaceAll("\\s*\\.\\s*", "。");
            content = content.replaceAll("\\s*\\?\\s*", "？");
            content = content.replaceAll("\\s*!\\s*", "！");
        }
        
        return content;
    }
    
    /**
     * 合併短句
     */
    private String mergeShortSentences(String content) {
        // 如果句子太短（少於10個字元），嘗試與下一句合併
        String[] sentences = content.split("[。！？.!?]");
        StringBuilder merged = new StringBuilder();
        
        for (int i = 0; i < sentences.length; i++) {
            String sentence = sentences[i].trim();
            if (sentence.length() < 10 && i < sentences.length - 1) {
                // 合併短句
                sentence += sentences[++i].trim();
            }
            if (!sentence.isEmpty()) {
                merged.append(sentence).append("。");
            }
        }
        
        return merged.toString();
    }
    
    /**
     * 分割長句
     */
    private String splitLongSentences(String content) {
        // 如果句子太長（超過50個字元），嘗試在適當位置分割
        return content.replaceAll("([，,])(?=.{20,})", "$1\n");
    }
    
    /**
     * 驗證字幕品質
     * @param content 字幕內容
     * @return 品質評分（0-100）
     */
    public int evaluateSubtitleQuality(String content) {
        int score = 100;
        
        // 檢查是否有明顯錯誤
        if (content.contains("[音樂]") || content.contains("[掌聲]")) {
            score -= 10;  // 包含音效標記
        }
        
        if (Pattern.compile("[a-zA-Z]{10,}").matcher(content).find()) {
            score -= 15;  // 包含長英文單詞（可能是錯誤識別）
        }
        
        if (content.length() < 10) {
            score -= 30;  // 內容太短
        }
        
        // 檢查標點符號比例
        long punctuationCount = content.chars()
                .filter(ch -> "，。！？,.!?".indexOf(ch) >= 0)
                .count();
        
        double punctuationRatio = (double) punctuationCount / content.length();
        if (punctuationRatio < 0.05) {
            score -= 20;  // 標點符號太少
        }
        
        return Math.max(0, score);
    }
}
```

---

## 5.4.7 Web 介面實現

### 字幕生成頁面

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 字幕產生器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 40px;
            max-width: 800px;
            width: 90%;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #333;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #666;
            font-size: 1.1rem;
        }
        
        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }
        
        .upload-area.dragover {
            border-color: #667eea;
            background: #f0f4ff;
        }
        
        .upload-icon {
            font-size: 3rem;
            color: #ddd;
            margin-bottom: 15px;
        }
        
        .upload-text {
            color: #666;
            font-size: 1.1rem;
            margin-bottom: 10px;
        }
        
        .upload-hint {
            color: #999;
            font-size: 0.9rem;
        }
        
        .options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .option-group {
            display: flex;
            flex-direction: column;
        }
        
        .option-group label {
            color: #333;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .option-group select,
        .option-group input {
            padding: 12px;
            border: 2px solid #eee;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }
        
        .option-group select:focus,
        .option-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .generate-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }
        
        .generate-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }
        
        .generate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .progress {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #eee;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .result {
            display: none;
            margin-top: 20px;
        }
        
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .result-title {
            color: #333;
            font-size: 1.3rem;
            font-weight: 600;
        }
        
        .download-btn {
            padding: 8px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }
        
        .download-btn:hover {
            background: #218838;
        }
        
        .result-content {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .options {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎬 AI 字幕產生器</h1>
            <p>上傳音訊或影片檔案，AI 自動生成高品質字幕</p>
        </div>
        
        <form id="subtitleForm" enctype="multipart/form-data">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">📁</div>
                <div class="upload-text">點擊選擇檔案或拖拽到此處</div>
                <div class="upload-hint">支援 MP3、WAV、M4A、MP4、WEBM 格式，最大 25MB</div>
                <input type="file" id="fileInput" name="file" accept="audio/*,video/*" style="display: none;">
            </div>
            
            <div class="options">
                <div class="option-group">
                    <label for="format">字幕格式</label>
                    <select id="format" name="format">
                        <option value="srt">SRT (最常用)</option>
                        <option value="vtt">VTT (網頁字幕)</option>
                        <option value="json">JSON (結構化)</option>
                        <option value="txt">TXT (純文字)</option>
                    </select>
                </div>
                
                <div class="option-group">
                    <label for="language">語言</label>
                    <select id="language" name="language">
                        <option value="zh">中文</option>
                        <option value="en">English</option>
                        <option value="ja">日本語</option>
                        <option value="ko">한국어</option>
                        <option value="auto">自動偵測</option>
                    </select>
                </div>
            </div>
            
            <button type="submit" class="generate-btn" id="generateBtn">
                🚀 開始生成字幕
            </button>
        </form>
        
        <div class="progress" id="progress">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="progressText">正在處理中，請稍候...</div>
        </div>
        
        <div class="result" id="result">
            <div class="result-header">
                <div class="result-title">✅ 字幕生成完成</div>
                <button class="download-btn" id="downloadBtn">📥 下載字幕</button>
            </div>
            <div class="result-content" id="resultContent"></div>
        </div>
    </div>
    
    <script>
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const form = document.getElementById('subtitleForm');
        const generateBtn = document.getElementById('generateBtn');
        const progress = document.getElementById('progress');
        const result = document.getElementById('result');
        const resultContent = document.getElementById('resultContent');
        const downloadBtn = document.getElementById('downloadBtn');
        
        let currentSubtitleData = null;
        
        // 檔案上傳區域事件
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', handleDragOver);
        uploadArea.addEventListener('dragleave', handleDragLeave);
        uploadArea.addEventListener('drop', handleDrop);
        
        fileInput.addEventListener('change', handleFileSelect);
        form.addEventListener('submit', handleSubmit);
        downloadBtn.addEventListener('click', handleDownload);
        
        function handleDragOver(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        }
        
        function handleDragLeave(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                fileInput.files = files;
                updateUploadArea(files[0]);
            }
        }
        
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                updateUploadArea(file);
            }
        }
        
        function updateUploadArea(file) {
            const uploadText = uploadArea.querySelector('.upload-text');
            const uploadHint = uploadArea.querySelector('.upload-hint');
            
            uploadText.textContent = `已選擇：${file.name}`;
            uploadHint.textContent = `檔案大小：${(file.size / 1024 / 1024).toFixed(2)} MB`;
        }
        
        async function handleSubmit(e) {
            e.preventDefault();
            
            const formData = new FormData(form);
            const file = fileInput.files[0];
            
            if (!file) {
                alert('請選擇要處理的檔案');
                return;
            }
            
            // 顯示進度
            showProgress();
            
            try {
                const response = await fetch('/api/subtitle/generate', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showResult(data);
                } else {
                    showError(data.error || '字幕生成失敗');
                }
                
            } catch (error) {
                console.error('Error:', error);
                showError('網路錯誤，請稍後再試');
            } finally {
                hideProgress();
            }
        }
        
        function showProgress() {
            generateBtn.disabled = true;
            generateBtn.textContent = '⏳ 處理中...';
            progress.style.display = 'block';
            result.style.display = 'none';
            
            // 模擬進度
            let progressValue = 0;
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            const interval = setInterval(() => {
                progressValue += Math.random() * 10;
                if (progressValue > 90) progressValue = 90;
                
                progressFill.style.width = progressValue + '%';
                
                if (progressValue < 30) {
                    progressText.textContent = '正在上傳檔案...';
                } else if (progressValue < 60) {
                    progressText.textContent = 'AI 正在分析音訊...';
                } else {
                    progressText.textContent = '正在生成字幕...';
                }
            }, 500);
            
            // 儲存 interval ID 以便後續清除
            progress.dataset.intervalId = interval;
        }
        
        function hideProgress() {
            generateBtn.disabled = false;
            generateBtn.textContent = '🚀 開始生成字幕';
            progress.style.display = 'none';
            
            // 清除進度模擬
            const intervalId = progress.dataset.intervalId;
            if (intervalId) {
                clearInterval(intervalId);
            }
        }
        
        function showResult(data) {
            currentSubtitleData = data;
            resultContent.textContent = data.content;
            result.style.display = 'block';
        }
        
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = '❌ ' + message;
            
            // 移除舊的錯誤訊息
            const oldError = document.querySelector('.error');
            if (oldError) {
                oldError.remove();
            }
            
            form.appendChild(errorDiv);
            
            // 3秒後自動移除錯誤訊息
            setTimeout(() => {
                errorDiv.remove();
            }, 3000);
        }
        
        function handleDownload() {
            if (!currentSubtitleData) return;
            
            const blob = new Blob([currentSubtitleData.content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            a.href = url;
            a.download = `${currentSubtitleData.fileName}_字幕.${currentSubtitleData.format}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
```

---

## 📝 本章重點回顧

1. **語音轉文字技術**：掌握了 Whisper 模型的工作原理和雲端處理優勢
2. **多格式字幕輸出**：實現了 SRT、VTT、JSON、TXT 等多種字幕格式
3. **企業級功能**：建立了完整的字幕生成、優化和管理系統
4. **Web 介面整合**：提供了友善的拖拽上傳和即時預覽功能
5. **品質優化技術**：掌握了字幕內容優化和品質評估方法

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **基礎轉譯** | ⭐⭐⭐ | 低 | 所有字幕應用 |
| **多格式輸出** | ⭐⭐⭐ | 中 | 不同平台需求 |
| **批次處理** | ⭐⭐ | 中 | 大量內容處理 |
| **品質優化** | ⭐⭐ | 高 | 專業字幕製作 |
| **Web 介面** | ⭐⭐ | 中 | 使用者體驗 |
| **檔案管理** | ⭐ | 低 | 企業級部署 |

### 成本效益分析

**OpenAI Whisper 定價**：
- 💰 **成本**：$0.006 per minute
- ⏱️ **速度**：通常比音訊時長快 5-10 倍
- 🎯 **準確度**：中文識別準確率 > 95%
- 📊 **性價比**：相比人工字幕製作節省 80% 成本

### 最佳實踐建議

1. **檔案預處理**：確保音訊品質，移除背景噪音
2. **語言設定**：正確設定語言可提升 10-15% 準確度
3. **溫度調整**：使用 0.0 溫度獲得最穩定結果
4. **批次處理**：大量檔案使用非同步處理提升效率
5. **品質檢查**：實施自動品質評估和人工校對流程

### 下一步學習方向

在下一章中，我們將學習文字轉語音技術，探索如何讓 AI 幫你配音，建立完整的語音合成應用。

---

**參考資料：**
- [Spring AI Audio Transcription Documentation](https://docs.spring.io/spring-ai/reference/api/audio.html)
- [OpenAI Whisper API](https://platform.openai.com/docs/guides/speech-to-text)
- [SRT Subtitle Format Specification](https://en.wikipedia.org/wiki/SubRip)
- [WebVTT Specification](https://www.w3.org/TR/webvtt1/)


\newpage

## 5.5 聲優太花錢？找 AI 幫你配音


> **本章重點**：學習使用 Spring AI 的文字轉語音功能，建立完整的 AI 配音系統，掌握語音合成和音訊處理技術，為多媒體內容創作提供專業的語音解決方案。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解文字轉語音技術**：掌握 TTS 技術的工作原理和應用場景
- 🎯 **實現多種語音風格**：支援不同聲音、語速、語調的語音生成
- 🎯 **建立配音管理系統**：完整的語音生成、儲存和下載功能
- 🎯 **優化語音品質**：掌握語音參數調整和品質控制技巧
- 🎯 **企業級應用設計**：建立可商用的 AI 配音服務平台

---

## 5.5.1 AI 配音技術革命

### AI 有 ABC 腔調

![AI 配音](https://ithelp.ithome.com.tw/upload/images/20240810/20161290YGtkKt0BkG.jpg)

昨天教大家上字幕，今天則是反過來，給文字讓 AI 幫你配音！

比起以前文字轉聲音的軟體，AI 的聲音更為自然，角色跟速度也都能調整，讓我們看看如何操作吧。

### AI 配音 vs 傳統配音對比

| 比較項目 | AI 配音 | 傳統配音 | 優勢分析 |
|----------|---------|----------|----------|
| **成本** | $0.015/1K字元 | $50-200/分鐘 | AI 節省 95%+ 成本 |
| **速度** | 即時生成 | 數天製作 | AI 快 100+ 倍 |
| **一致性** | 完全一致 | 人為變化 | AI 品質穩定 |
| **可調性** | 隨時調整 | 重新錄製 | AI 彈性極高 |
| **語言支援** | 多語言 | 限制較多 | AI 支援更廣 |
| **情感表達** | 持續改善 | 自然豐富 | 傳統仍有優勢 |

### AI 配音的核心價值

**1. 成本效益顯著**
- 💰 **大幅降低成本**：相比專業配音員節省 95% 以上費用
- ⏰ **即時生成**：從文字到語音幾秒鐘完成
- 🔄 **無限修改**：隨時調整內容無額外成本
- 📈 **規模化生產**：批次處理大量內容

**2. 品質持續提升**
- 🎭 **多種聲音選擇**：男聲、女聲、不同年齡和風格
- 🎵 **語調控制**：調整語速、音調、情感表達
- 🌍 **多語言支援**：支援數十種語言和方言
- 🔊 **高品質音訊**：CD 級音質輸出

**3. 應用場景廣泛**
- 📚 **教育培訓**：課程講解、有聲書製作
- 🎬 **影片製作**：旁白配音、角色對話
- 📢 **廣告行銷**：廣告配音、產品介紹
- 🤖 **智能助手**：語音回應、客服系統
- 🎮 **遊戲開發**：角色配音、劇情對話

---

## 5.5.2 Spring AI 語音生成服務

### 主要支援的語音服務

| 服務商 | 模型 | 語音選項 | 品質 | 成本 | 推薦場景 |
|--------|------|----------|------|------|----------|
| **OpenAI** | TTS-1, TTS-1-HD | 6種聲音 | 極高 | 中 | 通用配音、專業製作 |
| **Azure OpenAI** | TTS-1, TTS-1-HD | 6種聲音 | 極高 | 中 | 企業級應用 |
| **ElevenLabs** | 多種模型 | 自訂聲音 | 極高 | 高 | 高端配音、聲音克隆 |
| **Google Cloud** | WaveNet | 多種聲音 | 高 | 低 | 大量生成、成本敏感 |

### OpenAI TTS 語音選項詳解

文字轉語音也是劃分在 **Audio Model** 的部分，Spring AI 目前主要支援 OpenAI 和 Azure OpenAI：

![Spring AI 語音支援](https://ithelp.ithome.com.tw/upload/images/20240809/20161290wi54q7gekg.png)

**OpenAI TTS 可用聲音**：

| 聲音名稱 | 特色 | 適用場景 | 語言支援 |
|----------|------|----------|----------|
| **alloy** | 中性、清晰 | 新聞播報、教學 | 多語言 |
| **echo** | 男性、沉穩 | 商業簡報、紀錄片 | 多語言 |
| **fable** | 女性、溫暖 | 故事講述、客服 | 多語言 |
| **onyx** | 男性、深沉 | 廣告配音、旁白 | 多語言 |
| **nova** | 女性、活潑 | 廣告、娛樂內容 | 多語言 |
| **shimmer** | 女性、柔和 | 冥想、放鬆內容 | 多語言 |

**模型差異**：
- **TTS-1**：標準品質，速度快，成本低
- **TTS-1-HD**：高品質，音質更佳，成本稍高

---

## 5.5.3 專案建立與配置

### Maven 依賴配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>ai-voice-generator</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>ai-voice-generator</name>
    <description>AI-powered voice generation using Spring AI</description>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <!-- 使用 Spring AI BOM 管理版本 -->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.ai</groupId>
                <artifactId>spring-ai-bom</artifactId>
                <version>1.0.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <dependencies>
        <!-- Spring AI OpenAI Starter -->
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-starter-model-openai</artifactId>
        </dependency>
        
        <!-- Spring Boot Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Spring Boot Validation -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <!-- Audio Processing -->
        <dependency>
            <groupId>org.apache.tika</groupId>
            <artifactId>tika-core</artifactId>
            <version>2.9.2</version>
        </dependency>
        
        <!-- File Processing -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.15.1</version>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

### 應用程式配置

```yaml
# application.yml
spring:
  application:
    name: ai-voice-generator
  ai:
    model:
      audio:
        speech: openai  # 啟用 OpenAI 音訊語音模型
    openai:
      api-key: ${OPENAI_API_KEY}
      base-url: https://api.openai.com
      audio:
        speech:
          options:
            model: tts-1-hd  # 高品質模型
            voice: alloy     # 預設聲音
            response-format: mp3  # 音訊格式
            speed: 1.0       # 語速（0.25-4.0）

# 應用程式配置
app:
  voice:
    output-directory: ./generated-voices
    supported-formats: ["mp3", "opus", "aac", "flac"]
    max-text-length: 4096  # OpenAI TTS 限制
    default-voice: alloy
    default-model: tts-1-hd

# 伺服器配置
server:
  port: 8080
  servlet:
    context-path: /api

# 日誌配置
logging:
  level:
    org.springframework.ai: DEBUG
    com.example: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

---

## 5.5.4 基礎語音生成功能

### 語音生成控制器

```java
package com.example.controller;

import com.example.dto.VoiceRequest;
import com.example.dto.VoiceResponse;
import com.example.service.VoiceGenerationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.nio.charset.StandardCharsets;
import java.util.List;

@RestController
@RequestMapping("/voice")
@RequiredArgsConstructor
@Slf4j
public class VoiceController {
    
    private final VoiceGenerationService voiceService;
    
    /**
     * 基礎語音生成
     * @param text 要轉換的文字
     * @param voice 聲音選擇（可選）
     * @param speed 語速（可選）
     * @return 音訊檔案
     */
    @GetMapping("/generate")
    public ResponseEntity<Resource> generateVoice(
            @RequestParam String text,
            @RequestParam(value = "voice", defaultValue = "alloy") String voice,
            @RequestParam(value = "speed", defaultValue = "1.0") Float speed) {
        
        try {
            // 驗證文字長度
            if (text.length() > 4096) {
                throw new IllegalArgumentException("文字長度不能超過 4096 字元");
            }
            
            log.info("開始生成語音：文字長度={}, 聲音={}, 語速={}", 
                    text.length(), voice, speed);
            
            // 生成語音
            byte[] audioData = voiceService.generateVoice(text, voice, speed);
            
            // 建立回應
            ByteArrayResource resource = new ByteArrayResource(audioData);
            
            String fileName = String.format("配音_%s_%s.mp3", 
                    voice, 
                    System.currentTimeMillis());
            
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION,
                            "attachment; filename=\"" + fileName + "\"")
                    .contentType(MediaType.parseMediaType("audio/mpeg"))
                    .contentLength(audioData.length)
                    .body(resource);
            
        } catch (Exception e) {
            log.error("語音生成失敗：{}", text, e);
            
            String errorMessage = "語音生成失敗: " + e.getMessage();
            ByteArrayResource errorResource = new ByteArrayResource(
                    errorMessage.getBytes(StandardCharsets.UTF_8)
            );
            
            return ResponseEntity.badRequest()
                    .contentType(MediaType.TEXT_PLAIN)
                    .body(errorResource);
        }
    }
    
    /**
     * 進階語音生成（JSON API）
     * @param request 語音生成請求
     * @return JSON 格式回應
     */
    @PostMapping("/generate-advanced")
    public ResponseEntity<VoiceResponse> generateAdvancedVoice(
            @RequestBody @Valid VoiceRequest request) {
        
        try {
            log.info("進階語音生成請求：{}", request);
            
            VoiceResponse response = voiceService.generateAdvancedVoice(request);
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("進階語音生成失敗", e);
            
            VoiceResponse errorResponse = VoiceResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .text(request.getText())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 批次語音生成
     * @param requests 多個語音生成請求
     * @return 批次處理結果
     */
    @PostMapping("/batch-generate")
    public ResponseEntity<List<VoiceResponse>> batchGenerateVoice(
            @RequestBody @Valid List<VoiceRequest> requests) {
        
        try {
            log.info("批次語音生成：{} 個請求", requests.size());
            
            List<VoiceResponse> responses = voiceService.batchGenerateVoice(requests);
            
            return ResponseEntity.ok(responses);
            
        } catch (Exception e) {
            log.error("批次語音生成失敗", e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 獲取可用聲音列表
     * @return 聲音選項
     */
    @GetMapping("/voices")
    public ResponseEntity<List<VoiceOption>> getAvailableVoices() {
        List<VoiceOption> voices = voiceService.getAvailableVoices();
        return ResponseEntity.ok(voices);
    }
    
    /**
     * 語音預覽（短文字）
     * @param voice 聲音選擇
     * @return 預覽音訊
     */
    @GetMapping("/preview/{voice}")
    public ResponseEntity<Resource> previewVoice(@PathVariable String voice) {
        try {
            String previewText = "您好，這是 " + voice + " 聲音的預覽。";
            byte[] audioData = voiceService.generateVoice(previewText, voice, 1.0f);
            
            ByteArrayResource resource = new ByteArrayResource(audioData);
            
            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType("audio/mpeg"))
                    .body(resource);
            
        } catch (Exception e) {
            log.error("語音預覽失敗：{}", voice, e);
            return ResponseEntity.badRequest().build();
        }
    }
}
```

### 語音生成服務

```java
package com.example.service;

import com.example.dto.VoiceRequest;
import com.example.dto.VoiceResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.audio.speech.SpeechModel;
import org.springframework.ai.audio.speech.SpeechPrompt;
import org.springframework.ai.audio.speech.SpeechResponse;
import org.springframework.ai.openai.OpenAiAudioSpeechOptions;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class VoiceGenerationService {
    
    private final SpeechModel speechModel;
    private final VoiceStorageService storageService;
    
    /**
     * 基礎語音生成
     * @param text 文字內容
     * @param voice 聲音選擇
     * @param speed 語速
     * @return 音訊資料
     */
    public byte[] generateVoice(String text, String voice, Float speed) {
        try {
            // 建立語音選項
            OpenAiAudioSpeechOptions options = OpenAiAudioSpeechOptions.builder()
                    .model("tts-1-hd")
                    .voice(OpenAiAudioApi.SpeechRequest.Voice.valueOf(voice.toUpperCase()))
                    .responseFormat(OpenAiAudioApi.SpeechRequest.AudioResponseFormat.MP3)
                    .speed(speed)
                    .build();
            
            // 建立語音請求
            SpeechPrompt speechPrompt = new SpeechPrompt(text, options);
            
            // 執行語音生成
            SpeechResponse response = speechModel.call(speechPrompt);
            
            return response.getResult().getOutput();
            
        } catch (Exception e) {
            log.error("語音生成失敗：{}", text, e);
            throw new RuntimeException("語音生成失敗：" + e.getMessage(), e);
        }
    }
    
    /**
     * 進階語音生成
     * @param request 語音生成請求
     * @return 語音回應
     */
    public VoiceResponse generateAdvancedVoice(VoiceRequest request) {
        try {
            // 建立進階語音選項
            OpenAiAudioSpeechOptions options = OpenAiAudioSpeechOptions.builder()
                    .model(request.getModel())
                    .voice(OpenAiAudioApi.SpeechRequest.Voice.valueOf(
                            request.getVoice().toUpperCase()))
                    .responseFormat(OpenAiAudioApi.SpeechRequest.AudioResponseFormat
                            .valueOf(request.getFormat().toUpperCase()))
                    .speed(request.getSpeed())
                    .build();
            
            SpeechPrompt speechPrompt = new SpeechPrompt(request.getText(), options);
            SpeechResponse response = speechModel.call(speechPrompt);
            
            byte[] audioData = response.getResult().getOutput();
            
            // 儲存音訊檔案（如果需要）
            String filePath = null;
            if (request.isSaveFile()) {
                filePath = storageService.saveAudioFile(
                        audioData, 
                        request.getText(), 
                        request.getVoice(), 
                        request.getFormat()
                );
            }
            
            return VoiceResponse.builder()
                    .success(true)
                    .text(request.getText())
                    .voice(request.getVoice())
                    .model(request.getModel())
                    .format(request.getFormat())
                    .speed(request.getSpeed())
                    .audioData(audioData)
                    .filePath(filePath)
                    .fileSize((long) audioData.length)
                    .duration(estimateAudioDuration(request.getText(), request.getSpeed()))
                    .timestamp(LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("進階語音生成失敗：{}", request.getText(), e);
            throw new RuntimeException("進階語音生成失敗：" + e.getMessage(), e);
        }
    }
    
    /**
     * 批次語音生成
     * @param requests 請求列表
     * @return 批次處理結果
     */
    public List<VoiceResponse> batchGenerateVoice(List<VoiceRequest> requests) {
        log.info("開始批次處理 {} 個語音生成請求", requests.size());
        
        List<CompletableFuture<VoiceResponse>> futures = requests.stream()
                .map(request -> CompletableFuture.supplyAsync(() -> {
                    try {
                        return generateAdvancedVoice(request);
                    } catch (Exception e) {
                        log.error("批次處理失敗：{}", request.getText(), e);
                        return VoiceResponse.builder()
                                .success(false)
                                .text(request.getText())
                                .error(e.getMessage())
                                .build();
                    }
                }))
                .collect(Collectors.toList());
        
        // 等待所有任務完成
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(
                futures.toArray(new CompletableFuture[0])
        );
        
        return allFutures.thenApply(v -> 
                futures.stream()
                        .map(CompletableFuture::join)
                        .collect(Collectors.toList())
        ).join();
    }
    
    /**
     * 獲取可用聲音選項
     */
    public List<VoiceOption> getAvailableVoices() {
        return List.of(
            new VoiceOption("alloy", "中性、清晰", "新聞播報、教學"),
            new VoiceOption("echo", "男性、沉穩", "商業簡報、紀錄片"),
            new VoiceOption("fable", "女性、溫暖", "故事講述、客服"),
            new VoiceOption("onyx", "男性、深沉", "廣告配音、旁白"),
            new VoiceOption("nova", "女性、活潑", "廣告、娛樂內容"),
            new VoiceOption("shimmer", "女性、柔和", "冥想、放鬆內容")
        );
    }
    
    /**
     * 估算音訊時長（秒）
     */
    private Double estimateAudioDuration(String text, Float speed) {
        // 粗略估算：平均每分鐘 150 個字元
        double baseMinutes = text.length() / 150.0;
        return (baseMinutes * 60) / speed;
    }
}
```

---

## 5.5.5 請求和回應 DTO

### 語音請求 DTO

```java
package com.example.dto;

import lombok.Data;
import javax.validation.constraints.*;

@Data
public class VoiceRequest {
    
    @NotBlank(message = "文字內容不能為空")
    @Size(max = 4096, message = "文字長度不能超過 4096 字元")
    private String text;
    
    @Pattern(regexp = "^(alloy|echo|fable|onyx|nova|shimmer)$", 
             message = "聲音必須是 alloy、echo、fable、onyx、nova 或 shimmer")
    private String voice = "alloy";
    
    @Pattern(regexp = "^(tts-1|tts-1-hd)$", 
             message = "模型必須是 tts-1 或 tts-1-hd")
    private String model = "tts-1-hd";
    
    @Pattern(regexp = "^(mp3|opus|aac|flac)$", 
             message = "格式必須是 mp3、opus、aac 或 flac")
    private String format = "mp3";
    
    @DecimalMin(value = "0.25", message = "語速不能小於 0.25")
    @DecimalMax(value = "4.0", message = "語速不能大於 4.0")
    private Float speed = 1.0f;
    
    private boolean saveFile = false;
    
    private String category;  // 分類標籤
    private String description;  // 描述
}
```

### 語音回應 DTO

```java
package com.example.dto;

import lombok.Builder;
import lombok.Data;
import java.time.LocalDateTime;

@Data
@Builder
public class VoiceResponse {
    
    private boolean success;
    private String text;
    private String voice;
    private String model;
    private String format;
    private Float speed;
    private byte[] audioData;
    private String filePath;
    private Long fileSize;
    private Double duration;  // 音訊時長（秒）
    private String error;
    private LocalDateTime timestamp;
    
    // 統計資訊
    private Integer characterCount;
    private String audioUrl;  // 如果上傳到雲端儲存
    
    /**
     * 建立成功回應
     */
    public static VoiceResponse success(String text, String voice, byte[] audioData) {
        return VoiceResponse.builder()
                .success(true)
                .text(text)
                .voice(voice)
                .audioData(audioData)
                .fileSize((long) audioData.length)
                .characterCount(text.length())
                .timestamp(LocalDateTime.now())
                .build();
    }
    
    /**
     * 建立錯誤回應
     */
    public static VoiceResponse error(String text, String error) {
        return VoiceResponse.builder()
                .success(false)
                .text(text)
                .error(error)
                .timestamp(LocalDateTime.now())
                .build();
    }
}
```

### 聲音選項 DTO

```java
package com.example.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class VoiceOption {
    private String name;
    private String description;
    private String suitableFor;
    private String gender;
    private String style;
    
    public VoiceOption(String name, String description, String suitableFor) {
        this.name = name;
        this.description = description;
        this.suitableFor = suitableFor;
        
        // 根據聲音名稱設定性別和風格
        switch (name) {
            case "alloy" -> {
                this.gender = "中性";
                this.style = "清晰";
            }
            case "echo", "onyx" -> {
                this.gender = "男性";
                this.style = name.equals("echo") ? "沉穩" : "深沉";
            }
            case "fable", "nova", "shimmer" -> {
                this.gender = "女性";
                this.style = switch (name) {
                    case "fable" -> "溫暖";
                    case "nova" -> "活潑";
                    case "shimmer" -> "柔和";
                    default -> "自然";
                };
            }
        }
    }
}
```

---

## 5.5.6 進階功能實現

### 語音儲存服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class VoiceStorageService {
    
    @Value("${app.voice.output-directory:./generated-voices}")
    private String outputDirectory;
    
    /**
     * 儲存音訊檔案
     * @param audioData 音訊資料
     * @param text 原始文字
     * @param voice 聲音類型
     * @param format 音訊格式
     * @return 檔案路徑
     */
    public String saveAudioFile(byte[] audioData, String text, String voice, String format) {
        try {
            // 建立輸出目錄
            Path outputPath = Paths.get(outputDirectory);
            if (!Files.exists(outputPath)) {
                Files.createDirectories(outputPath);
            }
            
            // 生成檔案名稱
            String fileName = generateFileName(text, voice, format);
            Path filePath = outputPath.resolve(fileName);
            
            // 寫入檔案
            Files.write(filePath, audioData);
            
            log.info("音訊檔案已儲存：{}", filePath.toString());
            return filePath.toString();
            
        } catch (IOException e) {
            log.error("音訊檔案儲存失敗", e);
            throw new RuntimeException("音訊檔案儲存失敗：" + e.getMessage());
        }
    }
    
    /**
     * 生成檔案名稱
     */
    private String generateFileName(String text, String voice, String format) {
        String timestamp = LocalDateTime.now().format(
            DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")
        );
        String uuid = UUID.randomUUID().toString().substring(0, 8);
        String sanitizedText = sanitizeText(text);
        
        return String.format("%s_%s_%s_%s.%s", 
                timestamp, voice, uuid, sanitizedText, format);
    }
    
    /**
     * 清理文字作為檔案名稱
     */
    private String sanitizeText(String text) {
        return text.replaceAll("[^a-zA-Z0-9\u4e00-\u9fa5]", "_")
                  .substring(0, Math.min(text.length(), 20));
    }
    
    /**
     * 批次儲存音訊檔案
     */
    public List<String> batchSaveAudioFiles(List<VoiceResponse> responses) {
        return responses.stream()
                .filter(VoiceResponse::isSuccess)
                .filter(response -> response.getAudioData() != null)
                .map(response -> saveAudioFile(
                        response.getAudioData(),
                        response.getText(),
                        response.getVoice(),
                        response.getFormat()
                ))
                .collect(Collectors.toList());
    }
}
```

### 語音品質優化服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.regex.Pattern;

@Service
@RequiredArgsConstructor
@Slf4j
public class VoiceOptimizationService {
    
    /**
     * 優化文字內容以提升語音品質
     * @param text 原始文字
     * @param voice 聲音類型
     * @return 優化後的文字
     */
    public String optimizeTextForSpeech(String text, String voice) {
        String optimized = text;
        
        // 處理數字
        optimized = processNumbers(optimized);
        
        // 處理縮寫
        optimized = processAbbreviations(optimized);
        
        // 處理標點符號
        optimized = processPunctuation(optimized);
        
        // 處理語音停頓
        optimized = addSpeechPauses(optimized);
        
        // 根據聲音類型調整
        optimized = adjustForVoiceType(optimized, voice);
        
        return optimized;
    }
    
    /**
     * 處理數字轉換
     */
    private String processNumbers(String text) {
        // 將阿拉伯數字轉換為中文數字（提升中文語音品質）
        text = text.replaceAll("\\b(\\d{4})\\b", "$1年");
        text = text.replaceAll("\\b(\\d{1,2})月(\\d{1,2})日\\b", "$1月$2日");
        text = text.replaceAll("\\b(\\d+)%\\b", "百分之$1");
        
        return text;
    }
    
    /**
     * 處理縮寫
     */
    private String processAbbreviations(String text) {
        // 常見縮寫展開
        text = text.replaceAll("\\bAI\\b", "人工智慧");
        text = text.replaceAll("\\bAPI\\b", "應用程式介面");
        text = text.replaceAll("\\bURL\\b", "網址");
        text = text.replaceAll("\\bHTTP\\b", "超文本傳輸協定");
        
        return text;
    }
    
    /**
     * 處理標點符號
     */
    private String processPunctuation(String text) {
        // 在句號後添加較長停頓
        text = text.replaceAll("。", "。 ");
        
        // 在逗號後添加短停頓
        text = text.replaceAll("，", "， ");
        
        // 在問號和驚嘆號後添加停頓
        text = text.replaceAll("[？！]", "$0 ");
        
        return text;
    }
    
    /**
     * 添加語音停頓
     */
    private String addSpeechPauses(String text) {
        // 在長句中間添加適當停頓
        if (text.length() > 100) {
            text = text.replaceAll("([，。！？])(?=.{30,})", "$1 ");
        }
        
        return text;
    }
    
    /**
     * 根據聲音類型調整
     */
    private String adjustForVoiceType(String text, String voice) {
        switch (voice) {
            case "nova", "shimmer" -> {
                // 女性聲音，語調可以更溫和
                text = text.replaceAll("！", "。");
            }
            case "echo", "onyx" -> {
                // 男性聲音，可以保持較強語調
                // 保持原樣
            }
            case "alloy" -> {
                // 中性聲音，平衡處理
                text = text.replaceAll("！{2,}", "！");
            }
        }
        
        return text;
    }
    
    /**
     * 驗證文字適合語音轉換
     * @param text 文字內容
     * @return 品質評分（0-100）
     */
    public int evaluateTextQuality(String text) {
        int score = 100;
        
        // 檢查特殊字元
        if (Pattern.compile("[#@$%^&*()\\[\\]{}|\\\\]").matcher(text).find()) {
            score -= 20;  // 包含特殊字元
        }
        
        // 檢查數字比例
        long digitCount = text.chars().filter(Character::isDigit).count();
        double digitRatio = (double) digitCount / text.length();
        if (digitRatio > 0.3) {
            score -= 15;  // 數字太多
        }
        
        // 檢查英文比例
        long englishCount = text.chars().filter(ch -> (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')).count();
        double englishRatio = (double) englishCount / text.length();
        if (englishRatio > 0.5) {
            score -= 10;  // 英文太多（中文語音）
        }
        
        // 檢查句子長度
        String[] sentences = text.split("[。！？]");
        for (String sentence : sentences) {
            if (sentence.length() > 200) {
                score -= 5;  // 句子太長
            }
        }
        
        return Math.max(0, score);
    }
}
```

---

## 📝 本章重點回顧

1. **文字轉語音技術**：掌握了 TTS 技術的工作原理和 AI 配音優勢
2. **多聲音支援**：實現了 6 種不同風格的 AI 聲音選擇
3. **企業級功能**：建立了完整的語音生成、儲存和管理系統
4. **品質優化技術**：掌握了文字預處理和語音參數調整方法
5. **批次處理能力**：支援大量文字的並行語音生成

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **基礎語音生成** | ⭐⭐⭐ | 低 | 所有配音應用 |
| **多聲音選擇** | ⭐⭐⭐ | 低 | 個性化配音 |
| **批次處理** | ⭐⭐ | 中 | 大量內容生成 |
| **品質優化** | ⭐⭐ | 高 | 專業配音製作 |
| **檔案管理** | ⭐⭐ | 中 | 企業級部署 |
| **文字預處理** | ⭐ | 中 | 語音品質提升 |

### 成本效益分析

**OpenAI TTS 定價**：
- 💰 **成本**：$0.015 per 1K characters
- ⏱️ **速度**：即時生成，無等待時間
- 🎯 **品質**：接近人聲的自然度
- 📊 **性價比**：相比專業配音節省 95%+ 成本

### 最佳實踐建議

1. **文字預處理**：優化數字、縮寫和標點符號
2. **聲音選擇**：根據內容類型選擇合適的聲音
3. **語速調整**：根據聽眾和場景調整語速
4. **批次處理**：大量內容使用非同步處理提升效率
5. **品質控制**：實施文字品質評估和語音後處理

### 下一步學習方向

在下一章中，我們將學習 Function Calling 技術，探索如何讓 AI 調用外部工具和服務，實現更強大的功能整合。

---

**參考資料：**
- [Spring AI Audio Speech Documentation](https://docs.spring.io/spring-ai/reference/api/audio.html)
- [OpenAI Text-to-Speech API](https://platform.openai.com/docs/guides/text-to-speech)
- [Audio Format Specifications](https://en.wikipedia.org/wiki/Audio_file_format)
- [Speech Synthesis Markup Language (SSML)](https://www.w3.org/TR/speech-synthesis/)


\newpage

## 5.6 Function Calling (上) - 請支援 AI


> **本章重點**：學習 Spring AI 的 Tool Calling 技術，讓 AI 能夠調用外部工具和服務，突破 AI 的固有限制，實現更強大的功能整合和即時資料存取。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 Tool Calling 原理**：掌握 AI 工具調用的核心概念和工作流程
- 🎯 **識別 AI 的限制**：了解 LLM 的弱點和 Tool Calling 的解決方案
- 🎯 **實現基礎工具調用**：建立第一個 Tool Calling 功能
- 🎯 **設計工具介面**：掌握 @Tool 註解的使用和最佳實踐
- 🎯 **整合 ChatClient API**：使用最新的 Spring AI 1.1 API 進行工具整合

---

## 5.6.1 AI 的弱點與挑戰

### AI 不是萬能的

![AI 的弱點](https://ithelp.ithome.com.tw/upload/images/20240811/20161290wKqFOXe5Jy.jpg)

雖然 AI 很神奇，不過它不是萬能的，遇到以下幾種問題 AI 就沒轍：

### LLM 的四大限制

**1. 記憶限制**
- 🧠 **無狀態推論**：LLM 是一種無狀態推論模型
- 💭 **偽記憶現象**：雖然跟 ChatGPT 對話似乎能記住對話內容，實際上它是根據你送出的資料來推論結果
- 🔄 **上下文依賴**：每次對話都需要重新提供完整的上下文資訊
- 📝 **會話管理**：需要外部系統來管理對話歷史和狀態

**2. 即時資料限制**
- ⏰ **訓練資料截止點**：LLM 預訓練資料會在一個時間點後關閉
- 📰 **無法獲取最新資訊**：之後所發生的事情 AI 就無法回答
- 🏅 **實例說明**：問 AI「2024 巴黎奧運中華隊得了幾面金牌」，AI 不是不知道就是隨便編一個答案
- 🔍 **解決方案**：需要透過 API 調用獲取即時資料

**3. 數學運算限制**
- 🔢 **語言模型本質**：LLM 顧名思義就是一種語言模型
- 📚 **文科生現象**：就跟文科生數理普遍不好一樣
- ➕ **基礎運算錯誤**：有些簡單的加減法甚至會算錯
- ⚠️ **不保證準確性**：就連 ChatGPT 也不敢跟你保證算出的答案一定是對的

**4. 企業內部資料限制**
- 🏢 **私有資料無法訓練**：預訓練只能取得公開資料
- 🔒 **企業資訊保密**：企業不可能公開自己的內部資訊
- 🛠️ **Fine-tuning 成本高**：常見作法是透過 fine tuning，但耗時費力
- 💡 **RAG 解決方案**：透過檢索增強生成技術整合企業資料

### Tool Calling 的解決方案

| AI 限制 | Tool Calling 解決方案 | 實現方式 |
|---------|----------------------|----------|
| **記憶限制** | 外部記憶系統 | 資料庫、快取系統 |
| **即時資料** | API 調用 | REST API、WebSocket |
| **數學運算** | 計算工具 | 計算器、數學庫 |
| **企業資料** | 資料庫查詢 | SQL、NoSQL、搜尋引擎 |

---

## 5.6.2 Tool Calling 核心概念

### 什麼是 Tool Calling？

**Tool Calling**（也稱為 Function Calling）就像是 AI 的外掛系統，除了能透過 Tool 取得即時資料外，一些複雜的運算或是需要分析的部分，也可以透過 Tool 來呼叫外部函式取得結果。

### Tool Calling 調用流程

![Tool Calling 流程](https://ithelp.ithome.com.tw/upload/images/20240811/20161290o7GvM9RvQN.jpg)

**完整調用流程**：

```mermaid
sequenceDiagram
    participant User as 使用者
    participant Client as ChatClient
    participant AI as AI 模型
    participant Tool as 外部工具
    
    User->>Client: 1. 發送提示詞 + 註冊工具
    Client->>AI: 2. 傳送提示詞和工具描述
    AI->>AI: 3. 分析是否需要調用工具
    AI->>Client: 4. 返回工具調用請求
    Client->>Tool: 5. 執行工具函式
    Tool->>Client: 6. 返回工具執行結果
    Client->>AI: 7. 將結果傳回 AI
    AI->>Client: 8. 生成最終回應
    Client->>User: 9. 返回完整答案
```

**各步驟詳細說明**：

1. **註冊工具**：發送提示詞時告訴 AI 有哪些 Tool 可以調用
```java
return ChatClient.create(chatModel)
    .prompt(prompt)
    .tools(new DateTimeTools())  // 註冊可用工具
    .call()
    .content();
```

2. **工具匹配**：AI 查看是否有與提示詞相關的 Tool 描述
```java
@Tool(description = "Get the current date and time")
String getCurrentDateTime() {
    return LocalDateTime.now().toString();
}
```

3. **執行工具**：找到匹配的 Tool 後執行並調用其資訊
4. **結果整合**：將 Tool 回傳的資料以內部訊息格式傳送給 AI
5. **生成回應**：AI 根據提示詞以及 Tool 回傳結果生成最終答案

### Spring AI 1.1 的重大更新

**新舊 API 對比**：

| 比較項目 | 舊版 Function Calling | 新版 Tool Calling |
|----------|----------------------|-------------------|
| **API 名稱** | Function Calling | Tool Calling |
| **註解** | `@Function` | `@Tool` |
| **註冊方式** | 複雜的配置 | 直接傳入實例 |
| **類型安全** | 較弱 | 更強 |
| **易用性** | 複雜 | 簡化 |
| **效能** | 一般 | 優化 |

**遷移建議**：
- ✅ **新專案**：直接使用 Tool Calling API
- 🔄 **舊專案**：逐步遷移到新 API
- 📚 **學習重點**：掌握 @Tool 註解和 ChatClient 整合

---

## 5.6.3 第一個 Tool Calling 實現

### 專案建立與配置

**Maven 依賴**：

```xml
<!-- 使用 Spring AI BOM 管理版本 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-bom</artifactId>
            <version>1.0.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <!-- Spring AI OpenAI Starter -->
    <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
        </dependency>
    
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Lombok -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

**應用程式配置**：

```yaml
# application.yml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      chat:
        options:
          model: gpt-4o-mini  # 支援 Tool Calling 的模型
          temperature: 0.1

# 日誌配置
logging:
  level:
    org.springframework.ai: DEBUG
```

### 基礎工具類別實現

**程式目標**：詢問目前時間，返回真實的日期及時間

**步驟 1：撰寫 Tool 類別**

```java
package com.example.tools;

import org.springframework.ai.tool.annotation.Tool;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.TimeZone;

/**
 * 日期時間工具類別
 * 提供當前時間查詢功能
 */
@Component
public class DateTimeTools {
    
    /**
     * 獲取當前日期和時間
     * @return 格式化的當前日期時間字串
     */
    @Tool(description = "Get the current date and time in Taiwan (Asia/Taipei timezone)")
    public String getCurrentDateTime() {
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss");
        
        return String.format("當前時間：%s（台灣時間）", now.format(formatter));
    }
    
    /**
     * 獲取指定格式的當前時間
     * @param format 時間格式（如：yyyy-MM-dd HH:mm:ss）
     * @return 格式化的時間字串
     */
    @Tool(description = "Get current time in specified format")
    public String getCurrentTimeWithFormat(String format) {
        try {
            LocalDateTime now = LocalDateTime.now();
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(format);
            return now.format(formatter);
        } catch (Exception e) {
            return "時間格式錯誤，請使用正確的格式，例如：yyyy-MM-dd HH:mm:ss";
        }
    }
    
    /**
     * 獲取當前時間戳
     * @return Unix 時間戳
     */
    @Tool(description = "Get current Unix timestamp")
    public String getCurrentTimestamp() {
        long timestamp = System.currentTimeMillis() / 1000;
        return String.format("當前時間戳：%d", timestamp);
    }
    
    /**
     * 獲取當前是星期幾
     * @return 星期資訊
     */
    @Tool(description = "Get current day of week")
    public String getCurrentDayOfWeek() {
        LocalDateTime now = LocalDateTime.now();
        String[] weekDays = {"星期一", "星期二", "星期三", "星期四", "星期五", "星期六", "星期日"};
        int dayOfWeek = now.getDayOfWeek().getValue() - 1;
        
        return String.format("今天是%s", weekDays[dayOfWeek]);
    }
}
```

**步驟 2：建立 ChatClient 控制器**

```java
package com.example.controller;

import com.example.tools.DateTimeTools;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/tool-calling")
@RequiredArgsConstructor
@Slf4j
public class ToolCallingController {
    
    private final ChatModel chatModel;
    private final DateTimeTools dateTimeTools;
    
    /**
     * 基礎 Tool Calling 示例
     * @param prompt 使用者提示詞
     * @return AI 回應（可能包含工具調用結果）
     */
    @GetMapping("/basic")
    public String basicToolCalling(@RequestParam String prompt) {
        try {
            log.info("收到 Tool Calling 請求：{}", prompt);
            
            // 使用新的 ChatClient API 整合工具
            String response = ChatClient.create(chatModel)
                    .prompt(prompt)
                    .tools(dateTimeTools)  // 直接傳入 Tool 實例
                    .call()
                    .content();
            
            log.info("Tool Calling 回應：{}", response);
            return response;
            
        } catch (Exception e) {
            log.error("Tool Calling 執行失敗", e);
            return "Tool Calling 執行失敗：" + e.getMessage();
        }
    }
    
    /**
     * 多工具整合示例
     * @param prompt 使用者提示詞
     * @return AI 回應
     */
    @GetMapping("/multi-tools")
    public String multiToolCalling(@RequestParam String prompt) {
        try {
            // 可以同時註冊多個工具
            String response = ChatClient.create(chatModel)
                    .prompt(prompt)
                    .tools(dateTimeTools)  // 可以添加更多工具
                    .call()
                    .content();
            
            return response;
            
        } catch (Exception e) {
            log.error("多工具調用失敗", e);
            return "多工具調用失敗：" + e.getMessage();
        }
    }
    
    /**
     * 工具調用詳細資訊
     * @param prompt 使用者提示詞
     * @return 包含調用詳情的回應
     */
    @PostMapping("/detailed")
    public ToolCallingResponse detailedToolCalling(@RequestBody ToolCallingRequest request) {
        try {
            long startTime = System.currentTimeMillis();
            
            String response = ChatClient.create(chatModel)
                    .prompt(request.getPrompt())
                    .tools(dateTimeTools)
                    .call()
                    .content();
            
            long endTime = System.currentTimeMillis();
            
            return ToolCallingResponse.builder()
                    .success(true)
                    .prompt(request.getPrompt())
                    .response(response)
                    .executionTime(endTime - startTime)
                    .toolsUsed(List.of("DateTimeTools"))
                    .timestamp(LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("詳細工具調用失敗", e);
            
            return ToolCallingResponse.builder()
                    .success(false)
                    .prompt(request.getPrompt())
                    .error(e.getMessage())
                    .timestamp(LocalDateTime.now())
                    .build();
        }
    }
}
```

### 請求和回應 DTO

```java
package com.example.dto;

import lombok.Data;
import lombok.Builder;
import java.time.LocalDateTime;
import java.util.List;

@Data
public class ToolCallingRequest {
    private String prompt;
    private List<String> enabledTools;
    private boolean includeDetails;
}

@Data
@Builder
public class ToolCallingResponse {
    private boolean success;
    private String prompt;
    private String response;
    private Long executionTime;
    private List<String> toolsUsed;
    private String error;
    private LocalDateTime timestamp;
}
```

---

## 5.6.4 Tool 設計最佳實踐

### @Tool 註解詳解

**基本語法**：

```java
@Tool(description = "工具功能描述")
public String toolMethod(參數列表) {
    // 工具實現邏輯
    return "結果";
}
```

**重要原則**：

1. **描述要清晰**：AI 根據描述決定是否調用工具
2. **參數要明確**：支援基本類型和簡單物件
3. **返回值要有意義**：AI 會將返回值整合到回應中
4. **異常要處理**：避免工具調用失敗影響整體流程

### 進階工具設計

**帶參數的工具**：

```java
@Component
public class CalculatorTools {
    
    /**
     * 基本數學運算
     * @param operation 運算類型（add, subtract, multiply, divide）
     * @param a 第一個數字
     * @param b 第二個數字
     * @return 運算結果
     */
    @Tool(description = "Perform basic mathematical operations: add, subtract, multiply, divide")
    public String calculate(String operation, double a, double b) {
        try {
            double result = switch (operation.toLowerCase()) {
                case "add" -> a + b;
                case "subtract" -> a - b;
                case "multiply" -> a * b;
                case "divide" -> {
                    if (b == 0) {
                        yield Double.NaN;
                    }
                    yield a / b;
                }
                default -> throw new IllegalArgumentException("不支援的運算：" + operation);
            };
            
            if (Double.isNaN(result)) {
                return "錯誤：除數不能為零";
            }
            
            return String.format("%.2f %s %.2f = %.2f", a, getOperationSymbol(operation), b, result);
            
        } catch (Exception e) {
            return "計算錯誤：" + e.getMessage();
        }
    }
    
    /**
     * 複雜數學運算
     * @param expression 數學表達式（如："2 + 3 * 4"）
     * @return 計算結果
     */
    @Tool(description = "Evaluate complex mathematical expressions")
    public String evaluateExpression(String expression) {
        try {
            // 這裡可以整合數學表達式解析器
            // 為了簡化，這裡只做基本示例
            return "表達式 '" + expression + "' 的計算功能正在開發中";
        } catch (Exception e) {
            return "表達式計算錯誤：" + e.getMessage();
        }
    }
    
    private String getOperationSymbol(String operation) {
        return switch (operation.toLowerCase()) {
            case "add" -> "+";
            case "subtract" -> "-";
            case "multiply" -> "×";
            case "divide" -> "÷";
            default -> "?";
        };
    }
}
```

**物件參數工具**：

```java
@Component
public class WeatherTools {
    
    /**
     * 查詢天氣資訊
     * @param location 地點資訊
     * @return 天氣資訊
     */
    @Tool(description = "Get weather information for a specific location")
    public String getWeather(WeatherRequest location) {
        try {
            // 模擬天氣 API 調用
            return String.format("地點：%s\n天氣：%s\n溫度：%d°C\n濕度：%d%%",
                    location.getCity(),
                    "晴天",
                    25,
                    60);
        } catch (Exception e) {
            return "天氣查詢失敗：" + e.getMessage();
        }
    }
    
    @Data
    public static class WeatherRequest {
        private String city;
        private String country;
        private String unit = "celsius";  // celsius, fahrenheit
    }
}
```

### 工具組合和管理

**工具管理服務**：

```java
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@Service
@RequiredArgsConstructor
public class ToolManagementService {
    
    private final DateTimeTools dateTimeTools;
    private final CalculatorTools calculatorTools;
    private final WeatherTools weatherTools;
    
    /**
     * 根據場景獲取工具組合
     * @param scenario 應用場景
     * @return 工具列表
     */
    public List<Object> getToolsForScenario(String scenario) {
        return switch (scenario.toLowerCase()) {
            case "basic" -> List.of(dateTimeTools);
            case "math" -> List.of(dateTimeTools, calculatorTools);
            case "weather" -> List.of(dateTimeTools, weatherTools);
            case "all" -> List.of(dateTimeTools, calculatorTools, weatherTools);
            default -> List.of(dateTimeTools);
        };
    }
    
    /**
     * 智能工具選擇
     * @param prompt 使用者提示詞
     * @return 推薦的工具列表
     */
    public List<Object> selectToolsForPrompt(String prompt) {
        List<Object> selectedTools = new ArrayList<>();
        
        // 基於關鍵字選擇工具
        if (containsTimeKeywords(prompt)) {
            selectedTools.add(dateTimeTools);
        }
        
        if (containsMathKeywords(prompt)) {
            selectedTools.add(calculatorTools);
        }
        
        if (containsWeatherKeywords(prompt)) {
            selectedTools.add(weatherTools);
        }
        
        // 如果沒有匹配的工具，返回基礎工具
        if (selectedTools.isEmpty()) {
            selectedTools.add(dateTimeTools);
        }
        
        return selectedTools;
    }
    
    private boolean containsTimeKeywords(String prompt) {
        String[] timeKeywords = {"時間", "日期", "現在", "當前", "今天", "time", "date", "now"};
        return Arrays.stream(timeKeywords)
                .anyMatch(keyword -> prompt.toLowerCase().contains(keyword.toLowerCase()));
    }
    
    private boolean containsMathKeywords(String prompt) {
        String[] mathKeywords = {"計算", "加", "減", "乘", "除", "數學", "運算", "calculate", "math"};
        return Arrays.stream(mathKeywords)
                .anyMatch(keyword -> prompt.toLowerCase().contains(keyword.toLowerCase()));
    }
    
    private boolean containsWeatherKeywords(String prompt) {
        String[] weatherKeywords = {"天氣", "氣溫", "下雨", "晴天", "weather", "temperature"};
        return Arrays.stream(weatherKeywords)
                .anyMatch(keyword -> prompt.toLowerCase().contains(keyword.toLowerCase()));
    }
}
```

---

## 5.6.5 測試和除錯

### 基本測試範例

**測試用例**：

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class ToolCallingTest {
    
    @Autowired
    private ToolCallingController controller;
    
    @Test
    @Order(1)
    void testBasicTimeTool() {
        String prompt = "現在幾點了？";
        String response = controller.basicToolCalling(prompt);
        
        assertThat(response).isNotNull();
        assertThat(response).contains("時間");
        System.out.println("時間查詢回應：" + response);
    }
    
    @Test
    @Order(2)
    void testCalculationTool() {
        String prompt = "請幫我計算 15 + 27";
        String response = controller.basicToolCalling(prompt);
        
        assertThat(response).isNotNull();
        assertThat(response).contains("42");
        System.out.println("計算回應：" + response);
    }
    
    @Test
    @Order(3)
    void testNoToolNeeded() {
        String prompt = "你好，請介紹一下自己";
        String response = controller.basicToolCalling(prompt);
        
        assertThat(response).isNotNull();
        System.out.println("一般對話回應：" + response);
    }
}
```

### 除錯技巧

**日誌配置**：

```yaml
logging:
  level:
    org.springframework.ai: DEBUG
    com.example: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
```

**除錯輸出**：

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatModel;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@Slf4j
public class DebugToolCallingController {
    
    @GetMapping("/debug")
    public Map<String, Object> debugToolCalling(@RequestParam String prompt) {
        Map<String, Object> debugInfo = new HashMap<>();
        
        try {
            long startTime = System.currentTimeMillis();
            
            // 記錄工具調用前的狀態
            log.debug("開始 Tool Calling，提示詞：{}", prompt);
            
            String response = ChatClient.create(chatModel)
                    .prompt(prompt)
                    .tools(dateTimeTools)
                    .call()
                    .content();
            
            long endTime = System.currentTimeMillis();
            
            // 收集除錯資訊
            debugInfo.put("prompt", prompt);
            debugInfo.put("response", response);
            debugInfo.put("executionTime", endTime - startTime);
            debugInfo.put("toolsRegistered", List.of("DateTimeTools"));
            debugInfo.put("timestamp", LocalDateTime.now());
            
            log.debug("Tool Calling 完成，耗時：{}ms", endTime - startTime);
            
        } catch (Exception e) {
            log.error("Tool Calling 除錯失敗", e);
            debugInfo.put("error", e.getMessage());
            debugInfo.put("stackTrace", Arrays.toString(e.getStackTrace()));
        }
        
        return debugInfo;
    }
}
```

---

## 📝 本章重點回顧

1. **AI 限制理解**：掌握了 LLM 在記憶、即時資料、數學運算和企業資料方面的限制
2. **Tool Calling 原理**：理解了工具調用的完整流程和核心概念
3. **Spring AI 1.1 新特性**：學會了使用最新的 @Tool 註解和 ChatClient API
4. **基礎工具實現**：建立了第一個可用的 Tool Calling 功能
5. **最佳實踐掌握**：了解了工具設計、管理和測試的最佳實踐

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **@Tool 註解** | ⭐⭐⭐ | 低 | 所有工具調用 |
| **ChatClient 整合** | ⭐⭐⭐ | 低 | AI 對話系統 |
| **參數處理** | ⭐⭐ | 中 | 複雜工具功能 |
| **工具組合** | ⭐⭐ | 中 | 多功能應用 |
| **錯誤處理** | ⭐⭐ | 中 | 生產環境 |
| **效能優化** | ⭐ | 高 | 高併發場景 |

### 常見問題和解決方案

**Q1：工具沒有被調用？**
- 檢查 @Tool 描述是否清晰
- 確認模型支援 Tool Calling（如 GPT-4o-mini）
- 驗證工具註冊是否正確

**Q2：工具調用失敗？**
- 檢查參數類型是否支援
- 確認異常處理是否完善
- 查看日誌輸出的錯誤資訊

**Q3：回應不包含工具結果？**
- 確認工具返回值有意義
- 檢查 AI 是否正確整合了工具結果
- 調整提示詞使其更明確

### 下一步學習方向

在下一章中，我們將學習更進階的 Function Calling 技術，包括企業資料整合、複雜工具鏈和實際業務場景應用。

---

**參考資料：**
- [Spring AI Tool Calling Documentation](https://docs.spring.io/spring-ai/reference/api/tools.html)
- [OpenAI Function Calling Guide](https://platform.openai.com/docs/guides/function-calling)
- [Spring AI 1.1 Migration Guide](https://docs.spring.io/spring-ai/reference/upgrade-notes.html)
- [Tool Calling Best Practices](https://docs.spring.io/spring-ai/reference/concepts.html#_function_calling)


\newpage

## 5.7 Function Calling (中) - 讓 AI 讀取企業資訊


> **本章重點**：學習如何讓 AI 透過 Tool Calling 存取企業內部資料，實現 AI 與企業系統的深度整合，建立智能化的企業資料分析和查詢系統。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **企業資料整合**：讓 AI 能夠存取和分析企業內部資料
- 🎯 **複雜工具設計**：建立帶參數和結構化回應的進階工具
- 🎯 **多工具協作**：實現多個工具的組合使用和協同工作
- 🎯 **資料模型設計**：掌握企業級資料模型的設計和實現
- 🎯 **智能分析系統**：建立 AI 驅動的企業資料分析平台

---

## 5.7.1 企業 AI 整合的重要性

### 在地化的第一步

![企業資料整合](https://ithelp.ithome.com.tw/upload/images/20240811/20161290JBnMyu335V.jpg)

只是問時間似乎無法體會 Tool Calling 有什麼特別之處，今天我們模擬從後端取得資料並透過 AI 幫我們分析，看看工具該如何撰寫。

### 企業 AI 應用的核心挑戰

**1. 資料孤島問題**
- 🏢 **分散的企業系統**：ERP、CRM、財務、人事等系統各自獨立
- 📊 **資料格式不一**：不同系統使用不同的資料格式和標準
- 🔒 **存取權限複雜**：企業資料涉及安全性和權限管理
- 🔄 **即時性要求**：業務決策需要即時的資料分析

**2. 傳統解決方案的限制**
- 📈 **BI 工具複雜**：需要專業技能才能操作
- 💰 **開發成本高**：每個查詢需求都要單獨開發
- ⏰ **回應速度慢**：從需求到實現週期長
- 🎯 **靈活性不足**：難以應對臨時性的分析需求

**3. AI + Tool Calling 的優勢**
- 🗣️ **自然語言查詢**：用日常語言描述分析需求
- 🔄 **即時資料存取**：透過 API 即時獲取最新資料
- 🧠 **智能分析**：AI 自動進行資料分析和洞察
- 🎨 **靈活組合**：多個資料源的智能整合

### 企業 AI 應用場景

| 應用領域 | 具體場景 | Tool Calling 解決方案 |
|----------|----------|----------------------|
| **銷售分析** | 產品銷量統計、趨勢分析 | 銷售資料查詢工具 |
| **財務管理** | 收支分析、預算控制 | 財務資料存取工具 |
| **人力資源** | 員工績效、薪資分析 | HR 系統整合工具 |
| **庫存管理** | 庫存狀態、補貨建議 | 庫存查詢工具 |
| **客戶服務** | 客戶資訊、服務記錄 | CRM 系統工具 |
| **營運分析** | KPI 監控、異常檢測 | 營運資料工具 |

---

## 5.7.2 企業資料工具設計

### 程式目標設定

**實戰場景**：詢問 AI 公司每個產品去年的銷量，並統計占銷量的比例是多少

**技術要求**：
- 📊 從企業資料庫獲取產品銷售資料
- 🔢 支援年份和產品型號的篩選查詢
- 📈 提供結構化的資料回應
- 🧮 讓 AI 進行自動分析和計算

### 產品銷售工具實現

**步驟 1：資料模型設計**

```java
package com.example.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.fasterxml.jackson.annotation.JsonClassDescription;
import lombok.Data;
import lombok.Builder;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

/**
 * 產品銷售資料模型
 */
@Data
@Builder
public class Product {
    
    @JsonProperty("year")
    @JsonPropertyDescription("銷售年份")
    private String year;
    
    @JsonProperty("model")
    @JsonPropertyDescription("產品型號")
    private String model;
    
    @JsonProperty("name")
    @JsonPropertyDescription("產品名稱")
    private String name;
    
    @JsonProperty("quantity")
    @JsonPropertyDescription("銷售數量")
    private Integer quantity;
    
    @JsonProperty("revenue")
    @JsonPropertyDescription("銷售金額")
    private BigDecimal revenue;
    
    @JsonProperty("category")
    @JsonPropertyDescription("產品類別")
    private String category;
    
    @JsonProperty("launch_date")
    @JsonPropertyDescription("上市日期")
    private LocalDate launchDate;
}

/**
 * 產品銷售查詢回應
 */
@Data
@Builder
@JsonClassDescription("公司產品銷售資料回應")
public class ProductSalesResponse {
    
    @JsonProperty("products")
    @JsonPropertyDescription("產品銷售清單")
    private List<Product> products;
    
    @JsonProperty("total_quantity")
    @JsonPropertyDescription("總銷售數量")
    private Integer totalQuantity;
    
    @JsonProperty("total_revenue")
    @JsonPropertyDescription("總銷售金額")
    private BigDecimal totalRevenue;
    
    @JsonProperty("query_year")
    @JsonPropertyDescription("查詢年份")
    private String queryYear;
    
    @JsonProperty("query_product")
    @JsonPropertyDescription("查詢產品")
    private String queryProduct;
}

/**
 * 銷售統計資料
 */
@Data
@Builder
@JsonClassDescription("銷售統計分析結果")
public class SalesStatistics {
    
    @JsonProperty("top_products")
    @JsonPropertyDescription("銷量前五名產品")
    private List<Product> topProducts;
    
    @JsonProperty("category_stats")
    @JsonPropertyDescription("各類別銷售統計")
    private List<CategoryStat> categoryStats;
    
    @JsonProperty("year_over_year_growth")
    @JsonPropertyDescription("年度成長率")
    private BigDecimal yearOverYearGrowth;
    
    @Data
    @Builder
    public static class CategoryStat {
        private String category;
        private Integer quantity;
        private BigDecimal revenue;
        private Double percentage;
    }
}
```

**步驟 2：企業資料存取服務**

```java
package com.example.service;

import com.example.model.Product;
import com.example.model.ProductSalesResponse;
import com.example.model.SalesStatistics;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class EnterpriseDataService {
    
    /**
     * 模擬企業資料庫查詢
     * 實際應用中這裡會連接到真實的企業資料庫
     */
    public List<Product> getProductSalesData() {
        return List.of(
            Product.builder()
                .year("2022")
                .model("PD-1405")
                .name("智能手機 Pro")
                .quantity(12500)
                .revenue(new BigDecimal("625000000"))
                .category("電子產品")
                .launchDate(LocalDate.of(2021, 3, 15))
                .build(),
            
            Product.builder()
                .year("2023")
                .model("PD-1234")
                .name("筆記型電腦 Ultra")
                .quantity(10000)
                .revenue(new BigDecimal("800000000"))
                .category("電腦設備")
                .launchDate(LocalDate.of(2022, 6, 20))
                .build(),
            
            Product.builder()
                .year("2023")
                .model("PD-1235")
                .name("平板電腦 Lite")
                .quantity(1500)
                .revenue(new BigDecimal("45000000"))
                .category("電子產品")
                .launchDate(LocalDate.of(2022, 9, 10))
                .build(),
            
            Product.builder()
                .year("2023")
                .model("PD-1385")
                .name("智能手錶 Sport")
                .quantity(15000)
                .revenue(new BigDecimal("300000000"))
                .category("穿戴裝置")
                .launchDate(LocalDate.of(2023, 1, 5))
                .build(),
            
            Product.builder()
                .year("2024")
                .model("PD-1255")
                .name("無線耳機 Pro")
                .quantity(15000)
                .revenue(new BigDecimal("225000000"))
                .category("音響設備")
                .launchDate(LocalDate.of(2023, 8, 12))
                .build(),
            
            Product.builder()
                .year("2024")
                .model("PD-1300")
                .name("智能音箱 Home")
                .quantity(12000)
                .revenue(new BigDecimal("180000000"))
                .category("智能家居")
                .launchDate(LocalDate.of(2023, 11, 25))
                .build(),
            
            Product.builder()
                .year("2024")
                .model("PD-1405")
                .name("智能手機 Pro Max")
                .quantity(12500)
                .revenue(new BigDecimal("750000000"))
                .category("電子產品")
                .launchDate(LocalDate.of(2024, 2, 14))
                .build(),
            
            Product.builder()
                .year("2024")
                .model("PD-1235")
                .name("平板電腦 Pro")
                .quantity(15000)
                .revenue(new BigDecimal("600000000"))
                .category("電子產品")
                .launchDate(LocalDate.of(2024, 4, 8))
                .build(),
            
            Product.builder()
                .year("2024")
                .model("PD-1385")
                .name("智能手錶 Ultra")
                .quantity(15000)
                .revenue(new BigDecimal("450000000"))
                .category("穿戴裝置")
                .launchDate(LocalDate.of(2024, 6, 18))
                .build()
        );
    }
    
    /**
     * 根據條件篩選產品資料
     */
    public List<Product> filterProducts(String year, String productModel) {
        List<Product> allProducts = getProductSalesData();
        
        return allProducts.stream()
                .filter(product -> year == null || product.getYear().equals(year))
                .filter(product -> productModel == null || 
                        product.getModel().toLowerCase().contains(productModel.toLowerCase()) ||
                        product.getName().toLowerCase().contains(productModel.toLowerCase()))
                .collect(Collectors.toList());
    }
    
    /**
     * 計算銷售統計資料
     */
    public SalesStatistics calculateSalesStatistics(List<Product> products) {
        // 計算總銷量
        int totalQuantity = products.stream()
                .mapToInt(Product::getQuantity)
                .sum();
        
        // 計算各類別統計
        List<SalesStatistics.CategoryStat> categoryStats = products.stream()
                .collect(Collectors.groupingBy(Product::getCategory))
                .entrySet().stream()
                .map(entry -> {
                    String category = entry.getKey();
                    List<Product> categoryProducts = entry.getValue();
                    
                    int categoryQuantity = categoryProducts.stream()
                            .mapToInt(Product::getQuantity)
                            .sum();
                    
                    BigDecimal categoryRevenue = categoryProducts.stream()
                            .map(Product::getRevenue)
                            .reduce(BigDecimal.ZERO, BigDecimal::add);
                    
                    double percentage = totalQuantity > 0 ? 
                            (double) categoryQuantity / totalQuantity * 100 : 0;
                    
                    return SalesStatistics.CategoryStat.builder()
                            .category(category)
                            .quantity(categoryQuantity)
                            .revenue(categoryRevenue)
                            .percentage(percentage)
                            .build();
                })
                .collect(Collectors.toList());
        
        // 取得銷量前五名
        List<Product> topProducts = products.stream()
                .sorted((p1, p2) -> Integer.compare(p2.getQuantity(), p1.getQuantity()))
                .limit(5)
                .collect(Collectors.toList());
        
        return SalesStatistics.builder()
                .topProducts(topProducts)
                .categoryStats(categoryStats)
                .yearOverYearGrowth(calculateYearOverYearGrowth(products))
                .build();
    }
    
    private BigDecimal calculateYearOverYearGrowth(List<Product> products) {
        // 簡化的年度成長率計算
        // 實際應用中會比較不同年份的資料
        return new BigDecimal("15.5"); // 模擬 15.5% 成長率
    }
}
```

**步驟 3：產品銷售工具實現**

```java
package com.example.tools;

import com.example.model.Product;
import com.example.model.ProductSalesResponse;
import com.example.model.SalesStatistics;
import com.example.service.EnterpriseDataService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class ProductSalesTools {
    
    private final EnterpriseDataService dataService;
    
    /**
     * 查詢產品銷售資料
     * @param year 銷售年份（可選）
     * @param product 產品型號或名稱（可選）
     * @return 產品銷售資料
     */
    @Tool(description = "Get company product sales information by year and product model. " +
          "Can filter by year (e.g., '2023', '2024') and product (model or name). " +
          "Returns detailed sales data including quantity, revenue, and product information.")
    public ProductSalesResponse getProductSales(String year, String product) {
        try {
            log.info("查詢產品銷售資料：年份={}, 產品={}", year, product);
            
            // 從企業資料服務獲取資料
            List<Product> products = dataService.filterProducts(year, product);
            
            // 計算總計
            int totalQuantity = products.stream()
                    .mapToInt(Product::getQuantity)
                    .sum();
            
            BigDecimal totalRevenue = products.stream()
                    .map(Product::getRevenue)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            ProductSalesResponse response = ProductSalesResponse.builder()
                    .products(products)
                    .totalQuantity(totalQuantity)
                    .totalRevenue(totalRevenue)
                    .queryYear(year)
                    .queryProduct(product)
                    .build();
            
            log.info("查詢完成，找到 {} 筆產品資料，總銷量：{}", 
                    products.size(), totalQuantity);
            
            return response;
            
        } catch (Exception e) {
            log.error("查詢產品銷售資料失敗", e);
            throw new RuntimeException("查詢產品銷售資料失敗：" + e.getMessage());
        }
    }
    
    /**
     * 獲取銷售統計分析
     * @param year 分析年份
     * @return 銷售統計資料
     */
    @Tool(description = "Get sales statistics and analysis for a specific year. " +
          "Returns top-selling products, category breakdown, and growth metrics.")
    public SalesStatistics getSalesStatistics(String year) {
        try {
            log.info("獲取銷售統計分析：年份={}", year);
            
            List<Product> products = dataService.filterProducts(year, null);
            SalesStatistics statistics = dataService.calculateSalesStatistics(products);
            
            log.info("統計分析完成，共分析 {} 筆產品資料", products.size());
            
            return statistics;
            
        } catch (Exception e) {
            log.error("獲取銷售統計失敗", e);
            throw new RuntimeException("獲取銷售統計失敗：" + e.getMessage());
        }
    }
    
    /**
     * 比較不同年份的銷售表現
     * @param year1 第一個年份
     * @param year2 第二個年份
     * @return 比較結果
     */
    @Tool(description = "Compare sales performance between two years. " +
          "Returns detailed comparison including growth rates and product performance changes.")
    public String compareSalesByYear(String year1, String year2) {
        try {
            log.info("比較年度銷售表現：{} vs {}", year1, year2);
            
            List<Product> products1 = dataService.filterProducts(year1, null);
            List<Product> products2 = dataService.filterProducts(year2, null);
            
            int total1 = products1.stream().mapToInt(Product::getQuantity).sum();
            int total2 = products2.stream().mapToInt(Product::getQuantity).sum();
            
            BigDecimal revenue1 = products1.stream()
                    .map(Product::getRevenue)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            BigDecimal revenue2 = products2.stream()
                    .map(Product::getRevenue)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            double quantityGrowth = total1 > 0 ? 
                    ((double) (total2 - total1) / total1 * 100) : 0;
            
            double revenueGrowth = revenue1.compareTo(BigDecimal.ZERO) > 0 ?
                    revenue2.subtract(revenue1)
                            .divide(revenue1, 4, java.math.RoundingMode.HALF_UP)
                            .multiply(new BigDecimal("100"))
                            .doubleValue() : 0;
            
            String result = String.format(
                    "年度銷售比較分析 (%s vs %s):\n" +
                    "銷售數量：%d → %d (成長率：%.2f%%)\n" +
                    "銷售金額：%s → %s (成長率：%.2f%%)\n" +
                    "產品數量：%d → %d",
                    year1, year2,
                    total1, total2, quantityGrowth,
                    revenue1, revenue2, revenueGrowth,
                    products1.size(), products2.size()
            );
            
            log.info("年度比較完成");
            return result;
            
        } catch (Exception e) {
            log.error("年度銷售比較失敗", e);
            return "年度銷售比較失敗：" + e.getMessage();
        }
    }
}
```

---

## 5.7.3 多工具協作系統

### 工具組合配置

**ChatClient 配置**：

```java
package com.example.config;

import com.example.tools.DateTimeTools;
import com.example.tools.ProductSalesTools;
import com.example.tools.CalculatorTools;
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@RequiredArgsConstructor
public class AiConfig {
    
    private final ProductSalesTools productSalesTools;
    private final DateTimeTools dateTimeTools;
    private final CalculatorTools calculatorTools;
    
    /**
     * 配置企業級 ChatClient
     * 整合多個工具以支援複雜的企業查詢
     */
    @Bean
    public ChatClient enterpriseChatClient(ChatModel chatModel) {
        return ChatClient.builder(chatModel)
                .defaultTools(
                    productSalesTools,    // 產品銷售資料工具
                    dateTimeTools,        // 日期時間工具
                    calculatorTools       // 計算工具
                )
                .defaultSystem("""
                    你是一個專業的企業資料分析師，擅長分析銷售資料和提供商業洞察。
                    
                    當用戶詢問企業資料時，請：
                    1. 使用適當的工具獲取最新資料
                    2. 進行深入的資料分析
                    3. 提供清晰的洞察和建議
                    4. 用專業但易懂的語言回答
                    
                    可用的工具：
                    - 產品銷售資料查詢
                    - 銷售統計分析
                    - 年度比較分析
                    - 日期時間查詢
                    - 數學計算
                    """)
                .build();
    }
    
    /**
     * 簡化版 ChatClient（僅基礎功能）
     */
    @Bean("basicChatClient")
    public ChatClient basicChatClient(ChatModel chatModel) {
        return ChatClient.builder(chatModel)
                .defaultTools(dateTimeTools)
                .build();
    }
}
```

### 企業級控制器實現

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/enterprise")
@RequiredArgsConstructor
@Slf4j
public class EnterpriseAiController {
    
    private final ChatClient enterpriseChatClient;
    
    /**
     * 企業資料查詢和分析
     * @param prompt 自然語言查詢
     * @return AI 分析結果
     */
    @GetMapping("/query")
    public String enterpriseQuery(@RequestParam String prompt) {
        try {
            log.info("收到企業查詢請求：{}", prompt);
            
            long startTime = System.currentTimeMillis();
            
            String response = enterpriseChatClient
                    .prompt(prompt)
                    .call()
                    .content();
            
            long endTime = System.currentTimeMillis();
            
            log.info("企業查詢完成，耗時：{}ms", endTime - startTime);
            
            return response;
            
        } catch (Exception e) {
            log.error("企業查詢失敗：{}", prompt, e);
            return "查詢失敗：" + e.getMessage();
        }
    }
    
    /**
     * 銷售資料專用查詢
     * @param request 銷售查詢請求
     * @return 結構化回應
     */
    @PostMapping("/sales-analysis")
    public SalesAnalysisResponse salesAnalysis(@RequestBody SalesAnalysisRequest request) {
        try {
            log.info("銷售分析請求：{}", request);
            
            long startTime = System.currentTimeMillis();
            
            // 構建針對性的提示詞
            String prompt = buildSalesAnalysisPrompt(request);
            
            String aiResponse = enterpriseChatClient
                    .prompt(prompt)
                    .call()
                    .content();
            
            long endTime = System.currentTimeMillis();
            
            return SalesAnalysisResponse.builder()
                    .success(true)
                    .query(request.getQuery())
                    .analysis(aiResponse)
                    .executionTime(endTime - startTime)
                    .timestamp(LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("銷售分析失敗", e);
            
            return SalesAnalysisResponse.builder()
                    .success(false)
                    .query(request.getQuery())
                    .error(e.getMessage())
                    .timestamp(LocalDateTime.now())
                    .build();
        }
    }
    
    /**
     * 批次企業查詢
     * @param queries 多個查詢請求
     * @return 批次處理結果
     */
    @PostMapping("/batch-query")
    public Map<String, String> batchEnterpriseQuery(@RequestBody BatchQueryRequest queries) {
        try {
            log.info("批次企業查詢：{} 個請求", queries.getQueries().size());
            
            return queries.getQueries().parallelStream()
                    .collect(java.util.stream.Collectors.toMap(
                            query -> query,
                            query -> {
                                try {
                                    return enterpriseChatClient
                                            .prompt(query)
                                            .call()
                                            .content();
                                } catch (Exception e) {
                                    log.error("批次查詢失敗：{}", query, e);
                                    return "查詢失敗：" + e.getMessage();
                                }
                            }
                    ));
            
        } catch (Exception e) {
            log.error("批次企業查詢失敗", e);
            return Map.of("error", "批次查詢失敗：" + e.getMessage());
        }
    }
    
    private String buildSalesAnalysisPrompt(SalesAnalysisRequest request) {
        StringBuilder prompt = new StringBuilder();
        
        prompt.append("請分析以下銷售資料查詢：\n");
        prompt.append("查詢內容：").append(request.getQuery()).append("\n");
        
        if (request.getYear() != null) {
            prompt.append("指定年份：").append(request.getYear()).append("\n");
        }
        
        if (request.getProduct() != null) {
            prompt.append("指定產品：").append(request.getProduct()).append("\n");
        }
        
        prompt.append("\n請提供：\n");
        prompt.append("1. 相關的銷售資料\n");
        prompt.append("2. 資料分析和洞察\n");
        prompt.append("3. 商業建議\n");
        
        return prompt.toString();
    }
}
```

### 請求和回應 DTO

```java
package com.example.dto;

import lombok.Data;
import lombok.Builder;
import java.time.LocalDateTime;
import java.util.List;

@Data
public class SalesAnalysisRequest {
    private String query;
    private String year;
    private String product;
    private String analysisType;  // trend, comparison, forecast
}

@Data
@Builder
public class SalesAnalysisResponse {
    private boolean success;
    private String query;
    private String analysis;
    private Long executionTime;
    private String error;
    private LocalDateTime timestamp;
}

@Data
public class BatchQueryRequest {
    private List<String> queries;
}
```

---

## 5.7.4 實際應用場景

### 銷售分析對話範例

**場景 1：基礎銷售查詢**

```
用戶：「請告訴我 2023 年所有產品的銷售情況」

AI 回應：
根據查詢結果，2023年公司共有4款產品的銷售資料：

📊 **2023年銷售總覽**
- 總銷售數量：26,500 台
- 總銷售金額：11.45 億元

📈 **各產品表現**
1. PD-1385 智能手錶 Sport：15,000台 (56.6%)
2. PD-1234 筆記型電腦 Ultra：10,000台 (37.7%)
3. PD-1235 平板電腦 Lite：1,500台 (5.7%)

💡 **分析洞察**
- 智能手錶是主力產品，占總銷量超過一半
- 筆記型電腦雖然銷量第二，但單價較高，貢獻最多營收
- 平板電腦銷量較低，可能需要重新評估市場策略
```

**場景 2：比較分析**

```
用戶：「比較一下 2023 年和 2024 年的銷售表現」

AI 回應：
📊 **2023 vs 2024 年度銷售比較**

**整體表現**
- 銷售數量：26,500 → 54,500 台 (+105.7%)
- 銷售金額：11.45 → 20.55 億元 (+79.5%)
- 產品線：4 → 5 款產品

**成長亮點**
1. 新增產品線帶來顯著成長
2. 既有產品 PD-1235 和 PD-1385 都有大幅提升
3. 平均單價有所下降，但總營收大幅成長

**策略建議**
- 繼續擴展產品線多樣化
- 加強智能家居和音響設備市場布局
- 優化定價策略以提升利潤率
```

**場景 3：深度分析**

```
用戶：「分析一下我們在穿戴裝置類別的表現，並給出市場建議」

AI 回應：
🔍 **穿戴裝置類別深度分析**

**產品表現**
- PD-1385 智能手錶系列：2023年 15,000台 → 2024年 15,000台
- 市場占有率：在公司總銷量中占比從 56.6% 降至 27.5%

**市場洞察**
1. **銷量穩定但相對成長放緩**：雖然絕對數量維持，但在公司快速成長中相對比重下降
2. **產品升級成功**：從 Sport 版升級到 Ultra 版，單價提升 50%
3. **市場競爭加劇**：穿戴裝置市場趨於飽和

**策略建議**
1. **產品差異化**：開發專業運動、健康監測等細分市場產品
2. **生態系統整合**：與其他產品線形成互補，提升用戶黏性
3. **服務化轉型**：增加軟體服務和訂閱模式收入
4. **國際市場拓展**：尋找新興市場機會
```

---

## 📝 本章重點回顧

1. **企業資料整合**：學會了讓 AI 存取和分析企業內部資料的完整方法
2. **複雜工具設計**：掌握了帶參數和結構化回應的進階工具實現
3. **多工具協作**：實現了多個工具的智能組合和協同工作
4. **資料模型設計**：建立了企業級資料模型和回應結構
5. **實際應用場景**：展示了真實的企業 AI 分析對話和洞察生成

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **企業資料存取** | ⭐⭐⭐ | 中 | 所有企業 AI 應用 |
| **結構化回應** | ⭐⭐⭐ | 中 | 資料分析系統 |
| **多工具協作** | ⭐⭐ | 高 | 複雜業務場景 |
| **資料模型設計** | ⭐⭐ | 中 | 企業級應用 |
| **智能分析** | ⭐⭐ | 高 | 商業洞察系統 |
| **批次處理** | ⭐ | 中 | 大量查詢場景 |

### 企業應用價值

**1. 降低分析門檻**
- 🗣️ **自然語言查詢**：業務人員無需學習複雜的 BI 工具
- ⚡ **即時回應**：從數天的報表製作縮短到幾秒鐘
- 🎯 **精準洞察**：AI 自動發現資料中的模式和趨勢

**2. 提升決策效率**
- 📊 **即時資料**：基於最新資料進行決策
- 🔍 **深度分析**：多維度的資料分析和比較
- 💡 **智能建議**：基於資料的商業建議和策略

**3. 擴展應用場景**
- 📈 **銷售分析**：產品表現、市場趨勢、客戶行為
- 💰 **財務管理**：收支分析、成本控制、預算規劃
- 👥 **人力資源**：員工績效、薪資分析、人才規劃
- 📦 **營運管理**：庫存優化、供應鏈分析、品質控制

### 下一步學習方向

在下一章中，我們將學習 Function Calling 的最終組合技，包括複雜工具鏈、條件式調用和企業級工具生態系統的建立。

---

**參考資料：**
- [Spring AI Tool Calling Advanced Guide](https://docs.spring.io/spring-ai/reference/api/tools.html)
- [Enterprise AI Integration Patterns](https://docs.spring.io/spring-ai/reference/concepts.html)
- [JSON Schema for Tool Parameters](https://json-schema.org/)
- [Business Intelligence with AI](https://www.mckinsey.com/capabilities/quantumblack/our-insights/the-age-of-ai)


\newpage

## 5.8 Function Calling (下) - 最終組合技


> **本章重點**：掌握 Function Calling 的進階技巧，包括工具鏈式調用、條件式執行和複雜業務邏輯的實現，建立企業級的智能工具生態系統。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握工具鏈調用**：理解 AI 如何自動進行多層次工具調用
- 🎯 **實現條件式執行**：根據不同條件智能選擇和組合工具
- 🎯 **設計複雜工具鏈**：建立多步驟的業務流程自動化
- 🎯 **優化工具效能**：掌握工具調用的效能優化和成本控制
- 🎯 **建立工具生態**：設計可擴展的企業級工具管理系統

---

## 5.8.1 讓 AI 自己調用程式

### Function Calling 的進階特性

![AI 自動調用](https://ithelp.ithome.com.tw/upload/images/20240812/20161290El6Y5FmnHN.png)

原本 Function Call 只打算寫兩篇，不過最近參考其他框架發現 **Function Calling 是會被反覆調用的**，測試後發現 Spring AI 也有類似的效果。

Spring AI 會先去調用符合的 Function 並取得資料，之後會再拿取得的資料確認是否還有可匹配的 Function，並將目前取得的結果再次呼叫 Function。

### 工具鏈調用的核心概念

**1. 自動鏈式調用**
- 🔗 **智能串聯**：AI 自動判斷需要調用哪些工具
- 📊 **資料流轉**：前一個工具的輸出成為下一個工具的輸入
- 🎯 **目標導向**：AI 持續調用工具直到滿足使用者需求
- 🔄 **迭代優化**：根據中間結果調整後續調用策略

**2. 傳統方式 vs 工具鏈方式**

| 比較項目 | 傳統單一工具 | 工具鏈調用 |
|----------|-------------|------------|
| **資料處理** | 一次性返回所有資料 | 按需獲取，分步處理 |
| **成本控制** | 高（傳輸大量資料） | 低（按需調用） |
| **靈活性** | 低（固定資料結構） | 高（動態組合） |
| **維護性** | 複雜（單一工具承擔多責任） | 簡單（職責分離） |
| **擴展性** | 困難（修改影響全局） | 容易（獨立工具模組） |

**3. 工具鏈調用的優勢**

```
❌ 傳統方式：
用戶查詢 → 單一大型工具 → 返回所有相關資料 → AI 分析

✅ 工具鏈方式：
用戶查詢 → 工具A（基礎資料） → 工具B（詳細資訊） → 工具C（分析計算） → AI 整合回應
```

---

## 5.8.2 複雜工具鏈實現

### 程式目標設定

**實戰場景**：詢問 AI 公司去年最熱銷的產品，並列出該產品所有型號

**工具鏈流程**：
1. 🔍 **銷售查詢工具** → 獲取去年所有產品銷售資料
2. 📊 **資料分析工具** → 找出最熱銷產品
3. 🔎 **產品詳情工具** → 查詢該產品的所有型號
4. 🧮 **計算工具** → 進行相關統計計算
5. 🎯 **AI 整合** → 生成完整分析報告

### 產品詳情工具實現

**步驟 1：產品型號查詢工具**

```java
package com.example.tools;

import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

@Component
@Slf4j
public class ProductDetailsTools {
    
    /**
     * 產品詳情資料模型
     */
    public record ProductDetail(
            String product,
            String productName,
            List<String> models,
            String category,
            String description
    ) {}
    
    /**
     * 產品型號資料模型
     */
    public record ProductModel(
            String modelCode,
            String modelName,
            String specifications,
            String price,
            String availability
    ) {}
    
    /**
     * 根據產品名稱獲取產品型號列表
     * @param product 產品代碼或名稱
     * @return 產品詳情包含所有型號
     */
    @Tool(description = "Get detailed product information including all available models by product code or name. " +
          "Returns comprehensive product details with model specifications.")
    public ProductDetail getProductModels(String product) {
        try {
            log.info("查詢產品型號：{}", product);
            
            // 模擬企業產品資料庫
            Map<String, ProductDetail> productDatabase = Map.of(
                "PD-1405", new ProductDetail(
                    "PD-1405",
                    "智能手機 Pro 系列",
                    List.of("1405-001", "1405-002", "1405-003", "1405-004"),
                    "智能手機",
                    "高端智能手機系列，支援 5G 和 AI 攝影"
                ),
                "PD-1234", new ProductDetail(
                    "PD-1234",
                    "筆記型電腦 Ultra 系列",
                    List.of("1234-1", "1234-2", "1234-3", "1234-4", "1234-5"),
                    "筆記型電腦",
                    "輕薄高效能筆記型電腦，適合商務和創作"
                ),
                "PD-1235", new ProductDetail(
                    "PD-1235",
                    "平板電腦系列",
                    List.of("1235-4", "1235-5", "1235-6"),
                    "平板電腦",
                    "多功能平板電腦，支援手寫筆和鍵盤"
                ),
                "PD-1385", new ProductDetail(
                    "PD-1385",
                    "智能手錶系列",
                    List.of("1385-1", "1385-2", "1385-3", "1385-4"),
                    "穿戴裝置",
                    "健康監測智能手錶，支援運動追蹤和心率監測"
                ),
                "PD-1255", new ProductDetail(
                    "PD-1255",
                    "無線耳機系列",
                    List.of("1255-1", "1255-2"),
                    "音響設備",
                    "主動降噪無線耳機，高品質音效體驗"
                ),
                "PD-1300", new ProductDetail(
                    "PD-1300",
                    "智能音箱系列",
                    List.of("1300-1", "1300-2", "1300-3"),
                    "智能家居",
                    "AI 語音助手智能音箱，支援智能家居控制"
                )
            );
            
            ProductDetail result = productDatabase.get(product);
            if (result == null) {
                // 嘗試模糊匹配
                result = productDatabase.values().stream()
                        .filter(pd -> pd.productName().toLowerCase().contains(product.toLowerCase()))
                        .findFirst()
                        .orElse(new ProductDetail(
                                product,
                                "未知產品",
                                List.of("無此產品型號"),
                                "未分類",
                                "查無此產品資訊"
                        ));
            }
            
            log.info("查詢完成，產品：{}，型號數量：{}", 
                    result.productName(), result.models().size());
            
            return result;
            
        } catch (Exception e) {
            log.error("查詢產品型號失敗：{}", product, e);
            return new ProductDetail(
                    product,
                    "查詢失敗",
                    List.of("系統錯誤"),
                    "錯誤",
                    "查詢產品資訊時發生錯誤：" + e.getMessage()
            );
        }
    }
    
    /**
     * 獲取特定型號的詳細規格
     * @param productCode 產品代碼
     * @param modelCode 型號代碼
     * @return 型號詳細資訊
     */
    @Tool(description = "Get detailed specifications for a specific product model. " +
          "Returns comprehensive model information including price and availability.")
    public ProductModel getModelSpecifications(String productCode, String modelCode) {
        try {
            log.info("查詢型號規格：{}-{}", productCode, modelCode);
            
            // 模擬型號規格資料庫
            String fullModelCode = productCode + "-" + modelCode;
            
            // 根據產品類型生成規格資訊
            ProductModel model = switch (productCode) {
                case "PD-1405" -> new ProductModel(
                        modelCode,
                        "智能手機 Pro " + modelCode,
                        generatePhoneSpecs(modelCode),
                        generatePrice("phone", modelCode),
                        "現貨供應"
                );
                case "PD-1234" -> new ProductModel(
                        modelCode,
                        "筆記型電腦 Ultra " + modelCode,
                        generateLaptopSpecs(modelCode),
                        generatePrice("laptop", modelCode),
                        "現貨供應"
                );
                case "PD-1385" -> new ProductModel(
                        modelCode,
                        "智能手錶 " + modelCode,
                        generateWatchSpecs(modelCode),
                        generatePrice("watch", modelCode),
                        "現貨供應"
                );
                default -> new ProductModel(
                        modelCode,
                        "產品型號 " + modelCode,
                        "標準規格",
                        "價格面議",
                        "請洽詢"
                );
            };
            
            log.info("型號規格查詢完成：{}", model.modelName());
            return model;
            
        } catch (Exception e) {
            log.error("查詢型號規格失敗：{}-{}", productCode, modelCode, e);
            return new ProductModel(
                    modelCode,
                    "查詢失敗",
                    "無法獲取規格資訊",
                    "價格未知",
                    "查詢錯誤"
            );
        }
    }
    
    private String generatePhoneSpecs(String modelCode) {
        return switch (modelCode) {
            case "1405-001" -> "6.1吋 OLED 螢幕, 128GB 儲存, 雙鏡頭";
            case "1405-002" -> "6.1吋 OLED 螢幕, 256GB 儲存, 三鏡頭";
            case "1405-003" -> "6.7吋 OLED 螢幕, 512GB 儲存, 三鏡頭 Pro";
            case "1405-004" -> "6.7吋 OLED 螢幕, 1TB 儲存, 四鏡頭 Pro Max";
            default -> "標準智能手機規格";
        };
    }
    
    private String generateLaptopSpecs(String modelCode) {
        return switch (modelCode) {
            case "1234-1" -> "13吋, Intel i5, 8GB RAM, 256GB SSD";
            case "1234-2" -> "13吋, Intel i7, 16GB RAM, 512GB SSD";
            case "1234-3" -> "15吋, Intel i7, 16GB RAM, 1TB SSD";
            case "1234-4" -> "15吋, Intel i9, 32GB RAM, 1TB SSD";
            case "1234-5" -> "16吋, Intel i9, 64GB RAM, 2TB SSD";
            default -> "標準筆記型電腦規格";
        };
    }
    
    private String generateWatchSpecs(String modelCode) {
        return switch (modelCode) {
            case "1385-1" -> "41mm, GPS, 心率監測";
            case "1385-2" -> "45mm, GPS, 心率監測, 血氧檢測";
            case "1385-3" -> "41mm, GPS+Cellular, 心率監測, 血氧檢測";
            case "1385-4" -> "45mm, GPS+Cellular, 心率監測, 血氧檢測, ECG";
            default -> "標準智能手錶規格";
        };
    }
    
    private String generatePrice(String category, String modelCode) {
        return switch (category) {
            case "phone" -> switch (modelCode) {
                case "1405-001" -> "NT$ 25,900";
                case "1405-002" -> "NT$ 29,900";
                case "1405-003" -> "NT$ 35,900";
                case "1405-004" -> "NT$ 42,900";
                default -> "NT$ 25,000";
            };
            case "laptop" -> switch (modelCode) {
                case "1234-1" -> "NT$ 35,900";
                case "1234-2" -> "NT$ 45,900";
                case "1234-3" -> "NT$ 55,900";
                case "1234-4" -> "NT$ 75,900";
                case "1234-5" -> "NT$ 95,900";
                default -> "NT$ 40,000";
            };
            case "watch" -> switch (modelCode) {
                case "1385-1" -> "NT$ 12,900";
                case "1385-2" -> "NT$ 15,900";
                case "1385-3" -> "NT$ 18,900";
                case "1385-4" -> "NT$ 22,900";
                default -> "NT$ 15,000";
            };
            default -> "價格面議";
        };
    }
}
```

### 增強版銷售工具

**步驟 2：銷售資料分析工具**

```java
package com.example.tools;

import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Component
@Slf4j
public class EnhancedSalesTools {
    
    /**
     * 產品銷售資料模型
     */
    public record ProductSales(
            String product,
            String productName,
            int salesVolume,
            BigDecimal revenue,
            String category,
            double marketShare
    ) {}
    
    /**
     * 銷售排行資料模型
     */
    public record SalesRanking(
            List<ProductSales> topProducts,
            ProductSales bestSeller,
            int totalVolume,
            BigDecimal totalRevenue,
            String analysisYear
    ) {}
    
    /**
     * 獲取指定年份的產品銷售資料
     * @param year 查詢年份
     * @return 銷售資料列表
     */
    @Tool(description = "Get comprehensive product sales data for a specific year. " +
          "Returns detailed sales information including volume, revenue, and market share.")
    public SalesRanking getProductSalesRanking(int year) {
        try {
            log.info("查詢年度銷售排行：{}", year);
            
            List<ProductSales> salesData = getSalesDataByYear(year);
            
            if (salesData.isEmpty()) {
                return new SalesRanking(
                        List.of(),
                        null,
                        0,
                        BigDecimal.ZERO,
                        String.valueOf(year)
                );
            }
            
            // 計算總銷量和總營收
            int totalVolume = salesData.stream()
                    .mapToInt(ProductSales::salesVolume)
                    .sum();
            
            BigDecimal totalRevenue = salesData.stream()
                    .map(ProductSales::revenue)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            // 按銷量排序
            List<ProductSales> topProducts = salesData.stream()
                    .sorted((p1, p2) -> Integer.compare(p2.salesVolume(), p1.salesVolume()))
                    .collect(Collectors.toList());
            
            ProductSales bestSeller = topProducts.get(0);
            
            SalesRanking ranking = new SalesRanking(
                    topProducts,
                    bestSeller,
                    totalVolume,
                    totalRevenue,
                    String.valueOf(year)
            );
            
            log.info("銷售排行查詢完成：{}年，最佳銷售產品：{}", 
                    year, bestSeller.productName());
            
            return ranking;
            
        } catch (Exception e) {
            log.error("查詢銷售排行失敗：{}", year, e);
            throw new RuntimeException("查詢銷售排行失敗：" + e.getMessage());
        }
    }
    
    /**
     * 比較不同產品的銷售表現
     * @param year 比較年份
     * @param products 產品代碼列表
     * @return 比較結果
     */
    @Tool(description = "Compare sales performance between multiple products in a specific year. " +
          "Returns detailed comparison with rankings and performance metrics.")
    public String compareProductPerformance(int year, List<String> products) {
        try {
            log.info("比較產品銷售表現：{}年，產品：{}", year, products);
            
            List<ProductSales> allSales = getSalesDataByYear(year);
            
            List<ProductSales> targetProducts = allSales.stream()
                    .filter(sale -> products.contains(sale.product()))
                    .sorted((p1, p2) -> Integer.compare(p2.salesVolume(), p1.salesVolume()))
                    .collect(Collectors.toList());
            
            if (targetProducts.isEmpty()) {
                return "未找到指定產品的銷售資料";
            }
            
            StringBuilder comparison = new StringBuilder();
            comparison.append(String.format("📊 %d年產品銷售表現比較\n\n", year));
            
            for (int i = 0; i < targetProducts.size(); i++) {
                ProductSales product = targetProducts.get(i);
                comparison.append(String.format(
                        "%d. %s (%s)\n" +
                        "   銷售量：%,d 台\n" +
                        "   營收：%s\n" +
                        "   市場占有率：%.2f%%\n\n",
                        i + 1,
                        product.productName(),
                        product.product(),
                        product.salesVolume(),
                        formatCurrency(product.revenue()),
                        product.marketShare()
                ));
            }
            
            // 添加分析洞察
            ProductSales winner = targetProducts.get(0);
            comparison.append("🏆 **分析洞察**\n");
            comparison.append(String.format(
                    "- 最佳表現：%s，銷售量領先\n",
                    winner.productName()
            ));
            
            if (targetProducts.size() > 1) {
                ProductSales second = targetProducts.get(1);
                double gap = ((double) (winner.salesVolume() - second.salesVolume()) / second.salesVolume()) * 100;
                comparison.append(String.format(
                        "- 領先優勢：比第二名多 %.1f%%\n",
                        gap
                ));
            }
            
            log.info("產品比較完成");
            return comparison.toString();
            
        } catch (Exception e) {
            log.error("比較產品銷售表現失敗", e);
            return "比較產品銷售表現失敗：" + e.getMessage();
        }
    }
    
    private List<ProductSales> getSalesDataByYear(int year) {
        // 模擬不同年份的銷售資料
        Map<Integer, List<ProductSales>> salesDatabase = Map.of(
            2023, List.of(
                new ProductSales("PD-1385", "智能手錶系列", 15000, 
                        new BigDecimal("300000000"), "穿戴裝置", 35.7),
                new ProductSales("PD-1234", "筆記型電腦 Ultra 系列", 10000, 
                        new BigDecimal("800000000"), "筆記型電腦", 23.8),
                new ProductSales("PD-1405", "智能手機 Pro 系列", 8500, 
                        new BigDecimal("425000000"), "智能手機", 20.2),
                new ProductSales("PD-1235", "平板電腦系列", 1500, 
                        new BigDecimal("75000000"), "平板電腦", 3.6),
                new ProductSales("PD-1255", "無線耳機系列", 800, 
                        new BigDecimal("24000000"), "音響設備", 1.9),
                new ProductSales("PD-1300", "智能音箱系列", 500, 
                        new BigDecimal("15000000"), "智能家居", 1.2)
            ),
            2024, List.of(
                new ProductSales("PD-1405", "智能手機 Pro 系列", 18500, 
                        new BigDecimal("925000000"), "智能手機", 28.5),
                new ProductSales("PD-1385", "智能手錶系列", 17000, 
                        new BigDecimal("510000000"), "穿戴裝置", 26.2),
                new ProductSales("PD-1234", "筆記型電腦 Ultra 系列", 12000, 
                        new BigDecimal("960000000"), "筆記型電腦", 18.5),
                new ProductSales("PD-1235", "平板電腦系列", 8500, 
                        new BigDecimal("425000000"), "平板電腦", 13.1),
                new ProductSales("PD-1255", "無線耳機系列", 5500, 
                        new BigDecimal("165000000"), "音響設備", 8.5),
                new ProductSales("PD-1300", "智能音箱系列", 3500, 
                        new BigDecimal("105000000"), "智能家居", 5.4)
            )
        );
        
        return salesDatabase.getOrDefault(year, List.of());
    }
    
    private String formatCurrency(BigDecimal amount) {
        if (amount.compareTo(new BigDecimal("100000000")) >= 0) {
            return String.format("NT$ %.1f億", 
                    amount.divide(new BigDecimal("100000000"), 1, RoundingMode.HALF_UP).doubleValue());
        } else if (amount.compareTo(new BigDecimal("10000")) >= 0) {
            return String.format("NT$ %.0f萬", 
                    amount.divide(new BigDecimal("10000"), 0, RoundingMode.HALF_UP).doubleValue());
        } else {
            return String.format("NT$ %,d", amount.intValue());
        }
    }
}
```

---

## 5.8.3 工具鏈協調系統

### ChatClient 進階配置

```java
package com.example.config;

import com.example.tools.*;
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@RequiredArgsConstructor
public class AdvancedAiConfig {
    
    private final ProductDetailsTools productDetailsTools;
    private final EnhancedSalesTools enhancedSalesTools;
    private final DateTimeTools dateTimeTools;
    private final CalculatorTools calculatorTools;
    
    /**
     * 企業級工具鏈 ChatClient
     * 支援複雜的多步驟工具調用
     */
    @Bean
    public ChatClient toolChainChatClient(ChatModel chatModel) {
        return ChatClient.builder(chatModel)
                .defaultTools(
                    enhancedSalesTools,     // 銷售資料分析工具
                    productDetailsTools,    // 產品詳情工具
                    calculatorTools,        // 計算工具
                    dateTimeTools          // 時間工具
                )
                .defaultSystem("""
                    你是一個專業的企業資料分析專家，擅長使用多種工具進行深度分析。
                    
                    工具使用策略：
                    1. 根據用戶查詢自動選擇合適的工具組合
                    2. 按邏輯順序調用工具（先獲取基礎資料，再進行詳細分析）
                    3. 充分利用工具鏈的優勢，避免一次性獲取過多資料
                    4. 提供深入的分析洞察和商業建議
                    
                    可用工具：
                    - 銷售排行分析：獲取年度銷售資料和排行
                    - 產品詳情查詢：獲取產品型號和規格資訊
                    - 產品比較分析：比較多個產品的銷售表現
                    - 數學計算：進行各種統計計算
                    - 時間查詢：獲取當前時間和日期資訊
                    
                    回答風格：
                    - 使用專業但易懂的語言
                    - 提供結構化的分析結果
                    - 包含具體的數據和洞察
                    - 給出實用的商業建議
                    """)
                .build();
    }
    
    /**
     * 快速查詢 ChatClient（簡化版）
     */
    @Bean("quickQueryChatClient")
    public ChatClient quickQueryChatClient(ChatModel chatModel) {
        return ChatClient.builder(chatModel)
                .defaultTools(
                    enhancedSalesTools,
                    dateTimeTools
                )
                .defaultSystem("你是一個快速查詢助手，專門處理簡單的資料查詢請求。")
                .build();
    }
}
```

### 工具鏈控制器

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/tool-chain")
@RequiredArgsConstructor
@Slf4j
public class ToolChainController {
    
    private final ChatClient toolChainChatClient;
    
    /**
     * 複雜工具鏈查詢
     * @param prompt 自然語言查詢
     * @return AI 分析結果
     */
    @GetMapping("/complex-query")
    public String complexQuery(@RequestParam String prompt) {
        try {
            log.info("收到複雜工具鏈查詢：{}", prompt);
            
            long startTime = System.currentTimeMillis();
            
            String response = toolChainChatClient
                    .prompt(prompt)
                    .call()
                    .content();
            
            long endTime = System.currentTimeMillis();
            
            log.info("複雜查詢完成，耗時：{}ms，回應長度：{} 字元", 
                    endTime - startTime, response.length());
            
            return response;
            
        } catch (Exception e) {
            log.error("複雜工具鏈查詢失敗：{}", prompt, e);
            return "查詢失敗：" + e.getMessage();
        }
    }
    
    /**
     * 產品深度分析
     * @param request 分析請求
     * @return 詳細分析報告
     */
    @PostMapping("/product-analysis")
    public ProductAnalysisResponse productAnalysis(@RequestBody ProductAnalysisRequest request) {
        try {
            log.info("產品深度分析請求：{}", request);
            
            long startTime = System.currentTimeMillis();
            
            // 構建分析提示詞
            String prompt = buildAnalysisPrompt(request);
            
            String analysis = toolChainChatClient
                    .prompt(prompt)
                    .call()
                    .content();
            
            long endTime = System.currentTimeMillis();
            
            return ProductAnalysisResponse.builder()
                    .success(true)
                    .productCode(request.getProductCode())
                    .analysisType(request.getAnalysisType())
                    .analysis(analysis)
                    .executionTime(endTime - startTime)
                    .timestamp(LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("產品深度分析失敗", e);
            
            return ProductAnalysisResponse.builder()
                    .success(false)
                    .productCode(request.getProductCode())
                    .error(e.getMessage())
                    .timestamp(LocalDateTime.now())
                    .build();
        }
    }
    
    /**
     * 工具鏈執行追蹤
     * @param prompt 查詢內容
     * @return 執行追蹤資訊
     */
    @GetMapping("/trace")
    public Map<String, Object> traceExecution(@RequestParam String prompt) {
        try {
            log.info("工具鏈執行追蹤：{}", prompt);
            
            long startTime = System.currentTimeMillis();
            
            // 這裡可以添加工具調用追蹤邏輯
            String response = toolChainChatClient
                    .prompt(prompt)
                    .call()
                    .content();
            
            long endTime = System.currentTimeMillis();
            
            return Map.of(
                "prompt", prompt,
                "response", response,
                "executionTime", endTime - startTime,
                "toolsUsed", List.of("EnhancedSalesTools", "ProductDetailsTools"), // 實際應該從執行過程中獲取
                "timestamp", LocalDateTime.now()
            );
            
        } catch (Exception e) {
            log.error("工具鏈執行追蹤失敗", e);
            return Map.of(
                "error", e.getMessage(),
                "timestamp", LocalDateTime.now()
            );
        }
    }
    
    private String buildAnalysisPrompt(ProductAnalysisRequest request) {
        StringBuilder prompt = new StringBuilder();
        
        prompt.append("請進行深度產品分析：\n");
        prompt.append("產品代碼：").append(request.getProductCode()).append("\n");
        prompt.append("分析類型：").append(request.getAnalysisType()).append("\n");
        
        if (request.getYear() != null) {
            prompt.append("分析年份：").append(request.getYear()).append("\n");
        }
        
        prompt.append("\n請提供：\n");
        
        switch (request.getAnalysisType()) {
            case "comprehensive" -> {
                prompt.append("1. 產品銷售表現分析\n");
                prompt.append("2. 所有產品型號詳細資訊\n");
                prompt.append("3. 市場競爭力評估\n");
                prompt.append("4. 改進建議和策略\n");
            }
            case "sales" -> {
                prompt.append("1. 詳細銷售資料分析\n");
                prompt.append("2. 銷售趨勢和模式\n");
                prompt.append("3. 市場占有率分析\n");
            }
            case "product" -> {
                prompt.append("1. 產品型號完整資訊\n");
                prompt.append("2. 規格和定價分析\n");
                prompt.append("3. 產品線優化建議\n");
            }
        }
        
        return prompt.toString();
    }
}
```

### 請求和回應 DTO

```java
package com.example.dto;

import lombok.Data;
import lombok.Builder;
import java.time.LocalDateTime;

@Data
public class ProductAnalysisRequest {
    private String productCode;
    private String analysisType;  // comprehensive, sales, product
    private Integer year;
    private String focusArea;
}

@Data
@Builder
public class ProductAnalysisResponse {
    private boolean success;
    private String productCode;
    private String analysisType;
    private String analysis;
    private Long executionTime;
    private String error;
    private LocalDateTime timestamp;
}
```

---

## 5.8.4 實際工具鏈應用場景

### 場景 1：複雜銷售分析

**用戶查詢**：「請告訴我 2023 年最熱銷的產品，並列出該產品所有型號的詳細規格和價格」

**工具鏈執行流程**：

```
1. 🔍 EnhancedSalesTools.getProductSalesRanking(2023)
   → 獲取 2023 年銷售排行
   → 識別最熱銷產品：PD-1385 智能手錶系列

2. 📋 ProductDetailsTools.getProductModels("PD-1385")
   → 獲取 PD-1385 的所有型號
   → 返回：1385-1, 1385-2, 1385-3, 1385-4

3. 🔎 ProductDetailsTools.getModelSpecifications("PD-1385", "1385-1")
   → 獲取型號 1385-1 的詳細規格

4. 🔎 ProductDetailsTools.getModelSpecifications("PD-1385", "1385-2")
   → 獲取型號 1385-2 的詳細規格

5. 🔎 ProductDetailsTools.getModelSpecifications("PD-1385", "1385-3")
   → 獲取型號 1385-3 的詳細規格

6. 🔎 ProductDetailsTools.getModelSpecifications("PD-1385", "1385-4")
   → 獲取型號 1385-4 的詳細規格

7. 🧠 AI 整合分析
   → 生成完整的分析報告
```

**AI 回應範例**：

```
📊 **2023年最熱銷產品分析報告**

🏆 **最佳銷售產品**
- 產品：PD-1385 智能手錶系列
- 銷售量：15,000 台
- 營收：NT$ 3.0億
- 市場占有率：35.7%

📱 **產品型號完整資訊**

**1. 智能手錶 1385-1**
- 規格：41mm, GPS, 心率監測
- 價格：NT$ 12,900
- 定位：入門款，適合日常使用

**2. 智能手錶 1385-2**
- 規格：45mm, GPS, 心率監測, 血氧檢測
- 價格：NT$ 15,900
- 定位：進階款，增加健康監測功能

**3. 智能手錶 1385-3**
- 規格：41mm, GPS+Cellular, 心率監測, 血氧檢測
- 價格：NT$ 18,900
- 定位：獨立通訊款，支援獨立通話

**4. 智能手錶 1385-4**
- 規格：45mm, GPS+Cellular, 心率監測, 血氧檢測, ECG
- 價格：NT$ 22,900
- 定位：旗艦款，完整健康監測功能

💡 **商業洞察**
- 智能手錶市場需求強勁，占公司總銷量超過1/3
- 產品線完整，從入門到旗艦都有覆蓋
- 健康監測功能是主要賣點
- 建議加強運動和健康生態系統整合
```

### 場景 2：競品比較分析

**用戶查詢**：「比較 PD-1405 和 PD-1234 在 2024 年的銷售表現，並分析各自的產品優勢」

**工具鏈執行流程**：

```
1. 📊 EnhancedSalesTools.compareProductPerformance(2024, ["PD-1405", "PD-1234"])
   → 比較兩個產品的 2024 年銷售表現

2. 📋 ProductDetailsTools.getProductModels("PD-1405")
   → 獲取 PD-1405 產品詳情和型號

3. 📋 ProductDetailsTools.getProductModels("PD-1234")
   → 獲取 PD-1234 產品詳情和型號

4. 🧮 CalculatorTools.calculate(...)
   → 計算相關統計數據

5. 🧠 AI 綜合分析
   → 生成競品比較報告
```

---

## 📝 本章重點回顧

1. **工具鏈調用掌握**：學會了 AI 自動進行多層次工具調用的機制
2. **複雜工具設計**：實現了支援鏈式調用的進階工具系統
3. **智能協調系統**：建立了工具間的智能協調和資料流轉
4. **效能優化策略**：掌握了工具鏈的效能優化和成本控制
5. **企業級應用**：展示了真實的企業工具鏈應用場景

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **工具鏈調用** | ⭐⭐⭐ | 高 | 複雜業務流程 |
| **智能協調** | ⭐⭐⭐ | 高 | 企業級應用 |
| **效能優化** | ⭐⭐ | 中 | 生產環境 |
| **錯誤處理** | ⭐⭐ | 中 | 穩定性保證 |
| **監控追蹤** | ⭐⭐ | 高 | 運維管理 |
| **成本控制** | ⭐ | 中 | 商業應用 |

### 工具鏈設計原則

**1. 單一職責原則**
- 每個工具專注於特定功能
- 避免工具功能重疊
- 保持工具介面簡潔

**2. 鏈式調用優化**
- 設計合理的資料流轉
- 避免不必要的重複調用
- 實現智能的工具選擇

**3. 錯誤處理策略**
- 優雅的降級機制
- 完整的錯誤日誌
- 使用者友善的錯誤訊息

### 企業應用價值

**1. 降低開發成本**
- 🔧 **模組化設計**：工具可重複使用和組合
- ⚡ **快速開發**：新功能通過工具組合快速實現
- 🛠️ **易於維護**：單一工具的修改不影響其他功能

**2. 提升用戶體驗**
- 🗣️ **自然互動**：用戶用自然語言描述複雜需求
- 🎯 **精準回應**：AI 自動選擇最佳工具組合
- 📊 **深度分析**：提供比傳統 BI 更深入的洞察

**3. 擴展業務能力**
- 🚀 **無限擴展**：新工具可無縫整合到現有系統
- 🔄 **靈活組合**：根據業務需求動態組合工具
- 💡 **創新應用**：AI 可發現人類未想到的工具組合方式

### 下一步學習方向

恭喜您完成了 Function Calling 的完整學習！接下來我們將進入更進階的主題，學習如何讓 ChatBot 擁有記憶能力，建立真正智能的對話系統。

---

**參考資料：**
- [Spring AI Advanced Tool Calling](https://docs.spring.io/spring-ai/reference/api/tools.html)
- [AI Agent Design Patterns](https://www.anthropic.com/research/constitutional-ai-harmlessness-from-ai-feedback)
- [Enterprise AI Tool Integration](https://www.mckinsey.com/capabilities/quantumblack/our-insights/the-age-of-ai)
- [Function Calling Best Practices](https://platform.openai.com/docs/guides/function-calling)


\newpage

## 5.9 取得實際氣象資訊


> **本章重點**：學習如何整合真實的第三方 API 資料，透過 Function Calling 讓 AI 能夠獲取即時的氣象資訊，建立完整的天氣查詢和分析系統。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **整合第三方 API**：學會如何整合中央氣象局等真實 API 服務
- 🎯 **實現即時資料查詢**：讓 AI 能夠獲取最新的氣象資訊
- 🎯 **設計天氣工具系統**：建立完整的天氣查詢和分析工具
- 🎯 **處理 API 異常**：掌握第三方 API 的錯誤處理和容錯機制
- 🎯 **優化查詢效能**：實現快取和批次查詢優化策略

---

## 5.9.1 真實 API 整合的重要性

### 有了 AI 寫程式都可以偷懶

![AI Development](https://example.com/ai-development.jpg)

還記得前面提到要取得即時資訊只能透過 Function Calling 嗎？網路上一堆教學都使用模擬資料，今天來教大家怎麼抓中央氣象局的資料，並使用最新的 @Tool 註解實現更優雅的 Function Calling。

### 模擬資料 vs 真實資料

| 比較項目 | 模擬資料 | 真實 API 資料 |
|----------|----------|---------------|
| **資料準確性** | 固定不變 | 即時更新 |
| **開發複雜度** | 簡單 | 需要處理 API 整合 |
| **實用價值** | 僅供學習 | 可實際應用 |
| **錯誤處理** | 不需要 | 必須完善處理 |
| **效能考量** | 無限制 | 需要考慮 API 限制 |
| **成本** | 免費 | 可能有使用費用 |

### 真實 API 整合的挑戰

**1. API 限制和配額**
- 📊 **請求頻率限制**：每分鐘/每小時的請求次數限制
- 💰 **使用成本**：超過免費額度後的計費
- 🔑 **認證機制**：API Key 管理和安全性
- ⏰ **回應時間**：網路延遲和 API 處理時間

**2. 資料格式和解析**
- 📋 **複雜的 JSON 結構**：需要深度解析巢狀資料
- 🔄 **資料格式變更**：API 版本更新可能改變格式
- 🌐 **多語言支援**：處理不同語言的資料
- 📏 **單位轉換**：溫度、風速等單位的標準化

**3. 錯誤處理和容錯**
- 🚫 **API 服務中斷**：第三方服務不可用時的處理
- 📡 **網路問題**：連線超時和重試機制
- 🔍 **資料缺失**：部分地區或時間的資料不完整
- ⚠️ **格式錯誤**：API 回傳異常格式的處理

---

## 5.9.2 中央氣象局 API 整合

### 取得中央氣象局開放平台資料

**步驟 1：註冊和取得 API Key**

中央氣象局有個資料開放平台：[https://opendata.cwa.gov.tw/index](https://opendata.cwa.gov.tw/index)

註冊後就能在 **會員資訊－取得授權碼** 拿到自己的授權碼。

![Weather API](https://example.com/weather-api.png)

**步驟 2：選擇合適的資料集**

可以在資料主題找需要的資料，由於我只要抓到目前的氣象資訊，所以選擇 **觀測-現在天氣觀測報告**。

> 💡 **小提示**：最好找有 API 的，不然需要下載檔案再用讀檔的方式處理

**步驟 3：API 測試**

進入後就是 API 常用的 Swagger 網站了。點選 Try it out 輸入授權碼，按下 Execute 就能取得 JSON 資料了。

### 專案配置

**Maven 依賴**：

```xml
<!-- 使用 Spring AI BOM 管理版本 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-bom</artifactId>
            <version>1.0.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <!-- Spring AI OpenAI Starter -->
    <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
        </dependency>
    
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

**應用程式配置**：

```yaml
# application.yml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      chat:
        options:
          model: gpt-4o-mini
          temperature: 0.1

# 中央氣象局 API 配置
cwa:
  api:
    key: ${CWA_API_KEY}  # 中央氣象局 API Key
    base-url: https://opendata.cwa.gov.tw/api/v1/rest/datastore

# 日誌配置
logging:
  level:
    com.example.weather: DEBUG
    org.springframework.ai: DEBUG
```

---

## 5.9.3 天氣服務實現

### 核心天氣服務

```java
package com.example.service;

import com.fasterxml.jackson.databind.JsonNode;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class WeatherService {

    private final RestTemplate restTemplate;
    
    @Value("${cwa.api.key}")
    private String apiKey;
    
    @Value("${cwa.api.base-url:https://opendata.cwa.gov.tw/api/v1/rest/datastore}")
    private String baseUrl;

    /**
     * 取得指定地區的目前天氣資訊
     * @param location 地區名稱
     * @return 天氣資訊
     */
    @Tool(description = "Get current weather information for a specific location in Taiwan. " +
          "Supports major cities and counties like Taipei, Taoyuan, Taichung, Tainan, Kaohsiung, etc.")
    public WeatherInfo getCurrentWeather(String location) {
        try {
            log.info("查詢天氣資訊：{}", location);
            
            String url = baseUrl + "/O-A0003-001?Authorization=" + apiKey;
            
            JsonNode response = restTemplate.getForObject(url, JsonNode.class);
            
            if (response == null || !response.has("records")) {
                return WeatherInfo.error("無法取得天氣資料");
            }
            
            // 解析天氣資料
            JsonNode records = response.get("records");
            JsonNode locations = records.get("location");
            
            if (locations == null || !locations.isArray()) {
                return WeatherInfo.error("天氣資料格式錯誤");
            }
            
            // 尋找指定地區的天氣資料
            for (JsonNode locationNode : locations) {
                String locationName = locationNode.get("locationName").asText();
                
                if (locationName.contains(location) || location.contains(locationName)) {
                    WeatherInfo result = parseWeatherData(locationNode, locationName);
                    log.info("成功取得 {} 的天氣資訊", locationName);
                    return result;
                }
            }
            
            return WeatherInfo.notFound("找不到 " + location + " 的天氣資料，請確認地區名稱是否正確");
            
        } catch (Exception e) {
            log.error("取得天氣資料時發生錯誤: {}", e.getMessage(), e);
            return WeatherInfo.error("取得天氣資料失敗：" + e.getMessage());
        }
    }

    /**
     * 取得全台各地的溫度排行榜
     * @param topCount 排行數量
     * @return 溫度排行
     */
    @Tool(description = "Get temperature ranking for all locations in Taiwan. " +
          "Returns top N locations sorted by temperature.")
    public TemperatureRanking getTemperatureRanking(Integer topCount) {
        if (topCount == null || topCount <= 0) {
            topCount = 10;
        }
        
        try {
            log.info("查詢溫度排行榜：前 {} 名", topCount);
            
            String url = baseUrl + "/O-A0003-001?Authorization=" + apiKey;
            JsonNode response = restTemplate.getForObject(url, JsonNode.class);
            
            if (response == null || !response.has("records")) {
                return TemperatureRanking.error("無法取得天氣資料");
            }
            
            List<LocationTemperature> temperatures = new ArrayList<>();
            JsonNode locations = response.get("records").get("location");
            
            for (JsonNode locationNode : locations) {
                String locationName = locationNode.get("locationName").asText();
                JsonNode weatherElements = locationNode.get("weatherElement");
                
                Double temp = extractTemperature(weatherElements);
                if (temp != null) {
                    temperatures.add(new LocationTemperature(locationName, temp));
                }
            }
            
            // 按溫度排序並取前 N 名
            List<LocationTemperature> topTemperatures = temperatures.stream()
                    .sorted((a, b) -> Double.compare(b.temperature(), a.temperature()))
                    .limit(topCount)
                    .toList();
            
            log.info("成功取得溫度排行榜：{} 個地點", topTemperatures.size());
            
            return new TemperatureRanking(
                    topTemperatures,
                    true,
                    null,
                    LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
            );
            
        } catch (Exception e) {
            log.error("取得溫度排行時發生錯誤: {}", e.getMessage(), e);
            return TemperatureRanking.error("取得溫度排行失敗：" + e.getMessage());
        }
    }

    /**
     * 取得天氣預報資訊
     * @param location 地區名稱
     * @param days 預報天數
     * @return 天氣預報
     */
    @Tool(description = "Get weather forecast for a specific location. " +
          "Provides multi-day weather forecast including temperature and conditions.")
    public WeatherForecast getWeatherForecast(String location, Integer days) {
        if (days == null || days <= 0) {
            days = 3;
        }
        
        try {
            log.info("查詢天氣預報：{}，{} 天", location, days);
            
            // 這裡可以整合預報 API
            // 目前先返回模擬資料
            List<DailyForecast> forecasts = generateMockForecast(location, days);
            
            return new WeatherForecast(
                    location,
                    forecasts,
                    true,
                    null
            );
            
        } catch (Exception e) {
            log.error("取得天氣預報時發生錯誤: {}", e.getMessage(), e);
            return WeatherForecast.error("取得天氣預報失敗：" + e.getMessage());
        }
    }
    
    /**
     * 解析天氣資料
     */
    private WeatherInfo parseWeatherData(JsonNode locationNode, String locationName) {
        try {
            JsonNode weatherElements = locationNode.get("weatherElement");
            
            Double temperature = extractTemperature(weatherElements);
            Double humidity = extractHumidity(weatherElements);
            String weather = extractWeatherDescription(weatherElements);
            Double rainfall = extractRainfall(weatherElements);
            String windDirection = extractWindDirection(weatherElements);
            Double windSpeed = extractWindSpeed(weatherElements);
            
            return new WeatherInfo(
                    locationName,
                    temperature,
                    humidity,
                    weather,
                    rainfall,
                    windDirection,
                    windSpeed,
                    true,
                    null,
                    LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
            );
            
        } catch (Exception e) {
            log.error("解析天氣資料失敗", e);
            return WeatherInfo.error("解析天氣資料失敗：" + e.getMessage());
        }
    }
    
    private Double extractTemperature(JsonNode weatherElements) {
        return extractElementValue(weatherElements, "TEMP");
    }
    
    private Double extractHumidity(JsonNode weatherElements) {
        return extractElementValue(weatherElements, "HUMD");
    }
    
    private Double extractRainfall(JsonNode weatherElements) {
        return extractElementValue(weatherElements, "24R");
    }
    
    private Double extractWindSpeed(JsonNode weatherElements) {
        return extractElementValue(weatherElements, "WDSD");
    }
    
    private String extractWeatherDescription(JsonNode weatherElements) {
        JsonNode element = findWeatherElement(weatherElements, "Weather");
        if (element != null && element.has("elementValue")) {
            return element.get("elementValue").asText();
        }
        return null;
    }
    
    private String extractWindDirection(JsonNode weatherElements) {
        JsonNode element = findWeatherElement(weatherElements, "WDIR");
        if (element != null && element.has("elementValue")) {
            return element.get("elementValue").asText();
        }
        return null;
    }
    
    private Double extractElementValue(JsonNode weatherElements, String elementName) {
        JsonNode element = findWeatherElement(weatherElements, elementName);
        if (element != null && element.has("elementValue")) {
            try {
                return element.get("elementValue").asDouble();
            } catch (Exception e) {
                log.warn("無法解析 {} 的數值", elementName);
            }
        }
        return null;
    }
    
    private JsonNode findWeatherElement(JsonNode weatherElements, String elementName) {
        if (weatherElements != null && weatherElements.isArray()) {
            for (JsonNode element : weatherElements) {
                if (element.has("elementName") && 
                    elementName.equals(element.get("elementName").asText())) {
                    return element;
                }
            }
        }
        return null;
    }
    
    private List<DailyForecast> generateMockForecast(String location, int days) {
        List<DailyForecast> forecasts = new ArrayList<>();
        for (int i = 0; i < days; i++) {
            forecasts.add(new DailyForecast(
                    LocalDateTime.now().plusDays(i).toLocalDate().toString(),
                    "晴時多雲",
                    25.0 + i,
                    30.0 + i,
                    20.0 + i,
                    60.0
            ));
        }
        return forecasts;
    }
}
```

### 資料模型定義

```java
package com.example.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;

import java.util.List;

/**
 * 天氣資訊資料類別
 */
public record WeatherInfo(
        @JsonProperty("location") String location,
        @JsonProperty("temperature") Double temperature,
        @JsonProperty("humidity") Double humidity,
        @JsonProperty("weather") String weather,
        @JsonProperty("rainfall") Double rainfall,
        @JsonProperty("wind_direction") String windDirection,
        @JsonProperty("wind_speed") Double windSpeed,
        @JsonProperty("success") boolean success,
        @JsonProperty("error") String error,
        @JsonProperty("observation_time") String observationTime
) {
    public static WeatherInfo error(String message) {
        return new WeatherInfo(null, null, null, null, null, null, null,
                false, message, null);
    }
    
    public static WeatherInfo notFound(String message) {
        return new WeatherInfo(null, null, null, null, null, null, null,
                false, message, null);
    }
    
    @Override
    public String toString() {
        if (!success) {
            return "❌ " + error;
        }
        
        StringBuilder sb = new StringBuilder();
        sb.append("📍 地點：").append(location).append("\n");
        sb.append("🌡️ 溫度：").append(temperature != null ? temperature + "°C" : "無資料").append("\n");
        sb.append("💧 濕度：").append(humidity != null ? humidity + "%" : "無資料").append("\n");
        sb.append("☁️ 天氣：").append(weather != null ? weather : "無資料").append("\n");
        sb.append("🌧️ 降雨量：").append(rainfall != null ? rainfall + "mm" : "無資料").append("\n");
        sb.append("💨 風向：").append(windDirection != null ? windDirection : "無資料").append("\n");
        sb.append("🌪️ 風速：").append(windSpeed != null ? windSpeed + "m/s" : "無資料").append("\n");
        sb.append("⏰ 觀測時間：").append(observationTime);
        
        return sb.toString();
    }
}

/**
 * 溫度排行資料
 */
public record TemperatureRanking(
        List<LocationTemperature> rankings,
        boolean success,
        String error,
        String updateTime
) {
    public static TemperatureRanking error(String message) {
        return new TemperatureRanking(List.of(), false, message, null);
    }
}

public record LocationTemperature(
        String location,
        Double temperature
) {}

/**
 * 天氣預報資料
 */
public record WeatherForecast(
        String location,
        List<DailyForecast> forecasts,
        boolean success,
        String error
) {
    public static WeatherForecast error(String message) {
        return new WeatherForecast(null, List.of(), false, message);
    }
}

public record DailyForecast(
        String date,
        String weather,
        Double temperature,
        Double maxTemperature,
        Double minTemperature,
        Double humidity
) {}
```

---

## 5.9.4 天氣查詢控制器

### REST API 控制器

```java
package com.example.controller;

import com.example.model.WeatherInfo;
import com.example.model.TemperatureRanking;
import com.example.service.WeatherService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/weather")
@RequiredArgsConstructor
@Slf4j
public class WeatherController {

    private final ChatClient chatClient;
    private final WeatherService weatherService;

    /**
     * AI 天氣查詢
     * @param question 天氣查詢問題
     * @return AI 回應
     */
    @GetMapping("/chat")
    public ResponseEntity<WeatherChatResponse> chatWeather(@RequestParam String question) {
        
        try {
            log.info("收到天氣查詢：{}", question);
            
            String response = chatClient
                    .prompt(question)
                    .tools(weatherService)
                    .call()
                    .content();
            
            WeatherChatResponse chatResponse = new WeatherChatResponse(
                    question,
                    response,
                    true,
                    null,
                    System.currentTimeMillis()
            );
            
            return ResponseEntity.ok(chatResponse);
            
        } catch (Exception e) {
            log.error("天氣查詢失敗: {}", e.getMessage(), e);
            
            WeatherChatResponse errorResponse = new WeatherChatResponse(
                    question,
                    null,
                    false,
                    "天氣查詢失敗：" + e.getMessage(),
                    System.currentTimeMillis()
            );
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(errorResponse);
        }
    }

    /**
     * 直接取得天氣資訊
     * @param location 地點名稱
     * @return 天氣資訊
     */
    @GetMapping("/current")
    public ResponseEntity<WeatherInfo> getCurrentWeather(@RequestParam String location) {
        
        WeatherInfo weatherInfo = weatherService.getCurrentWeather(location);
        
        if (weatherInfo.success()) {
            return ResponseEntity.ok(weatherInfo);
        } else {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(weatherInfo);
        }
    }

    /**
     * 取得溫度排行榜
     * @param topCount 排行數量
     * @return 溫度排行
     */
    @GetMapping("/temperature-ranking")
    public ResponseEntity<TemperatureRanking> getTemperatureRanking(
            @RequestParam(defaultValue = "10") Integer topCount) {
        
        TemperatureRanking ranking = weatherService.getTemperatureRanking(topCount);
        return ResponseEntity.ok(ranking);
    }

    /**
     * 天氣查詢回應
     */
    public record WeatherChatResponse(
            String question,
            String answer,
            boolean success,
            String error,
            long timestamp
    ) {}
}
```

---

## 5.9.5 簡化配置

### 基本配置類

```java
package com.example.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class WeatherApiConfig {

    /**
     * 天氣 API 專用的 RestTemplate
     */
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

---

## 5.9.6 測試應用

### 測試天氣查詢

**基本 API 測試**：

```bash
# 基本天氣查詢
curl "http://localhost:8080/api/weather/chat?question=桃園目前天氣如何？"

# 溫度排行查詢
curl "http://localhost:8080/api/weather/chat?question=全台最高溫的前三名是哪些地方？"

# 天氣預報查詢
curl "http://localhost:8080/api/weather/chat?question=台中未來三天天氣預報"

# 直接 API 調用
curl "http://localhost:8080/api/weather/current?location=台北"

# 溫度排行榜
curl "http://localhost:8080/api/weather/temperature-ranking?topCount=5"
```

**回應範例**：

```json
{
  "question": "桃園目前天氣如何？",
  "answer": "📍 地點：桃園\n🌡️ 溫度：28.5°C\n💧 濕度：72%\n☁️ 天氣：多雲\n🌧️ 降雨量：0.0mm\n💨 風向：東南風\n🌪️ 風速：2.3m/s\n⏰ 觀測時間：2025-01-29 14:30",
  "success": true,
  "error": null,
  "timestamp": 1706518200000
}
```

### 進階功能測試

**多地點比較查詢**：

```
用戶：「比較台北、台中、高雄三個城市的天氣狀況」

AI 回應：
🌤️ **三大城市天氣比較**

📍 **台北**
🌡️ 溫度：26.8°C
💧 濕度：78%
☁️ 天氣：陰天

📍 **台中**
🌡️ 溫度：29.2°C
💧 濕度：65%
☁️ 天氣：晴時多雲

📍 **高雄**
🌡️ 溫度：31.5°C
💧 濕度：70%
☁️ 天氣：晴天

📊 **分析總結**
- 🔥 最熱：高雄 (31.5°C)
- 🌡️ 最涼：台北 (26.8°C)
- 💧 最潮濕：台北 (78%)
- ☀️ 天氣最佳：高雄
```

**智能建議查詢**：

```
用戶：「明天要去台中，需要帶雨具嗎？」

AI 回應：
🌦️ **台中明天天氣建議**

📅 **明天天氣預報**
🌡️ 溫度：25-30°C
☁️ 天氣：晴時多雲
🌧️ 降雨機率：20%
💨 風力：微風

☂️ **攜帶建議**
✅ 建議攜帶輕便雨具
- 雖然降雨機率不高，但午後可能有局部陣雨
- 可準備摺疊傘以備不時之需
- 穿著輕薄透氣的衣物即可

🎯 **出行建議**
- 適合戶外活動
- 注意防曬
- 多補充水分
```

---

## 📝 本章重點回顧

1. **真實 API 整合**：學會了整合中央氣象局等第三方 API 服務
2. **即時資料查詢**：實現了 AI 獲取最新氣象資訊的能力
3. **Tool Calling 應用**：建立了天氣查詢和分析的 AI 工具
4. **資料解析處理**：掌握了 JSON 資料的解析和轉換技術
5. **AI 智能分析**：實現了基於真實資料的智能天氣分析

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **第三方 API 整合** | ⭐⭐⭐ | 中 | 所有即時資料應用 |
| **資料解析處理** | ⭐⭐⭐ | 中 | API 資料處理 |
| **Tool Calling** | ⭐⭐⭐ | 中 | AI 工具整合 |
| **JSON 處理** | ⭐⭐ | 低 | 資料轉換 |
| **錯誤處理** | ⭐⭐ | 中 | 系統穩定性 |

### 最佳實踐建議

**1. API 使用策略**
- 🔑 **安全管理**：妥善保管 API Key，使用環境變數
- 📊 **配額監控**：監控 API 使用量，避免超過限制
- 🛡️ **錯誤處理**：對 API 調用失敗進行適當的錯誤處理

**2. 資料處理優化**
- 🎯 **精確解析**：仔細處理 JSON 結構，避免解析錯誤
- 🛡️ **防禦性編程**：對所有可能的空值和異常進行處理
- 📏 **單位標準化**：統一溫度、風速等單位的表示方式

**3. AI 工具設計**
- 💬 **清晰描述**：為 @Tool 註解提供清晰的功能描述
- 📊 **結構化回應**：提供清晰、易讀的天氣資訊格式
- 🎨 **視覺化展示**：使用表情符號和格式化增強可讀性
- 💡 **智能建議**：基於天氣資訊提供實用的生活建議

### 企業應用價值

**1. 商業應用場景**
- 🏢 **企業決策支援**：為戶外作業、物流配送提供天氣資訊
- 📱 **移動應用整合**：為 App 提供即時天氣查詢功能
- 🤖 **智能客服**：在客服系統中整合天氣查詢能力
- 📊 **資料分析平台**：將天氣資料納入商業分析模型

**2. 技術架構優勢**
- 🔧 **模組化設計**：天氣服務可獨立部署和擴展
- 🚀 **AI 工具整合**：透過 Tool Calling 實現智能天氣分析
- 📈 **即時資料存取**：獲取最新的氣象資訊
- 🔄 **易於維護**：清晰的代碼結構和錯誤處理

### 下一步學習方向

在下一章中，我們將學習結構化資料轉換器，探索如何讓 AI 輸出結構化的資料格式，為企業應用提供更標準化的資料介面。

---

**參考資料：**
- [中央氣象局開放資料平台](https://opendata.cwa.gov.tw/index)
- [Spring AI Tool Calling Documentation](https://docs.spring.io/spring-ai/reference/api/tools.html)


\newpage

## 5.10 結構化資料轉換器


> **本章重點**：學習 Spring AI 的結構化資料轉換技術，掌握如何讓 AI 輸出標準化的資料格式，建立企業級的資料處理和整合系統。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解結構化輸出**：掌握 AI 結構化資料輸出的重要性和應用場景
- 🎯 **使用現代化 API**：學會使用 ChatClient 的 entity() 方法進行類型轉換
- 🎯 **掌握傳統轉換器**：了解 BeanOutputConverter、MapOutputConverter 等轉換器
- 🎯 **設計資料模型**：建立適合 AI 輸出的 Java 資料結構
- 🎯 **企業級應用**：實現可用於生產環境的結構化資料處理系統

---

## 5.10.1 結構化輸出的重要性

### Spring 很注重一致性

![Spring 一致性](https://ithelp.ithome.com.tw/upload/images/20240814/20161290CYmKc1rZYz.png)

先說個題外話，Spring AI 1.1 在結構化輸出方面有了重大改進！不僅保留了原有的 `StructuredOutputConverter`，還在 ChatClient 中新增了更簡潔的 `entity()` 方法，讓開發者有更多選擇。

### Converter 就是將 JSON 轉為 Java 的結構

對程式而言，要看懂 ChatGPT 回應的文字並不容易，所以 OpenAI 也提供了許多方式將回應轉為不同型態，JSON、XML 或是 Markdown 的語法，最近 OpenAI 還更新了新的功能，透過強制約束，讓 OpenAI 的輸出可以與定義的 JSON 格式完全一致，有了這功能後進行外部系統整合才能讓失誤率降到最低。

### 結構化輸出的核心價值

**1. 系統整合的必要性**
- 🔗 **API 整合**：與其他系統進行資料交換時需要標準格式
- 📊 **資料處理**：程式需要結構化資料才能進行邏輯處理
- 🎯 **類型安全**：強型別語言需要明確的資料結構
- 🔄 **自動化流程**：結構化資料可以觸發後續的自動化處理

**2. 傳統文字 vs 結構化資料**

| 比較項目 | 傳統文字回應 | 結構化資料 |
|----------|-------------|------------|
| **可讀性** | 人類友善 | 程式友善 |
| **處理難度** | 需要解析 | 直接使用 |
| **準確性** | 容易出錯 | 格式保證 |
| **整合性** | 困難 | 容易 |
| **維護性** | 複雜 | 簡單 |
| **擴展性** | 受限 | 靈活 |

**3. Spring AI 1.1 的改進**

Spring AI 1.1 在這方面有了顯著的改進，現在提供了兩種主要方式來處理結構化輸出：

1. **傳統的 StructuredOutputConverter** - 需要手動處理格式描述
2. **新的 ChatClient entity() 方法** - 自動處理類型轉換

![轉換器架構](https://ithelp.ithome.com.tw/upload/images/20240814/201612906iIB5Aaeg3.jpg)

---

## 5.10.2 三種轉換器的用途

### 轉換器類型概覽

Spring AI 目前提供的轉換器有三個 `BeanOutputConverter`、`MapOutputConverter` 和 `ListOutputConverter`（抽象類別就不看了）

![轉換器類型](https://ithelp.ithome.com.tw/upload/images/20240814/20161290XuAnAxIQer.jpg)

### 各轉換器詳細說明

**1. BeanOutputConverter**
- 🎯 **用途**：AI 產生的格式化資料主要以 JSON 為主，這個轉換器就是將 JSON 轉為 Java 程式需要的 Bean
- 🔧 **技術實現**：背後用到的就是 Spring MVC 最常用到的 ObjectMapper
- 📋 **適用場景**：複雜的資料結構、企業級應用、需要強型別的場合
- ✅ **優勢**：類型安全、IDE 支援、易於維護

**2. MapOutputConverter**
- 🎯 **用途**：這個轉換器是將資料使用 Map 的方式轉出，對未知的格式最常使用的處理方式
- 🔧 **技術實現**：將 JSON 轉換為 Map<String, Object> 結構
- 📋 **適用場景**：動態資料結構、探索性開發、快速原型
- ✅ **優勢**：靈活性高、無需預定義結構、快速開發

**3. ListOutputConverter**
- 🎯 **用途**：這個轉換器顧名思義就是將結果轉為 List，不過這裡主要以字串的 List 為主
- 🔧 **技術實現**：解析 AI 回應中的列表項目
- 📋 **適用場景**：簡單列表資料、選項清單、標籤集合
- ✅ **優勢**：簡單直接、處理效率高、記憶體佔用少

**使用建議**：
- 例如請 AI 提供最受歡迎的五種冰淇淋口味，若是結構化的複數資料則還是使用 `BeanOutputConverter` 進行轉換，只是將 Bean 的類別改為 `ParameterizedTypeReference`

---

## 5.10.3 現代化 API 實現

### 方法一：使用 ChatClient entity() 方法（推薦）

Spring AI 1.1 新增的 `entity()` 方法是最簡潔的方式，它會自動處理類型轉換：

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/structured")
@RequiredArgsConstructor
@Slf4j
public class StructuredOutputController {
    
    private final ChatClient chatClient;
    
    /**
     * 單一演員的電影作品
     * @param actor 演員名稱
     * @return 演員電影作品
     */
    @GetMapping("/actor-films")
    public ActorsFilms getActorFilms(@RequestParam String actor) {
        try {
            log.info("查詢演員電影作品：{}", actor);
            
            ActorsFilms result = chatClient.prompt()
                    .user("Generate the filmography of 5 movies for {actor}. " +
                          "Please provide the response in JSON format with 'actor' and 'movies' fields.", 
                          Map.of("actor", actor))
                    .call()
                    .entity(ActorsFilms.class);
            
            log.info("成功取得 {} 的電影作品，共 {} 部電影", 
                    result.actor(), result.movies().size());
            
            return result;
            
        } catch (Exception e) {
            log.error("查詢演員電影作品失敗：{}", actor, e);
            return new ActorsFilms(actor, List.of("查詢失敗：" + e.getMessage()));
        }
    }
    
    /**
     * 多位演員的電影作品
     * @return 多位演員的電影作品列表
     */
    @GetMapping("/multiple-actors")
    public List<ActorsFilms> getMultipleActors() {
        try {
            log.info("查詢多位演員電影作品");
            
            List<ActorsFilms> results = chatClient.prompt()
                    .user("Generate the filmography of 5 movies each for Tom Hanks and Bill Murray. " +
                          "Please provide the response as a JSON array with each object containing 'actor' and 'movies' fields.")
                    .call()
                    .entity(new ParameterizedTypeReference<List<ActorsFilms>>() {});
            
            log.info("成功取得 {} 位演員的電影作品", results.size());
            
            return results;
            
        } catch (Exception e) {
            log.error("查詢多位演員電影作品失敗", e);
            return List.of(
                new ActorsFilms("Tom Hanks", List.of("查詢失敗：" + e.getMessage())),
                new ActorsFilms("Bill Murray", List.of("查詢失敗：" + e.getMessage()))
            );
        }
    }
    
    /**
     * 電影資訊查詢
     * @param movieTitle 電影標題
     * @return 電影詳細資訊
     */
    @GetMapping("/movie-info")
    public MovieInfo getMovieInfo(@RequestParam String movieTitle) {
        try {
            log.info("查詢電影資訊：{}", movieTitle);
            
            MovieInfo result = chatClient.prompt()
                    .user("Provide detailed information about the movie '{movieTitle}'. " +
                          "Include title, director, year, genre, rating, and a brief plot summary. " +
                          "Format the response as JSON.", 
                          Map.of("movieTitle", movieTitle))
                    .call()
                    .entity(MovieInfo.class);
            
            log.info("成功取得電影資訊：{} ({})", result.title(), result.year());
            
            return result;
            
        } catch (Exception e) {
            log.error("查詢電影資訊失敗：{}", movieTitle, e);
            return new MovieInfo(
                    movieTitle,
                    "未知",
                    0,
                    "未知",
                    0.0,
                    "查詢失敗：" + e.getMessage()
            );
        }
    }
    
    /**
     * 產品推薦列表
     * @param category 產品類別
     * @param count 推薦數量
     * @return 產品推薦列表
     */
    @GetMapping("/product-recommendations")
    public ProductRecommendations getProductRecommendations(
            @RequestParam String category,
            @RequestParam(defaultValue = "5") int count) {
        
        try {
            log.info("查詢產品推薦：類別={}，數量={}", category, count);
            
            ProductRecommendations result = chatClient.prompt()
                    .user("Recommend {count} popular {category} products. " +
                          "For each product, provide name, brand, price, rating, and description. " +
                          "Format as JSON with 'category', 'count', and 'products' array.",
                          Map.of("count", count, "category", category))
                    .call()
                    .entity(ProductRecommendations.class);
            
            log.info("成功取得 {} 類別的 {} 個產品推薦", 
                    result.category(), result.products().size());
            
            return result;
            
        } catch (Exception e) {
            log.error("查詢產品推薦失敗：類別={}", category, e);
            return new ProductRecommendations(
                    category,
                    0,
                    List.of(),
                    "查詢失敗：" + e.getMessage()
            );
        }
    }
}
```

### 資料模型定義

```java
package com.example.model;

import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.List;

/**
 * 演員電影作品
 */
public record ActorsFilms(
        @JsonProperty("actor") String actor,
        @JsonProperty("movies") List<String> movies
) {}

/**
 * 電影資訊
 */
public record MovieInfo(
        @JsonProperty("title") String title,
        @JsonProperty("director") String director,
        @JsonProperty("year") int year,
        @JsonProperty("genre") String genre,
        @JsonProperty("rating") double rating,
        @JsonProperty("plot") String plot
) {}

/**
 * 產品資訊
 */
public record Product(
        @JsonProperty("name") String name,
        @JsonProperty("brand") String brand,
        @JsonProperty("price") double price,
        @JsonProperty("rating") double rating,
        @JsonProperty("description") String description
) {}

/**
 * 產品推薦列表
 */
public record ProductRecommendations(
        @JsonProperty("category") String category,
        @JsonProperty("count") int count,
        @JsonProperty("products") List<Product> products,
        @JsonProperty("error") String error
) {
    public ProductRecommendations(String category, int count, List<Product> products) {
        this(category, count, products, null);
    }
}

/**
 * 企業資料分析結果
 */
public record BusinessAnalysis(
        @JsonProperty("summary") String summary,
        @JsonProperty("key_metrics") List<KeyMetric> keyMetrics,
        @JsonProperty("recommendations") List<String> recommendations,
        @JsonProperty("risk_factors") List<String> riskFactors,
        @JsonProperty("confidence_score") double confidenceScore
) {}

public record KeyMetric(
        @JsonProperty("name") String name,
        @JsonProperty("value") String value,
        @JsonProperty("trend") String trend,
        @JsonProperty("importance") String importance
) {}
```

---

## 5.10.4 傳統轉換器實現

### 方法二：使用傳統的 StructuredOutputConverter

如果你需要更多控制權，仍可以使用傳統的轉換器：

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.converter.BeanOutputConverter;
import org.springframework.ai.converter.ListOutputConverter;
import org.springframework.ai.converter.MapOutputConverter;
import org.springframework.core.convert.support.DefaultConversionService;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/converter")
@RequiredArgsConstructor
@Slf4j
public class ConverterController {
    
    private final ChatClient chatClient;
    
    /**
     * Bean Output Converter 範例
     * @param actor 演員名稱
     * @return 演員電影作品
     */
    @GetMapping("/actor-films-converter")
    public ActorsFilms getActorFilmsWithConverter(@RequestParam String actor) {
        try {
            log.info("使用 BeanOutputConverter 查詢演員電影作品：{}", actor);
            
            BeanOutputConverter<ActorsFilms> beanOutputConverter = 
                    new BeanOutputConverter<>(ActorsFilms.class);
            String format = beanOutputConverter.getFormat();
            
            log.debug("轉換器格式：{}", format);
            
            String response = chatClient.prompt()
                    .user("Generate the filmography of 5 movies for {actor}. {format}", 
                          Map.of("actor", actor, "format", format))
                    .call()
                    .content();
            
            log.debug("AI 回應：{}", response);
            
            ActorsFilms result = beanOutputConverter.convert(response);
            
            log.info("成功轉換演員電影作品：{}", result.actor());
            
            return result;
            
        } catch (Exception e) {
            log.error("BeanOutputConverter 查詢失敗：{}", actor, e);
            return new ActorsFilms(actor, List.of("查詢失敗：" + e.getMessage()));
        }
    }
    
    /**
     * Map Output Converter 範例
     * @return 數字資料的 Map 格式
     */
    @GetMapping("/numbers-map")
    public Map<String, Object> getNumbersAsMap() {
        try {
            log.info("使用 MapOutputConverter 查詢數字資料");
            
            MapOutputConverter mapOutputConverter = new MapOutputConverter();
            String format = mapOutputConverter.getFormat();
            
            log.debug("轉換器格式：{}", format);
            
            String response = chatClient.prompt()
                    .user("Provide interesting statistics about the number 42. {format}", 
                          Map.of("format", format))
                    .call()
                    .content();
            
            log.debug("AI 回應：{}", response);
            
            Map<String, Object> result = mapOutputConverter.convert(response);
            
            log.info("成功轉換為 Map，包含 {} 個鍵值對", result.size());
            
            return result;
            
        } catch (Exception e) {
            log.error("MapOutputConverter 查詢失敗", e);
            return Map.of("error", "查詢失敗：" + e.getMessage());
        }
    }
    
    /**
     * List Output Converter 範例
     * @param category 類別
     * @param count 數量
     * @return 項目列表
     */
    @GetMapping("/items-list")
    public List<String> getItemsList(
            @RequestParam String category,
            @RequestParam(defaultValue = "5") int count) {
        
        try {
            log.info("使用 ListOutputConverter 查詢項目列表：類別={}，數量={}", category, count);
            
            ListOutputConverter listOutputConverter = 
                    new ListOutputConverter(new DefaultConversionService());
            String format = listOutputConverter.getFormat();
            
            log.debug("轉換器格式：{}", format);
            
            String response = chatClient.prompt()
                    .user("List {count} popular {category} items. {format}",
                          Map.of("count", count, "category", category, "format", format))
                    .call()
                    .content();
            
            log.debug("AI 回應：{}", response);
            
            List<String> result = listOutputConverter.convert(response);
            
            log.info("成功轉換為列表，包含 {} 個項目", result.size());
            
            return result;
            
        } catch (Exception e) {
            log.error("ListOutputConverter 查詢失敗：類別={}", category, e);
            return List.of("查詢失敗：" + e.getMessage());
        }
    }
    
    /**
     * 複雜業務分析（使用 BeanOutputConverter）
     * @param businessData 業務資料
     * @return 分析結果
     */
    @PostMapping("/business-analysis")
    public BusinessAnalysis analyzeBusinessData(@RequestBody String businessData) {
        try {
            log.info("使用 BeanOutputConverter 進行業務分析");
            
            BeanOutputConverter<BusinessAnalysis> converter = 
                    new BeanOutputConverter<>(BusinessAnalysis.class);
            String format = converter.getFormat();
            
            String response = chatClient.prompt()
                    .user("Analyze the following business data and provide insights: \n{data}\n\n" +
                          "Please provide a comprehensive analysis including summary, key metrics, " +
                          "recommendations, risk factors, and confidence score. {format}",
                          Map.of("data", businessData, "format", format))
                    .call()
                    .content();
            
            BusinessAnalysis result = converter.convert(response);
            
            log.info("業務分析完成，信心分數：{}", result.confidenceScore());
            
            return result;
            
        } catch (Exception e) {
            log.error("業務分析失敗", e);
            return new BusinessAnalysis(
                    "分析失敗：" + e.getMessage(),
                    List.of(),
                    List.of(),
                    List.of("系統錯誤"),
                    0.0
            );
        }
    }
}
```

---

## 5.10.5 企業級應用場景

### 資料分析平台整合

```java
package com.example.service;

import com.example.model.BusinessAnalysis;
import com.example.model.ProductRecommendations;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
@Slf4j
public class StructuredAnalysisService {
    
    private final ChatClient chatClient;
    
    /**
     * 銷售資料分析
     * @param salesData 銷售資料
     * @return 結構化分析結果
     */
    public SalesAnalysisResult analyzeSalesData(Map<String, Object> salesData) {
        try {
            log.info("開始銷售資料分析");
            
            SalesAnalysisResult result = chatClient.prompt()
                    .system("你是一個專業的銷售資料分析師，請提供準確且結構化的分析結果。")
                    .user("分析以下銷售資料並提供洞察：\n{data}\n\n" +
                          "請提供結構化的分析，包括：\n" +
                          "1. 銷售趨勢分析\n" +
                          "2. 產品表現評估\n" +
                          "3. 市場機會識別\n" +
                          "4. 改進建議\n" +
                          "5. 風險評估",
                          Map.of("data", salesData))
                    .call()
                    .entity(SalesAnalysisResult.class);
            
            log.info("銷售資料分析完成，趨勢：{}", result.trend());
            
            return result;
            
        } catch (Exception e) {
            log.error("銷售資料分析失敗", e);
            throw new RuntimeException("銷售資料分析失敗：" + e.getMessage());
        }
    }
    
    /**
     * 客戶行為分析
     * @param customerData 客戶資料
     * @return 客戶洞察
     */
    public CustomerInsights analyzeCustomerBehavior(List<Map<String, Object>> customerData) {
        try {
            log.info("開始客戶行為分析，資料筆數：{}", customerData.size());
            
            CustomerInsights result = chatClient.prompt()
                    .system("你是一個客戶行為分析專家，請基於資料提供深入的客戶洞察。")
                    .user("分析以下客戶行為資料：\n{data}\n\n" +
                          "請提供結構化的客戶洞察，包括：\n" +
                          "1. 客戶細分\n" +
                          "2. 行為模式\n" +
                          "3. 偏好分析\n" +
                          "4. 流失風險\n" +
                          "5. 個性化建議",
                          Map.of("data", customerData))
                    .call()
                    .entity(CustomerInsights.class);
            
            log.info("客戶行為分析完成，識別出 {} 個客戶群體", 
                    result.segments().size());
            
            return result;
            
        } catch (Exception e) {
            log.error("客戶行為分析失敗", e);
            throw new RuntimeException("客戶行為分析失敗：" + e.getMessage());
        }
    }
    
    /**
     * 市場趨勢預測
     * @param marketData 市場資料
     * @param timeframe 預測時間範圍
     * @return 市場預測結果
     */
    public MarketForecast predictMarketTrends(Map<String, Object> marketData, String timeframe) {
        try {
            log.info("開始市場趨勢預測，時間範圍：{}", timeframe);
            
            MarketForecast result = chatClient.prompt()
                    .system("你是一個市場分析和預測專家，請基於歷史資料提供準確的市場預測。")
                    .user("基於以下市場資料預測 {timeframe} 的市場趨勢：\n{data}\n\n" +
                          "請提供結構化的預測結果，包括：\n" +
                          "1. 整體市場趨勢\n" +
                          "2. 關鍵指標預測\n" +
                          "3. 機會與威脅\n" +
                          "4. 策略建議\n" +
                          "5. 預測信心度",
                          Map.of("data", marketData, "timeframe", timeframe))
                    .call()
                    .entity(MarketForecast.class);
            
            log.info("市場趨勢預測完成，整體趨勢：{}，信心度：{}", 
                    result.overallTrend(), result.confidenceLevel());
            
            return result;
            
        } catch (Exception e) {
            log.error("市場趨勢預測失敗", e);
            throw new RuntimeException("市場趨勢預測失敗：" + e.getMessage());
        }
    }
}
```

### 企業資料模型

```java
package com.example.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.List;

/**
 * 銷售分析結果
 */
public record SalesAnalysisResult(
        @JsonProperty("trend") String trend,
        @JsonProperty("total_revenue") double totalRevenue,
        @JsonProperty("growth_rate") double growthRate,
        @JsonProperty("top_products") List<String> topProducts,
        @JsonProperty("opportunities") List<String> opportunities,
        @JsonProperty("recommendations") List<String> recommendations,
        @JsonProperty("risk_factors") List<String> riskFactors
) {}

/**
 * 客戶洞察
 */
public record CustomerInsights(
        @JsonProperty("segments") List<CustomerSegment> segments,
        @JsonProperty("behavior_patterns") List<String> behaviorPatterns,
        @JsonProperty("preferences") List<String> preferences,
        @JsonProperty("churn_risk") ChurnRisk churnRisk,
        @JsonProperty("personalization_suggestions") List<String> personalizationSuggestions
) {}

public record CustomerSegment(
        @JsonProperty("name") String name,
        @JsonProperty("size") int size,
        @JsonProperty("characteristics") List<String> characteristics,
        @JsonProperty("value") String value
) {}

public record ChurnRisk(
        @JsonProperty("high_risk_count") int highRiskCount,
        @JsonProperty("medium_risk_count") int mediumRiskCount,
        @JsonProperty("low_risk_count") int lowRiskCount,
        @JsonProperty("key_indicators") List<String> keyIndicators
) {}

/**
 * 市場預測
 */
public record MarketForecast(
        @JsonProperty("overall_trend") String overallTrend,
        @JsonProperty("key_metrics") List<MetricForecast> keyMetrics,
        @JsonProperty("opportunities") List<String> opportunities,
        @JsonProperty("threats") List<String> threats,
        @JsonProperty("strategic_recommendations") List<String> strategicRecommendations,
        @JsonProperty("confidence_level") double confidenceLevel,
        @JsonProperty("timeframe") String timeframe
) {}

public record MetricForecast(
        @JsonProperty("metric_name") String metricName,
        @JsonProperty("current_value") double currentValue,
        @JsonProperty("predicted_value") double predictedValue,
        @JsonProperty("change_percentage") double changePercentage,
        @JsonProperty("confidence") double confidence
) {}
```

---

## 5.10.6 最佳實踐和優化

### 轉換器選擇指南

```java
package com.example.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Service
@Slf4j
public class ConverterSelectionGuide {
    
    /**
     * 根據使用場景選擇最適合的轉換器
     */
    public String getRecommendedApproach(String useCase) {
        return switch (useCase.toLowerCase()) {
            case "simple_entity" -> 
                "推薦使用 ChatClient.entity() 方法 - 最簡潔且類型安全";
            
            case "complex_validation" -> 
                "推薦使用 BeanOutputConverter - 可以添加自定義驗證邏輯";
            
            case "dynamic_structure" -> 
                "推薦使用 MapOutputConverter - 適合未知或動態的資料結構";
            
            case "simple_list" -> 
                "推薦使用 ListOutputConverter - 處理簡單的列表資料";
            
            case "enterprise_integration" -> 
                "推薦使用 ChatClient.entity() + 自定義 Jackson 配置";
            
            default -> 
                "建議先使用 ChatClient.entity() 方法，如需更多控制再考慮傳統轉換器";
        };
    }
}
```

### 效能優化策略

```java
package com.example.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategies;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class StructuredOutputConfig {
    
    /**
     * 自定義 ObjectMapper 用於結構化輸出
     */
    @Bean("structuredOutputMapper")
    public ObjectMapper structuredOutputMapper() {
        return new ObjectMapper()
                .setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)
                .findAndRegisterModules();
    }
    
    /**
     * 提供轉換器最佳實踐建議
     */
    public static class BestPractices {
        
        public static final String[] RECOMMENDATIONS = {
            "1. 優先使用 entity() 方法：對於大多數結構化輸出需求，新的 entity() 方法更簡潔",
            "2. 複雜場景使用轉換器：需要自定義格式或特殊處理時，使用傳統轉換器",
            "3. 合理設計資料模型：使用 record 類型提高效能和可讀性",
            "4. 添加適當的 JSON 註解：確保序列化和反序列化的正確性",
            "5. 實現錯誤處理：對轉換失敗的情況提供優雅的降級處理",
            "6. 使用快取機制：對於重複的轉換操作考慮添加快取",
            "7. 監控轉換效能：追蹤轉換時間和成功率",
            "8. 驗證輸出格式：確保 AI 輸出符合預期的資料結構"
        };
    }
}
```

---

## 📝 本章重點回顧

1. **結構化輸出理解**：掌握了 AI 結構化資料輸出的重要性和技術實現
2. **現代化 API 使用**：學會了使用 ChatClient 的 entity() 方法進行類型轉換
3. **傳統轉換器掌握**：了解了三種轉換器的特點和適用場景
4. **企業級應用設計**：實現了完整的結構化資料處理系統
5. **最佳實踐應用**：掌握了轉換器選擇和效能優化策略

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **ChatClient entity()** | ⭐⭐⭐ | 低 | 現代化應用開發 |
| **BeanOutputConverter** | ⭐⭐⭐ | 中 | 複雜資料結構 |
| **MapOutputConverter** | ⭐⭐ | 低 | 動態資料處理 |
| **ListOutputConverter** | ⭐⭐ | 低 | 簡單列表資料 |
| **資料模型設計** | ⭐⭐ | 中 | 企業級應用 |
| **錯誤處理** | ⭐⭐ | 中 | 生產環境穩定性 |

### 選擇建議

**1. 新專案推薦**
- ✅ **優先選擇**：ChatClient entity() 方法
- 🎯 **理由**：簡潔、類型安全、易於維護
- 📋 **適用**：90% 的結構化輸出需求

**2. 特殊需求場景**
- 🔧 **BeanOutputConverter**：需要自定義格式描述或驗證邏輯
- 🗺️ **MapOutputConverter**：處理未知或動態的資料結構
- 📝 **ListOutputConverter**：簡單的字串列表處理

**3. 企業級應用建議**
- 🏢 **混合使用**：根據具體場景選擇最適合的方法
- 📊 **監控機制**：追蹤轉換成功率和效能指標
- 🛡️ **錯誤處理**：實現完善的異常處理和降級機制
- 🔄 **版本管理**：考慮資料模型的版本相容性

### 企業應用價值

**1. 系統整合效益**
- 🔗 **API 標準化**：提供一致的資料介面格式
- 📊 **資料處理自動化**：減少人工資料處理工作
- 🎯 **類型安全保證**：編譯時期發現資料結構問題
- 🚀 **開發效率提升**：簡化 AI 輸出的處理邏輯

**2. 業務價值創造**
- 💼 **決策支援**：結構化的分析結果支援商業決策
- 📈 **洞察生成**：自動化的資料洞察和趨勢分析
- 🎨 **個性化服務**：基於結構化資料的個性化推薦
- 🔍 **智能分析**：深度的業務資料分析和預測

### 下一步學習方向

恭喜您完成了第五章「個性化 ChatBot」的完整學習！接下來我們將進入第六章，學習如何讓 ChatBot 擁有記憶能力，建立真正智能的對話系統。

---

**參考資料：**
- [Spring AI Structured Output Documentation](https://docs.spring.io/spring-ai/reference/api/structured-output-converter.html)
- [ChatClient Entity Method Guide](https://docs.spring.io/spring-ai/reference/api/chatclient.html)
- [Jackson JSON Processing](https://github.com/FasterXML/jackson)
- [OpenAI Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)


\newpage


# 第六章：記憶與向量資料庫 {.unnumbered .unlisted}


## 6.1 魔鏡~誰是 Spring AI 的專家？


> **本章重點**：探索 Spring AI 記憶管理系統的核心概念，從傳統的「土炮記憶」到企業級記憶解決方案，為建立真正智能的對話系統奠定基礎。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解記憶的重要性**：掌握為什麼 AI 需要記憶能力以及記憶在對話系統中的作用
- 🎯 **認識記憶類型**：了解短期記憶、長期記憶和向量記憶的差異與應用場景
- 🎯 **掌握 Spring AI 記憶架構**：學習 Spring AI 1.0 GA 中的記憶管理系統設計
- 🎯 **比較記憶實現方案**：分析傳統做法與企業級解決方案的優缺點
- 🎯 **建立記憶系統基礎**：為後續章節的記憶實現做好準備

---

## 6.1.1 AI 記憶的重要性

### 魔鏡魔鏡告訴我，誰是 Spring AI 的專家？

![Spring AI 記憶系統](https://ithelp.ithome.com.tw/upload/images/20240817/20161290GI4axNwalT.png)

想像一下，如果每次與朋友對話時，對方都完全忘記之前說過的話，這樣的對話體驗會是多麼糟糕！同樣地，沒有記憶能力的 AI 就像患了「金魚腦」，每次對話都是全新的開始，無法建立連貫的對話體驗。

### AI 記憶的核心價值

**1. 對話連貫性**
- 🔗 **上下文理解**：AI 能夠理解對話的前後關聯
- 💬 **自然對話流程**：避免重複詢問相同問題
- 🎯 **個性化回應**：根據對話歷史提供更精準的回答
- 📝 **任務延續**：能夠跨多輪對話完成複雜任務

**2. 用戶體驗提升**
- 😊 **友善互動**：更像與真人對話的自然體驗
- ⚡ **效率提升**：減少重複說明，提高溝通效率
- 🎨 **個性化服務**：記住用戶偏好和習慣
- 🔄 **會話恢復**：能夠在中斷後繼續之前的對話

**3. 企業應用價值**
- 📊 **客戶服務**：記住客戶問題和解決方案
- 🎓 **知識累積**：建立組織的對話知識庫
- 🔍 **行為分析**：分析用戶對話模式和需求
- 💼 **業務連續性**：跨會話的業務流程支援

---

## 6.1.2 記憶類型與應用場景

### 記憶的分類體系

在 Spring AI 中，記憶系統可以分為以下幾種類型：

**1. 短期記憶（Session Memory）**
```
特點：
- 存在於單次會話中
- 通常存儲在記憶體中
- 會話結束後消失
- 處理速度快

適用場景：
- 單次對話的上下文管理
- 臨時任務的狀態追蹤
- 快速原型開發
- 測試和除錯
```

**2. 長期記憶（Persistent Memory）**
```
特點：
- 持久化存儲
- 跨會話保持
- 支援多種存儲後端
- 可擴展性強

適用場景：
- 用戶個人助手
- 客戶服務系統
- 知識管理平台
- 企業級應用
```

**3. 向量記憶（Vector Memory）**
```
特點：
- 基於語義相似性
- 支援模糊匹配
- 可處理大量歷史資料
- 智能檢索能力

適用場景：
- 大規模對話歷史檢索
- 語義相關內容查找
- 知識圖譜應用
- 智能推薦系統
```

### 記憶類型比較

| 記憶類型 | 存儲方式 | 持久性 | 檢索方式 | 適用規模 | 實現複雜度 |
|----------|----------|--------|----------|----------|------------|
| **短期記憶** | 記憶體 | 會話級 | 順序存取 | 小型 | 低 |
| **長期記憶** | 資料庫 | 永久 | 關鍵字查詢 | 中大型 | 中 |
| **向量記憶** | 向量資料庫 | 永久 | 語義搜尋 | 大型 | 高 |

---

## 6.1.3 傳統做法 vs 企業級解決方案

### 土炮記憶實現

最簡單的記憶實現方式是使用 List 來存儲對話歷史：

```java
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.messages.AssistantMessage;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.ArrayList;
import java.util.List;

@RestController
@RequiredArgsConstructor
public class BasicMemoryController {
    
    private final ChatClient chatClient;
    private List<Message> memMessage = new ArrayList<>();
    
    @GetMapping("/basic-memory")
    public String chat(@RequestParam String prompt) {
        // 將用戶訊息加入記憶
        memMessage.add(new UserMessage(prompt));
        
        // 發送完整對話歷史給 AI
        String response = chatClient.prompt()
            .messages(memMessage)
            .call()
            .content();
            
        // 將 AI 回應也加入記憶
        memMessage.add(new AssistantMessage(response));
        
        return response;
    }
}
```

**土炮記憶的特點**：
- ✅ **實現簡單**：幾行程式碼就能完成
- ✅ **理解容易**：邏輯直觀，易於除錯
- ✅ **快速原型**：適合概念驗證和測試
- ❌ **無持久化**：應用重啟後記憶消失
- ❌ **無隔離性**：所有用戶共享同一個記憶
- ❌ **記憶體洩漏**：長時間運行會消耗大量記憶體
- ❌ **無擴展性**：無法處理大量用戶和對話

### Spring AI 企業級記憶系統

Spring AI 1.0 GA 提供了完整的企業級記憶管理系統：

```java
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.memory.ChatMemoryRepository;
import org.springframework.ai.chat.memory.MessageWindowChatMemory;
import org.springframework.ai.chat.memory.JdbcChatMemoryRepository;
import org.springframework.ai.chat.memory.RedisChatMemoryRepository;
import org.springframework.ai.chat.memory.Neo4jChatMemoryRepository;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.neo4j.core.Neo4jTemplate;

import javax.sql.DataSource;

@Configuration
public class EnterpriseMemoryConfig {
    
    @Bean
    public ChatMemory chatMemory(ChatMemoryRepository repository) {
        return MessageWindowChatMemory.builder()
            .maxMessages(100)        // 滑動視窗大小
            .chatMemoryRepository(repository)
            .build();
    }
    
    @Bean
    @ConditionalOnProperty(name = "app.memory.type", havingValue = "jdbc")
    public ChatMemoryRepository jdbcChatMemoryRepository(DataSource dataSource) {
        return new JdbcChatMemoryRepository(dataSource);
    }
    
    @Bean
    @ConditionalOnProperty(name = "app.memory.type", havingValue = "redis")
    public ChatMemoryRepository redisChatMemoryRepository(RedisTemplate<String, Object> redisTemplate) {
        return new RedisChatMemoryRepository(redisTemplate);
    }
    
    @Bean
    @ConditionalOnProperty(name = "app.memory.type", havingValue = "neo4j")
    public ChatMemoryRepository neo4jChatMemoryRepository(Neo4jTemplate neo4jTemplate) {
        return new Neo4jChatMemoryRepository(neo4jTemplate);
    }
}
```

**企業級記憶的優勢**：
- ✅ **持久化存儲**：支援多種資料庫後端
- ✅ **會話隔離**：每個用戶有獨立的對話記憶
- ✅ **滑動視窗**：自動管理記憶大小，避免無限增長
- ✅ **高可用性**：支援叢集部署和故障恢復
- ✅ **可擴展性**：能夠處理大量並發用戶
- ✅ **靈活配置**：可根據需求選擇不同的存儲後端

---

## 6.1.4 Spring AI 記憶架構深度解析

### 核心介面設計

Spring AI 的記憶系統採用分層架構設計：

```java
import org.springframework.ai.chat.messages.Message;
import java.util.List;

// 1. ChatMemory 核心介面
public interface ChatMemory {
    // 新增訊息到對話
    void add(String conversationId, Message message);
    void add(String conversationId, List<Message> messages);
    
    // 取得對話歷史
    List<Message> get(String conversationId);
    List<Message> get(String conversationId, int lastN);
    
    // 清除對話
    void clear(String conversationId);
    
    // 檢查對話是否存在
    boolean exists(String conversationId);
}

// 2. ChatMemoryRepository 存儲層
public interface ChatMemoryRepository {
    void save(String conversationId, List<Message> messages);
    List<Message> findByConversationId(String conversationId);
    void deleteByConversationId(String conversationId);
    boolean existsByConversationId(String conversationId);
}

// 3. MessageWindowChatMemory 實現類
public class MessageWindowChatMemory implements ChatMemory {
    private final int maxMessages;
    private final ChatMemoryRepository repository;
    
    // 實現滑動視窗邏輯
    @Override
    public void add(String conversationId, Message message) {
        List<Message> messages = get(conversationId);
        messages.add(message);
        
        // 滑動視窗：保持最新的 maxMessages 條訊息
        if (messages.size() > maxMessages) {
            messages = messages.subList(messages.size() - maxMessages, messages.size());
        }
        
        repository.save(conversationId, messages);
    }
}
```

### 記憶系統架構圖

```
┌─────────────────────────────────────────────────────────────┐
│                    Spring AI Memory System                  │
├─────────────────────────────────────────────────────────────┤
│  ChatClient API Layer                                       │
│  ┌─────────────────┐    ┌─────────────────┐               │
│  │  MessageChat    │    │  PromptChat     │               │
│  │  MemoryAdvisor  │    │  MemoryAdvisor  │               │
│  └─────────────────┘    └─────────────────┘               │
├─────────────────────────────────────────────────────────────┤
│  Memory Management Layer                                    │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              ChatMemory Interface                       │ │
│  │  ┌─────────────────────────────────────────────────┐   │ │
│  │  │        MessageWindowChatMemory                  │   │ │
│  │  │  • Sliding Window Logic                         │   │ │
│  │  │  • Message Lifecycle Management                 │   │ │
│  │  │  • Conversation Isolation                       │   │ │
│  │  └─────────────────────────────────────────────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Storage Abstraction Layer                                  │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │           ChatMemoryRepository Interface                │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Storage Implementation Layer                               │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │InMemory     │ │JDBC         │ │Redis        │          │
│  │Repository   │ │Repository   │ │Repository   │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │Cassandra    │ │Neo4j        │ │MongoDB      │          │
│  │Repository   │ │Repository   │ │Repository   │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

---

## 6.1.5 記憶系統的選擇策略

### 根據應用場景選擇記憶類型

**1. 開發和測試階段**
```yaml
# application-dev.yml
app:
  memory:
    type: memory  # 使用記憶體存儲
    max-messages: 50
```

**2. 生產環境 - 中小型應用**
```yaml
# application-prod.yml
app:
  memory:
    type: jdbc    # 使用關聯式資料庫
    max-messages: 200
    
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/chatbot
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
```

**3. 生產環境 - 大型應用**
```yaml
# application-prod.yml
app:
  memory:
    type: redis   # 使用 Redis 快取
    max-messages: 500
    
spring:
  data:
    redis:
      host: ${REDIS_HOST}
      port: ${REDIS_PORT}
      password: ${REDIS_PASSWORD}
```

**4. 企業級 - 知識圖譜應用**
```yaml
# application-enterprise.yml
app:
  memory:
    type: neo4j   # 使用圖形資料庫
    max-messages: 1000
    
spring:
  neo4j:
    uri: ${NEO4J_URI}
    authentication:
      username: ${NEO4J_USERNAME}
      password: ${NEO4J_PASSWORD}
```

### 選擇決策樹

```
開始選擇記憶系統
        │
        ▼
   是否為生產環境？
    ┌─────┴─────┐
   否│          │是
    ▼           ▼
記憶體存儲    需要持久化？
 (InMemory)   ┌─────┴─────┐
             否│          │是
              ▼           ▼
           Redis快取   資料量大小？
                      ┌─────┴─────┐
                     小│          │大
                      ▼           ▼
                   JDBC        Neo4j/MongoDB
                 (PostgreSQL)  (圖形/文檔)
```

---

## 6.1.6 記憶系統的最佳實踐

### 1. 記憶大小管理

```java
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.SystemMessage;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.List;

@Component
@RequiredArgsConstructor
public class MemoryManagementService {
    
    private final ChatMemory chatMemory;
    
    /**
     * 智能記憶清理策略
     */
    @Scheduled(fixedRate = 3600000) // 每小時執行一次
    public void cleanupOldConversations() {
        // 清理超過 7 天的對話
        LocalDateTime cutoff = LocalDateTime.now().minusDays(7);
        
        // 實現具體的清理邏輯
        cleanupConversationsOlderThan(cutoff);
    }
    
    /**
     * 記憶壓縮策略
     */
    public void compressLongConversation(String conversationId) {
        List<Message> messages = chatMemory.get(conversationId);
        
        if (messages.size() > 100) {
            // 保留最近 50 條訊息
            List<Message> recentMessages = messages.subList(messages.size() - 50, messages.size());
            
            // 將較舊的訊息進行摘要
            String summary = summarizeOldMessages(messages.subList(0, messages.size() - 50));
            
            // 重建記憶
            chatMemory.clear(conversationId);
            chatMemory.add(conversationId, new SystemMessage("對話摘要：" + summary));
            chatMemory.add(conversationId, recentMessages);
        }
    }
}
```

### 2. 記憶安全性

```java
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.stereotype.Component;

@Component
public class MemorySecurityService {
    
    /**
     * 敏感資訊過濾
     */
    public Message sanitizeMessage(Message message) {
        String content = message.getContent();
        
        // 移除敏感資訊
        content = removeSensitiveInfo(content);
        
        return new UserMessage(content);
    }
    
    private String removeSensitiveInfo(String content) {
        // 移除信用卡號
        content = content.replaceAll("\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b", "[CARD_NUMBER]");
        
        // 移除電話號碼
        content = content.replaceAll("\\b\\d{10,11}\\b", "[PHONE_NUMBER]");
        
        // 移除電子郵件
        content = content.replaceAll("\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b", "[EMAIL]");
        
        return content;
    }
}
```

### 3. 記憶效能監控

```java
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tags;
import io.micrometer.core.instrument.Timer;
import org.springframework.stereotype.Component;

import java.util.function.Supplier;

@Component
public class MemoryMetricsService {
    
    private final MeterRegistry meterRegistry;
    private final Counter memoryOperations;
    private final Timer memoryAccessTime;
    
    public MemoryMetricsService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.memoryOperations = Counter.builder("memory.operations")
            .description("Memory operations count")
            .register(meterRegistry);
        this.memoryAccessTime = Timer.builder("memory.access.time")
            .description("Memory access time")
            .register(meterRegistry);
    }
    
    public void recordMemoryOperation(String operation, String conversationId) {
        memoryOperations.increment(
            Tags.of(
                "operation", operation,
                "conversation_id", conversationId
            )
        );
    }
    
    public <T> T timeMemoryAccess(Supplier<T> operation) {
        return memoryAccessTime.recordCallable(operation::get);
    }
}
```

---

## 📝 本章重點回顧

1. **記憶重要性理解**：掌握了 AI 記憶在對話系統中的核心價值和作用
2. **記憶類型分類**：學會了短期記憶、長期記憶和向量記憶的特點與應用
3. **架構設計認知**：理解了 Spring AI 記憶系統的分層架構和設計原則
4. **實現方案比較**：分析了傳統做法與企業級解決方案的優缺點
5. **選擇策略掌握**：學會了根據不同場景選擇合適的記憶系統類型

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **ChatMemory 介面** | ⭐⭐⭐ | 低 | 所有記憶應用 |
| **MessageWindowChatMemory** | ⭐⭐⭐ | 中 | 企業級應用 |
| **多存儲後端支援** | ⭐⭐ | 中 | 大型系統 |
| **記憶安全性** | ⭐⭐ | 中 | 生產環境 |
| **效能監控** | ⭐⭐ | 低 | 運維管理 |

### 下一步學習方向

在下一章中，我們將深入實作 Spring AI 的記憶功能，學習如何：
- 實現基本的對話記憶功能
- 配置不同的存儲後端
- 使用 MessageChatMemoryAdvisor 進行記憶管理
- 建立完整的對話系統

---

**參考資料：**
- [Spring AI Memory Documentation](https://docs.spring.io/spring-ai/reference/api/chat-memory.html)
- [ChatClient API Guide](https://docs.spring.io/spring-ai/reference/api/chatclient.html)
- [Spring AI Advisors](https://docs.spring.io/spring-ai/reference/api/advisors.html)
- [Memory Management Best Practices](https://docs.spring.io/spring-ai/reference/concepts.html)


\newpage

## 6.2 讓 AI 記住對話


> **本章重點**：實際動手實現 Spring AI 的對話記憶功能，從基礎的記憶體存儲到企業級的持久化解決方案，讓 AI 真正擁有記憶能力。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **實現基本對話記憶**：使用 InMemoryChatMemory 建立簡單的記憶功能
- 🎯 **掌握 Advisor 系統**：理解 Spring AI 的增強器機制和最新 API
- 🎯 **配置記憶管理**：學會配置不同類型的記憶存儲後端
- 🎯 **實現會話隔離**：為不同用戶建立獨立的對話記憶
- 🎯 **優化記憶效能**：掌握記憶大小控制和效能優化技巧

---

## 6.2.1 從土炮到企業級的進化

### AOP 無所不在

![AOP概念圖](https://ithelp.ithome.com.tw/upload/images/20240819/20161290PpCeC08JCZ.jpg)

Spring 框架有兩個很重要的觀念，一個是 IoC，另一個則是 AOP。AOP 的基本概念就是可以攔截指定的方法並且增強方法的功能，且無需修改到主要的業務代碼，使業務與非業務處理邏輯分離。

**AOP 在日常開發中的應用**：
- 🔄 **@Transactional**：自動處理資料庫交易的開啟、提交和回滾
- 📝 **@Cacheable**：自動處理快取的存取和更新
- 🔒 **@PreAuthorize**：自動進行權限檢查
- 📊 **@Timed**：自動記錄方法執行時間

### Spring AI 的 Advisor 系統

Spring AI 將 AOP 的概念應用到 AI 對話處理中，提供了 **Advisor（增強器）** 系統。Advisor 可以在 AI 請求的前後進行攔截和增強，實現記憶管理、內容過濾、日誌記錄等功能。

---

## 6.2.2 Spring AI Advisor API 的重大更新

### API 演進歷程

**重要更新說明**：Spring AI 1.0 GA 版本對 Advisor API 進行了重大重構，提供了更清晰和強大的介面。

#### 舊版 API（已廢棄）
```java
// ❌ 已在 1.0.0-M3 標記為 deprecated，1.0.0-RC1 完全移除
RequestResponseAdvisor advisor = new MessageChatMemoryAdvisor(chatMemory, chatId, 30);
```

#### 新版 API（當前使用）
```java
// ✅ 使用最新的 Builder 模式和清晰的介面
ChatMemory chatMemory = MessageWindowChatMemory.builder().build();

ChatClient chatClient = ChatClient.builder(chatModel)
    .defaultAdvisors(MessageChatMemoryAdvisor.builder(chatMemory).build())
    .build();

// 在調用時指定對話 ID
String conversationId = "007";
String response = chatClient.prompt()
    .advisors(advisor -> advisor.param(ChatMemory.CONVERSATION_ID, conversationId))
    .user(userText)
    .call()
    .content();
```

### 新版 API 的核心介面

**1. CallAdvisor - 非串流場景**
```java
public interface CallAdvisor {
    String getName();
    int getOrder();
    
    ChatClientRequest adviseRequest(ChatClientRequest request, Map<String, Object> context);
    ChatClientResponse adviseResponse(ChatClientResponse response, Map<String, Object> context);
}
```

**2. StreamAdvisor - 串流場景**
```java
public interface StreamAdvisor {
    String getName();
    int getOrder();
    
    ChatClientRequest adviseRequest(ChatClientRequest request, Map<String, Object> context);
    Flux<ChatClientResponse> adviseResponse(Flux<ChatClientResponse> response, Map<String, Object> context);
}
```

### API 更新的優勢

| 特性 | 舊版 API | 新版 API |
|------|----------|----------|
| **類型安全** | 較弱 | 強類型檢查 |
| **建構方式** | 構造函數 | Builder 模式 |
| **可讀性** | 一般 | 高可讀性 |
| **擴展性** | 有限 | 高度可擴展 |
| **維護性** | 困難 | 容易維護 |

---

## 6.2.3 Spring AI 內建的 Advisor 類別

### 記憶管理 Advisor

![Advisor類別圖](https://ithelp.ithome.com.tw/upload/images/20240819/201612900g7q0iHGAj.png)

Spring AI 提供了三種主要的記憶管理 Advisor：

**1. MessageChatMemoryAdvisor**
```java
特點：
- 將對話歷史作為 Message 集合加入到 Prompt 中
- 保持完整的對話結構和上下文
- 適合需要精確對話順序的場景

使用場景：
- 客戶服務對話
- 任務導向的多輪對話
- 需要嚴格上下文的業務流程

**1. MessageChatMemoryAdvisor - 基本記憶管理**
```java
// 建立記憶存儲
ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .maxMessages(10)  // 保留最近 10 條訊息
    .build();

// 配置 ChatClient
ChatClient chatClient = ChatClient.builder(chatModel)
    .defaultAdvisors(MessageChatMemoryAdvisor.builder(chatMemory).build())
    .build();

// 使用時指定對話 ID
String conversationId = "user-123";
String response = chatClient.prompt()
    .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, conversationId))
    .user("你好，我是新用戶")
    .call()
    .content();
```

**2. PromptChatMemoryAdvisor**
```java
特點：
- 將對話歷史轉換為純文字附加到系統提示中
- 更節省 Token 使用量
- 適合簡單的上下文記憶

使用場景：
- 簡單的問答系統
- 成本敏感的應用
- 不需要複雜對話結構的場景
```

**3. VectorStoreChatMemoryAdvisor**
```java
特點：
- 使用向量資料庫存儲對話記憶
- 支援語義相似性搜尋
- 可處理大量歷史對話資料

使用場景：
- 長期對話歷史管理
- 大規模用戶系統
- 需要語義搜尋的智能助手
```

### Advisor 比較表

| Advisor 類型 | 存儲方式 | Token 消耗 | 檢索能力 | 適用規模 |
|--------------|----------|------------|----------|----------|
| **MessageChatMemoryAdvisor** | 結構化訊息 | 高 | 順序檢索 | 中小型 |
| **PromptChatMemoryAdvisor** | 純文字 | 中 | 文字匹配 | 小型 |
| **VectorStoreChatMemoryAdvisor** | 向量化 | 低 | 語義搜尋 | 大型 |

---

## 6.2.4 實現基本對話記憶

### 第一步：建立簡單的記憶服務

```java
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.memory.InMemoryChatMemoryRepository;
import org.springframework.ai.chat.memory.MessageWindowChatMemory;
import org.springframework.ai.chat.memory.advisor.MessageChatMemoryAdvisor;
import org.springframework.ai.chat.messages.Message;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class BasicChatMemoryService {
    
    private final ChatClient chatClient;
    private final ChatMemory chatMemory = MessageWindowChatMemory.builder()
            .chatMemoryRepository(new InMemoryChatMemoryRepository())
            .build();
    
    /**
     * 基本對話記憶實現
     */
    public String chat(String conversationId, String userMessage) {
        return chatClient.prompt()
            .advisors(advisor -> advisor.param(ChatMemory.CONVERSATION_ID, conversationId))
            .user(userMessage)
            .call()
            .content();
    }
    
    /**
     * 獲取對話歷史
     */
    public List<Message> getConversationHistory(String conversationId) {
        return chatMemory.get(conversationId);
    }
    
    /**
     * 清除對話記憶
     */
    public void clearConversation(String conversationId) {
        chatMemory.clear(conversationId);
    }
}
```

### 第二步：建立 REST API 控制器

```java
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.messages.Message;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/chat")
@RequiredArgsConstructor
public class ChatMemoryController {
    
    private final BasicChatMemoryService chatService;
    
    /**
     * 對話 API
     */
    @PostMapping("/conversation/{conversationId}")
    public ResponseEntity<ChatResponse> chat(
            @PathVariable String conversationId,
            @RequestBody ChatRequest request) {
        
        String response = chatService.chat(conversationId, request.getMessage());
        
        return ResponseEntity.ok(ChatResponse.builder()
            .conversationId(conversationId)
            .message(response)
            .timestamp(LocalDateTime.now())
            .build());
    }
    
    /**
     * 獲取對話歷史
     */
    @GetMapping("/conversation/{conversationId}/history")
    public ResponseEntity<ConversationHistory> getHistory(
            @PathVariable String conversationId,
            @RequestParam(defaultValue = "50") int limit) {
        
        List<Message> messages = chatService.getConversationHistory(conversationId);
        
        // 限制返回的訊息數量
        if (messages.size() > limit) {
            messages = messages.subList(messages.size() - limit, messages.size());
        }
        
        return ResponseEntity.ok(ConversationHistory.builder()
            .conversationId(conversationId)
            .messages(messages)
            .totalCount(messages.size())
            .build());
    }
    
    /**
     * 清除對話
     */
    @DeleteMapping("/conversation/{conversationId}")
    public ResponseEntity<Void> clearConversation(@PathVariable String conversationId) {
        chatService.clearConversation(conversationId);
        return ResponseEntity.ok().build();
    }
}
```

### 第三步：定義資料傳輸物件

```java
import lombok.Builder;
import lombok.Data;
import org.springframework.ai.chat.messages.Message;

import javax.validation.constraints.NotBlank;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * 聊天請求 DTO
 */
@Data
@Builder
public class ChatRequest {
    @NotBlank(message = "訊息不能為空")
    private String message;
    
    private Map<String, Object> metadata;
}

/**
 * 聊天回應 DTO
 */
@Data
@Builder
public class ChatResponse {
    private String conversationId;
    private String message;
    private LocalDateTime timestamp;
    private Map<String, Object> metadata;
}

/**
 * 對話歷史 DTO
 */
@Data
@Builder
public class ConversationHistory {
    private String conversationId;
    private List<Message> messages;
    private int totalCount;
    private LocalDateTime lastUpdated;
}
```

---

## 6.2.5 企業級記憶配置

### 配置不同的存儲後端

```java
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.memory.InMemoryChatMemoryRepository;
import org.springframework.ai.chat.memory.JdbcChatMemoryRepository;
import org.springframework.ai.chat.memory.MessageWindowChatMemory;
import org.springframework.ai.chat.memory.RedisChatMemoryRepository;
import org.springframework.ai.chat.memory.Neo4jChatMemoryRepository;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.neo4j.core.Neo4jTemplate;

import javax.sql.DataSource;

@Configuration
@EnableConfigurationProperties(ChatMemoryProperties.class)
public class ChatMemoryConfig {
    
    /**
     * 記憶體存儲（開發環境）
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "memory")
    public ChatMemory inMemoryChatMemory() {
        return MessageWindowChatMemory.builder()
            .chatMemoryRepository(new InMemoryChatMemoryRepository())
            .build();
    }
    
    /**
     * JDBC 存儲（生產環境）
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "jdbc")
    public ChatMemory jdbcChatMemory(DataSource dataSource) {
        return MessageWindowChatMemory.builder()
            .maxMessages(200)
            .chatMemoryRepository(new JdbcChatMemoryRepository(dataSource))
            .build();
    }
    
    /**
     * Redis 存儲（高效能環境）
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "redis")
    public ChatMemory redisChatMemory(RedisTemplate<String, Object> redisTemplate) {
        return MessageWindowChatMemory.builder()
            .maxMessages(500)
            .chatMemoryRepository(new RedisChatMemoryRepository(redisTemplate))
            .build();
    }
    
    /**
     * Neo4j 存儲（圖形資料庫）
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "neo4j")
    public ChatMemory neo4jChatMemory(Neo4jTemplate neo4jTemplate) {
        return MessageWindowChatMemory.builder()
            .maxMessages(1000)
            .chatMemoryRepository(new Neo4jChatMemoryRepository(neo4jTemplate))
            .build();
    }
}
```

### 記憶配置屬性

```java
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "app.chat.memory")
@Data
public class ChatMemoryProperties {
    
    /**
     * 記憶存儲類型
     */
    private String type = "memory";
    
    /**
     * 最大訊息數量
     */
    private int maxMessages = 100;
    
    /**
     * 記憶過期時間（小時）
     */
    private int expirationHours = 24;
    
    /**
     * 是否啟用記憶壓縮
     */
    private boolean compressionEnabled = false;
    
    /**
     * 壓縮閾值
     */
    private int compressionThreshold = 200;
}
```

### 應用程式配置

```yaml
# application.yml
app:
  chat:
    memory:
      type: jdbc  # memory, jdbc, redis, neo4j
      max-messages: 200
      expiration-hours: 48
      compression-enabled: true
      compression-threshold: 300

# 開發環境
---
spring:
  config:
    activate:
      on-profile: dev
app:
  chat:
    memory:
      type: memory
      max-messages: 50

# 生產環境
---
spring:
  config:
    activate:
      on-profile: prod
app:
  chat:
    memory:
      type: redis
      max-messages: 500
      expiration-hours: 72
```

---

## 6.2.6 進階記憶管理

### 建議的最佳實踐寫法

推薦在 ChatClient 建構時就預設 Advisor，這樣可以獲得更好的效能：

```java
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.memory.advisor.MessageChatMemoryAdvisor;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ChatClientConfig {
    
    @Bean
    public ChatClient chatClient(ChatModel chatModel, ChatMemory chatMemory) {
        return ChatClient.builder(chatModel)
            .defaultAdvisors(
                MessageChatMemoryAdvisor.builder(chatMemory).build()
            )
            .build();
    }
    
    @Bean
    public ChatClient streamingChatClient(ChatModel chatModel, ChatMemory chatMemory) {
        return ChatClient.builder(chatModel)
            .defaultAdvisors(
                // 串流場景使用不同的配置
                MessageChatMemoryAdvisor.builder(chatMemory)
                    .lastN(20)  // 串流時使用較少的歷史訊息
                    .build()
            )
            .build();
    }
}
```

### 動態 Advisor 參數設定

```java
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class DynamicChatService {
    
    private final ChatClient chatClient;
    private final ChatMemory chatMemory;
    
    public String chat(String conversationId, String userMessage, ChatOptions options) {
        return chatClient.prompt()
            .advisors(advisor -> {
                // 動態設定 Advisor 參數
                advisor.param(ChatMemory.CONVERSATION_ID, conversationId);
                
                // 根據選項調整記憶大小
                if (options.isDetailedContext()) {
                    advisor.param("lastN", 50);
                } else {
                    advisor.param("lastN", 20);
                }
            })
            .user(userMessage)
            .call()
            .content();
    }
}
```

### 記憶效能優化

```java
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.SystemMessage;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Component
@RequiredArgsConstructor
public class MemoryOptimizationService {
    
    private final ChatMemory chatMemory;
    private final ChatClient summaryClient;
    
    /**
     * 智能記憶壓縮
     */
    @Scheduled(fixedRate = 3600000) // 每小時執行一次
    public void optimizeMemory() {
        // 獲取所有活躍的對話 ID
        Set<String> activeConversations = getActiveConversations();
        
        for (String conversationId : activeConversations) {
            List<Message> messages = chatMemory.get(conversationId);
            
            if (messages.size() > 100) {
                compressConversation(conversationId, messages);
            }
        }
    }
    
    private void compressConversation(String conversationId, List<Message> messages) {
        // 保留最近 30 條訊息
        List<Message> recentMessages = messages.subList(messages.size() - 30, messages.size());
        
        // 將較舊的訊息進行摘要
        List<Message> oldMessages = messages.subList(0, messages.size() - 30);
        String summary = summarizeMessages(oldMessages);
        
        // 重建記憶
        chatMemory.clear(conversationId);
        chatMemory.add(conversationId, new SystemMessage("對話摘要：" + summary));
        chatMemory.add(conversationId, recentMessages);
    }
    
    private String summarizeMessages(List<Message> messages) {
        String conversation = messages.stream()
            .map(Message::getContent)
            .collect(Collectors.joining("\n"));
            
        return summaryClient.prompt()
            .user("請簡潔摘要以下對話的重點：\n" + conversation)
            .call()
            .content();
    }
}
```

---

## 6.2.7 測試對話記憶功能

### 基本功能測試

```java
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
import org.springframework.ai.chat.messages.Message;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class ChatMemoryServiceTest {
    
    @Autowired
    private BasicChatMemoryService chatService;
    
    private static final String CONVERSATION_ID = "test-conversation-001";
    
    @Test
    @Order(1)
    void testFirstMessage() {
        String response = chatService.chat(CONVERSATION_ID, "我的名字是 Kevin");
        
        assertThat(response).isNotNull();
        
        // 驗證記憶中有訊息
        List<Message> history = chatService.getConversationHistory(CONVERSATION_ID);
        assertThat(history).hasSize(2); // User + Assistant
    }
    
    @Test
    @Order(2)
    void testMemoryRecall() {
        String response = chatService.chat(CONVERSATION_ID, "我剛才說我的名字是什麼？");
        
        assertThat(response.toLowerCase()).contains("kevin");
        
        // 驗證記憶增長
        List<Message> history = chatService.getConversationHistory(CONVERSATION_ID);
        assertThat(history).hasSizeGreaterThan(2);
    }
    
    @Test
    @Order(3)
    void testClearMemory() {
        chatService.clearConversation(CONVERSATION_ID);
        
        List<Message> history = chatService.getConversationHistory(CONVERSATION_ID);
        assertThat(history).isEmpty();
    }
}
```

### API 端點測試

```java
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureTestDatabase
class ChatMemoryControllerTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    void testChatConversation() {
        String conversationId = "api-test-001";
        
        // 第一輪對話
        ChatRequest request1 = ChatRequest.builder()
            .message("我喜歡喝咖啡")
            .build();
            
        ResponseEntity<ChatResponse> response1 = restTemplate.postForEntity(
            "/api/chat/conversation/" + conversationId,
            request1,
            ChatResponse.class
        );
        
        assertThat(response1.getStatusCode()).isEqualTo(HttpStatus.OK);
        
        // 第二輪對話 - 測試記憶
        ChatRequest request2 = ChatRequest.builder()
            .message("我剛才說我喜歡什麼？")
            .build();
            
        ResponseEntity<ChatResponse> response2 = restTemplate.postForEntity(
            "/api/chat/conversation/" + conversationId,
            request2,
            ChatResponse.class
        );
        
        assertThat(response2.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response2.getBody().getMessage().toLowerCase()).contains("咖啡");
    }
}
```

---

## 📝 本章重點回顧

1. **Advisor 系統理解**：掌握了 Spring AI 的增強器機制和 AOP 概念的應用
2. **API 更新認知**：學會了最新的 Advisor API 使用方式和 Builder 模式
3. **記憶類型選擇**：理解了不同 Advisor 的特點和適用場景
4. **實際功能實現**：完成了基本對話記憶功能的完整實現
5. **企業級配置**：掌握了多種存儲後端的配置和選擇策略

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **MessageChatMemoryAdvisor** | ⭐⭐⭐ | 低 | 基本對話記憶 |
| **多存儲後端配置** | ⭐⭐⭐ | 中 | 企業級應用 |
| **動態 Advisor 參數** | ⭐⭐ | 中 | 靈活配置 |
| **記憶效能優化** | ⭐⭐ | 高 | 大規模應用 |
| **API 測試** | ⭐⭐ | 低 | 品質保證 |

### 最佳實踐建議

1. **開發階段**：使用 InMemoryChatMemory 進行快速原型開發
2. **測試階段**：配置適當的記憶大小限制，避免測試資料過多
3. **生產階段**：選擇合適的持久化存儲，並配置記憶清理策略
4. **效能優化**：實施記憶壓縮和定期清理機制
5. **監控告警**：建立記憶使用量的監控和告警機制

### 下一步學習方向

在下一章中，我們將深入學習 Spring AI 的官方記憶系統，包括：
- Spring AI 官方提供的記憶管理 API
- 更進階的記憶配置選項
- 記憶系統的監控和管理
- 與其他 Spring AI 功能的整合

---

**參考資料：**
- [Spring AI Advisors Documentation](https://docs.spring.io/spring-ai/reference/api/advisors.html)
- [Chat Memory API Guide](https://docs.spring.io/spring-ai/reference/api/chat-memory.html)
- [ChatClient Builder Pattern](https://docs.spring.io/spring-ai/reference/api/chatclient.html)
- [Spring AI Best Practices](https://docs.spring.io/spring-ai/reference/concepts.html)


\newpage

## 6.3 Spring AI 官方記憶


> **本章重點**：深入探索 Spring AI 1.0 GA 官方提供的記憶管理系統，掌握企業級記憶解決方案的完整功能和最佳實踐。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握官方記憶 API**：深入理解 Spring AI 官方記憶系統的完整架構
- 🎯 **配置企業級存儲**：學會配置和使用各種官方支援的存儲後端
- 🎯 **實現記憶策略**：掌握滑動視窗、記憶壓縮等進階記憶管理策略
- 🎯 **監控記憶系統**：建立記憶使用量監控和效能優化機制
- 🎯 **整合業務邏輯**：將記憶系統與實際業務需求完美結合

---

## 6.3.1 Spring AI 官方記憶系統架構

### 記憶系統的核心設計理念

Spring AI 1.0 GA 的記憶系統採用了分層架構設計，遵循 Spring 框架的核心原則：

**設計原則**：
- 🏗️ **抽象與實現分離**：清晰的介面定義和多種實現選擇
- 🔄 **可插拔架構**：支援不同存儲後端的無縫切換
- 📈 **可擴展性**：支援從單機到分散式的各種部署場景
- 🛡️ **企業級特性**：內建安全性、監控和管理功能

### 官方記憶系統架構圖

```
┌─────────────────────────────────────────────────────────────┐
│                Spring AI Memory System 1.0 GA              │
├─────────────────────────────────────────────────────────────┤
│  Application Layer                                          │
│  ┌─────────────────┐    ┌─────────────────┐               │
│  │   ChatClient    │    │   Memory        │               │
│  │   Integration   │    │   Management    │               │
│  └─────────────────┘    └─────────────────┘               │
├─────────────────────────────────────────────────────────────┤
│  Memory Management Layer                                    │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              ChatMemory Interface                       │ │
│  │  ┌─────────────────────────────────────────────────┐   │ │
│  │  │        MessageWindowChatMemory                  │   │ │
│  │  │  • Sliding Window Management                    │   │ │
│  │  │  • Automatic Cleanup                            │   │ │
│  │  │  • Memory Compression                           │   │ │
│  │  │  • Conversation Isolation                       │   │ │
│  │  └─────────────────────────────────────────────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Repository Abstraction Layer                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │           ChatMemoryRepository Interface                │ │
│  │  • save(conversationId, messages)                       │ │
│  │  • findByConversationId(conversationId)                 │ │
│  │  • deleteByConversationId(conversationId)               │ │
│  │  • existsByConversationId(conversationId)               │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Official Storage Implementations                           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │InMemory     │ │JDBC         │ │Redis        │          │
│  │Repository   │ │Repository   │ │Repository   │          │
│  │• Fast       │ │• Reliable   │ │• Scalable   │          │
│  │• Volatile   │ │• ACID       │ │• Distributed│          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │Cassandra    │ │Neo4j        │ │MongoDB      │          │
│  │Repository   │ │Repository   │ │Repository   │          │
│  │• BigData    │ │• Graph      │ │• Document   │          │
│  │• NoSQL      │ │• Relations  │ │• Flexible   │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

---

## 6.3.2 ChatMemory 核心介面深度解析

### 官方 ChatMemory 介面定義

```java
/**
 * Spring AI 官方記憶介面
 * 提供對話記憶的核心操作
 */
public interface ChatMemory {
    
    /**
     * 新增單一訊息到指定對話
     * @param conversationId 對話識別碼
     * @param message 要新增的訊息
     */
    void add(String conversationId, Message message);
    
    /**
     * 批次新增訊息到指定對話
     * @param conversationId 對話識別碼
     * @param messages 要新增的訊息列表
     */
    void add(String conversationId, List<Message> messages);
    
    /**
     * 獲取指定對話的所有訊息
     * @param conversationId 對話識別碼
     * @return 訊息列表
     */
    List<Message> get(String conversationId);
    
    /**
     * 清除指定對話的所有訊息
     * @param conversationId 對話識別碼
     */
    void clear(String conversationId);
    
    /**
     * 對話 ID 常數
     */
    String CONVERSATION_ID = "conversation_id";
}
```

### MessageWindowChatMemory 實現

```java
/**
 * 滑動視窗記憶實現
 * 自動管理記憶大小，保留最近的 N 條訊息
 */
public class MessageWindowChatMemory implements ChatMemory {
    
    private final ChatMemoryRepository repository;
    private final int maxMessages;
    
    /**
     * 使用 Builder 模式建立實例
     */
    public static Builder builder() {
        return new Builder();
    }
    
    public static class Builder {
        private ChatMemoryRepository repository;
        private int maxMessages = 10;
        
        public Builder chatMemoryRepository(ChatMemoryRepository repository) {
            this.repository = repository;
            return this;
        }
        
        public Builder maxMessages(int maxMessages) {
            this.maxMessages = maxMessages;
            return this;
        }
        
        public MessageWindowChatMemory build() {
            if (repository == null) {
                repository = new InMemoryChatMemoryRepository();
            }
            return new MessageWindowChatMemory(repository, maxMessages);
        }
    }
}
```

---

## 6.3.3 官方記憶存儲後端

### 支援的存儲實現

Spring AI 1.0 GA 提供了多種官方記憶存儲實現：

```java
// 可用的記憶存儲實現
InMemoryChatMemoryRepository    // 記憶體存儲
JdbcChatMemoryRepository        // JDBC 資料庫存儲
CassandraChatMemoryRepository   // Cassandra 存儲
Neo4jChatMemoryRepository       // Neo4j 圖形資料庫存儲
```

### 1. InMemory 記憶存儲

**特點**：
- ✅ **快速存取**：記憶體中的資料存取速度最快
- ✅ **零配置**：無需額外的資料庫設置
- ✅ **開發友善**：適合開發和測試環境
- ❌ **資料易失**：應用重啟後資料消失
- ❌ **記憶體限制**：受限於可用記憶體大小

**使用方式**：
```java
// 自動配置（預設）
@Autowired
ChatMemory chatMemory;

// 手動建立
ChatMemoryRepository repository = new InMemoryChatMemoryRepository();
ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .chatMemoryRepository(repository)
    .maxMessages(10)
    .build();
```

### 2. JDBC 記憶存儲

**Maven 依賴**：
```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-starter-model-chat-memory-repository-jdbc</artifactId>
</dependency>
```

**配置屬性**：
```properties
# 資料庫初始化設置
spring.ai.chat.memory.repository.jdbc.initialize-schema=embedded  # 僅嵌入式資料庫
spring.ai.chat.memory.repository.jdbc.initialize-schema=always    # 總是初始化
spring.ai.chat.memory.repository.jdbc.initialize-schema=never     # 從不初始化

# 自定義 Schema 路徑
spring.ai.chat.memory.repository.jdbc.schema=classpath:/custom/path/schema-mysql.sql
```

**使用方式**：
```java
// 自動配置
@Autowired
JdbcChatMemoryRepository chatMemoryRepository;

ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .chatMemoryRepository(chatMemoryRepository)
    .maxMessages(10)
    .build();

// 手動建立
ChatMemoryRepository chatMemoryRepository = JdbcChatMemoryRepository.builder()
    .jdbcTemplate(jdbcTemplate)
    .dialect(new PostgresChatMemoryDialect())
    .build();
```

### 3. Neo4j 記憶存儲

**Maven 依賴**：
```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-starter-model-chat-memory-repository-neo4j</artifactId>
</dependency>
```

**配置屬性**：
```properties
# Neo4j 記憶配置
spring.ai.chat.memory.repository.neo4j.sessionLabel=ChatSession
spring.ai.chat.memory.repository.neo4j.messageLabel=ChatMessage
spring.ai.chat.memory.repository.neo4j.toolCallLabel=ToolCall
spring.ai.chat.memory.repository.neo4j.metadataLabel=MessageMetadata
spring.ai.chat.memory.repository.neo4j.toolResponseLabel=ToolResponse
spring.ai.chat.memory.repository.neo4j.mediaLabel=MessageMedia
```

**使用方式**：
```java
// 自動配置
@Autowired
Neo4jChatMemoryRepository chatMemoryRepository;

ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .chatMemoryRepository(chatMemoryRepository)
    .maxMessages(10)
    .build();

// 手動建立
ChatMemoryRepository chatMemoryRepository = Neo4jChatMemoryRepository.builder()
    .driver(driver)
    .build();
```

### 4. Cassandra 記憶存儲

**Maven 依賴**：
```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-starter-model-chat-memory-repository-cassandra</artifactId>
</dependency>
```

**配置屬性**：
```properties
# Cassandra 配置
spring.cassandra.port=9042
spring.cassandra.localDatacenter=datacenter1
spring.ai.chat.memory.cassandra.time-to-live=3600
spring.ai.chat.memory.cassandra.keyspace=chat_memory
spring.ai.chat.memory.cassandra.messages-column=messages
spring.ai.chat.memory.cassandra.table=conversations
spring.ai.chat.memory.cassandra.initialize-schema=true
```

**使用方式**：
```java
// 自動配置
@Autowired
CassandraChatMemoryRepository chatMemoryRepository;

ChatMemory chatMemory = MessageWindowChatMemory.builder()
    .chatMemoryRepository(chatMemoryRepository)
    .maxMessages(10)
    .build();

// 手動建立
ChatMemoryRepository chatMemoryRepository = CassandraChatMemoryRepository
    .create(CassandraChatMemoryConfig.builder().withCqlSession(cqlSession));
```
    
}
```

### MessageWindowChatMemory 官方實現

```java
/**
 * Spring AI 官方滑動視窗記憶實現
 * 支援自動記憶管理和多種存儲後端
 */
public class MessageWindowChatMemory implements ChatMemory {
    
    private final int maxMessages;
    private final ChatMemoryRepository repository;
    private final boolean autoCleanup;
    private final Duration cleanupInterval;
    
    /**
     * 使用 Builder 模式建構記憶實例
     */
    public static Builder builder() {
        return new Builder();
    }
    
    public static class Builder {
        private int maxMessages = 100;
        private ChatMemoryRepository repository;
        private boolean autoCleanup = true;
        private Duration cleanupInterval = Duration.ofHours(1);
        
        public Builder maxMessages(int maxMessages) {
            this.maxMessages = maxMessages;
            return this;
        }
        
        public Builder chatMemoryRepository(ChatMemoryRepository repository) {
            this.repository = repository;
            return this;
        }
        
        public Builder autoCleanup(boolean autoCleanup) {
            this.autoCleanup = autoCleanup;
            return this;
        }
        
        public Builder cleanupInterval(Duration interval) {
            this.cleanupInterval = interval;
            return this;
        }
        
        public MessageWindowChatMemory build() {
            if (repository == null) {
                repository = new InMemoryChatMemoryRepository();
            }
            return new MessageWindowChatMemory(maxMessages, repository, autoCleanup, cleanupInterval);
        }
    }
    
    @Override
    public void add(String conversationId, Message message) {
        List<Message> messages = get(conversationId);
        messages.add(message);
        
        // 滑動視窗邏輯：保持最新的 maxMessages 條訊息
        if (messages.size() > maxMessages) {
            messages = messages.subList(messages.size() - maxMessages, messages.size());
        }
        
        repository.save(conversationId, messages);
    }
    
    @Override
    public List<Message> get(String conversationId) {
        return repository.findByConversationId(conversationId);
    }
}
```

---

## 6.3.3 官方存儲後端實現

### 1. InMemoryChatMemoryRepository

```java
/**
 * 記憶體存儲實現 - 適合開發和測試
 */
@Component
public class InMemoryChatMemoryRepository implements ChatMemoryRepository {
    
    private final Map<String, List<Message>> conversations = new ConcurrentHashMap<>();
    
    @Override
    public void save(String conversationId, List<Message> messages) {
        conversations.put(conversationId, new ArrayList<>(messages));
    }
    
    @Override
    public List<Message> findByConversationId(String conversationId) {
        return conversations.getOrDefault(conversationId, new ArrayList<>());
    }
    
    @Override
    public void deleteByConversationId(String conversationId) {
        conversations.remove(conversationId);
    }
    
    @Override
    public boolean existsByConversationId(String conversationId) {
        return conversations.containsKey(conversationId);
    }
    
    @Override
    public Set<String> getAllConversationIds() {
        return new HashSet<>(conversations.keySet());
    }
}
```

### 2. JdbcChatMemoryRepository

```java
/**
 * JDBC 存儲實現 - 適合生產環境
 */
@Repository
@RequiredArgsConstructor
public class JdbcChatMemoryRepository implements ChatMemoryRepository {
    
    private final JdbcTemplate jdbcTemplate;
    private final ObjectMapper objectMapper;
    
    @PostConstruct
    public void initializeSchema() {
        jdbcTemplate.execute("""
            CREATE TABLE IF NOT EXISTS chat_memory (
                conversation_id VARCHAR(255) NOT NULL,
                message_index INTEGER NOT NULL,
                message_type VARCHAR(50) NOT NULL,
                content TEXT NOT NULL,
                metadata JSON,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (conversation_id, message_index)
            )
        """);
    }
    
    @Override
    public void save(String conversationId, List<Message> messages) {
        // 先清除舊資料
        jdbcTemplate.update(
            "DELETE FROM chat_memory WHERE conversation_id = ?",
            conversationId
        );
        
        // 批次插入新資料
        List<Object[]> batchArgs = new ArrayList<>();
        for (int i = 0; i < messages.size(); i++) {
            Message message = messages.get(i);
            batchArgs.add(new Object[]{
                conversationId,
                i,
                message.getMessageType().name(),
                message.getContent(),
                serializeMetadata(message.getMetadata())
            });
        }
        
        jdbcTemplate.batchUpdate(
            "INSERT INTO chat_memory (conversation_id, message_index, message_type, content, metadata) VALUES (?, ?, ?, ?, ?)",
            batchArgs
        );
    }
    
    @Override
    public List<Message> findByConversationId(String conversationId) {
        return jdbcTemplate.query(
            "SELECT * FROM chat_memory WHERE conversation_id = ? ORDER BY message_index",
            new Object[]{conversationId},
            this::mapRowToMessage
        );
    }
    
    private Message mapRowToMessage(ResultSet rs, int rowNum) throws SQLException {
        String messageType = rs.getString("message_type");
        String content = rs.getString("content");
        String metadataJson = rs.getString("metadata");
        
        Map<String, Object> metadata = deserializeMetadata(metadataJson);
        
        return switch (MessageType.valueOf(messageType)) {
            case USER -> new UserMessage(content, metadata);
            case ASSISTANT -> new AssistantMessage(content, metadata);
            case SYSTEM -> new SystemMessage(content, metadata);
            case TOOL -> new ToolMessage(content, metadata);
        };
    }
}
```

### 3. RedisChatMemoryRepository

```java
/**
 * Redis 存儲實現 - 適合高效能和分散式環境
 */
@Repository
@RequiredArgsConstructor
public class RedisChatMemoryRepository implements ChatMemoryRepository {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;
    
    private static final String CONVERSATION_KEY_PREFIX = "chat:memory:";
    private static final String CONVERSATION_SET_KEY = "chat:conversations";
    
    @Override
    public void save(String conversationId, List<Message> messages) {
        String key = CONVERSATION_KEY_PREFIX + conversationId;
        
        try {
            // 序列化訊息列表
            String serializedMessages = objectMapper.writeValueAsString(messages);
            
            // 存儲到 Redis
            redisTemplate.opsForValue().set(key, serializedMessages);
            
            // 將對話 ID 加入集合
            redisTemplate.opsForSet().add(CONVERSATION_SET_KEY, conversationId);
            
            // 設定過期時間（可選）
            redisTemplate.expire(key, Duration.ofDays(7));
            
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to serialize messages", e);
        }
    }
    
    @Override
    public List<Message> findByConversationId(String conversationId) {
        String key = CONVERSATION_KEY_PREFIX + conversationId;
        String serializedMessages = (String) redisTemplate.opsForValue().get(key);
        
        if (serializedMessages == null) {
            return new ArrayList<>();
        }
        
        try {
            return objectMapper.readValue(
                serializedMessages,
                new TypeReference<List<Message>>() {}
            );
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to deserialize messages", e);
        }
    }
    
    @Override
    public void deleteByConversationId(String conversationId) {
        String key = CONVERSATION_KEY_PREFIX + conversationId;
        redisTemplate.delete(key);
        redisTemplate.opsForSet().remove(CONVERSATION_SET_KEY, conversationId);
    }
    
    @Override
    public Set<String> getAllConversationIds() {
        return redisTemplate.opsForSet().members(CONVERSATION_SET_KEY)
            .stream()
            .map(Object::toString)
            .collect(Collectors.toSet());
    }
}
```

---

## 6.3.4 企業級記憶配置

### 統一配置管理

```java
@Configuration
@EnableConfigurationProperties(ChatMemoryProperties.class)
@Slf4j
public class OfficialChatMemoryConfig {
    
    /**
     * 主要記憶 Bean - 根據配置自動選擇實現
     */
    @Bean
    @Primary
    public ChatMemory primaryChatMemory(
            ChatMemoryProperties properties,
            List<ChatMemoryRepository> repositories) {
        
        ChatMemoryRepository repository = selectRepository(properties.getType(), repositories);
        
        return MessageWindowChatMemory.builder()
            .maxMessages(properties.getMaxMessages())
            .chatMemoryRepository(repository)
            .autoCleanup(properties.isAutoCleanup())
            .cleanupInterval(Duration.ofHours(properties.getCleanupIntervalHours()))
            .build();
    }
    
    /**
     * 記憶體存儲配置
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "memory")
    public ChatMemoryRepository inMemoryRepository() {
        log.info("Configuring InMemory ChatMemoryRepository");
        return new InMemoryChatMemoryRepository();
    }
    
    /**
     * JDBC 存儲配置
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "jdbc")
    public ChatMemoryRepository jdbcRepository(
            JdbcTemplate jdbcTemplate,
            ObjectMapper objectMapper) {
        log.info("Configuring JDBC ChatMemoryRepository");
        return new JdbcChatMemoryRepository(jdbcTemplate, objectMapper);
    }
    
    /**
     * Redis 存儲配置
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "redis")
    public ChatMemoryRepository redisRepository(
            RedisTemplate<String, Object> redisTemplate,
            ObjectMapper objectMapper) {
        log.info("Configuring Redis ChatMemoryRepository");
        return new RedisChatMemoryRepository(redisTemplate, objectMapper);
    }
    
    /**
     * Neo4j 存儲配置
     */
    @Bean
    @ConditionalOnProperty(name = "app.chat.memory.type", havingValue = "neo4j")
    public ChatMemoryRepository neo4jRepository(Neo4jTemplate neo4jTemplate) {
        log.info("Configuring Neo4j ChatMemoryRepository");
        return new Neo4jChatMemoryRepository(neo4jTemplate);
    }
    
    private ChatMemoryRepository selectRepository(
            String type, 
            List<ChatMemoryRepository> repositories) {
        
        return repositories.stream()
            .filter(repo -> matchesType(repo, type))
            .findFirst()
            .orElseThrow(() -> new IllegalStateException(
                "No ChatMemoryRepository found for type: " + type));
    }
    
    private boolean matchesType(ChatMemoryRepository repository, String type) {
        return switch (type.toLowerCase()) {
            case "memory" -> repository instanceof InMemoryChatMemoryRepository;
            case "jdbc" -> repository instanceof JdbcChatMemoryRepository;
            case "redis" -> repository instanceof RedisChatMemoryRepository;
            case "neo4j" -> repository instanceof Neo4jChatMemoryRepository;
            default -> false;
        };
    }
}
```

### 配置屬性類

```java
@ConfigurationProperties(prefix = "app.chat.memory")
@Data
@Validated
public class ChatMemoryProperties {
    
    /**
     * 記憶存儲類型
     */
    @NotBlank
    private String type = "memory";
    
    /**
     * 滑動視窗最大訊息數量
     */
    @Min(1)
    @Max(10000)
    private int maxMessages = 100;
    
    /**
     * 是否啟用自動清理
     */
    private boolean autoCleanup = true;
    
    /**
     * 清理間隔（小時）
     */
    @Min(1)
    @Max(168) // 最多一週
    private int cleanupIntervalHours = 24;
    
    /**
     * 記憶過期時間（天）
     */
    @Min(1)
    @Max(365)
    private int expirationDays = 7;
    
    /**
     * 是否啟用記憶壓縮
     */
    private boolean compressionEnabled = false;
    
    /**
     * 壓縮閾值
     */
    @Min(50)
    private int compressionThreshold = 200;
    
    /**
     * 是否啟用記憶統計
     */
    private boolean metricsEnabled = true;
    
    /**
     * 批次處理大小
     */
    @Min(1)
    @Max(1000)
    private int batchSize = 100;
}
```

---

## 6.3.5 記憶監控與管理

### 記憶統計服務

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class ChatMemoryMetricsService {
    
    private final ChatMemory chatMemory;
    private final MeterRegistry meterRegistry;
    
    // 統計指標
    private final Counter memoryOperations;
    private final Timer memoryAccessTime;
    private final Gauge activeConversations;
    private final Gauge totalMessages;
    
    public ChatMemoryMetricsService(ChatMemory chatMemory, MeterRegistry meterRegistry) {
        this.chatMemory = chatMemory;
        this.meterRegistry = meterRegistry;
        
        // 初始化統計指標
        this.memoryOperations = Counter.builder("chat.memory.operations")
            .description("Chat memory operations count")
            .register(meterRegistry);
            
        this.memoryAccessTime = Timer.builder("chat.memory.access.time")
            .description("Chat memory access time")
            .register(meterRegistry);
            
        this.activeConversations = Gauge.builder("chat.memory.conversations.active")
            .description("Number of active conversations")
            .register(meterRegistry, this, ChatMemoryMetricsService::getActiveConversationCount);
            
        this.totalMessages = Gauge.builder("chat.memory.messages.total")
            .description("Total number of messages in memory")
            .register(meterRegistry, this, ChatMemoryMetricsService::getTotalMessageCount);
    }
    
    /**
     * 記錄記憶操作
     */
    public void recordOperation(String operation, String conversationId) {
        memoryOperations.increment(
            Tags.of(
                "operation", operation,
                "conversation_id", conversationId
            )
        );
    }
    
    /**
     * 測量記憶存取時間
     */
    public <T> T timeMemoryAccess(String operation, Supplier<T> supplier) {
        return memoryAccessTime.recordCallable(() -> {
            try {
                return supplier.get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }
    
    /**
     * 取得活躍對話數量
     */
    public double getActiveConversationCount() {
        try {
            // 注意：實際實現需要根據具體的 ChatMemoryRepository 介面
            // 官方 ChatMemory 介面不包含 getConversationIds() 方法
            // 以下為示例實現
            return 0;
        } catch (Exception e) {
            log.warn("Failed to get active conversation count", e);
            return 0;
        }
    }
    
    /**
     * 取得總訊息數量
     */
    public double getTotalMessageCount() {
        try {
            // 注意：實際實現需要根據具體的 ChatMemoryRepository 介面
            // 官方 ChatMemory 介面不包含 getConversationIds() 或 size() 方法
            // 以下為示例實現
            return 0;
        } catch (Exception e) {
            log.warn("Failed to get total message count", e);
            return 0;
        }
    }
    
    /**
     * 取得記憶統計報告
     */
    public MemoryStatistics getMemoryStatistics() {
        // 注意：實際實現需要根據具體的 ChatMemoryRepository 介面
        // 官方 ChatMemory 介面不包含 getConversationIds() 或 size() 方法
        // 以下為示例實現
        Set<String> conversationIds = new HashSet<>();
        int totalConversations = conversationIds.size();
        int totalMessages = 0; // 需要透過 repository 查詢得到
        
        double averageMessagesPerConversation = totalConversations > 0 
            ? (double) totalMessages / totalConversations 
            : 0;
        
        return MemoryStatistics.builder()
            .totalConversations(totalConversations)
            .totalMessages(totalMessages)
            .averageMessagesPerConversation(averageMessagesPerConversation)
            .timestamp(LocalDateTime.now())
            .build();
    }
}
```

### 記憶健康檢查

```java
@Component
public class ChatMemoryHealthIndicator implements HealthIndicator {
    
    private final ChatMemory chatMemory;
    private final ChatMemoryProperties properties;
    
    public ChatMemoryHealthIndicator(ChatMemory chatMemory, ChatMemoryProperties properties) {
        this.chatMemory = chatMemory;
        this.properties = properties;
    }
    
    @Override
    public Health health() {
        try {
            // 檢查記憶系統基本功能
            String testConversationId = "health-check-" + System.currentTimeMillis();
            
            // 測試寫入
            chatMemory.add(testConversationId, new SystemMessage("Health check"));
            
            // 測試讀取
            List<Message> messages = chatMemory.get(testConversationId);
            
            // 測試刪除
            chatMemory.clear(testConversationId);
            
            // 檢查記憶使用情況
            // 注意：官方 ChatMemory 介面不包含 getConversationIds() 方法
            int activeConversations = 0; // 需要透過 ChatMemoryRepository 實現統計
            int maxConversations = properties.getMaxMessages() * 10; // 估算值
            
            Health.Builder healthBuilder = Health.up()
                .withDetail("type", properties.getType())
                .withDetail("activeConversations", activeConversations)
                .withDetail("maxMessages", properties.getMaxMessages())
                .withDetail("autoCleanup", properties.isAutoCleanup());
            
            // 檢查記憶使用率
            if (activeConversations > maxConversations * 0.8) {
                healthBuilder.status("WARNING")
                    .withDetail("warning", "Memory usage is high");
            }
            
            return healthBuilder.build();
            
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .withException(e)
                .build();
        }
    }
}
```

---

## 6.3.6 記憶管理最佳實踐

### 自動記憶清理服務

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class ChatMemoryCleanupService {
    
    private final ChatMemory chatMemory;
    private final ChatMemoryProperties properties;
    private final ChatMemoryMetricsService metricsService;
    
    /**
     * 定期清理過期對話
     */
    @Scheduled(fixedRateString = "#{chatMemoryProperties.cleanupIntervalHours * 3600000}")
    public void cleanupExpiredConversations() {
        if (!properties.isAutoCleanup()) {
            return;
        }
        
        log.info("Starting memory cleanup process");
        
        try {
            // 注意：官方 ChatMemory 介面不包含 getConversationIds() 方法
            // 實際應用中需要透過 ChatMemoryRepository 來獲取對話列表
            Set<String> conversationIds = new HashSet<>();
            int cleanedCount = 0;
            
            for (String conversationId : conversationIds) {
                if (shouldCleanupConversation(conversationId)) {
                    chatMemory.clear(conversationId);
                    cleanedCount++;
                    
                    metricsService.recordOperation("cleanup", conversationId);
                }
            }
            
            log.info("Memory cleanup completed. Cleaned {} conversations", cleanedCount);
            
        } catch (Exception e) {
            log.error("Memory cleanup failed", e);
        }
    }
    
    /**
     * 智能記憶壓縮
     */
    @Scheduled(fixedRate = 7200000) // 每 2 小時執行一次
    public void compressLongConversations() {
        if (!properties.isCompressionEnabled()) {
            return;
        }
        
        log.info("Starting memory compression process");
        
        // 注意：官方 ChatMemory 介面不包含 getConversationIds() 方法
        Set<String> conversationIds = new HashSet<>();
        
        for (String conversationId : conversationIds) {
            // 注意：官方 ChatMemory 介面不包含 size() 方法
            int messageCount = chatMemory.get(conversationId).size();
            
            if (messageCount > properties.getCompressionThreshold()) {
                compressConversation(conversationId);
            }
        }
    }
    
    private boolean shouldCleanupConversation(String conversationId) {
        // 實現清理邏輯，例如基於最後活動時間
        // 這裡簡化為檢查對話 ID 中的時間戳
        try {
            if (conversationId.contains("-")) {
                String[] parts = conversationId.split("-");
                long timestamp = Long.parseLong(parts[parts.length - 1]);
                long expirationTime = System.currentTimeMillis() - 
                    (properties.getExpirationDays() * 24 * 60 * 60 * 1000L);
                
                return timestamp < expirationTime;
            }
        } catch (Exception e) {
            log.warn("Failed to parse conversation timestamp: {}", conversationId);
        }
        
        return false;
    }
    
    private void compressConversation(String conversationId) {
        List<Message> messages = chatMemory.get(conversationId);
        
        if (messages.size() <= properties.getCompressionThreshold()) {
            return;
        }
        
        // 保留最近的訊息
        int keepCount = properties.getMaxMessages() / 2;
        List<Message> recentMessages = messages.subList(
            messages.size() - keepCount, 
            messages.size()
        );
        
        // 壓縮較舊的訊息
        List<Message> oldMessages = messages.subList(0, messages.size() - keepCount);
        String summary = summarizeMessages(oldMessages);
        
        // 重建記憶
        chatMemory.clear(conversationId);
        chatMemory.add(conversationId, new SystemMessage("對話摘要：" + summary));
        chatMemory.add(conversationId, recentMessages);
        
        log.info("Compressed conversation {} from {} to {} messages", 
            conversationId, messages.size(), recentMessages.size() + 1);
    }
    
    private String summarizeMessages(List<Message> messages) {
        // 實現訊息摘要邏輯
        return "[摘要] 包含 " + messages.size() + " 條歷史訊息的對話摘要";
    }
}
```

### 記憶備份與恢復

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class ChatMemoryBackupService {
    
    private final ChatMemory chatMemory;
    private final ObjectMapper objectMapper;
    
    /**
     * 備份所有對話記憶
     */
    public void backupMemory(String backupPath) throws IOException {
        log.info("Starting memory backup to: {}", backupPath);
        
        Map<String, List<Message>> allConversations = new HashMap<>();
        
        // 注意：官方 ChatMemory 介面不包含 getConversationIds() 方法
        // 實際應用中需要透過 ChatMemoryRepository 來獲取對話列表
        Set<String> conversationIds = new HashSet<>();
        for (String conversationId : conversationIds) {
            List<Message> messages = chatMemory.get(conversationId);
            allConversations.put(conversationId, messages);
        }
        
        MemoryBackup backup = MemoryBackup.builder()
            .conversations(allConversations)
            .backupTime(LocalDateTime.now())
            .version("1.0")
            .build();
        
        objectMapper.writeValue(new File(backupPath), backup);
        
        log.info("Memory backup completed. Backed up {} conversations", 
            allConversations.size());
    }
    
    /**
     * 恢復對話記憶
     */
    public void restoreMemory(String backupPath) throws IOException {
        log.info("Starting memory restore from: {}", backupPath);
        
        MemoryBackup backup = objectMapper.readValue(new File(backupPath), MemoryBackup.class);
        
        int restoredCount = 0;
        for (Map.Entry<String, List<Message>> entry : backup.getConversations().entrySet()) {
            String conversationId = entry.getKey();
            List<Message> messages = entry.getValue();
            
            chatMemory.clear(conversationId);
            chatMemory.add(conversationId, messages);
            restoredCount++;
        }
        
        log.info("Memory restore completed. Restored {} conversations", restoredCount);
    }
}
```

---

## 📝 本章重點回顧

1. **官方記憶架構**：深入理解了 Spring AI 官方記憶系統的完整架構設計
2. **核心介面掌握**：掌握了 ChatMemory 和 ChatMemoryRepository 的官方介面定義
3. **多存儲後端**：學會了配置和使用官方支援的各種存儲後端實現
4. **企業級配置**：建立了統一的配置管理和自動選擇機制
5. **監控與管理**：實現了完整的記憶監控、健康檢查和自動管理功能

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **MessageWindowChatMemory** | ⭐⭐⭐ | 中 | 核心記憶管理 |
| **多存儲後端支援** | ⭐⭐⭐ | 高 | 靈活部署 |
| **自動配置機制** | ⭐⭐ | 中 | 簡化配置 |
| **記憶監控系統** | ⭐⭐ | 中 | 運維管理 |
| **自動清理壓縮** | ⭐⭐ | 高 | 效能優化 |

### 最佳實踐建議

1. **存儲選擇**：根據應用規模和需求選擇合適的存儲後端
2. **配置管理**：使用統一的配置屬性管理所有記憶相關設定
3. **監控告警**：建立完整的記憶使用量監控和告警機制
4. **自動化管理**：實施自動清理、壓縮和備份策略
5. **效能優化**：根據實際使用情況調整滑動視窗大小和清理策略

### 下一步學習方向

在下一章中，我們將學習 Spring AI 的鏈式增強器（Advisor）系統，包括：
- Advisor 的進階應用和自定義開發
- 多個 Advisor 的組合和優先級管理
- 企業級 Advisor 的設計模式
- 與記憶系統的深度整合

---

**參考資料：**
- [Spring AI Memory Documentation](https://docs.spring.io/spring-ai/reference/api/chat-memory.html)
- [MessageWindowChatMemory API](https://docs.spring.io/spring-ai/reference/api/chat-memory.html#_messagewindowchatmemory)
- [ChatMemoryRepository Interface](https://docs.spring.io/spring-ai/reference/api/chat-memory.html#_chatmemoryrepository)
- [Spring Boot Actuator Integration](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html)


\newpage

## 6.4 Spring AI 的鏈式增強器


> **本章重點**：深入探索 Spring AI 的 Advisor 系統，掌握鏈式增強器的進階應用，學會設計和實現自定義的 AI 增強功能。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握 Advisor 鏈式機制**：理解多個 Advisor 的組合和執行順序
- 🎯 **設計自定義 Advisor**：學會開發符合業務需求的增強器
- 🎯 **實現進階功能**：建立內容過濾、日誌記錄、安全檢查等增強功能
- 🎯 **優化 Advisor 效能**：掌握 Advisor 的效能優化和最佳實踐
- 🎯 **整合企業需求**：將 Advisor 系統與實際業務場景完美結合

---

## 6.4.1 Advisor 鏈式機制深度解析

### 鏈式增強器的核心概念

Spring AI 的 Advisor 系統採用了責任鏈模式（Chain of Responsibility Pattern），允許多個增強器按照特定順序對 AI 請求和回應進行處理。

**鏈式處理流程**：
```
User Request
    ↓
┌─────────────────────────────────────────────────────────────┐
│                    Advisor Chain                            │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │  Advisor 1  │ →  │  Advisor 2  │ →  │  Advisor 3  │     │
│  │ (Order: 0)  │    │ (Order: 10) │    │ (Order: 20) │     │
│  └─────────────┘    └─────────────┘    └─────────────┘     │
└─────────────────────────────────────────────────────────────┘
    ↓
AI Model Processing
    ↓
┌─────────────────────────────────────────────────────────────┐
│                 Response Processing                         │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │  Advisor 3  │ ←  │  Advisor 2  │ ←  │  Advisor 1  │     │
│  │ (Response)  │    │ (Response)  │    │ (Response)  │     │
│  └─────────────┘    └─────────────┘    └─────────────┘     │
└─────────────────────────────────────────────────────────────┘
    ↓
Final Response
```

### Advisor 執行順序控制

```java
/**
 * Advisor 執行順序介面
 */
public interface Ordered {
    int HIGHEST_PRECEDENCE = Integer.MIN_VALUE;
    int LOWEST_PRECEDENCE = Integer.MAX_VALUE;
    
    int getOrder();
}

/**
 * Spring AI Advisor 基礎介面
 */
public interface Advisor extends Ordered {
    String getName();
}

/**
 * CallAdvisor - 非串流場景
 */
public interface CallAdvisor extends Advisor {
    ChatClientResponse adviseCall(
        ChatClientRequest chatClientRequest, 
        CallAdvisorChain callAdvisorChain);
}

/**
 * StreamAdvisor - 串流場景
 */
public interface StreamAdvisor extends Advisor {
    Flux<ChatClientResponse> adviseStream(
        ChatClientRequest chatClientRequest, 
        StreamAdvisorChain streamAdvisorChain);
}

/**
 * Advisor Chain 介面
 */
public interface CallAdvisorChain extends AdvisorChain {
    ChatClientResponse nextCall(ChatClientRequest chatClientRequest);
    List<CallAdvisor> getCallAdvisors();
}

public interface StreamAdvisorChain extends AdvisorChain {
    Flux<ChatClientResponse> nextStream(ChatClientRequest chatClientRequest);
    List<StreamAdvisor> getStreamAdvisors();
}
```

### 內建 Advisor 的執行順序

```java
public class AdvisorOrder {
    // 記憶管理 - 最高優先級
    public static final int MEMORY_ORDER = 0;
    
    // 內容過濾 - 高優先級
    public static final int CONTENT_FILTER_ORDER = 100;
    
    // RAG 檢索 - 中優先級
    public static final int RAG_RETRIEVAL_ORDER = 200;
    
    // 日誌記錄 - 低優先級
    public static final int LOGGING_ORDER = 800;
    
    // 統計監控 - 最低優先級
    public static final int METRICS_ORDER = 900;
}
```

---

## 6.4.2 自定義 Advisor 開發

### 1. 內容過濾 Advisor

```java
import org.springframework.ai.chat.client.advisor.api.*;
import org.springframework.ai.chat.messages.*;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.model.Generation;
import org.springframework.ai.chat.prompt.Prompt;
import java.util.List;

/**
 * 內容過濾增強器
 * 過濾敏感內容和不當言論
 */
@Component
@Slf4j
public class ContentFilterAdvisor implements CallAdvisor {
    
    private final ContentFilterService filterService;
    private final MeterRegistry meterRegistry;
    
    public ContentFilterAdvisor(ContentFilterService filterService, MeterRegistry meterRegistry) {
        this.filterService = filterService;
        this.meterRegistry = meterRegistry;
    }
    
    @Override
    public String getName() {
        return "ContentFilterAdvisor";
    }
    
    @Override
    public int getOrder() {
        return AdvisorOrder.CONTENT_FILTER_ORDER;
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        log.debug("Processing request through content filter");
        
        // 過濾用戶輸入
        String originalContent = extractUserMessage(request);
        FilterResult filterResult = filterService.filterInput(originalContent);
        
        // 記錄過濾統計
        meterRegistry.counter("content.filter.requests", 
            "filtered", String.valueOf(filterResult.isFiltered())).increment();
        
        if (filterResult.isFiltered()) {
            log.warn("Content filtered: {}", filterResult.getReason());
            
            // 如果內容被過濾，替換為安全內容
            request = replaceUserMessage(request, filterResult.getSafeContent());
        }
        
        // 繼續執行鏈中的下一個 Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // 過濾 AI 回應
        String responseContent = response.chatResponse().getResult().getOutput().getContent();
        FilterResult responseFilterResult = filterService.filterOutput(responseContent);
        
        if (responseFilterResult.isFiltered()) {
            log.warn("AI response filtered: {}", responseFilterResult.getReason());
            
            // 替換為安全的回應
            response = replaceResponseContent(response, responseFilterResult.getSafeContent());
        }
        
        return response;
    }
    
    private String extractUserMessage(ChatClientRequest request) {
        return request.prompt().getInstructions().stream()
            .filter(msg -> msg instanceof UserMessage)
            .map(Message::getContent)
            .findFirst()
            .orElse("");
    }
    
    private ChatClientRequest replaceUserMessage(ChatClientRequest request, String safeContent) {
        // 實現訊息替換邏輯
        return request.mutate()
            .prompt(Prompt.from(UserMessage.from(safeContent)))
            .build();
    }
    
    private ChatClientResponse replaceResponseContent(ChatClientResponse response, String safeContent) {
        // 實現回應替換邏輯
        Generation generation = new Generation(new AssistantMessage(safeContent));
        ChatResponse chatResponse = new ChatResponse(List.of(generation));
        return new ChatClientResponse(chatResponse, response.adviseContext());
    }
}
```

### 2. 簡單日誌記錄 Advisor

```java
/**
 * 簡單日誌記錄增強器
 * 記錄所有 AI 請求和回應的詳細資訊
 */
@Component
public class SimpleLoggerAdvisor implements CallAdvisor, StreamAdvisor {
    
    private static final Logger logger = LoggerFactory.getLogger(SimpleLoggerAdvisor.class);
    
    @Override
    public String getName() {
        return this.getClass().getSimpleName();
    }
    
    @Override
    public int getOrder() {
        return 0;
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest chatClientRequest, 
                                       CallAdvisorChain callAdvisorChain) {
        logRequest(chatClientRequest);
        
        ChatClientResponse chatClientResponse = callAdvisorChain.nextCall(chatClientRequest);
        
        logResponse(chatClientResponse);
        
        return chatClientResponse;
    }
    
    @Override
    public Flux<ChatClientResponse> adviseStream(ChatClientRequest chatClientRequest,
                                               StreamAdvisorChain streamAdvisorChain) {
        logRequest(chatClientRequest);
        
        Flux<ChatClientResponse> chatClientResponses = streamAdvisorChain.nextStream(chatClientRequest);
        
        return new ChatClientMessageAggregator()
            .aggregateChatClientResponse(chatClientResponses, this::logResponse);
    }
    
    private void logRequest(ChatClientRequest request) {
        logger.debug("request: {}", request);
    }
    
    private void logResponse(ChatClientResponse chatClientResponse) {
        logger.debug("response: {}", chatClientResponse);
    }
}```

### 3. 企業級日誌記錄 Advisor

```java
/**
 * 企業級日誌記錄增強器
 * 提供完整的審計日誌功能
 */
@Component
@Slf4j
public class EnterpriseLoggingAdvisor implements CallAdvisor {
    
    private final ObjectMapper objectMapper;
    private final AuditLogService auditLogService;
    
    public EnterpriseLoggingAdvisor(ObjectMapper objectMapper, AuditLogService auditLogService) {
        this.objectMapper = objectMapper;
        this.auditLogService = auditLogService;
    }
    
    @Override
    public String getName() {
        return "EnterpriseLoggingAdvisor";
    }
    
    @Override
    public int getOrder() {
        return AdvisorOrder.LOGGING_ORDER;
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String conversationId = extractConversationId(request);
        String userId = extractUserId(request);
        
        try {
            // 記錄請求日誌
            AuditLog auditLog = AuditLog.builder()
                .conversationId(conversationId)
                .userId(userId)
                .eventType("AI_REQUEST")
                .requestContent(extractRequestContent(request))
                .timestamp(LocalDateTime.now())
                .metadata(createMetadata(request))
                .build();
            
            auditLogService.logEvent(auditLog);
            
            // 繼續執行鏈中的下一個 Advisor
            ChatClientResponse response = chain.nextCall(request);
            
            // 記錄回應日誌
            AuditLog responseLog = AuditLog.builder()
                .requestId(auditLog.getId())
                .eventType("AI_RESPONSE")
                .responseContent(extractResponseContent(response))
                .timestamp(LocalDateTime.now())
                .tokenUsage(extractTokenUsage(response))
                .build();
            
            auditLogService.logEvent(responseLog);
            
            return response;
            
        } catch (Exception e) {
            log.error("Failed to log request/response", e);
            // 即使日誌記錄失敗，也要繼續執行
            return chain.nextCall(request);
        }
    }
    
    private String extractRequestContent(ChatClientRequest request) {
        try {
            return objectMapper.writeValueAsString(request.getPrompt().getInstructions());
        } catch (Exception e) {
            return "[Failed to serialize request]";
        }
    }
    
    private String extractResponseContent(ChatClientResponse response) {
        return response.chatResponse().getResult().getOutput().getContent();
    }
    
    private Map<String, Object> createMetadata(ChatClientRequest request) {
        Map<String, Object> metadata = new HashMap<>();
        if (request.chatOptions() != null) {
            metadata.put("model", request.chatOptions().getModel());
            metadata.put("temperature", request.chatOptions().getTemperature());
            metadata.put("maxTokens", request.chatOptions().getMaxTokens());
        }
        return metadata;
    }
}```

### 3. 安全檢查 Advisor

```java
/**
 * 安全檢查增強器
 * 實施訪問控制和安全策略
 */
@Component
@Slf4j
public class SecurityAdvisor implements CallAdvisor {
    
    private final SecurityService securityService;
    private final RateLimitService rateLimitService;
    
    public SecurityAdvisor(SecurityService securityService, RateLimitService rateLimitService) {
        this.securityService = securityService;
        this.rateLimitService = rateLimitService;
    }
    
    @Override
    public String getName() {
        return "SecurityAdvisor";
    }
    
    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE; // 最高優先級
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String userId = extractUserId(request);
        String conversationId = extractConversationId(request);
        
        // 1. 用戶身份驗證
        if (!securityService.isValidUser(userId)) {
            throw new SecurityException("Invalid user: " + userId);
        }
        
        // 2. 權限檢查
        if (!securityService.hasPermission(userId, "AI_CHAT")) {
            throw new SecurityException("User does not have AI chat permission: " + userId);
        }
        
        // 3. 速率限制檢查
        if (!rateLimitService.isAllowed(userId)) {
            throw new RateLimitExceededException("Rate limit exceeded for user: " + userId);
        }
        
        // 4. 內容安全檢查
        String userMessage = extractUserMessage(request);
        if (securityService.containsMaliciousContent(userMessage)) {
            throw new SecurityException("Malicious content detected");
        }
        
        // 5. 對話安全檢查
        if (!securityService.canAccessConversation(userId, conversationId)) {
            throw new SecurityException("User cannot access conversation: " + conversationId);
        }
        
        log.debug("Security check passed for user: {}", userId);
        
        // 繼續執行鏈中的下一個 Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // 回應階段的安全檢查
        String responseContent = response.chatResponse().getResult().getOutput().getContent();
        
        // 檢查回應是否包含敏感資訊
        if (securityService.containsSensitiveInfo(responseContent)) {
            log.warn("Sensitive information detected in AI response");
            
            // 遮蔽敏感資訊
            String sanitizedContent = securityService.sanitizeContent(responseContent);
            response = replaceResponseContent(response, sanitizedContent);
        }
        
        return response;
    }
}
```

---

## 6.4.3 Advisor 組合與配置

### 多 Advisor 組合配置

```java
@Configuration
@EnableConfigurationProperties(AdvisorProperties.class)
public class AdvisorChainConfig {
    
    /**
     * 配置完整的 Advisor 鏈
     */
    @Bean
    public ChatClient advisorChainChatClient(
            ChatModel chatModel,
            List<CallAdvisor> advisors,
            AdvisorProperties properties) {
        
        // 根據 Order 排序 Advisor
        List<CallAdvisor> sortedAdvisors = advisors.stream()
            .sorted(Comparator.comparingInt(CallAdvisor::getOrder))
            .collect(Collectors.toList());
        
        log.info("Configuring ChatClient with {} advisors: {}", 
            sortedAdvisors.size(),
            sortedAdvisors.stream().map(CallAdvisor::getName).collect(Collectors.toList()));
        
        return ChatClient.builder(chatModel)
            .defaultAdvisors(sortedAdvisors)
            .build();
    }
    
    /**
     * 條件化 Advisor 配置
     */
    @Bean
    @ConditionalOnProperty(name = "app.advisor.security.enabled", havingValue = "true")
    public SecurityAdvisor securityAdvisor(SecurityService securityService, RateLimitService rateLimitService) {
        return new SecurityAdvisor(securityService, rateLimitService);
    }
    
    @Bean
    @ConditionalOnProperty(name = "app.advisor.content-filter.enabled", havingValue = "true")
    public ContentFilterAdvisor contentFilterAdvisor(ContentFilterService filterService, MeterRegistry meterRegistry) {
        return new ContentFilterAdvisor(filterService, meterRegistry);
    }
    
    @Bean
    @ConditionalOnProperty(name = "app.advisor.logging.enabled", havingValue = "true")
    public LoggingAdvisor loggingAdvisor(ObjectMapper objectMapper, AuditLogService auditLogService) {
        return new LoggingAdvisor(objectMapper, auditLogService);
    }
    
    /**
     * 自定義 Advisor 鏈建構器
     */
    @Bean
    public AdvisorChainBuilder advisorChainBuilder(List<CallAdvisor> advisors) {
        return new AdvisorChainBuilder(advisors);
    }
}
```

### Advisor 配置屬性

```java
@ConfigurationProperties(prefix = "app.advisor")
@Data
public class AdvisorProperties {
    
    /**
     * 安全 Advisor 配置
     */
    private Security security = new Security();
    
    /**
     * 內容過濾 Advisor 配置
     */
    private ContentFilter contentFilter = new ContentFilter();
    
    /**
     * 日誌 Advisor 配置
     */
    private Logging logging = new Logging();
    
    /**
     * 記憶 Advisor 配置
     */
    private Memory memory = new Memory();
    
    @Data
    public static class Security {
        private boolean enabled = true;
        private int order = -1000;
        private boolean strictMode = false;
        private List<String> allowedUsers = new ArrayList<>();
    }
    
    @Data
    public static class ContentFilter {
        private boolean enabled = true;
        private int order = 100;
        private List<String> blockedWords = new ArrayList<>();
        private boolean enableAiFilter = true;
    }
    
    @Data
    public static class Logging {
        private boolean enabled = true;
        private int order = 800;
        private boolean logRequests = true;
        private boolean logResponses = true;
        private boolean logMetadata = true;
    }
    
    @Data
    public static class Memory {
        private boolean enabled = true;
        private int order = 0;
        private int maxMessages = 100;
        private boolean autoCleanup = true;
    }
}
```

### 動態 Advisor 鏈建構

```java
@Component
public class AdvisorChainBuilder {
    
    private final List<CallAdvisor> availableAdvisors;
    private final AdvisorProperties properties;
    
    public AdvisorChainBuilder(List<CallAdvisor> availableAdvisors, AdvisorProperties properties) {
        this.availableAdvisors = availableAdvisors;
        this.properties = properties;
    }
    
    /**
     * 根據用戶需求建構 Advisor 鏈
     */
    public List<CallAdvisor> buildChain(AdvisorChainRequest request) {
        List<CallAdvisor> chain = new ArrayList<>();
        
        // 1. 安全 Advisor（如果啟用）
        if (request.isSecurityRequired() && properties.getSecurity().isEnabled()) {
            findAdvisor(SecurityAdvisor.class).ifPresent(chain::add);
        }
        
        // 2. 內容過濾 Advisor（如果啟用）
        if (request.isContentFilterRequired() && properties.getContentFilter().isEnabled()) {
            findAdvisor(ContentFilterAdvisor.class).ifPresent(chain::add);
        }
        
        // 3. 記憶 Advisor（如果啟用）
        if (request.isMemoryRequired() && properties.getMemory().isEnabled()) {
            findAdvisor(MessageChatMemoryAdvisor.class).ifPresent(chain::add);
        }
        
        // 4. 自定義 Advisor
        request.getCustomAdvisors().forEach(advisorClass -> {
            findAdvisor(advisorClass).ifPresent(chain::add);
        });
        
        // 5. 日誌 Advisor（如果啟用）
        if (request.isLoggingRequired() && properties.getLogging().isEnabled()) {
            findAdvisor(LoggingAdvisor.class).ifPresent(chain::add);
        }
        
        // 按 Order 排序
        return chain.stream()
            .sorted(Comparator.comparingInt(CallAdvisor::getOrder))
            .collect(Collectors.toList());
    }
    
    private <T extends CallAdvisor> Optional<T> findAdvisor(Class<T> advisorClass) {
        return availableAdvisors.stream()
            .filter(advisorClass::isInstance)
            .map(advisorClass::cast)
            .findFirst();
    }
}
```

---

## 6.4.4 Advisor 效能優化

### 非同步 Advisor 處理

```java
/**
 * 非同步日誌 Advisor
 * 避免日誌記錄影響 AI 回應速度
 */
@Component
@Slf4j
public class AsyncLoggingAdvisor implements CallAdvisor {
    
    private final AsyncAuditLogService asyncAuditLogService;
    private final ExecutorService executorService;
    
    public AsyncLoggingAdvisor(AsyncAuditLogService asyncAuditLogService) {
        this.asyncAuditLogService = asyncAuditLogService;
        this.executorService = Executors.newFixedThreadPool(5, 
            new ThreadFactoryBuilder()
                .setNameFormat("async-logging-%d")
                .setDaemon(true)
                .build());
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        // 非同步記錄請求
        CompletableFuture.runAsync(() -> {
            try {
                logRequest(request);
            } catch (Exception e) {
                log.error("Async request logging failed", e);
            }
        }, executorService);
        
        // 繼續執行鏈中的下一個 Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // 非同步記錄回應
        CompletableFuture.runAsync(() -> {
            try {
                logResponse(response);
            } catch (Exception e) {
                log.error("Async response logging failed", e);
            }
        }, executorService);
        
        return response;
    }
    
    @PreDestroy
    public void shutdown() {
        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
```

### Advisor 快取機制

```java
/**
 * 快取增強的內容過濾 Advisor
 */
@Component
public class CachedContentFilterAdvisor implements CallAdvisor {
    
    private final ContentFilterService filterService;
    private final Cache<String, FilterResult> filterCache;
    
    public CachedContentFilterAdvisor(ContentFilterService filterService, CacheManager cacheManager) {
        this.filterService = filterService;
        this.filterCache = cacheManager.getCache("content-filter", String.class, FilterResult.class);
    }
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String content = extractUserMessage(request);
        String contentHash = DigestUtils.md5Hex(content);
        
        // 嘗試從快取取得過濾結果
        FilterResult cachedResult = filterCache.get(contentHash);
        
        if (cachedResult != null) {
            log.debug("Using cached filter result for content hash: {}", contentHash);
            request = processCachedResult(request, cachedResult);
        } else {
            // 快取未命中，執行過濾並快取結果
            FilterResult filterResult = filterService.filterInput(content);
            filterCache.put(contentHash, filterResult);
            request = processFilterResult(request, filterResult);
        }
        
        // 繼續執行鏈中的下一個 Advisor
        return chain.nextCall(request);
    }
}
```

### Advisor 效能監控

```java
/**
 * Advisor 效能監控服務
 */
@Service
@RequiredArgsConstructor
public class AdvisorMetricsService {
    
    private final MeterRegistry meterRegistry;
    
    /**
     * 記錄 Advisor 執行時間
     */
    public <T> T timeAdvisorExecution(String advisorName, String phase, Supplier<T> operation) {
        return Timer.Sample.start(meterRegistry)
            .stop(Timer.builder("advisor.execution.time")
                .description("Advisor execution time")
                .tag("advisor", advisorName)
                .tag("phase", phase)
                .register(meterRegistry))
            .recordCallable(operation::get);
    }
    
    /**
     * 記錄 Advisor 執行次數
     */
    public void recordAdvisorExecution(String advisorName, String phase, boolean success) {
        meterRegistry.counter("advisor.executions",
            "advisor", advisorName,
            "phase", phase,
            "success", String.valueOf(success))
            .increment();
    }
    
    /**
     * 記錄 Advisor 鏈長度
     */
    public void recordChainLength(int chainLength) {
        meterRegistry.gauge("advisor.chain.length", chainLength);
    }
}
```

---

## 6.4.5 企業級 Advisor 應用場景

### 1. 多租戶 Advisor

```java
/**
 * 多租戶隔離 Advisor
 */
@Component
public class MultiTenantAdvisor implements CallAdvisor {
    
    private final TenantService tenantService;
    private final TenantContextHolder tenantContextHolder;
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String tenantId = extractTenantId(request);
        
        // 驗證租戶
        Tenant tenant = tenantService.validateTenant(tenantId);
        if (tenant == null) {
            throw new IllegalArgumentException("Invalid tenant: " + tenantId);
        }
        
        // 設定租戶上下文
        tenantContextHolder.setCurrentTenant(tenant);
        
        try {
            // 應用租戶特定的配置
            request = applyTenantConfiguration(request, tenant);
            
            // 繼續執行鏈中的下一個 Advisor
            ChatClientResponse response = chain.nextCall(request);
            
            // 應用租戶特定的回應處理
            return applyTenantResponseProcessing(response, tenant);
        } finally {
            // 清理租戶上下文
            tenantContextHolder.clear();
        }
    }
}
```

### 2. 成本控制 Advisor

```java
/**
 * 成本控制 Advisor
 */
@Component
public class CostControlAdvisor implements CallAdvisor {
    
    private final CostTrackingService costTrackingService;
    private final BudgetService budgetService;
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String userId = extractUserId(request);
        
        // 檢查用戶預算
        Budget userBudget = budgetService.getUserBudget(userId);
        if (userBudget.isExceeded()) {
            throw new BudgetExceededException("User budget exceeded: " + userId);
        }
        
        // 估算請求成本
        CostEstimate estimate = costTrackingService.estimateRequestCost(request);
        if (!userBudget.canAfford(estimate.getEstimatedCost())) {
            throw new InsufficientBudgetException("Insufficient budget for request");
        }
        
        // 繼續執行鏈中的下一個 Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // 計算實際成本
        Cost actualCost = costTrackingService.calculateActualCost(response);
        
        // 扣除用戶預算
        budgetService.deductBudget(userId, actualCost);
        
        // 記錄成本統計
        costTrackingService.recordCost(userId, actualCost, estimate);
        
        return response;
    }
}
```

### 3. A/B 測試 Advisor

```java
/**
 * A/B 測試 Advisor
 */
@Component
public class ABTestAdvisor implements CallAdvisor {
    
    private final ABTestService abTestService;
    private final ExperimentService experimentService;
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        String userId = extractUserId(request);
        Map<String, String> experiments = new HashMap<>();
        
        // 取得用戶的實驗分組
        List<Experiment> activeExperiments = experimentService.getActiveExperiments(userId);
        
        for (Experiment experiment : activeExperiments) {
            String variant = abTestService.getVariant(userId, experiment.getId());
            
            // 根據實驗變體調整請求
            request = applyExperimentVariant(request, experiment, variant);
            
            // 記錄實驗參與
            experiments.put(experiment.getId(), variant);
        }
        
        // 繼續執行鏈中的下一個 Advisor
        ChatClientResponse response = chain.nextCall(request);
        
        // 記錄實驗結果
        experiments.forEach((experimentId, variant) -> {
            abTestService.recordResult(experimentId, variant, response);
        });
        
        return response;
    }
}
```

---

## 📝 本章重點回顧

1. **鏈式機制理解**：掌握了 Advisor 的責任鏈模式和執行順序控制
2. **自定義 Advisor 開發**：學會了開發內容過濾、日誌記錄、安全檢查等增強器
3. **組合配置技巧**：掌握了多 Advisor 的組合配置和動態建構
4. **效能優化策略**：實現了非同步處理、快取機制和效能監控
5. **企業級應用**：建立了多租戶、成本控制、A/B 測試等企業場景的解決方案

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **自定義 Advisor 開發** | ⭐⭐⭐ | 中 | 業務定制化 |
| **Advisor 鏈式組合** | ⭐⭐⭐ | 中 | 功能模組化 |
| **效能優化機制** | ⭐⭐ | 高 | 系統效能 |
| **企業級應用場景** | ⭐⭐⭐ | 高 | 商業價值 |
| **監控和診斷** | ⭐⭐ | 中 | 運維管理 |

### 最佳實踐建議

1. **設計原則**：遵循單一職責原則，每個 Advisor 只負責一個特定功能
2. **執行順序**：合理設計 Advisor 的執行順序，確保依賴關係正確
3. **效能考量**：對於耗時操作使用非同步處理，避免影響 AI 回應速度
4. **錯誤處理**：實現完善的錯誤處理機制，避免單個 Advisor 影響整個鏈
5. **監控告警**：建立完整的 Advisor 執行監控和告警機制

### 下一步學習方向

在下一章中，我們將學習如何自行開發 Spring AI 插件，包括：
- 插件架構設計和開發規範
- 自定義功能模組的實現
- 插件的打包、分發和部署
- 與 Spring AI 生態系統的整合

---

**參考資料：**
- [Spring AI Advisors Documentation](https://docs.spring.io/spring-ai/reference/api/advisors.html)
- [Chain of Responsibility Pattern](https://refactoring.guru/design-patterns/chain-of-responsibility)
- [Spring Boot Conditional Configuration](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration.condition-annotations)
- [Micrometer Metrics](https://micrometer.io/docs)


\newpage

## 6.5 Spring AI 擴展機制：Advisors 與 Tools 開發


> **本章重點**：學習 Spring AI 的官方擴展機制，包括 Advisors API 和 Tools 開發，從基礎概念到實際應用，建立強大的 AI 增強功能。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握 Advisors 架構**：理解 Spring AI Advisors 系統的設計原理和執行流程
- 🎯 **開發自定義 Advisors**：學會創建請求/響應攔截器和數據轉換器
- 🎯 **實現 Tools 功能**：掌握工具調用機制，整合外部 API 和服務
- 🎯 **管理擴展生命週期**：理解擴展的載入、執行順序和上下文管理
- 🎯 **整合第三方服務**：將外部服務和 API 整合到 Spring AI 生態中

---

## 6.5.1 Spring AI 擴展架構概述

### 擴展系統的設計理念

Spring AI 採用多層次擴展機制，提供靈活的增強點來擴展 AI 應用功能，而不需要修改核心框架。

**核心設計原則**：
- 🔌 **多重擴展點**：Advisors、Tools、ETL Pipeline 等不同層次的擴展
- 🏗️ **標準化介面**：統一的擴展開發規範和 API
- 🔄 **鏈式執行**：支援多個擴展組件的有序執行
- 🛡️ **類型安全**：強類型介面設計，確保擴展安全性
- 📦 **Spring 整合**：完整的 Spring Boot 自動配置支援

### Spring AI 擴展架構圖

```
┌─────────────────────────────────────────────────────────────┐
│              Spring AI Extension Architecture               │
├─────────────────────────────────────────────────────────────┤
│  Application Layer                                          │
│  ┌─────────────────┐    ┌─────────────────┐               │
│  │   ChatClient    │    │   ChatModel     │               │
│  │                 │    │                 │               │
│  └─────────────────┘    └─────────────────┘               │
├─────────────────────────────────────────────────────────────┤
│  Extension Layer                                            │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Advisors Chain                             │ │
│  │  ┌─────────────────────────────────────────────────┐   │ │
│  │  │  • CallAroundAdvisor                            │   │ │
│  │  │  • StreamAroundAdvisor                          │   │ │
│  │  │  • Chain Execution & Context Management        │   │ │
│  │  └─────────────────────────────────────────────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Tools System                               │ │
│  │  • ToolCallback Interface                              │ │
│  │  • ToolCallingManager                                  │ │
│  │  • Method-based Tools (@Tool)                          │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Implementation Layer                                       │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │Custom       │ │Memory       │ │RAG          │          │
│  │Advisors     │ │Advisors     │ │Advisors     │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │Weather      │ │Database     │ │External API │          │
│  │Tools        │ │Tools        │ │Tools        │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

---

## 6.5.2 Advisors API 基礎框架

### 核心 Advisor 介面定義

```java
/**
 * Spring AI Advisor 基礎介面
 */
public interface Advisor extends Ordered {
    
    /**
     * Advisor 唯一名稱
     */
    String getName();
    
    /**
     * 執行順序，數值越小優先級越高
     */
    int getOrder();
}

/**
 * 同步調用 Advisor 介面
 */
public interface CallAroundAdvisor extends Advisor {
    
    /**
     * 環繞通知，攔截 ChatModel.call() 方法
     * @param advisedRequest 請求物件
     * @param chain advisor 鏈
     * @return 響應物件
     */
    AdvisedResponse aroundCall(AdvisedRequest advisedRequest, CallAroundAdvisorChain chain);
}

/**
 * 流式調用 Advisor 介面
 */
public interface StreamAroundAdvisor extends Advisor {
    
    /**
     * 環繞通知，攔截 ChatModel.stream() 方法
     * @param advisedRequest 請求物件
     * @param chain advisor 鏈
     * @return 響應流
     */
    Flux<AdvisedResponse> aroundStream(AdvisedRequest advisedRequest, StreamAroundAdvisorChain chain);
}

/**
 * Advisor 鏈介面 - 同步
 */
public interface CallAroundAdvisorChain {
    AdvisedResponse nextAroundCall(AdvisedRequest advisedRequest);
}

/**
 * Advisor 鏈介面 - 異步
 */
public interface StreamAroundAdvisorChain {
    Flux<AdvisedResponse> nextAroundStream(AdvisedRequest advisedRequest);
}
```

### Advisors 執行流程管理

```java
/**
 * AdvisedRequest - 包裝的請求物件
 */
public record AdvisedRequest(
    Prompt prompt,
    String userText,
    Map<String, Object> userParams,
    Map<String, Object> systemParams,
    Map<String, Object> advisorContext
) {
    
    /**
     * 更新上下文
     */
    public AdvisedRequest updateContext(Function<Map<String, Object>, Map<String, Object>> contextUpdater) {
        Map<String, Object> updatedContext = contextUpdater.apply(new HashMap<>(advisorContext));
        return new AdvisedRequest(prompt, userText, userParams, systemParams, Map.copyOf(updatedContext));
    }
    
    /**
     * 建造者模式
     */
    public static Builder from(AdvisedRequest request) {
        return new Builder(request);
    }
}

/**
 * AdvisedResponse - 包裝的響應物件
 */
public record AdvisedResponse(
    ChatCompletion chatCompletion,
    Map<String, Object> advisorContext
) {
    
    /**
     * 取得響應內容
     */
    public String content() {
        return chatCompletion.content();
    }
}
/**
 * MessageAggregator - 消息聚合器工具類
 */
public class MessageAggregator {
    
    /**
     * 聚合流式響應為單一響應
     */
    public Flux<AdvisedResponse> aggregateAdvisedResponse(
            Flux<AdvisedResponse> advisedResponses, 
            Consumer<AdvisedResponse> onComplete) {
        
        return advisedResponses
            .buffer() // 集合所有響應
            .map(responses -> {
                // 合併所有響應內容
                StringBuilder combinedContent = new StringBuilder();
                Map<String, Object> finalContext = new HashMap<>();
                
                for (AdvisedResponse response : responses) {
                    combinedContent.append(response.content());
                    finalContext.putAll(response.advisorContext());
                }
                
                AdvisedResponse aggregated = new AdvisedResponse(
                    new ChatCompletion(combinedContent.toString()),
                    finalContext
                );
                
                onComplete.accept(aggregated);
                return aggregated;
            })
            .flatMapIterable(response -> List.of(response));
    }
}
/**
 * 自定義 Advisor 配置類
 */
@Component
@Slf4j
public class AdvisorConfiguration {
    
    /**
     * 配置 ChatClient 的預設 Advisors
     */
    @Bean
    public ChatClient chatClient(
            ChatModel chatModel,
            ChatMemory chatMemory,
            VectorStore vectorStore) {
        
        return ChatClient.builder(chatModel)
            .defaultAdvisors(
                // 記憶管理 Advisor
                MessageChatMemoryAdvisor.builder(chatMemory).build(),
                
                // RAG 問答 Advisor  
                QuestionAnswerAdvisor.builder(vectorStore).build(),
                
                // 自定義日誌 Advisor
                new SimpleLoggerAdvisor(),
                
                // Re-Reading Advisor
                new ReReadingAdvisor()
            )
            .build();
    }
}
/**
 * Spring AI 內建 Advisors
 */
public class BuiltInAdvisors {
    
    /**
     * 記憶管理 Advisor - 為對話提供上下文記憶
     */
    public static class MessageChatMemoryAdvisor implements CallAroundAdvisor, StreamAroundAdvisor {
        
        private final ChatMemory chatMemory;
        
        public MessageChatMemoryAdvisor(ChatMemory chatMemory) {
            this.chatMemory = chatMemory;
        }
        
        @Override
        public String getName() {
            return "MessageChatMemoryAdvisor";
        }
        
        @Override
        public int getOrder() {
            return 100; // 預設優先級
        }
        
        @Override
        public AdvisedResponse aroundCall(AdvisedRequest request, CallAroundAdvisorChain chain) {
            // 從記憶中恢復歷史對話
            String conversationId = (String) request.userParams().get(ChatMemory.CONVERSATION_ID);
            List<Message> history = chatMemory.get(conversationId);
            
            // 將歷史加入請求
            Prompt enhancedPrompt = new Prompt(history);
            AdvisedRequest enhancedRequest = AdvisedRequest.from(request)
                .prompt(enhancedPrompt)
                .build();
            
            // 繼續執行鏈
            AdvisedResponse response = chain.nextAroundCall(enhancedRequest);
            
            // 將新的對話儲存到記憶中
            chatMemory.add(conversationId, request.userText(), response.content());
            
            return response;
        }
        
        @Override
        public Flux<AdvisedResponse> aroundStream(AdvisedRequest request, StreamAroundAdvisorChain chain) {
            // 簡化版本，實際實作會更複雜
            return chain.nextAroundStream(request);
        }
        
        public static Builder builder(ChatMemory chatMemory) {
            return new Builder(chatMemory);
        }
        
        public static class Builder {
            private final ChatMemory chatMemory;
            
            public Builder(ChatMemory chatMemory) {
                this.chatMemory = chatMemory;
            }
            
            public MessageChatMemoryAdvisor build() {
                return new MessageChatMemoryAdvisor(chatMemory);
            }
        }
    }
    
    /**
     * RAG 問答 Advisor - 提供檢索增強產生功能
     */
    public static class QuestionAnswerAdvisor implements CallAroundAdvisor, StreamAroundAdvisor {
        
        private final VectorStore vectorStore;
        
        public QuestionAnswerAdvisor(VectorStore vectorStore) {
            this.vectorStore = vectorStore;
        }
        
        @Override
        public String getName() {
            return "QuestionAnswerAdvisor";
        }
        
        @Override
        public int getOrder() {
            return 200;
        }
        
        @Override
        public AdvisedResponse aroundCall(AdvisedRequest request, CallAroundAdvisorChain chain) {
            // 從向量資料庫檢索相關文檔
            List<Document> relevantDocs = vectorStore.similaritySearch(
                SearchRequest.query(request.userText()).withTopK(5)
            );
            
            // 將相關文檔加入系統提示
            String context = relevantDocs.stream()
                .map(Document::getContent)
                .collect(Collectors.joining("\n"));
                
            String systemMessage = "Based on the following context, please answer the user's question:\n" + context;
            
            AdvisedRequest enhancedRequest = AdvisedRequest.from(request)
                .systemParams(Map.of("context", context))
                .build();
            
            return chain.nextAroundCall(enhancedRequest);
        }
        
        @Override
        public Flux<AdvisedResponse> aroundStream(AdvisedRequest request, StreamAroundAdvisorChain chain) {
            // 簡化版本
            return chain.nextAroundStream(request);
        }
        
        public static Builder builder(VectorStore vectorStore) {
            return new Builder(vectorStore);
        }
        
        public static class Builder {
            private final VectorStore vectorStore;
            
            public Builder(VectorStore vectorStore) {
                this.vectorStore = vectorStore;
            }
            
            public QuestionAnswerAdvisor build() {
                return new QuestionAnswerAdvisor(vectorStore);
            }
        }
    }
}
```

---

## 6.5.3 實戰：開發自定義 Advisor

### 簡單日誌 Advisor

```java
/**
 * 簡單日誌 Advisor - 記錄請求和響應
 */
@Component
@Slf4j
public class SimpleLoggerAdvisor implements CallAroundAdvisor, StreamAroundAdvisor {
    
    @Override
    public String getName() {
        return "SimpleLoggerAdvisor";
    }
    
    @Override
    public int getOrder() {
        return 0; // 高優先級，率先執行
    }
    
    @Override
    public AdvisedResponse aroundCall(AdvisedRequest advisedRequest, CallAroundAdvisorChain chain) {
        
        log.debug("BEFORE CALL: User={}, Context={}", 
            advisedRequest.userText(), 
            advisedRequest.advisorContext());
        
        // 記錄請求時間
        long startTime = System.currentTimeMillis();
        
        AdvisedResponse advisedResponse = chain.nextAroundCall(advisedRequest);
        
        long duration = System.currentTimeMillis() - startTime;
        
        log.debug("AFTER CALL: Response={}, Duration={}ms", 
            advisedResponse.content().substring(0, Math.min(100, advisedResponse.content().length())), 
            duration);
        
        return advisedResponse;
    }
    
    @Override
    public Flux<AdvisedResponse> aroundStream(AdvisedRequest advisedRequest, StreamAroundAdvisorChain chain) {
        
        log.debug("BEFORE STREAM: User={}", advisedRequest.userText());
        
        Flux<AdvisedResponse> advisedResponses = chain.nextAroundStream(advisedRequest);
        
        // 使用 MessageAggregator 整合流式響應進行日誌記錄
        return new MessageAggregator().aggregateAdvisedResponse(advisedResponses,
            advisedResponse -> log.debug("AFTER STREAM: {}", 
                advisedResponse.content().substring(0, Math.min(100, advisedResponse.content().length()))
            )
        );
    }
}
```

### Re-Reading (Re2) Advisor

```java
/**
 * Re-Reading Advisor - 實現 Re2 技術提升推理能力
 */
@Component
@Slf4j  
public class ReReadingAdvisor implements CallAroundAdvisor, StreamAroundAdvisor {
    
    @Override
    public String getName() {
        return "ReReadingAdvisor";
    }
    
    @Override
    public int getOrder() {
        return 50; // 中等優先級
    }
    
    /**
     * 預處理方法 - 將 Re2 技術應用到使用者輸入
     */
    private AdvisedRequest before(AdvisedRequest advisedRequest) {
        
        Map<String, Object> advisedUserParams = new HashMap<>(advisedRequest.userParams());
        advisedUserParams.put("re2_input_query", advisedRequest.userText());
        
        return AdvisedRequest.from(advisedRequest)
            .userText("""
                {re2_input_query}
                Read the question again: {re2_input_query}
                """)
            .userParams(advisedUserParams)
            .build();
    }
    
    @Override
    public AdvisedResponse aroundCall(AdvisedRequest advisedRequest, CallAroundAdvisorChain chain) {
        return chain.nextAroundCall(this.before(advisedRequest));
    }
    
    @Override
    public Flux<AdvisedResponse> aroundStream(AdvisedRequest advisedRequest, StreamAroundAdvisorChain chain) {
        return chain.nextAroundStream(this.before(advisedRequest));
    }
}
```

---

## 6.5.4 Tools 開發實戰

### 天氣查詢工具開發

```java
/**
 * 天氣查詢工具類
 */
@Component
@Slf4j
public class WeatherTools {
    
    private final WeatherService weatherService;
    
    public WeatherTools() {
        // 初始化天氣服務（實際應用中應使用配置注入）
        String apiKey = System.getenv("WEATHER_API_KEY");
        String baseUrl = "https://api.openweathermap.org/data/2.5";
        this.weatherService = new WeatherService(apiKey, baseUrl);
    }
    
    /**
     * 取得當前天氣 - 使用 @Tool 註解
     */
    @Tool(description = "Get current weather information for a specific location")
    public WeatherInfo getCurrentWeather(WeatherRequest request) {
        try {
            log.debug("Getting current weather for: {}", request.location());
            
            WeatherInfo weather = weatherService.getCurrentWeather(
                request.location(),
                request.unit()
            );
            
            log.debug("Weather retrieved successfully for: {}", request.location());
            return weather;
            
        } catch (Exception e) {
            log.error("Failed to get weather for: {}", request.location(), e);
            throw new RuntimeException("Failed to get weather information", e);
        }
    }
    
    /**
     * 取得天氣預報
     */
    @Tool(description = "Get weather forecast for a specific location")
    public List<WeatherForecast> getWeatherForecast(ForecastRequest request) {
        try {
            log.debug("Getting weather forecast for: {}", request.location());
            
            List<WeatherForecast> forecast = weatherService.getWeatherForecast(
                request.location(),
                request.days(),
                request.unit()
            );
            
            log.debug("Weather forecast retrieved successfully for: {}", request.location());
            return forecast;
            
        } catch (Exception e) {
            log.error("Failed to get weather forecast for: {}", request.location(), e);
            throw new RuntimeException("Failed to get weather forecast", e);
        }
    }
    
    /**
     * 設定鬧鐘 - 行動類工具
     */
    @Tool(description = "Set an alarm for the given time, provided in ISO-8601 format")
    public String setAlarm(String time) {
        try {
            LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME);
            log.info("Alarm set for {}", alarmTime);
            
            // 實際應用中這裡會整合真實的鬧鐘系統
            return String.format("Alarm successfully set for %s", alarmTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
            
        } catch (Exception e) {
            log.error("Failed to set alarm for time: {}", time, e);
            throw new RuntimeException("Failed to set alarm", e);
        }
    }
    
    /**
     * 取得當前時間 - 資訊檢索類工具
     */
    @Tool(description = "Get the current date and time in the user's timezone")
    public String getCurrentDateTime() {
        return LocalDateTime.now()
            .atZone(LocaleContextHolder.getTimeZone().toZoneId())
            .format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
    }
}
```

### 工具資料模型

```java
/**
 * 天氣查詢請求 - 使用 Record 類型
 */
public record WeatherRequest(
    @JsonProperty("location")
    @JsonPropertyDescription("The location to get weather for (city name, coordinates, etc.)")
    String location,
    
    @JsonProperty("unit")
    @JsonPropertyDescription("Temperature unit: celsius, fahrenheit, or kelvin")
    String unit
) {
    // 預設建構器
    public WeatherRequest {
        if (unit == null) {
            unit = "celsius";
        }
    }
}

/**
 * 天氣預報請求
 */
public record ForecastRequest(
    @JsonProperty("location")
    @JsonPropertyDescription("The location to get weather forecast for")
    String location,
    
    @JsonProperty("days")
    @JsonPropertyDescription("Number of days for forecast (1-7)")
    Integer days,
    
    @JsonProperty("unit")
    @JsonPropertyDescription("Temperature unit: celsius, fahrenheit, or kelvin")
    String unit
) {
    public ForecastRequest {
        if (days == null) {
            days = 3;
        }
        if (unit == null) {
            unit = "celsius";
        }
    }
}

/**
 * 天氣資訊
 */
public record WeatherInfo(
    String location,
    String description,
    double temperature,
    double feelsLike,
    int humidity,
    double windSpeed,
    String unit,
    LocalDateTime timestamp
) {}

/**
 * 天氣預報
 */
public record WeatherForecast(
    LocalDate date,
    String description,
    double maxTemperature,
    double minTemperature,
    int humidity,
    double windSpeed,
    String unit
) {}
```

### ChatClient 與 Tools 使用示例

```java
/**
 * ChatClient 使用天氣工具的示例
 */
@Component
@Slf4j
public class WeatherChatExample {
    
    private final ChatClient chatClient;
    private final WeatherTools weatherTools;
    
    public WeatherChatExample(ChatModel chatModel, WeatherTools weatherTools) {
        this.weatherTools = weatherTools;
        this.chatClient = ChatClient.create(chatModel);
    }
    
    /**
     * 使用 Tools 的基本對話
     */
    public String askWeatherQuestion(String question) {
        return chatClient
            .prompt(question)
            .tools(weatherTools) // 直接傳遞工具類實例
            .call()
            .content();
    }
    
    /**
     * 使用多個 Tools 的進階示例
     */
    public String complexWeatherQuery(String query) {
        
        // 使用多個工具類
        DateTimeTools dateTimeTools = new DateTimeTools();
        
        return chatClient
            .prompt(query)
            .tools(weatherTools, dateTimeTools)
            .call()
            .content();
    }
    
    /**
     * 使用 Advisors 和 Tools 結合
     */
    public String enhancedWeatherChat(String question, String conversationId) {
        
        return ChatClient.builder(chatClient.getChatModel())
            .defaultAdvisors(
                new SimpleLoggerAdvisor(),
                new ReReadingAdvisor()
            )
            .build()
            .prompt(question)
            .advisors(advisor -> advisor.param(ChatMemory.CONVERSATION_ID, conversationId))
            .tools(weatherTools)
            .call()
            .content();
    }
}
```

### 日期時間工具類

```java
/**
 * 日期時間相關工具
 */
@Component
public class DateTimeTools {
    
    @Tool(description = "Get the current date and time in the user's timezone")
    public String getCurrentDateTime() {
        return LocalDateTime.now()
            .atZone(LocaleContextHolder.getTimeZone().toZoneId())
            .toString();
    }
    
    @Tool(description = "Set a user alarm for the given time, provided in ISO-8601 format")
    public String setAlarm(String time) {
        try {
            LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME);
            System.out.println("Alarm set for " + alarmTime);
            return "Alarm set successfully for " + alarmTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"));
        } catch (Exception e) {
            throw new RuntimeException("Invalid time format. Please use ISO-8601 format.", e);
        }
    }
}
/**
 * 天氣服務實現類 - 簡化版
 */
@Service
@Slf4j
public class WeatherService {
    
    private final String apiKey;
    private final String baseUrl;
    private final RestTemplate restTemplate;
    
    public WeatherService(@Value("${weather.api.key}") String apiKey,
                         @Value("${weather.api.baseUrl:https://api.openweathermap.org/data/2.5}") String baseUrl) {
        this.apiKey = apiKey;
        this.baseUrl = baseUrl;
        this.restTemplate = new RestTemplate();
    }
    
    public WeatherInfo getCurrentWeather(String location, String unit) {
        try {
            String url = String.format("%s/weather?q=%s&appid=%s&units=%s",
                baseUrl, location, apiKey, convertUnit(unit));
                
            // 簡化的實作，實際應用中會需要更完整的錯誤處理
            Map<String, Object> response = restTemplate.getForObject(url, Map.class);
            
            return new WeatherInfo(
                (String) response.get("name"),
                (String) ((Map) ((List) response.get("weather")).get(0)).get("description"),
                ((Number) ((Map) response.get("main")).get("temp")).doubleValue(),
                ((Number) ((Map) response.get("main")).get("feels_like")).doubleValue(),
                ((Number) ((Map) response.get("main")).get("humidity")).intValue(),
                ((Number) ((Map) response.get("wind")).get("speed")).doubleValue(),
                unit,
                LocalDateTime.now()
            );
            
        } catch (Exception e) {
            log.error("Failed to get current weather for: {}", location, e);
            throw new RuntimeException("Weather service error", e);
        }
    }
    
    public List<WeatherForecast> getWeatherForecast(String location, int days, String unit) {
        // 簡化實作 - 實際應用中會需要完整的 API 調用和數據處理
        List<WeatherForecast> forecasts = new ArrayList<>();
        
        for (int i = 1; i <= days; i++) {
            forecasts.add(new WeatherForecast(
                LocalDate.now().plusDays(i),
                "Partly cloudy",
                25.0 + i, // 模擬數據
                15.0 + i,
                60 + i * 2,
                10.5,
                unit
            ));
        }
        
        return forecasts;
    }
    
    private String convertUnit(String unit) {
        if (unit == null) return "metric";
        return switch (unit.toLowerCase()) {
            case "celsius" -> "metric";
            case "fahrenheit" -> "imperial";
            case "kelvin" -> "standard";
            default -> "metric";
        };
    }
}
```

---

## 6.5.5 Spring AI 配置與部署

### Application 配置檔案

```yaml
# application.yml - Spring AI 配置
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      chat:
        options:
          model: gpt-4o-mini
          temperature: 0.7
    
    # 向量資料庫配置
    vectordatabase:
      pgvector:
        url: jdbc:postgresql://localhost:5432/vectordb
        username: ${DB_USERNAME}
        password: ${DB_PASSWORD}
        
# 天氣 API 配置
weather:
  api:
    key: ${WEATHER_API_KEY}
    baseUrl: https://api.openweathermap.org/data/2.5
    timeout: 5000
    retries: 3

# 應用程序配置
logging:
  level:
    org.springframework.ai: DEBUG
    com.example.advisor: DEBUG
    com.example.tools: DEBUG
```

### Spring Boot 自動配置

```java
/**
 * Spring AI 自動配置類
 */
@Configuration
@EnableConfigurationProperties({WeatherProperties.class})
@Slf4j
public class SpringAIAutoConfiguration {
    
    /**
     * 配置 ChatClient Bean
     */
    @Bean
    @ConditionalOnMissingBean
    public ChatClient chatClient(
            ChatModel chatModel,
            @Autowired(required = false) List<Advisor> advisors,
            @Autowired(required = false) ChatMemory chatMemory,
            @Autowired(required = false) VectorStore vectorStore) {
        
        var builder = ChatClient.builder(chatModel);
        
        // 自動註冊所有可用的 Advisors
        if (advisors != null && !advisors.isEmpty()) {
            builder.defaultAdvisors(advisors.toArray(new Advisor[0]));
        }
        
        // 自動添加常用的 Advisors
        List<Advisor> defaultAdvisors = new ArrayList<>();
        
        if (chatMemory != null) {
            defaultAdvisors.add(MessageChatMemoryAdvisor.builder(chatMemory).build());
        }
        
        if (vectorStore != null) {
            defaultAdvisors.add(QuestionAnswerAdvisor.builder(vectorStore).build());
        }
        
        if (!defaultAdvisors.isEmpty()) {
            builder.defaultAdvisors(defaultAdvisors.toArray(new Advisor[0]));
        }
        
        return builder.build();
    }
    
    /**
     * 自動註冊所有 Tools
     */
    @Bean
    @ConditionalOnMissingBean
    public ToolCallbackResolver toolCallbackResolver(ApplicationContext applicationContext) {
        return new SpringContextToolCallbackResolver(applicationContext);
    }
    
    /**
     * 天氣工具配置
     */
    @Bean
    @ConditionalOnProperty(name = "weather.enabled", havingValue = "true", matchIfMissing = true)
    public WeatherTools weatherTools(WeatherService weatherService) {
        return new WeatherTools(weatherService);
    }
    
    /**
     * 日期時間工具配置
     */
    @Bean
    public DateTimeTools dateTimeTools() {
        return new DateTimeTools();
    }
    
    /**
     * 自定義 Advisors 配置
     */
    @Bean
    @ConditionalOnProperty(name = "spring.ai.advisor.logger.enabled", havingValue = "true", matchIfMissing = true)
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public SimpleLoggerAdvisor simpleLoggerAdvisor() {
        return new SimpleLoggerAdvisor();
    }
    
    @Bean
    @ConditionalOnProperty(name = "spring.ai.advisor.rereading.enabled", havingValue = "true")
    @Order(50)
    public ReReadingAdvisor reReadingAdvisor() {
        return new ReReadingAdvisor();
    }
    
    /**
     * 向量資料庫配置
     */
    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnProperty(name = "spring.ai.vectordatabase.pgvector.enabled", havingValue = "true")
    public VectorStore vectorStore(@Value("${spring.ai.vectordatabase.pgvector.url}") String url,
                                   @Value("${spring.ai.vectordatabase.pgvector.username}") String username,
                                   @Value("${spring.ai.vectordatabase.pgvector.password}") String password) {
        // PgVector 配置
        return new PgVectorStore(url, username, password);
    }
    
    /**
     * 記憶管理配置
     */
    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnProperty(name = "spring.ai.chat.memory.enabled", havingValue = "true")
    public ChatMemory chatMemory() {
        return new InMemoryChatMemory();
    }
}

/**
 * 天氣配置屬性
 */
@ConfigurationProperties(prefix = "weather")
@Data
public class WeatherProperties {
    private Api api = new Api();
    
    @Data
    public static class Api {
        private String key;
        private String baseUrl = "https://api.openweathermap.org/data/2.5";
        private int timeout = 5000;
        private int retries = 3;
    }
}
/**
 * Spring Context Tool Callback Resolver
 */
public class SpringContextToolCallbackResolver implements ToolCallbackResolver {
    
    private final ApplicationContext applicationContext;
    
    public SpringContextToolCallbackResolver(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    
    @Override
    public List<ToolCallback> resolve(String... toolNames) {
        List<ToolCallback> callbacks = new ArrayList<>();
        
        // 從 Spring 上下文中解析工具
        for (String toolName : toolNames) {
            try {
                Object bean = applicationContext.getBean(toolName);
                if (bean != null) {
                    // 將 Bean 轉換為 ToolCallback
                    ToolCallback callback = createToolCallbackFromBean(bean);
                    if (callback != null) {
                        callbacks.add(callback);
                    }
                }
            } catch (Exception e) {
                log.warn("Failed to resolve tool: {}", toolName, e);
            }
        }
        
        return callbacks;
    }
    
    private ToolCallback createToolCallbackFromBean(Object bean) {
        // 使用反射將 @Tool 註解的方法轉換為 ToolCallback
        return MethodToolCallback.fromObject(bean);
    }
}
```

---

## 6.5.6 實際使用示例

### 建立完整的 AI 應用

```java
/**
 * AI 助理應用控制器
 */
@RestController
@RequestMapping("/api/ai")
@RequiredArgsConstructor
@Slf4j
public class AIAssistantController {
    
    private final ChatClient chatClient;
    private final WeatherTools weatherTools;
    private final DateTimeTools dateTimeTools;
    
    /**
     * 基本 AI 對話
     */
    @PostMapping("/chat")
    public ResponseEntity<ChatResponse> chat(@RequestBody ChatRequest request) {
        try {
            String response = chatClient
                .prompt(request.getMessage())
                .call()
                .content();
            
            return ResponseEntity.ok(new ChatResponse(response));
        } catch (Exception e) {
            log.error("Chat error", e);
            return ResponseEntity.status(500)
                .body(new ChatResponse("Sorry, I encountered an error: " + e.getMessage()));
        }
    }
    
    /**
     * 安裝插件
     */
    @PostMapping("/install")
    public ResponseEntity<ApiResponse> installPlugin(@RequestBody InstallPluginRequest request) {
        try {
            pluginService.installPlugin(request.getPluginPath());
            return ResponseEntity.ok(ApiResponse.success("Plugin installed successfully"));
        } catch (PluginException e) {
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Plugin installation failed: " + e.getMessage()));
        }
    }
    
    /**
     * 啟用插件
     */
    @PostMapping("/{pluginId}/enable")
    public ResponseEntity<ApiResponse> enablePlugin(@PathVariable String pluginId) {
        try {
            pluginService.enablePlugin(pluginId);
            return ResponseEntity.ok(ApiResponse.success("Plugin enabled successfully"));
        } catch (PluginException e) {
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Plugin enable failed: " + e.getMessage()));
        }
    }
    
    /**
     * 停用插件
     */
    @PostMapping("/{pluginId}/disable")
    public ResponseEntity<ApiResponse> disablePlugin(@PathVariable String pluginId) {
        try {
            pluginService.disablePlugin(pluginId);
            return ResponseEntity.ok(ApiResponse.success("Plugin disabled successfully"));
        } catch (PluginException e) {
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Plugin disable failed: " + e.getMessage()));
        }
    }
    
    /**
     * 卸載插件
     */
    @DeleteMapping("/{pluginId}")
    public ResponseEntity<ApiResponse> uninstallPlugin(@PathVariable String pluginId) {
        try {
            pluginService.uninstallPlugin(pluginId);
            return ResponseEntity.ok(ApiResponse.success("Plugin uninstalled successfully"));
        } catch (PluginException e) {
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Plugin uninstall failed: " + e.getMessage()));
        }
    }
}
```

---

## 📝 本章重點回顧

1. **插件架構理解**：掌握了 Spring AI 插件系統的設計原理和架構模式
2. **插件開發實踐**：完成了從基礎框架到實際插件的完整開發流程
3. **生命週期管理**：實現了插件的載入、初始化、啟動、停止和卸載機制
4. **配置管理系統**：建立了完整的插件配置和管理體系
5. **REST API 整合**：提供了插件管理的 Web 介面和 API

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **插件架構設計** | ⭐⭐⭐ | 高 | 系統擴展性 |
| **生命週期管理** | ⭐⭐⭐ | 高 | 穩定性保證 |
| **配置管理** | ⭐⭐ | 中 | 易用性提升 |
| **REST API 整合** | ⭐⭐ | 中 | 管理便利性 |
| **依賴管理** | ⭐⭐ | 高 | 系統可靠性 |

### 最佳實踐建議

1. **設計原則**：遵循單一職責和開放封閉原則，確保插件的獨立性和可擴展性
2. **錯誤處理**：實現完善的錯誤處理和恢復機制，避免插件錯誤影響系統穩定性
3. **安全考量**：建立插件權限管理和安全檢查機制，防止惡意插件
4. **效能優化**：使用延遲載入和資源池化技術，提升插件系統效能
5. **文檔規範**：建立完整的插件開發文檔和規範，降低開發門檻

### 下一步學習方向

在下一章中，我們將學習如何安裝和配置 Neo4j 向量資料庫，包括：
- Neo4j 的安裝和基本配置
- 向量資料庫的概念和應用
- 與 Spring AI 的整合配置
- Docker 容器化部署

---

**參考資料：**
- [Spring Plugin Framework](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java)
- [Java Plugin Architecture](https://www.baeldung.com/java-plugin-system)
- [OSGi Bundle Development](https://www.osgi.org/developer/)
- [Spring Boot Auto Configuration](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration)


\newpage

## 6.6 安裝 Neo4j 向量資料庫


> **本章重點**：學習如何安裝和配置 Neo4j 向量資料庫，為 Spring AI 的向量記憶功能建立強大的存儲後端。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解向量資料庫概念**：掌握向量資料庫的原理和應用場景
- 🎯 **安裝 Neo4j 資料庫**：學會在不同環境中安裝和配置 Neo4j
- 🎯 **配置向量索引**：建立高效的向量搜尋和存儲機制
- 🎯 **整合 Spring AI**：將 Neo4j 與 Spring AI 記憶系統完美整合
- 🎯 **效能優化調校**：掌握 Neo4j 的效能調校和監控技巧

---

## 6.6.1 向量資料庫概述

### 什麼是向量資料庫？

向量資料庫是專門設計用來存儲、索引和查詢高維向量資料的資料庫系統。在 AI 和機器學習領域，向量資料庫扮演著關鍵角色。

**核心特性**：
- 🔍 **語義搜尋**：基於向量相似性進行搜尋，而非關鍵字匹配
- 📊 **高維支援**：支援數百到數千維的向量資料
- ⚡ **高效檢索**：使用專門的索引算法實現快速相似性搜尋
- 🔄 **實時更新**：支援向量資料的即時插入、更新和刪除
- 📈 **可擴展性**：能夠處理大規模的向量資料集

### 向量資料庫 vs 傳統資料庫

| 特性 | 傳統資料庫 | 向量資料庫 |
|------|------------|------------|
| **資料類型** | 結構化資料 | 高維向量 |
| **查詢方式** | 精確匹配 | 相似性搜尋 |
| **索引方法** | B-Tree, Hash | HNSW, IVF, LSH |
| **應用場景** | 事務處理 | AI/ML 應用 |
| **查詢語言** | SQL | 向量查詢 API |

### Neo4j 作為向量資料庫的優勢

**1. 圖形資料庫基礎**
- 🕸️ **關係建模**：天然支援複雜的資料關係
- 🔗 **圖形查詢**：強大的 Cypher 查詢語言
- 📊 **圖形分析**：內建豐富的圖形算法

**2. 向量功能整合**
- 🎯 **向量索引**：支援高效的向量相似性搜尋
- 🔄 **混合查詢**：結合圖形查詢和向量搜尋
- 📈 **可擴展性**：支援大規模向量資料處理

**3. 企業級特性**
- 🛡️ **ACID 事務**：保證資料一致性
- 🔒 **安全控制**：完整的身份驗證和授權
- 📊 **監控管理**：豐富的監控和管理工具

---

## 6.6.2 Neo4j 安裝方式選擇

### 安裝方式比較

| 安裝方式 | 適用場景 | 優點 | 缺點 |
|----------|----------|------|------|
| **Docker** | 開發、測試 | 快速部署、環境隔離 | 效能略低 |
| **本地安裝** | 生產環境 | 最佳效能、完全控制 | 配置複雜 |
| **Neo4j Desktop** | 開發學習 | 圖形介面、易於使用 | 僅適合開發 |
| **雲端服務** | 企業部署 | 託管服務、高可用 | 成本較高 |

### 系統需求

**最低需求**：
- **CPU**：2 核心
- **記憶體**：4GB RAM
- **存儲**：10GB 可用空間
- **Java**：JDK 17 或更高版本

**推薦配置**：
- **CPU**：4+ 核心
- **記憶體**：8GB+ RAM
- **存儲**：SSD 存儲，50GB+ 可用空間
- **網路**：千兆網路連接

---

## 6.6.3 Docker 方式安裝 Neo4j

### 基本 Docker 安裝

```bash
# 拉取 Neo4j 官方映像
docker pull neo4j:5.15

# 建立 Neo4j 容器
docker run -d \
  --name neo4j-vector \
  -p 7474:7474 \
  -p 7687:7687 \
  -e NEO4J_AUTH=neo4j/password123 \
  -e NEO4J_PLUGINS='["apoc","graph-data-science"]' \
  -v neo4j_data:/data \
  -v neo4j_logs:/logs \
  neo4j:5.15
```

### Docker Compose 配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  neo4j:
    image: neo4j:5.15
    container_name: neo4j-vector
    restart: unless-stopped
    ports:
      - "7474:7474"  # HTTP
      - "7687:7687"  # Bolt
    environment:
      # 認證設定
      NEO4J_AUTH: neo4j/password123
      
      # 插件配置
      NEO4J_PLUGINS: '["apoc","graph-data-science"]'
      
      # 記憶體配置
      NEO4J_dbms_memory_heap_initial__size: 1G
      NEO4J_dbms_memory_heap_max__size: 2G
      NEO4J_dbms_memory_pagecache_size: 1G
      
      # 向量配置
      NEO4J_db_index_vector_enabled: 'true'
      NEO4J_db_index_vector_dimensions_limit: 2048
      
      # 安全配置
      NEO4J_dbms_security_procedures_unrestricted: 'apoc.*,gds.*'
      NEO4J_dbms_security_procedures_allowlist: 'apoc.*,gds.*'
      
      # 效能配置
      NEO4J_dbms_query_cache_size: 1000
      NEO4J_dbms_query_cache_ttl: 70s
      
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs
      - neo4j_import:/var/lib/neo4j/import
      - neo4j_plugins:/plugins
    
    healthcheck:
      test: ["CMD-SHELL", "cypher-shell -u neo4j -p password123 'RETURN 1'"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

volumes:
  neo4j_data:
  neo4j_logs:
  neo4j_import:
  neo4j_plugins:

networks:
  default:
    name: spring-ai-network
```

### 啟動和驗證

```bash
# 啟動 Neo4j
docker-compose up -d

# 檢查容器狀態
docker-compose ps

# 查看日誌
docker-compose logs -f neo4j

# 進入容器
docker exec -it neo4j-vector bash

# 使用 Cypher Shell 連接
docker exec -it neo4j-vector cypher-shell -u neo4j -p password123
```

---

## 6.6.4 Neo4j 向量功能配置

### 啟用向量索引功能

```cypher
-- 檢查向量功能是否啟用
CALL dbms.components() YIELD name, versions, edition
WHERE name = 'Neo4j Kernel'
RETURN name, versions, edition;

-- 檢查可用的索引類型
CALL db.indexes() YIELD name, type, entityType, labelsOrTypes, properties
WHERE type CONTAINS 'VECTOR'
RETURN *;
```

### 建立向量索引

```cypher
-- 建立文檔向量索引
CREATE VECTOR INDEX document_embeddings IF NOT EXISTS
FOR (d:Document)
ON d.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'cosine'
  }
};

-- 建立對話記憶向量索引
CREATE VECTOR INDEX conversation_embeddings IF NOT EXISTS
FOR (m:Message)
ON m.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'cosine'
  }
};

-- 建立用戶查詢向量索引
CREATE VECTOR INDEX query_embeddings IF NOT EXISTS
FOR (q:Query)
ON q.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'euclidean'
  }
};
```

### 向量相似性函數選擇

```cypher
-- Cosine 相似性（推薦用於文本嵌入）
CREATE VECTOR INDEX cosine_index
FOR (n:Node) ON n.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'cosine'
  }
};

-- Euclidean 距離
CREATE VECTOR INDEX euclidean_index
FOR (n:Node) ON n.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'euclidean'
  }
};

-- 內積相似性
CREATE VECTOR INDEX dot_product_index
FOR (n:Node) ON n.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'dot_product'
  }
};
```

---

## 6.6.5 Spring AI 整合配置

### Maven 依賴配置

```xml
<!-- pom.xml -->
<dependencies>
    <!-- Spring AI Neo4j Vector Store -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-starter-vector-store-neo4j</artifactId>
    </dependency>
    
    <!-- Neo4j Java Driver -->
    <dependency>
        <groupId>org.neo4j.driver</groupId>
        <artifactId>neo4j-java-driver</artifactId>
    </dependency>
    
    <!-- Spring Boot Starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Spring AI OpenAI -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
    </dependency>
</dependencies>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-bom</artifactId>
            <version>1.0.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### Spring Boot 配置

```yaml
# application.yml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      chat:
        options:
          model: gpt-4o-mini
          temperature: 0.7
    
    vectorstore:
      neo4j:
        initialize-schema: true
        database-name: neo4j
        index-name: spring-ai-document-index
        embedding-dimension: 1536
        distance-type: cosine
        label: Document
        embedding-property: embedding

  neo4j:
    uri: bolt://localhost:7687
    authentication:
      username: neo4j
      password: password123

# 開發環境配置
---
spring:
  config:
    activate:
      on-profile: dev
  ai:
    vectorstore:
      neo4j:
        initialize-schema: true
  neo4j:
    uri: bolt://localhost:7687
        
# 生產環境配置
---
spring:
  config:
    activate:
      on-profile: prod
  ai:
    vectorstore:
      neo4j:
        initialize-schema: false
  neo4j:
    uri: ${NEO4J_URI}
    authentication:
      username: ${NEO4J_USERNAME}
      password: ${NEO4J_PASSWORD}
```

### Neo4j 向量存儲配置類

```java
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Config;
import org.neo4j.driver.Logging;
import org.springframework.ai.vectorstore.Neo4jVectorStore;
import org.springframework.ai.vectorstore.Neo4jVectorStore.Neo4jDistanceType;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import io.micrometer.core.instrument.MeterRegistry;
import lombok.extern.slf4j.Slf4j;
import java.util.concurrent.TimeUnit;

/**
 * Neo4j 向量存儲配置
 */
@Configuration
@EnableConfigurationProperties(Neo4jVectorStoreProperties.class)
@Slf4j
public class Neo4jVectorStoreConfig {
    
    /**
     * Neo4j Driver 配置
     */
    @Bean
    public Driver neo4jDriver(@Value("${spring.neo4j.uri}") String uri,
                              @Value("${spring.neo4j.authentication.username}") String username,
                              @Value("${spring.neo4j.authentication.password}") String password) {
        log.info("Configuring Neo4j Driver with URI: {}", uri);
        
        Config config = Config.builder()
            .withConnectionTimeout(30, TimeUnit.SECONDS)
            .withMaxTransactionRetryTime(15, TimeUnit.SECONDS)
            .withLogging(Logging.slf4j())
            .build();
        
        return GraphDatabase.driver(uri, AuthTokens.basic(username, password), config);
    }
    
    /**
     * Neo4j Vector Store 配置
     */
    @Bean
    public Neo4jVectorStore neo4jVectorStore(
            Driver driver,
            EmbeddingModel embeddingModel,
            Neo4jVectorStoreProperties properties) {
        
        log.info("Configuring Neo4j Vector Store");
        
        return Neo4jVectorStore.builder(driver, embeddingModel)
            .databaseName(properties.getDatabaseName())
            .embeddingDimension(properties.getEmbeddingDimension())
            .distanceType(Neo4jDistanceType.valueOf(properties.getDistanceType().toUpperCase()))
            .indexName(properties.getIndexName())
            .label(properties.getLabel())
            .embeddingProperty(properties.getEmbeddingProperty())
            .initializeSchema(properties.isInitializeSchema())
            .build();
    }
    
    /**
     * Neo4j 健康檢查
     */
    @Bean
    public Neo4jHealthIndicator neo4jHealthIndicator(Driver driver) {
        return new Neo4jHealthIndicator(driver);
    }
    
    /**
     * Neo4j 監控指標
     */
    @Bean
    public Neo4jMetrics neo4jMetrics(Driver driver, MeterRegistry meterRegistry) {
        return new Neo4jMetrics(driver, meterRegistry);
    }
}
```

### 配置屬性類

```java
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;
import lombok.Data;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Min;
import javax.validation.constraints.Max;
import java.time.Duration;

/**
 * Neo4j 向量存儲配置屬性
 */
@ConfigurationProperties(prefix = "spring.ai.vectorstore.neo4j")
@Data
@Validated
public class Neo4jVectorStoreProperties {
    
    /**
     * 是否初始化 Schema
     */
    private boolean initializeSchema = false;
    
    /**
     * 資料庫名稱
     */
    private String databaseName = "neo4j";
    
    /**
     * 向量維度
     */
    @Min(1)
    @Max(4096)
    private int embeddingDimension = 1536;
    
    /**
     * 距離函數類型
     */
    private String distanceType = "cosine";
    
    /**
     * 索引名稱
     */
    private String indexName = "spring_ai_embeddings";
    
    /**
     * 節點標籤
     */
    private String label = "Document";
    
    /**
     * 嵌入屬性名稱
     */
    private String embeddingProperty = "embedding";
    
    
    // Getter 和 Setter 方法
    public boolean isInitializeSchema() {
        return initializeSchema;
    }
    
    public void setInitializeSchema(boolean initializeSchema) {
        this.initializeSchema = initializeSchema;
    }
    
    public String getDatabaseName() {
        return databaseName;
    }
    
    public void setDatabaseName(String databaseName) {
        this.databaseName = databaseName;
    }
}
```

---

## 6.6.6 Neo4j 效能優化

### 記憶體配置優化

```bash
# neo4j.conf 配置檔案

# JVM 堆記憶體配置
server.memory.heap.initial_size=2G
server.memory.heap.max_size=4G

# 頁面快取配置（用於存儲節點和關係）
server.memory.pagecache.size=2G

# 事務狀態記憶體
db.memory.transaction.global_max_size=1G
db.memory.transaction.max_size=100M

# 查詢記憶體配置
dbms.memory.query.max_size=500M
dbms.memory.query.cache_size=1000
```

### 向量索引優化

```cypher
-- 檢查向量索引狀態
CALL db.indexes() YIELD name, type, state, populationPercent
WHERE type CONTAINS 'VECTOR'
RETURN name, type, state, populationPercent;

-- 重建向量索引（如果需要）
DROP INDEX document_embeddings IF EXISTS;
CREATE VECTOR INDEX document_embeddings
FOR (d:Document)
ON d.embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1536,
    `vector.similarity_function`: 'cosine',
    `vector.hnsw.max_connections`: 16,
    `vector.hnsw.ef_construction`: 200
  }
};

-- 檢查索引效能
CALL db.index.fulltext.queryNodes('document_embeddings', 'test') 
YIELD node, score
RETURN count(node) as total_nodes;
```

### 查詢效能優化

```cypher
-- 使用 EXPLAIN 分析查詢計劃
EXPLAIN
CALL db.index.vector.queryNodes('document_embeddings', 10, $queryVector)
YIELD node, score
RETURN node.content, score
ORDER BY score DESC
LIMIT 5;

-- 使用 PROFILE 分析查詢效能
PROFILE
CALL db.index.vector.queryNodes('document_embeddings', 10, $queryVector)
YIELD node, score
WHERE score > 0.8
RETURN node.content, score
ORDER BY score DESC
LIMIT 5;
```

### 監控和診斷

```java
/**
 * Neo4j 效能監控服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class Neo4jMonitoringService {
    
    private final Driver driver;
    private final MeterRegistry meterRegistry;
    
    @EventListener
    @Async
    public void handleVectorQuery(VectorQueryEvent event) {
        // 記錄向量查詢統計
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("neo4j.vector.query.time")
            .description("Neo4j vector query execution time")
            .tag("index", event.getIndexName())
            .register(meterRegistry));
        
        meterRegistry.counter("neo4j.vector.query.count",
            "index", event.getIndexName(),
            "success", String.valueOf(event.isSuccess()))
            .increment();
    }
    
    /**
     * 取得資料庫統計資訊
     */
    @Scheduled(fixedRate = 60000) // 每分鐘執行一次
    public void collectDatabaseStats() {
        try (Session session = driver.session()) {
            // 節點數量統計
            Result nodeCountResult = session.run("MATCH (n) RETURN count(n) as nodeCount");
            long nodeCount = nodeCountResult.single().get("nodeCount").asLong();
            meterRegistry.gauge("neo4j.nodes.count", nodeCount);
            
            // 關係數量統計
            Result relCountResult = session.run("MATCH ()-[r]->() RETURN count(r) as relCount");
            long relCount = relCountResult.single().get("relCount").asLong();
            meterRegistry.gauge("neo4j.relationships.count", relCount);
            
            // 向量索引統計
            Result indexResult = session.run(
                "CALL db.indexes() YIELD name, type, state, populationPercent " +
                "WHERE type CONTAINS 'VECTOR' " +
                "RETURN name, populationPercent"
            );
            
            while (indexResult.hasNext()) {
                Record record = indexResult.next();
                String indexName = record.get("name").asString();
                double populationPercent = record.get("populationPercent").asDouble();
                
                meterRegistry.gauge("neo4j.index.population.percent",
                    Tags.of("index", indexName), populationPercent);
            }
            
        } catch (Exception e) {
            log.error("Failed to collect Neo4j statistics", e);
        }
    }
    
    /**
     * 檢查資料庫健康狀態
     */
    public DatabaseHealthStatus checkHealth() {
        try (Session session = driver.session()) {
            // 執行簡單查詢測試連接
            session.run("RETURN 1").consume();
            
            // 檢查向量索引狀態
            Result indexResult = session.run(
                "CALL db.indexes() YIELD name, type, state " +
                "WHERE type CONTAINS 'VECTOR' AND state <> 'ONLINE' " +
                "RETURN count(*) as offlineIndexes"
            );
            
            long offlineIndexes = indexResult.single().get("offlineIndexes").asLong();
            
            return DatabaseHealthStatus.builder()
                .healthy(true)
                .offlineIndexes(offlineIndexes)
                .timestamp(LocalDateTime.now())
                .build();
                
        } catch (Exception e) {
            log.error("Neo4j health check failed", e);
            return DatabaseHealthStatus.builder()
                .healthy(false)
                .error(e.getMessage())
                .timestamp(LocalDateTime.now())
                .build();
        }
    }
}
```

---

## 6.6.7 測試和驗證

### 基本功能測試

```java
/**
 * Neo4j 向量存儲測試
 */
@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class Neo4jVectorStoreTest {
    
    @Autowired
    private Neo4jVectorStore vectorStore;
    
    @Autowired
    private EmbeddingModel embeddingModel;
    
    private static final String TEST_CONTENT_1 = "Spring AI is a powerful framework for building AI applications.";
    private static final String TEST_CONTENT_2 = "Neo4j is a graph database that supports vector operations.";
    
    @Test
    @Order(1)
    void testAddDocuments() {
        // 建立測試文檔
        List<Document> documents = Arrays.asList(
            new Document(TEST_CONTENT_1, Map.of("category", "framework")),
            new Document(TEST_CONTENT_2, Map.of("category", "database"))
        );
        
        // 添加到向量存儲
        vectorStore.add(documents);
        
        // 驗證文檔已添加
        assertThat(documents).allMatch(doc -> doc.getId() != null);
    }
    
    @Test
    @Order(2)
    void testSimilaritySearch() {
        // 執行相似性搜尋
        String query = "What is Spring AI?";
        List<Document> results = vectorStore.similaritySearch(
            SearchRequest.builder().query(query).topK(5).build()
        );
        
        // 驗證搜尋結果
        assertThat(results).isNotEmpty();
        assertThat(results.get(0).getContent()).contains("Spring AI");
    }
    
    @Test
    @Order(3)
    void testSimilaritySearchWithThreshold() {
        // 使用相似性閾值搜尋
        String query = "graph database";
        List<Document> results = vectorStore.similaritySearch(
            SearchRequest.builder()
                .query(query)
                .topK(10)
                .similarityThreshold(0.7)
                .build()
        );
        
        // 驗證結果符合閾值要求
        assertThat(results).isNotEmpty();
        results.forEach(doc -> {
            assertThat(doc.getMetadata()).containsKey("distance");
            double similarity = 1.0 - (Double) doc.getMetadata().get("distance");
            assertThat(similarity).isGreaterThanOrEqualTo(0.7);
        });
    }
    
    @Test
    @Order(4)
    void testDeleteDocuments() {
        // 搜尋要刪除的文檔
        List<Document> documents = vectorStore.similaritySearch(
            SearchRequest.builder().query(TEST_CONTENT_1).topK(1).build()
        );
        
        assertThat(documents).isNotEmpty();
        
        // 刪除文檔
        List<String> idsToDelete = documents.stream()
            .map(Document::getId)
            .collect(Collectors.toList());
        
        vectorStore.delete(idsToDelete);
        
        // 驗證文檔已刪除
        List<Document> remainingDocs = vectorStore.similaritySearch(
            SearchRequest.builder().query(TEST_CONTENT_1).topK(1).build()
        );
        
        assertThat(remainingDocs).isEmpty();
    }
}
```

### 效能測試

```java
/**
 * Neo4j 向量存儲效能測試
 */
@SpringBootTest
class Neo4jVectorStorePerformanceTest {
    
    @Autowired
    private Neo4jVectorStore vectorStore;
    
    @Test
    void testBatchInsertPerformance() {
        int batchSize = 1000;
        List<Document> documents = generateTestDocuments(batchSize);
        
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        vectorStore.add(documents);
        
        stopWatch.stop();
        
        long executionTime = stopWatch.getTotalTimeMillis();
        double documentsPerSecond = (double) batchSize / (executionTime / 1000.0);
        
        log.info("Batch insert performance: {} documents in {} ms ({} docs/sec)",
            batchSize, executionTime, String.format("%.2f", documentsPerSecond));
        
        // 驗證效能指標
        assertThat(documentsPerSecond).isGreaterThan(10); // 至少 10 docs/sec
    }
    
    @Test
    void testSearchPerformance() {
        // 先插入測試資料
        List<Document> documents = generateTestDocuments(5000);
        vectorStore.add(documents);
        
        // 測試搜尋效能
        String query = "test query for performance";
        int iterations = 100;
        
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        for (int i = 0; i < iterations; i++) {
            vectorStore.similaritySearch(
                SearchRequest.builder().query(query + " " + i).topK(10).build()
            );
        }
        
        stopWatch.stop();
        
        long totalTime = stopWatch.getTotalTimeMillis();
        double avgQueryTime = (double) totalTime / iterations;
        
        log.info("Search performance: {} queries in {} ms (avg: {} ms/query)",
            iterations, totalTime, String.format("%.2f", avgQueryTime));
        
        // 驗證搜尋效能
        assertThat(avgQueryTime).isLessThan(1000); // 平均查詢時間小於 1 秒
    }
    
    private List<Document> generateTestDocuments(int count) {
        return IntStream.range(0, count)
            .mapToObj(i -> new Document(
                "Test document content " + i + " with some random text for testing purposes.",
                Map.of("index", i, "category", "test")
            ))
            .collect(Collectors.toList());
    }
}
```

---

## 📝 本章重點回顧

1. **向量資料庫概念**：理解了向量資料庫的原理和 Neo4j 的優勢
2. **Docker 安裝配置**：掌握了使用 Docker 和 Docker Compose 安裝 Neo4j
3. **向量索引建立**：學會了建立和配置高效的向量索引
4. **Spring AI 整合**：完成了 Neo4j 與 Spring AI 的完整整合配置
5. **效能優化調校**：實現了記憶體配置、索引優化和監控機制

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **Docker 部署** | ⭐⭐⭐ | 低 | 快速部署 |
| **向量索引配置** | ⭐⭐⭐ | 中 | 搜尋效能 |
| **Spring AI 整合** | ⭐⭐⭐ | 中 | 功能整合 |
| **效能優化** | ⭐⭐ | 高 | 生產就緒 |
| **監控診斷** | ⭐⭐ | 中 | 運維管理 |

### 最佳實踐建議

1. **環境規劃**：根據應用規模選擇合適的部署方式和硬體配置
2. **索引設計**：合理選擇向量維度和相似性函數，優化搜尋效能
3. **記憶體配置**：根據資料量和查詢頻率調整記憶體分配
4. **監控告警**：建立完整的效能監控和健康檢查機制
5. **備份策略**：制定定期備份和災難恢復計劃

### 下一步學習方向

在下一章中，我們將學習如何使用向量資料庫作為對話的長久記憶，包括：
- VectorStoreChatMemoryAdvisor 的使用
- 語義相似性搜尋的實現
- 大規模對話歷史的管理
- 智能記憶檢索策略

---

**參考資料：**
- [Neo4j Vector Index Documentation](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/)
- [Spring AI Neo4j Vector Store](https://docs.spring.io/spring-ai/reference/api/vectordbs/neo4j.html)
- [Neo4j Docker Documentation](https://neo4j.com/developer/docker/)
- [Neo4j Performance Tuning](https://neo4j.com/developer/guide-performance-tuning/)


\newpage

## 6.7 使用向量資料庫作為對話的長久記憶


> **本章重點**：整合 Neo4j 向量資料庫與 Spring AI 記憶系統，實現基於語義搜尋的智能長期記憶功能，讓 AI 擁有真正的「長期記憶」能力。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **實現向量記憶系統**：使用 VectorStoreChatMemoryAdvisor 建立語義記憶
- 🎯 **掌握語義搜尋技術**：基於向量相似性的智能記憶檢索
- 🎯 **建立混合記憶架構**：結合短期和長期記憶的完整解決方案
- 🎯 **優化記憶檢索策略**：實現高效的記憶管理和檢索算法
- 🎯 **構建企業級記憶系統**：可擴展的大規模對話記憶解決方案

---

## 6.7.1 向量記憶 vs 傳統記憶

### 傳統記憶的限制

在前面的章節中，我們學習了 MessageChatMemoryAdvisor 和 PromptChatMemoryAdvisor，這些都屬於「短期記憶」：

**短期記憶的特點**：
- 📝 **順序存取**：按照時間順序存儲和檢索對話
- 🔢 **數量限制**：通常只能保存最近的 N 條訊息
- 💾 **記憶體存儲**：重啟後記憶消失
- 🔍 **精確匹配**：無法進行語義相關的搜尋

**短期記憶的問題**：
```
用戶：我昨天問過關於 Spring Boot 的問題
AI：抱歉，我無法找到您昨天的問題，因為它已經超出了我的記憶範圍。

用戶：我之前提到過我喜歡 Java 開發
AI：我沒有找到相關的記錄，請您再次告訴我您的偏好。
```

### 向量記憶的優勢

向量記憶使用語義搜尋技術，能夠：

**語義理解能力**：
- 🧠 **語義搜尋**：基於意思而非關鍵字進行搜尋
- 🔄 **模糊匹配**：找到語義相關的歷史對話
- 📚 **長期存儲**：可以保存大量歷史對話
- 🎯 **智能檢索**：自動找到最相關的記憶片段

**向量記憶的效果**：
```
用戶：我昨天問過關於 Spring Boot 的問題
AI：我記得您昨天詢問了 Spring Boot 的自動配置機制，您想了解更多相關內容嗎？

用戶：我之前提到過我喜歡 Java 開發
AI：是的，我記得您提到過偏好 Java 開發，還特別關注 Spring 框架的應用。
```

### 記憶類型比較

| 特性 | 短期記憶 | 向量記憶 |
|------|----------|----------|
| **存儲方式** | 順序列表 | 向量索引 |
| **檢索方式** | 時間順序 | 語義相似性 |
| **存儲容量** | 有限（通常 < 100 條） | 大容量（數萬條+） |
| **持久性** | 會話級 | 永久存儲 |
| **搜尋能力** | 精確匹配 | 模糊語義搜尋 |
| **適用場景** | 短期對話 | 長期知識積累 |

---

## 6.7.2 VectorStoreChatMemoryAdvisor 深度解析

### 核心工作原理

```
┌─────────────────────────────────────────────────────────────┐
│              VectorStoreChatMemoryAdvisor 工作流程          │
├─────────────────────────────────────────────────────────────┤
│  1. 用戶輸入                                                │
│     ↓                                                       │
│  2. 向量化查詢 (Embedding)                                  │
│     ↓                                                       │
│  3. 向量相似性搜尋                                          │
│     ↓                                                       │
│  4. 檢索相關歷史對話                                        │
│     ↓                                                       │
│  5. 構建增強提示詞                                          │
│     ↓                                                       │
│  6. 發送給 AI 模型                                          │
│     ↓                                                       │
│  7. 存儲新的對話記錄                                        │
└─────────────────────────────────────────────────────────────┘
```

### 基本配置和使用

```java
/**
 * 向量記憶服務配置
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class VectorMemoryService {
    
    private final ChatClient chatClient;
    private final VectorStore vectorStore;
    
    /**
     * 基本向量記憶對話
     */
    public String chatWithVectorMemory(String conversationId, String userMessage) {
        return chatClient.prompt()
            .advisors(VectorStoreChatMemoryAdvisor.builder(vectorStore)
                .conversationId(conversationId)
                .topK(10)  // 檢索最相關的 10 條記憶
                .build())
            .user(userMessage)
            .call()
            .content();
    }
    
    /**
     * 進階向量記憶對話（自定義參數）
     */
    public String chatWithAdvancedVectorMemory(
            String conversationId, 
            String userMessage,
            VectorMemoryOptions options) {
        
        return chatClient.prompt()
            .advisors(VectorStoreChatMemoryAdvisor.builder(vectorStore)
                .conversationId(conversationId)
                .topK(options.getRetrieveSize())
                .similarityThreshold(options.getSimilarityThreshold())
                .build())
            .user(userMessage)
            .call()
            .content();
    }
}
```

### 向量記憶配置選項

```java
/**
 * 向量記憶配置選項
 */
@Data
@Builder
public class VectorMemoryOptions {
    
    /**
     * 檢索記憶數量
     */
    @Builder.Default
    private int retrieveSize = 10;
    
    /**
     * 相似性閾值（0.0 - 1.0）
     */
    @Builder.Default
    private double similarityThreshold = 0.7;
    
    /**
     * 是否包含元數據
     */
    @Builder.Default
    private boolean includeMetadata = true;
    
    /**
     * 記憶過期時間（天）
     */
    @Builder.Default
    private int expirationDays = 30;
    
    /**
     * 是否啟用記憶壓縮
     */
    @Builder.Default
    private boolean enableCompression = false;
}
```

---

## 6.7.3 混合記憶架構實現

### 短期 + 長期記憶組合

最佳實踐是結合短期記憶和長期記憶，創建一個完整的記憶系統：

```java
/**
 * 混合記憶服務
 * 結合短期記憶（MessageChatMemoryAdvisor）和長期記憶（VectorStoreChatMemoryAdvisor）
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class HybridMemoryService {
    
    private final ChatClient chatClient;
    private final ChatMemory shortTermMemory;  // 短期記憶
    private final VectorStore longTermMemory;  // 長期記憶
    
    /**
     * 混合記憶對話
     */
    public String chatWithHybridMemory(String conversationId, String userMessage) {
        log.debug("Processing hybrid memory chat for conversation: {}", conversationId);
        
        return chatClient.prompt()
            .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, conversationId))
            .advisors(
                // 1. 短期記憶 - 最近的對話上下文
                MessageChatMemoryAdvisor.builder(shortTermMemory).build(),
                
                // 2. 長期記憶 - 語義相關的歷史對話
                VectorStoreChatMemoryAdvisor.builder(longTermMemory)
                    .conversationId(conversationId)
                    .topK(5)  // 最相關的 5 條歷史記憶
                    .similarityThreshold(0.75)
                    .build()
            )
            .user(userMessage)
            .call()
            .content();
    }
    
    /**
     * 智能記憶選擇
     * 根據查詢類型動態選擇記憶策略
     */
    public String chatWithSmartMemory(String conversationId, String userMessage) {
        MemoryStrategy strategy = determineMemoryStrategy(userMessage);
        
        switch (strategy) {
            case SHORT_TERM_ONLY:
                return chatWithShortTermMemory(conversationId, userMessage);
                
            case LONG_TERM_ONLY:
                return chatWithLongTermMemory(conversationId, userMessage);
                
            case HYBRID:
            default:
                return chatWithHybridMemory(conversationId, userMessage);
        }
    }
    
    /**
     * 決定記憶策略
     */
    private MemoryStrategy determineMemoryStrategy(String userMessage) {
        // 簡單的策略判斷邏輯
        if (userMessage.contains("剛才") || userMessage.contains("剛剛")) {
            return MemoryStrategy.SHORT_TERM_ONLY;
        }
        
        if (userMessage.contains("之前") || userMessage.contains("以前") || userMessage.contains("記得")) {
            return MemoryStrategy.LONG_TERM_ONLY;
        }
        
        return MemoryStrategy.HYBRID;
    }
    
    private String chatWithShortTermMemory(String conversationId, String userMessage) {
        return chatClient.prompt()
            .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, conversationId))
            .advisors(MessageChatMemoryAdvisor.builder(shortTermMemory).build())
            .user(userMessage)
            .call()
            .content();
    }
    
    private String chatWithLongTermMemory(String conversationId, String userMessage) {
        return chatClient.prompt()
            .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, conversationId))
            .advisors(VectorStoreChatMemoryAdvisor.builder(longTermMemory)
                .conversationId(conversationId)
                .topK(10)
                .similarityThreshold(0.7)
                .build())
            .user(userMessage)
            .call()
            .content();
    }
}

enum MemoryStrategy {
    SHORT_TERM_ONLY,
    LONG_TERM_ONLY,
    HYBRID
}
```

### 記憶同步機制

```java
/**
 * 記憶同步服務
 * 負責在短期記憶和長期記憶之間同步資料
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class MemorySyncService {
    
    private final ChatMemory shortTermMemory;
    private final VectorStore longTermMemory;
    private final EmbeddingModel embeddingModel;
    
    /**
     * 定期同步短期記憶到長期記憶
     */
    @Scheduled(fixedRate = 300000) // 每 5 分鐘執行一次
    public void syncMemories() {
        log.debug("Starting memory synchronization");
        
        try {
            // 由於 ChatMemory 介面不提供 getConversationIds() 方法
            // 這裡需要根據實際的記憶實現來維護對話 ID 清單
            // 或使用其他方式管理活動的對話
            List<String> activeConversationIds = getActiveConversationIds();
            
            for (String conversationId : activeConversationIds) {
                syncConversationMemory(conversationId);
            }
            
            log.info("Memory synchronization completed for {} conversations", activeConversationIds.size());
            
        } catch (Exception e) {
            log.error("Memory synchronization failed", e);
        }
    }
    
    /**
     * 取得活動的對話 ID 清單
     */
    private List<String> getActiveConversationIds() {
        // 這裡需要根據實際的應用程式來實現
        // 可以使用數據庫查詢或其他管理機制
        return java.util.Arrays.asList("conversation1", "conversation2");
    }
    
    /**
     * 同步單個對話的記憶
     */
    private void syncConversationMemory(String conversationId) {
        try {
            List<Message> recentMessages = shortTermMemory.get(conversationId);
            
            if (recentMessages.isEmpty()) {
                return;
            }
            
            // 只取最近的 10 條訊息進行同步
            List<Message> messagesToSync = recentMessages.size() > 10 ? 
                recentMessages.subList(0, 10) : recentMessages;
            
            // 將訊息轉換為文檔並存儲到向量資料庫
            List<Document> documents = convertMessagesToDocuments(conversationId, messagesToSync);
            
            if (!documents.isEmpty()) {
                longTermMemory.add(documents);
                log.debug("Synced {} messages for conversation: {}", documents.size(), conversationId);
            }
            
        } catch (Exception e) {
            log.error("Failed to sync memory for conversation: {}", conversationId, e);
        }
    }
    
    /**
     * 將訊息轉換為向量文檔
     */
    private List<Document> convertMessagesToDocuments(String conversationId, List<Message> messages) {
        List<Document> documents = new ArrayList<>();
        
        for (int i = 0; i < messages.size(); i++) {
            Message message = messages.get(i);
            
            // 只處理用戶和助手的訊息
            if (message instanceof UserMessage || message instanceof AssistantMessage) {
                
                Map<String, Object> metadata = new HashMap<>();
                metadata.put("conversationId", conversationId);
                metadata.put("messageType", message.getClass().getSimpleName());
                metadata.put("timestamp", LocalDateTime.now().toString());
                metadata.put("messageIndex", i);
                
                // 添加上下文資訊
                if (i > 0) {
                    Message previousMessage = messages.get(i - 1);
                    metadata.put("previousMessageType", previousMessage.getClass().getSimpleName());
                }
                
                Document document = new Document(
                    message.getContent(),
                    metadata
                );
                
                documents.add(document);
            }
        }
        
        return documents;
    }
    
    /**
     * 手動觸發記憶同步
     */
    public void forceSyncMemory(String conversationId) {
        log.info("Force syncing memory for conversation: {}", conversationId);
        syncConversationMemory(conversationId);
    }
    
    /**
     * 清理過期的長期記憶
     */
    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨 2 點執行
    public void cleanupExpiredMemories() {
        log.info("Starting cleanup of expired memories");
        
        try {
            // 查詢過期的記憶（超過 30 天）
            LocalDateTime cutoffDate = LocalDateTime.now().minusDays(30);
            
            // 這裡需要根據實際的向量資料庫實現來查詢和刪除過期資料
            // 由於 VectorStore 介面的限制，這裡提供一個概念性的實現
            
            log.info("Expired memories cleanup completed");
            
        } catch (Exception e) {
            log.error("Failed to cleanup expired memories", e);
        }
    }
}
```

---

## 6.7.4 智能記憶檢索策略

### 多層次記憶檢索

```java
/**
 * 智能記憶檢索服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class SmartMemoryRetrievalService {
    
    private final VectorStore vectorStore;
    private final ChatMemory shortTermMemory;
    private final EmbeddingModel embeddingModel;
    
    /**
     * 多層次記憶檢索
     */
    public MemoryRetrievalResult retrieveRelevantMemories(
            String conversationId, 
            String query,
            RetrievalOptions options) {
        
        log.debug("Retrieving memories for query: {}", query);
        
        // 1. 短期記憶檢索
        List<Message> shortTermResults = retrieveShortTermMemories(conversationId, options.getShortTermLimit());
        
        // 2. 長期記憶檢索
        List<Document> longTermResults = retrieveLongTermMemories(conversationId, query, options);
        
        // 3. 記憶融合和排序
        List<MemoryItem> fusedMemories = fuseAndRankMemories(shortTermResults, longTermResults, query);
        
        return MemoryRetrievalResult.builder()
            .conversationId(conversationId)
            .query(query)
            .shortTermMemories(shortTermResults)
            .longTermMemories(longTermResults)
            .fusedMemories(fusedMemories)
            .retrievalTime(LocalDateTime.now())
            .build();
    }
    
    /**
     * 檢索短期記憶
     */
    private List<Message> retrieveShortTermMemories(String conversationId, int limit) {
        try {
            List<Message> allMessages = shortTermMemory.get(conversationId);
            return allMessages.size() > limit ? allMessages.subList(0, limit) : allMessages;
        } catch (Exception e) {
            log.warn("Failed to retrieve short-term memories for conversation: {}", conversationId, e);
            return Collections.emptyList();
        }
    }
    
    /**
     * 檢索長期記憶
     */
    private List<Document> retrieveLongTermMemories(
            String conversationId, 
            String query, 
            RetrievalOptions options) {
        
        try {
            // 建立搜尋請求
            SearchRequest searchRequest = SearchRequest.builder()
                .query(query)
                .topK(options.getLongTermLimit())
                .similarityThreshold(options.getSimilarityThreshold())
                .filterExpression(String.format("conversationId == '%s'", conversationId))
                .build();
            
            return vectorStore.similaritySearch(searchRequest);
            
        } catch (Exception e) {
            log.warn("Failed to retrieve long-term memories for conversation: {}", conversationId, e);
            return Collections.emptyList();
        }
    }
    
    /**
     * 融合和排序記憶
     */
    private List<MemoryItem> fuseAndRankMemories(
            List<Message> shortTermMemories,
            List<Document> longTermMemories,
            String query) {
        
        List<MemoryItem> allMemories = new ArrayList<>();
        
        // 轉換短期記憶
        for (int i = 0; i < shortTermMemories.size(); i++) {
            Message message = shortTermMemories.get(i);
            allMemories.add(MemoryItem.builder()
                .content(message.getContent())
                .type(MemoryType.SHORT_TERM)
                .relevanceScore(calculateShortTermRelevance(message, query, i))
                .timestamp(extractTimestamp(message))
                .metadata(message.getMetadata())
                .build());
        }
        
        // 轉換長期記憶
        for (Document document : longTermMemories) {
            allMemories.add(MemoryItem.builder()
                .content(document.getContent())
                .type(MemoryType.LONG_TERM)
                .relevanceScore(extractSimilarityScore(document))
                .timestamp(extractTimestamp(document))
                .metadata(document.getMetadata())
                .build());
        }
        
        // 按相關性排序
        return allMemories.stream()
            .sorted(Comparator.comparingDouble(MemoryItem::getRelevanceScore).reversed())
            .collect(Collectors.toList());
    }
    
    /**
     * 計算短期記憶相關性
     */
    private double calculateShortTermRelevance(Message message, String query, int position) {
        // 基於位置的權重（越近的訊息權重越高）
        double positionWeight = 1.0 - (position * 0.1);
        
        // 基於內容相似性的權重（簡化實現）
        double contentSimilarity = calculateTextSimilarity(message.getContent(), query);
        
        return (positionWeight * 0.6) + (contentSimilarity * 0.4);
    }
    
    /**
     * 簡單的文本相似性計算
     */
    private double calculateTextSimilarity(String text1, String text2) {
        // 這裡使用簡單的關鍵字匹配，實際應用中可以使用更複雜的算法
        String[] words1 = text1.toLowerCase().split("\\s+");
        String[] words2 = text2.toLowerCase().split("\\s+");
        
        Set<String> set1 = new HashSet<>(Arrays.asList(words1));
        Set<String> set2 = new HashSet<>(Arrays.asList(words2));
        
        Set<String> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        
        Set<String> union = new HashSet<>(set1);
        union.addAll(set2);
        
        return union.isEmpty() ? 0.0 : (double) intersection.size() / union.size();
    }
    
    private double extractSimilarityScore(Document document) {
        Object score = document.getMetadata().get("distance");
        if (score instanceof Number) {
            return 1.0 - ((Number) score).doubleValue(); // 轉換距離為相似性
        }
        return 0.5; // 預設值
    }
    
    private LocalDateTime extractTimestamp(Message message) {
        Object timestamp = message.getMetadata().get("timestamp");
        if (timestamp instanceof LocalDateTime) {
            return (LocalDateTime) timestamp;
        }
        return LocalDateTime.now();
    }
    
    private LocalDateTime extractTimestamp(Document document) {
        Object timestamp = document.getMetadata().get("timestamp");
        if (timestamp instanceof String) {
            try {
                return LocalDateTime.parse((String) timestamp);
            } catch (Exception e) {
                log.warn("Failed to parse timestamp: {}", timestamp);
            }
        }
        return LocalDateTime.now();
    }
}
```

### 記憶檢索配置和結果類

```java
/**
 * 記憶檢索選項
 */
@Data
@Builder
public class RetrievalOptions {
    
    /**
     * 短期記憶限制
     */
    @Builder.Default
    private int shortTermLimit = 20;
    
    /**
     * 長期記憶限制
     */
    @Builder.Default
    private int longTermLimit = 10;
    
    /**
     * 相似性閾值
     */
    @Builder.Default
    private double similarityThreshold = 0.7;
    
    /**
     * 是否包含元數據
     */
    @Builder.Default
    private boolean includeMetadata = true;
    
    /**
     * 時間範圍過濾（天）
     */
    private Integer timeRangeDays;
}

/**
 * 記憶檢索結果
 */
@Data
@Builder
public class MemoryRetrievalResult {
    private String conversationId;
    private String query;
    private List<Message> shortTermMemories;
    private List<Document> longTermMemories;
    private List<MemoryItem> fusedMemories;
    private LocalDateTime retrievalTime;
}

/**
 * 記憶項目
 */
@Data
@Builder
public class MemoryItem {
    private String content;
    private MemoryType type;
    private double relevanceScore;
    private LocalDateTime timestamp;
    private Map<String, Object> metadata;
}

enum MemoryType {
    SHORT_TERM,
    LONG_TERM
}
```

---

## 6.7.5 企業級記憶管理系統

### 記憶管理控制器

```java
/**
 * 記憶管理 REST API
 */
@RestController
@RequestMapping("/api/memory")
@RequiredArgsConstructor
@Slf4j
public class MemoryManagementController {
    
    private final HybridMemoryService hybridMemoryService;
    private final SmartMemoryRetrievalService retrievalService;
    private final MemorySyncService syncService;
    private final MemoryAnalyticsService analyticsService;
    
    /**
     * 混合記憶對話
     */
    @PostMapping("/chat/{conversationId}")
    public ResponseEntity<ChatResponse> chat(
            @PathVariable String conversationId,
            @RequestBody ChatRequest request) {
        
        try {
            String response = hybridMemoryService.chatWithHybridMemory(
                conversationId, 
                request.getMessage()
            );
            
            return ResponseEntity.ok(ChatResponse.builder()
                .conversationId(conversationId)
                .message(response)
                .timestamp(LocalDateTime.now())
                .memoryType("hybrid")
                .build());
                
        } catch (Exception e) {
            log.error("Chat failed for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest()
                .body(ChatResponse.builder()
                    .conversationId(conversationId)
                    .error("Chat processing failed: " + e.getMessage())
                    .timestamp(LocalDateTime.now())
                    .build());
        }
    }
    
    /**
     * 智能記憶對話
     */
    @PostMapping("/smart-chat/{conversationId}")
    public ResponseEntity<ChatResponse> smartChat(
            @PathVariable String conversationId,
            @RequestBody ChatRequest request) {
        
        try {
            String response = hybridMemoryService.chatWithSmartMemory(
                conversationId, 
                request.getMessage()
            );
            
            return ResponseEntity.ok(ChatResponse.builder()
                .conversationId(conversationId)
                .message(response)
                .timestamp(LocalDateTime.now())
                .memoryType("smart")
                .build());
                
        } catch (Exception e) {
            log.error("Smart chat failed for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 檢索記憶
     */
    @PostMapping("/retrieve/{conversationId}")
    public ResponseEntity<MemoryRetrievalResult> retrieveMemories(
            @PathVariable String conversationId,
            @RequestBody MemoryRetrievalRequest request) {
        
        try {
            RetrievalOptions options = RetrievalOptions.builder()
                .shortTermLimit(request.getShortTermLimit())
                .longTermLimit(request.getLongTermLimit())
                .similarityThreshold(request.getSimilarityThreshold())
                .timeRangeDays(request.getTimeRangeDays())
                .build();
            
            MemoryRetrievalResult result = retrievalService.retrieveRelevantMemories(
                conversationId, 
                request.getQuery(), 
                options
            );
            
            return ResponseEntity.ok(result);
            
        } catch (Exception e) {
            log.error("Memory retrieval failed for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 手動同步記憶
     */
    @PostMapping("/sync/{conversationId}")
    public ResponseEntity<ApiResponse> syncMemory(@PathVariable String conversationId) {
        try {
            syncService.forceSyncMemory(conversationId);
            return ResponseEntity.ok(ApiResponse.success("Memory synced successfully"));
        } catch (Exception e) {
            log.error("Memory sync failed for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Memory sync failed: " + e.getMessage()));
        }
    }
    
    /**
     * 取得記憶統計
     */
    @GetMapping("/analytics/{conversationId}")
    public ResponseEntity<MemoryAnalytics> getMemoryAnalytics(@PathVariable String conversationId) {
        try {
            MemoryAnalytics analytics = analyticsService.getConversationAnalytics(conversationId);
            return ResponseEntity.ok(analytics);
        } catch (Exception e) {
            log.error("Failed to get memory analytics for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 清除對話記憶
     */
    @DeleteMapping("/clear/{conversationId}")
    public ResponseEntity<ApiResponse> clearMemory(@PathVariable String conversationId) {
        try {
            // 清除短期記憶
            shortTermMemory.clear(conversationId);
            
            // 清除長期記憶（需要根據實際的 VectorStore 實現來進行刪除操作）
            // 由於 VectorStore 介面不提供按對話 ID 刪除的方法
            // 這裡可能需要使用特定的 VectorStore 實現來達成
            
            return ResponseEntity.ok(ApiResponse.success("Memory cleared successfully"));
        } catch (Exception e) {
            log.error("Failed to clear memory for conversation: {}", conversationId, e);
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("Memory clear failed: " + e.getMessage()));
        }
    }
}
```

### 記憶分析服務

```java
/**
 * 記憶分析服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class MemoryAnalyticsService {
    
    private final ChatMemory shortTermMemory;
    private final VectorStore longTermMemory;
    private final MeterRegistry meterRegistry;
    
    /**
     * 取得對話記憶分析
     */
    public MemoryAnalytics getConversationAnalytics(String conversationId) {
        try {
            // 短期記憶統計
            List<Message> shortTermMessages = shortTermMemory.get(conversationId);
            int shortTermCount = shortTermMessages.size();
            
            // 長期記憶統計（簡化實現）
            int longTermCount = estimateLongTermMemoryCount(conversationId);
            
            // 記憶使用統計
            MemoryUsageStats usageStats = calculateMemoryUsage(shortTermMessages);
            
            // 記憶品質分析
            MemoryQualityMetrics qualityMetrics = analyzeMemoryQuality(conversationId);
            
            return MemoryAnalytics.builder()
                .conversationId(conversationId)
                .shortTermMemoryCount(shortTermCount)
                .longTermMemoryCount(longTermCount)
                .usageStats(usageStats)
                .qualityMetrics(qualityMetrics)
                .analysisTime(LocalDateTime.now())
                .build();
                
        } catch (Exception e) {
            log.error("Failed to analyze memory for conversation: {}", conversationId, e);
            throw new RuntimeException("Memory analysis failed", e);
        }
    }
    
    /**
     * 估算長期記憶數量
     */
    private int estimateLongTermMemoryCount(String conversationId) {
        try {
            // 這裡需要根據實際的向量資料庫實現來查詢
            // 由於 VectorStore 介面的限制，這裡提供一個概念性的實現
            SearchRequest searchRequest = SearchRequest.builder()
                .query("*")
                .topK(1000)
                .filterExpression(String.format("conversationId == '%s'", conversationId))
                .build();
            
            List<Document> results = longTermMemory.similaritySearch(searchRequest);
            return results.size();
            
        } catch (Exception e) {
            log.warn("Failed to estimate long-term memory count for conversation: {}", conversationId, e);
            return 0;
        }
    }
    
    /**
     * 計算記憶使用統計
     */
    private MemoryUsageStats calculateMemoryUsage(List<Message> messages) {
        int totalMessages = messages.size();
        int userMessages = 0;
        int assistantMessages = 0;
        int totalCharacters = 0;
        
        for (Message message : messages) {
            if (message instanceof UserMessage) {
                userMessages++;
            } else if (message instanceof AssistantMessage) {
                assistantMessages++;
            }
            totalCharacters += message.getContent().length();
        }
        
        double avgMessageLength = totalMessages > 0 ? (double) totalCharacters / totalMessages : 0;
        
        return MemoryUsageStats.builder()
            .totalMessages(totalMessages)
            .userMessages(userMessages)
            .assistantMessages(assistantMessages)
            .totalCharacters(totalCharacters)
            .averageMessageLength(avgMessageLength)
            .build();
    }
    
    /**
     * 分析記憶品質
     */
    private MemoryQualityMetrics analyzeMemoryQuality(String conversationId) {
        // 這裡可以實現更複雜的記憶品質分析
        // 例如：記憶的相關性、完整性、時效性等
        
        return MemoryQualityMetrics.builder()
            .relevanceScore(0.85)  // 相關性分數
            .completenessScore(0.90)  // 完整性分數
            .freshnessScore(0.75)  // 時效性分數
            .overallQuality(0.83)  // 整體品質
            .build();
    }
    
    /**
     * 記錄記憶操作統計
     */
    public void recordMemoryOperation(String operation, String conversationId, boolean success) {
        meterRegistry.counter("memory.operations",
            "operation", operation,
            "conversation_id", conversationId,
            "success", String.valueOf(success))
            .increment();
    }
    
    /**
     * 記錄記憶檢索時間
     */
    public void recordRetrievalTime(String memoryType, long timeMs) {
        meterRegistry.timer("memory.retrieval.time",
            "type", memoryType)
            .record(timeMs, TimeUnit.MILLISECONDS);
    }
}
```

---

## 6.7.6 測試和驗證

### 向量記憶功能測試

```java
/**
 * 向量記憶功能測試
 */
@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class VectorMemoryIntegrationTest {
    
    @Autowired
    private HybridMemoryService hybridMemoryService;
    
    @Autowired
    private VectorStore vectorStore;
    
    @Autowired
    private ChatMemory shortTermMemory;
    
    private static final String TEST_CONVERSATION_ID = "test-vector-memory-001";
    
    @Test
    @Order(1)
    void testBasicVectorMemory() {
        // 第一輪對話 - 建立記憶
        String response1 = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "我喜歡學習 Spring Boot 框架，特別是它的自動配置功能。"
        );
        
        assertThat(response1).isNotNull();
        
        // 等待記憶同步
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // 第二輪對話 - 測試記憶召回
        String response2 = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "我之前提到過我對哪個框架感興趣？"
        );
        
        assertThat(response2.toLowerCase()).contains("spring");
    }
    
    @Test
    @Order(2)
    void testSemanticMemoryRetrieval() {
        // 建立語義相關的記憶
        hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "我正在開發一個電商網站，使用 Java 和 Spring 技術棧。"
        );
        
        hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "這個專案需要處理用戶註冊、商品管理和訂單處理功能。"
        );
        
        // 等待記憶同步
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // 測試語義搜尋
        String response = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "關於我的網站開發專案，你還記得什麼？"
        );
        
        assertThat(response.toLowerCase())
            .containsAnyOf("電商", "java", "spring", "用戶", "商品", "訂單");
    }
    
    @Test
    @Order(3)
    void testMemoryPersistence() {
        // 清除短期記憶
        shortTermMemory.clear(TEST_CONVERSATION_ID);
        
        // 測試長期記憶是否仍然可用
        String response = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "我們之前討論過什麼技術？"
        );
        
        // 應該能從長期記憶中找到相關資訊
        assertThat(response).isNotNull();
    }
    
    @Test
    @Order(4)
    void testMemoryRetrievalWithThreshold() {
        // 測試相似性閾值過濾
        String response = hybridMemoryService.chatWithHybridMemory(
            TEST_CONVERSATION_ID,
            "完全不相關的隨機問題關於天氣預報"
        );
        
        // 由於相似性閾值，應該不會檢索到不相關的記憶
        assertThat(response).isNotNull();
    }
}
```

### 記憶效能測試

```java
/**
 * 記憶效能測試
 */
@SpringBootTest
class MemoryPerformanceTest {
    
    @Autowired
    private HybridMemoryService hybridMemoryService;
    
    @Autowired
    private SmartMemoryRetrievalService retrievalService;
    
    @Test
    void testMemoryRetrievalPerformance() {
        String conversationId = "perf-test-001";
        
        // 建立大量測試記憶
        for (int i = 0; i < 100; i++) {
            hybridMemoryService.chatWithHybridMemory(
                conversationId,
                "測試訊息 " + i + " 關於 Spring Boot 開發和 Java 程式設計的內容。"
            );
        }
        
        // 測試檢索效能
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        for (int i = 0; i < 50; i++) {
            RetrievalOptions options = RetrievalOptions.builder()
                .shortTermLimit(10)
                .longTermLimit(5)
                .similarityThreshold(0.7)
                .build();
            
            retrievalService.retrieveRelevantMemories(
                conversationId,
                "Spring Boot 相關問題 " + i,
                options
            );
        }
        
        stopWatch.stop();
        
        long totalTime = stopWatch.getTotalTimeMillis();
        double avgRetrievalTime = (double) totalTime / 50;
        
        log.info("Memory retrieval performance: 50 queries in {} ms (avg: {} ms/query)",
            totalTime, String.format("%.2f", avgRetrievalTime));
        
        // 驗證效能指標
        assertThat(avgRetrievalTime).isLessThan(500); // 平均檢索時間小於 500ms
    }
    
    @Test
    void testConcurrentMemoryAccess() throws InterruptedException {
        String conversationId = "concurrent-test-001";
        int threadCount = 10;
        int operationsPerThread = 20;
        
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);
        AtomicInteger successCount = new AtomicInteger(0);
        
        for (int i = 0; i < threadCount; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    for (int j = 0; j < operationsPerThread; j++) {
                        String response = hybridMemoryService.chatWithHybridMemory(
                            conversationId,
                            String.format("Thread %d operation %d message", threadId, j)
                        );
                        
                        if (response != null && !response.isEmpty()) {
                            successCount.incrementAndGet();
                        }
                    }
                } catch (Exception e) {
                    log.error("Concurrent operation failed in thread {}", threadId, e);
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await(60, TimeUnit.SECONDS);
        executor.shutdown();
        
        int expectedOperations = threadCount * operationsPerThread;
        double successRate = (double) successCount.get() / expectedOperations;
        
        log.info("Concurrent memory access: {}/{} operations succeeded ({}%)",
            successCount.get(), expectedOperations, String.format("%.1f", successRate * 100));
        
        // 驗證併發操作成功率
        assertThat(successRate).isGreaterThan(0.95); // 95% 以上成功率
    }
}
```

---

## 📝 本章重點回顧

1. **向量記憶理解**：掌握了向量記憶與傳統記憶的差異和優勢
2. **VectorStoreChatMemoryAdvisor 應用**：學會了使用向量記憶進行語義搜尋
3. **混合記憶架構**：實現了短期和長期記憶的完美結合
4. **智能檢索策略**：建立了多層次的記憶檢索和融合機制
5. **企業級管理系統**：完成了完整的記憶管理和分析平台

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **VectorStoreChatMemoryAdvisor** | ⭐⭐⭐ | 中 | 語義記憶 |
| **混合記憶架構** | ⭐⭐⭐ | 高 | 完整解決方案 |
| **智能檢索策略** | ⭐⭐ | 高 | 檢索效能 |
| **記憶同步機制** | ⭐⭐ | 中 | 資料一致性 |
| **企業級管理** | ⭐⭐ | 中 | 運維便利性 |

### 最佳實踐建議

1. **記憶策略選擇**：根據查詢類型動態選擇短期、長期或混合記憶策略
2. **相似性閾值調整**：根據應用場景調整向量搜尋的相似性閾值
3. **記憶同步頻率**：平衡記憶同步的即時性和系統效能
4. **效能監控**：建立完整的記憶操作監控和效能分析
5. **資料清理策略**：定期清理過期和低品質的記憶資料

### 第六章完整總結

恭喜您完成了第六章「讓 ChatBot 不再金魚腦」的完整學習！本章涵蓋了：

- **6.1 記憶系統概述**：理解了 AI 記憶的重要性和類型
- **6.2 基本記憶實現**：掌握了 Advisor 系統和對話記憶
- **6.3 官方記憶系統**：學會了 Spring AI 官方記憶 API
- **6.4 鏈式增強器**：實現了複雜的 Advisor 組合和自定義
- **6.5 插件開發**：建立了可擴展的插件系統
- **6.6 Neo4j 安裝**：部署了企業級向量資料庫
- **6.7 向量記憶**：實現了基於語義搜尋的長期記憶

通過本章的學習，您已經掌握了建立智能對話系統的完整技術棧，能夠開發出具有真正「記憶」能力的 AI 應用！

---

**參考資料：**
- [Spring AI Vector Store Documentation](https://docs.spring.io/spring-ai/reference/api/vectordbs.html)
- [VectorStoreChatMemoryAdvisor API](https://docs.spring.io/spring-ai/reference/api/advisors.html)
- [Neo4j Vector Search](https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/)
- [Semantic Search Best Practices](https://www.pinecone.io/learn/semantic-search/)


\newpage


# 第七章：RAG 實作 {.unnumbered .unlisted}


## 7.1 RAG 流程詳解


> **本章重點**：深入理解 RAG（Retrieval-Augmented Generation）的完整工作流程，掌握企業級 RAG 系統的設計原理和實現方法。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 RAG 核心概念**：掌握檢索增強生成的基本原理和應用場景
- 🎯 **掌握 RAG 完整流程**：了解從文檔處理到答案生成的每個步驟
- 🎯 **設計 RAG 系統架構**：學會設計可擴展的企業級 RAG 解決方案
- 🎯 **實現基礎 RAG 功能**：使用 Spring AI 建立第一個 RAG 應用
- 🎯 **優化 RAG 效能**：掌握 RAG 系統的效能調校和最佳實踐

---

## 7.1.1 什麼是 RAG？

### RAG 的定義與價值

**RAG（Retrieval-Augmented Generation）** 是一種結合了資訊檢索和文本生成的 AI 技術，它能夠讓大型語言模型（LLM）基於外部知識庫來生成更準確、更具時效性的回答。

**核心價值**：
- 📚 **知識擴展**：突破 LLM 訓練資料的時間限制
- 🎯 **準確性提升**：基於可靠的外部資料源生成答案
- 🔄 **即時更新**：知識庫可以即時更新，無需重新訓練模型
- 💰 **成本效益**：避免重新訓練大型模型的高昂成本
- 🔍 **可追溯性**：答案來源可追溯，提高可信度

### RAG vs 傳統 LLM

| 特性 | 傳統 LLM | RAG 系統 |
|------|----------|----------|
| **知識來源** | 訓練資料 | 外部知識庫 + 訓練資料 |
| **知識更新** | 需要重新訓練 | 即時更新知識庫 |
| **準確性** | 依賴訓練資料 | 基於最新、可靠資料 |
| **可追溯性** | 無法追溯 | 可追溯到具體文檔 |
| **專業領域** | 泛化能力強 | 專業知識更準確 |
| **成本** | 訓練成本高 | 維護成本低 |

### RAG 的應用場景

**1. 企業知識管理**
```
場景：員工詢問公司政策、流程、產品資訊
優勢：
- 基於最新的內部文檔
- 確保資訊的準確性和一致性
- 減少人工客服負擔
```

**2. 技術文檔助手**
```
場景：開發者查詢 API 文檔、技術規範
優勢：
- 即時反映文檔更新
- 提供精確的技術資訊
- 支援多版本文檔查詢
```

**3. 客戶服務系統**
```
場景：客戶詢問產品功能、故障排除
優勢：
- 基於產品手冊和 FAQ
- 提供個性化解決方案
- 24/7 不間斷服務
```

**4. 法律和合規諮詢**
```
場景：查詢法規條文、合規要求
優勢：
- 基於最新法規資料
- 確保合規性和準確性
- 降低法律風險
```

---

## 7.1.2 RAG 系統架構概覽

### 完整的 RAG 系統架構

```
┌─────────────────────────────────────────────────────────────┐
│                    RAG System Architecture                  │
├─────────────────────────────────────────────────────────────┤
│  User Interface Layer                                       │
│  ┌─────────────────┐    ┌─────────────────┐               │
│  │   Web UI        │    │   Mobile App    │               │
│  │   Chat Bot      │    │   API Client    │               │
│  └─────────────────┘    └─────────────────┘               │
├─────────────────────────────────────────────────────────────┤
│  Application Layer                                          │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              RAG Orchestration Engine                   │ │
│  │  ┌─────────────────────────────────────────────────┐   │ │
│  │  │  • Query Processing                             │   │ │
│  │  │  • Retrieval Coordination                       │   │ │
│  │  │  • Response Generation                          │   │ │
│  │  │  • Result Ranking & Filtering                   │   │ │
│  │  └─────────────────────────────────────────────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Retrieval Layer                                           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │Vector Store │ │Search Engine│ │Knowledge    │          │
│  │• Embeddings │ │• Full-text  │ │Graph        │          │
│  │• Similarity │ │• Keywords   │ │• Relations  │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
├─────────────────────────────────────────────────────────────┤
│  Data Processing Layer                                      │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                ETL Pipeline                             │ │
│  │  ┌─────────────────────────────────────────────────┐   │ │
│  │  │  Extract → Transform → Load                     │   │ │
│  │  │  • Document Parsing                             │   │ │
│  │  │  • Text Chunking                                │   │ │
│  │  │  • Embedding Generation                         │   │ │
│  │  │  • Metadata Enrichment                          │   │ │
│  │  └─────────────────────────────────────────────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Data Sources Layer                                         │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │Documents    │ │Databases    │ │APIs         │          │
│  │• PDF        │ │• SQL        │ │• REST       │          │
│  │• Word       │ │• NoSQL      │ │• GraphQL    │          │
│  │• Web Pages  │ │• Vector DB  │ │• External   │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

### 核心組件說明

**1. 資料來源層（Data Sources Layer）**
- 📄 **文檔資料**：PDF、Word、Excel、PowerPoint 等
- 🗄️ **資料庫**：關聯式資料庫、NoSQL、向量資料庫
- 🌐 **API 介面**：REST API、GraphQL、第三方服務
- 📊 **結構化資料**：CSV、JSON、XML 等格式

**2. 資料處理層（Data Processing Layer）**
- 🔄 **ETL 管道**：提取、轉換、載入資料
- ✂️ **文本分塊**：將長文檔切分為適當大小的片段
- 🧮 **向量化**：將文本轉換為數值向量
- 🏷️ **元資料增強**：添加分類、標籤、時間戳等資訊

**3. 檢索層（Retrieval Layer）**
- 🔍 **向量存儲**：基於語義相似性的檢索
- 📝 **全文搜尋**：基於關鍵字的傳統搜尋
- 🕸️ **知識圖譜**：基於實體關係的檢索

**4. 應用層（Application Layer）**
- 🎯 **查詢處理**：理解和預處理用戶查詢
- 🔗 **檢索協調**：協調多個檢索源的結果
- 📝 **回應生成**：基於檢索結果生成最終答案
- 📊 **結果排序**：對檢索結果進行排序和過濾

---

## 7.1.3 RAG 工作流程詳解

### 完整的 RAG 工作流程

```
┌─────────────────────────────────────────────────────────────┐
│                    RAG Workflow Process                     │
├─────────────────────────────────────────────────────────────┤
│  Phase 1: Data Preparation (Offline)                       │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  1. Document Collection                                 │ │
│  │     ↓                                                   │ │
│  │  2. Document Parsing & Cleaning                         │ │
│  │     ↓                                                   │ │
│  │  3. Text Chunking & Segmentation                        │ │
│  │     ↓                                                   │ │
│  │  4. Embedding Generation                                │ │
│  │     ↓                                                   │ │
│  │  5. Vector Storage & Indexing                           │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Phase 2: Query Processing (Online)                        │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  1. User Query Input                                    │ │
│  │     ↓                                                   │ │
│  │  2. Query Understanding & Enhancement                   │ │
│  │     ↓                                                   │ │
│  │  3. Query Embedding Generation                          │ │
│  │     ↓                                                   │ │
│  │  4. Similarity Search & Retrieval                       │ │
│  │     ↓                                                   │ │
│  │  5. Context Assembly & Ranking                          │ │
│  │     ↓                                                   │ │
│  │  6. LLM Generation with Context                         │ │
│  │     ↓                                                   │ │
│  │  7. Response Post-processing                            │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 階段一：資料準備（離線處理）

**步驟 1：文檔收集**
```java
/**
 * 文檔收集服務
 */
@Service
public class DocumentCollectionService {
    
    public List<Document> collectDocuments(List<String> sources) {
        List<Document> documents = new ArrayList<>();
        
        for (String source : sources) {
            if (source.endsWith(".pdf")) {
                documents.addAll(loadPdfDocuments(source));
            } else if (source.startsWith("http")) {
                documents.addAll(loadWebDocuments(source));
            } else if (source.contains("database")) {
                documents.addAll(loadDatabaseDocuments(source));
            }
        }
        
        return documents;
    }
}
```

**步驟 2：文檔解析與清理**
```java
/**
 * 文檔處理服務
 */
@Service
public class DocumentProcessingService {
    
    public Document processDocument(Document rawDocument) {
        // 1. 提取純文本
        String cleanText = extractText(rawDocument);
        
        // 2. 清理和標準化
        cleanText = cleanAndNormalize(cleanText);
        
        // 3. 提取元資料
        Map<String, Object> metadata = extractMetadata(rawDocument);
        
        return new Document(cleanText, metadata);
    }
    
    private String cleanAndNormalize(String text) {
        return text
            .replaceAll("\\s+", " ")  // 標準化空白字符
            .replaceAll("[^\\p{L}\\p{N}\\p{P}\\p{Z}]", "")  // 移除特殊字符
            .trim();
    }
}
```

**步驟 3：文本分塊**
```java
/**
 * 文本分塊服務
 */
@Service
public class TextChunkingService {
    
    private static final int DEFAULT_CHUNK_SIZE = 1000;
    private static final int DEFAULT_OVERLAP = 200;
    
    public List<Document> chunkDocument(Document document) {
        String text = document.getContent();
        List<Document> chunks = new ArrayList<>();
        
        int start = 0;
        int chunkIndex = 0;
        
        while (start < text.length()) {
            int end = Math.min(start + DEFAULT_CHUNK_SIZE, text.length());
            
            // 尋找適當的分割點（句號、段落等）
            if (end < text.length()) {
                end = findBestSplitPoint(text, start, end);
            }
            
            String chunkText = text.substring(start, end);
            
            // 建立分塊文檔
            Map<String, Object> chunkMetadata = new HashMap<>(document.getMetadata());
            chunkMetadata.put("chunk_index", chunkIndex);
            chunkMetadata.put("chunk_start", start);
            chunkMetadata.put("chunk_end", end);
            
            chunks.add(new Document(chunkText, chunkMetadata));
            
            start = end - DEFAULT_OVERLAP;  // 重疊處理
            chunkIndex++;
        }
        
        return chunks;
    }
}
```

**步驟 4：向量化處理**
```java
/**
 * 向量化服務
 */
@Service
public class EmbeddingService {
    
    private final EmbeddingModel embeddingModel;
    
    public List<Document> generateEmbeddings(List<Document> documents) {
        List<Document> embeddedDocuments = new ArrayList<>();
        
        // 批次處理以提高效率
        List<List<Document>> batches = createBatches(documents, 100);
        
        for (List<Document> batch : batches) {
            List<String> texts = batch.stream()
                .map(Document::getContent)
                .collect(Collectors.toList());
            
            // 生成嵌入向量
            EmbeddingResponse embeddingResponse = embeddingModel.embedForResponse(texts);
            List<List<Double>> embeddings = embeddingResponse.getResults().stream()
                .map(result -> result.getOutput())
                .collect(Collectors.toList());
            
            // 將向量添加到文檔中
            for (int i = 0; i < batch.size(); i++) {
                Document doc = batch.get(i);
                // Spring AI 會自動處理嵌入向量，不需要手動設置
                embeddedDocuments.add(doc);
            }
        }
        
        return embeddedDocuments;
    }
}
```

### 階段二：查詢處理（線上處理）

**步驟 1：查詢理解與增強**
```java
/**
 * 查詢處理服務
 */
@Service
public class QueryProcessingService {
    
    public ProcessedQuery processQuery(String rawQuery) {
        // 1. 查詢清理
        String cleanQuery = cleanQuery(rawQuery);
        
        // 2. 查詢擴展
        List<String> expandedQueries = expandQuery(cleanQuery);
        
        // 3. 意圖識別
        QueryIntent intent = identifyIntent(cleanQuery);
        
        return ProcessedQuery.builder()
            .originalQuery(rawQuery)
            .cleanQuery(cleanQuery)
            .expandedQueries(expandedQueries)
            .intent(intent)
            .build();
    }
    
    private List<String> expandQuery(String query) {
        List<String> expanded = new ArrayList<>();
        expanded.add(query);
        
        // 添加同義詞
        expanded.addAll(findSynonyms(query));
        
        // 添加相關詞彙
        expanded.addAll(findRelatedTerms(query));
        
        return expanded;
    }
}
```

**步驟 2：相似性搜尋**

在 Spring AI 中，相似性搜尋已經由 `QuestionAnswerAdvisor` 和 `VectorStore` 內部自動處理，開發者不需要手動實現檢索邏輯：

```java
/**
 * 基本的向量檢索示例
 */
@Service
public class DocumentRetrievalService {
    
    private final VectorStore vectorStore;
    
    public DocumentRetrievalService(VectorStore vectorStore) {
        this.vectorStore = vectorStore;
    }
    
    /**
     * 手動檢索文檔（當需要自定義檢索邏輯時）
     */
    public List<Document> searchDocuments(String query, int topK, double threshold) {
        return vectorStore.similaritySearch(
            SearchRequest.builder()
                .query(query)
                .topK(topK)
                .similarityThreshold(threshold)
                .build()
        );
    }
}
```

**步驟 3：上下文組裝與生成**

在 Spring AI 中，RAG 的上下文組裝和生成由 `QuestionAnswerAdvisor` 自動處理：

```java
/**
 * RAG 生成服務示例
 */
@Service
public class RAGGenerationService {
    
    private final ChatClient ragChatClient;
    
    public RAGGenerationService(ChatClient ragChatClient) {
        this.ragChatClient = ragChatClient;
    }
    
    /**
     * 使用 RAG 生成回應
     */
    public String generateResponse(String query) {
        // Spring AI 的 QuestionAnswerAdvisor 會自動：
        // 1. 檢索相關文檔
        // 2. 組裝上下文
        // 3. 構建提示詞
        // 4. 調用 LLM 生成回應
        return ragChatClient.prompt()
            .user(query)
            .call()
            .content();
    }
    
    /**
     * 帶有動態過濾條件的 RAG 查詢
     */
    public String generateResponseWithFilter(String query, String filterExpression) {
        return ragChatClient.prompt()
            .user(query)
            .advisors(a -> a.param(QuestionAnswerAdvisor.FILTER_EXPRESSION, filterExpression))
            .call()
            .content();
    }
}
```

---

## 7.1.4 Spring AI RAG 實現

### 基礎 RAG 配置

```java
/**
 * RAG 系統配置
 */
@Configuration
@EnableConfigurationProperties(RAGProperties.class)
public class RAGConfig {
    
    @Bean
    public VectorStore vectorStore(EmbeddingModel embeddingModel) {
        return new SimpleVectorStore(embeddingModel);
    }
    
    @Bean
    public QuestionAnswerAdvisor questionAnswerAdvisor(
            VectorStore vectorStore,
            RAGProperties properties) {
        
        return QuestionAnswerAdvisor.builder(vectorStore)
            .searchRequest(SearchRequest.builder()
                .topK(properties.getTopK())
                .similarityThreshold(properties.getSimilarityThreshold())
                .build())
            .build();
    }
    
    @Bean
    public ChatClient ragChatClient(
            ChatModel chatModel,
            QuestionAnswerAdvisor questionAnswerAdvisor) {
        
        return ChatClient.builder(chatModel)
            .defaultAdvisors(questionAnswerAdvisor)
            .build();
    }
}
```

### RAG 服務實現

```java
/**
 * RAG 服務實現
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RAGService {
    
    private final ChatClient ragChatClient;
    private final VectorStore vectorStore;
    private final DocumentProcessingService documentProcessor;
    
    /**
     * 添加文檔到知識庫
     */
    public void addDocuments(List<Resource> resources) {
        log.info("Adding {} documents to knowledge base", resources.size());
        
        List<Document> documents = new ArrayList<>();
        
        for (Resource resource : resources) {
            try {
                // 使用 Spring AI 的 ETL pipeline 處理文檔
                List<Document> processedDocs = processDocumentWithETL(resource);
                documents.addAll(processedDocs);
                
            } catch (Exception e) {
                log.error("Failed to process document: {}", resource.getFilename(), e);
            }
        }
        
        // 存儲到向量資料庫
        vectorStore.add(documents);
        
        log.info("Successfully added {} document chunks to knowledge base", documents.size());
    }
    
    private List<Document> processDocumentWithETL(Resource resource) {
        // Spring AI 的 ETL pipeline 會自動：
        // 1. 解析文檔內容
        // 2. 分塊處理
        // 3. 生成嵌入向量
        // 開發者只需要調用相應的 DocumentReader
        
        // 根據文件類型選擇合適的 DocumentReader
        // 例如：PdfDocumentReader, TextDocumentReader 等
        
        // 這裡簡化處理，實際應用中會根據文件類型使用對應的 Reader
        return List.of(new Document(resource.toString()));
    }
    
    /**
     * RAG 查詢
     */
    public RAGResponse query(String question) {
        log.debug("Processing RAG query: {}", question);
        
        long startTime = System.currentTimeMillis();
        
        try {
            // RAG 查詢使用 ChatClient 內建的 Advisor 機制
            String response = ragChatClient.prompt()
                .user(question)
                .call()
                .content();
            
            long processingTime = System.currentTimeMillis() - startTime;
            
            return RAGResponse.builder()
                .question(question)
                .answer(response)
                .processingTimeMs(processingTime)
                .timestamp(LocalDateTime.now())
                .build();
                
        } catch (Exception e) {
            log.error("RAG query failed: {}", question, e);
            throw new RAGException("Failed to process query", e);
        }
    }
    
    /**
     * 提取文檔來源
     */
    private List<DocumentSource> extractSources(List<Document> documents) {
        return documents.stream()
            .map(doc -> DocumentSource.builder()
                .title(getDocumentTitle(doc))
                .source(getDocumentSource(doc))
                .relevanceScore(getRelevanceScore(doc))
                .build())
            .collect(Collectors.toList());
    }
}
```

### RAG REST API

```java
/**
 * RAG REST API 控制器
 */
@RestController
@RequestMapping("/api/rag")
@RequiredArgsConstructor
@Slf4j
public class RAGController {
    
    private final RAGService ragService;
    
    /**
     * RAG 查詢端點
     */
    @PostMapping("/query")
    public ResponseEntity<RAGResponse> query(@RequestBody RAGQueryRequest request) {
        try {
            RAGResponse response = ragService.query(request.getQuestion());
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("RAG query failed", e);
            return ResponseEntity.badRequest()
                .body(RAGResponse.builder()
                    .question(request.getQuestion())
                    .error("查詢處理失敗：" + e.getMessage())
                    .timestamp(LocalDateTime.now())
                    .build());
        }
    }
    
    /**
     * 添加文檔端點
     */
    @PostMapping("/documents")
    public ResponseEntity<ApiResponse> addDocuments(
            @RequestParam("files") List<MultipartFile> files) {
        
        try {
            List<Resource> resources = files.stream()
                .map(this::convertToResource)
                .collect(Collectors.toList());
            
            ragService.addDocuments(resources);
            
            return ResponseEntity.ok(ApiResponse.success(
                String.format("成功添加 %d 個文檔到知識庫", files.size())));
                
        } catch (Exception e) {
            log.error("Failed to add documents", e);
            return ResponseEntity.badRequest()
                .body(ApiResponse.error("文檔添加失敗：" + e.getMessage()));
        }
    }
    
    /**
     * 知識庫統計端點
     */
    @GetMapping("/stats")
    public ResponseEntity<KnowledgeBaseStats> getStats() {
        // 實現知識庫統計邏輯
        KnowledgeBaseStats stats = KnowledgeBaseStats.builder()
            .totalDocuments(1000)
            .totalChunks(5000)
            .lastUpdated(LocalDateTime.now())
            .build();
        
        return ResponseEntity.ok(stats);
    }
}
```

---

## 📝 本章重點回顧

1. **RAG 核心概念**：理解了檢索增強生成的基本原理和企業價值
2. **系統架構設計**：掌握了完整的 RAG 系統分層架構
3. **工作流程詳解**：學會了從資料準備到查詢處理的完整流程
4. **Spring AI 實現**：完成了基於 Spring AI 的 RAG 系統實現
5. **API 介面設計**：建立了完整的 RAG 服務 REST API

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **RAG 架構設計** | ⭐⭐⭐ | 中 | 系統基礎 |
| **文檔處理流程** | ⭐⭐⭐ | 中 | 資料品質 |
| **向量檢索** | ⭐⭐⭐ | 高 | 檢索準確性 |
| **上下文組裝** | ⭐⭐ | 中 | 回應品質 |
| **API 設計** | ⭐⭐ | 低 | 系統整合 |

### 最佳實踐建議

1. **文檔品質**：確保輸入文檔的品質和結構化程度
2. **分塊策略**：根據文檔類型選擇合適的分塊大小和重疊度
3. **檢索優化**：調整相似性閾值和檢索數量以平衡準確性和效能
4. **提示詞設計**：設計清晰的提示詞模板以提高生成品質
5. **效能監控**：建立完整的 RAG 系統效能監控機制

### 下一步學習方向

在下一章中，我們將深入學習如何將內容向量化，包括：
- 不同嵌入模型的選擇和比較
- 向量化的最佳實踐
- 向量品質評估和優化
- 多語言向量化處理

---

**參考資料：**
- [Spring AI RAG Documentation](https://docs.spring.io/spring-ai/reference/api/vectordbs.html)
- [Retrieval-Augmented Generation Paper](https://arxiv.org/abs/2005.11401)
- [Vector Database Best Practices](https://www.pinecone.io/learn/vector-database/)
- [RAG System Design Patterns](https://blog.langchain.dev/rag-from-scratch/)


\newpage

## 7.2 如何將內容向量化


> **本章重點**：深入理解文本向量化技術，掌握不同嵌入模型的選擇和使用，學會優化向量品質以提升 RAG 系統效能。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解向量化原理**：掌握文本向量化的基本概念和數學原理
- 🎯 **選擇合適的嵌入模型**：了解不同嵌入模型的特點和適用場景
- 🎯 **實現向量化處理**：使用 Spring AI 實現高效的文本向量化
- 🎯 **優化向量品質**：掌握向量品質評估和優化技巧
- 🎯 **處理多語言向量化**：實現跨語言的向量化解決方案

---

## 7.2.1 向量化基礎概念

### 什麼是文本向量化？

**文本向量化（Text Embedding）** 是將文本轉換為數值向量的過程，這些向量能夠在高維空間中表示文本的語義資訊。

**核心概念**：
- 📊 **高維表示**：將文本映射到高維向量空間（通常 100-4096 維）
- 🎯 **語義捕捉**：相似意思的文本在向量空間中距離較近
- 🔢 **數值計算**：支援數學運算，如相似性計算、聚類分析
- 🔄 **可比較性**：不同文本可以通過向量距離進行比較

### 向量化的數學原理

**向量相似性計算**：

```
1. 餘弦相似性（Cosine Similarity）
   similarity = (A · B) / (||A|| × ||B||)
   
2. 歐幾里得距離（Euclidean Distance）
   distance = √(Σ(Ai - Bi)²)
   
3. 點積相似性（Dot Product）
   similarity = Σ(Ai × Bi)
```

**向量空間示例**：
```
文本: "Spring Boot 是一個 Java 框架"
向量: [0.2, -0.1, 0.8, 0.3, ..., 0.5]  (1536維)

文本: "Spring Boot is a Java framework"
向量: [0.18, -0.08, 0.82, 0.28, ..., 0.52]  (1536維)

相似性: 0.95 (高度相似)
```

### 向量化的發展歷程

| 技術 | 時期 | 特點 | 維度 | 適用場景 |
|------|------|------|------|----------|
| **One-Hot** | 1950s | 稀疏、高維 | 詞彙表大小 | 簡單分類 |
| **TF-IDF** | 1970s | 統計特徵 | 詞彙表大小 | 資訊檢索 |
| **Word2Vec** | 2013 | 密集向量 | 100-300 | 詞語相似性 |
| **GloVe** | 2014 | 全域統計 | 100-300 | 詞語關係 |
| **BERT** | 2018 | 上下文感知 | 768-1024 | 語義理解 |
| **OpenAI Embeddings** | 2022 | 大規模預訓練 | 1536-3072 | 通用語義 |

---

## 7.2.2 Spring AI 中的嵌入模型

### 支援的嵌入模型

Spring AI 支援多種嵌入模型，每種都有其特點和適用場景：

**1. OpenAI Embeddings**
```java
// OpenAI text-embedding-3-small (最新推薦)
@Bean
public EmbeddingModel openAIEmbeddingModel() {
    var openAiApi = OpenAiApi.builder()
        .apiKey(System.getenv("OPENAI_API_KEY"))
        .build();
    return new OpenAiEmbeddingModel(
        openAiApi,
        MetadataMode.EMBED,
        OpenAiEmbeddingOptions.builder()
            .withModel("text-embedding-3-small")  // 1536 維
            .withDimensions(1536)
            .build(),
        RetryUtils.DEFAULT_RETRY_TEMPLATE
    );
}

// OpenAI text-embedding-3-large (高精度)
@Bean
public EmbeddingModel openAILargeEmbeddingModel() {
    var openAiApi = OpenAiApi.builder()
        .apiKey(System.getenv("OPENAI_API_KEY"))
        .build();
    return new OpenAiEmbeddingModel(
        openAiApi,
        MetadataMode.EMBED,
        OpenAiEmbeddingOptions.builder()
            .withModel("text-embedding-3-large")  // 3072 維
            .withDimensions(3072)
            .build(),
        RetryUtils.DEFAULT_RETRY_TEMPLATE
    );
}
```

**2. Azure OpenAI Embeddings**
```java
@Bean
public EmbeddingModel azureEmbeddingModel() {
    var azureOpenAiApi = AzureOpenAiApi.builder()
        .apiKey(System.getenv("AZURE_OPENAI_API_KEY"))
        .endpoint(System.getenv("AZURE_OPENAI_ENDPOINT"))
        .build();
    return new AzureOpenAiEmbeddingModel(
        azureOpenAiApi,
        MetadataMode.EMBED,
        AzureOpenAiEmbeddingOptions.builder()
            .withDeploymentName("text-embedding-ada-002")
            .withDimensions(1536)
            .build(),
        RetryUtils.DEFAULT_RETRY_TEMPLATE
    );
}
```

**3. Ollama 本地嵌入模型**
```java
@Bean
public EmbeddingModel ollamaEmbeddingModel() {
    var ollamaApi = new OllamaApi();
    return new OllamaEmbeddingModel(
        ollamaApi,
        OllamaOptions.create()
            .withModel("nomic-embed-text")  // 本地模型
    );
}
```

**4. Transformers 嵌入模型**
```java
@Bean
public EmbeddingModel transformersEmbeddingModel() {
    return new TransformersEmbeddingModel(
        TransformersEmbeddingOptions.builder()
            .withModelName("sentence-transformers/all-MiniLM-L6-v2")
            .withDimensions(384)
            .build()
    );
}
```

### 嵌入模型比較

| 模型 | 維度 | 語言支援 | 效能 | 成本 | 適用場景 |
|------|------|----------|------|------|----------|
| **text-embedding-3-small** | 1536 | 多語言 | 高 | 低 | 通用推薦 |
| **text-embedding-3-large** | 3072 | 多語言 | 最高 | 中 | 高精度需求 |
| **text-embedding-ada-002** | 1536 | 多語言 | 高 | 低 | 穩定選擇 |
| **nomic-embed-text** | 768 | 英文為主 | 中 | 免費 | 本地部署 |
| **all-MiniLM-L6-v2** | 384 | 多語言 | 中 | 免費 | 輕量級應用 |

---

## 7.2.3 向量化服務實現

### 基礎向量化服務

```java
/**
 * 文本向量化服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class TextEmbeddingService {
    
    private final EmbeddingModel embeddingModel;
    private final MeterRegistry meterRegistry;
    
    /**
     * 單一文本向量化
     */
    public float[] embedText(String text) {
        if (text == null || text.trim().isEmpty()) {
            throw new IllegalArgumentException("Text cannot be null or empty");
        }
        
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            // 預處理文本
            String processedText = preprocessText(text);
            
            // 生成向量
            float[] embedding = embeddingModel.embed(processedText);
            
            // 記錄指標
            sample.stop(Timer.builder("embedding.generation.time")
                .description("Time to generate text embedding")
                .register(meterRegistry));
            
            meterRegistry.counter("embedding.generation.count").increment();
            
            log.debug("Generated embedding for text: {} chars, vector dim: {}", 
                text.length(), embedding.length);
            
            return embedding;
            
        } catch (Exception e) {
            meterRegistry.counter("embedding.generation.errors").increment();
            log.error("Failed to generate embedding for text: {}", text, e);
            throw new EmbeddingException("Failed to generate embedding", e);
        }
    }
    
    /**
     * 批次文本向量化
     */
    public List<float[]> embedTexts(List<String> texts) {
        if (texts == null || texts.isEmpty()) {
            return Collections.emptyList();
        }
        
        log.info("Generating embeddings for {} texts", texts.size());
        
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            // 預處理所有文本
            List<String> processedTexts = texts.stream()
                .map(this::preprocessText)
                .collect(Collectors.toList());
            
            // 批次生成向量
            List<float[]> embeddings = embeddingModel.embed(processedTexts);
            
            sample.stop(Timer.builder("embedding.batch.generation.time")
                .description("Time to generate batch embeddings")
                .register(meterRegistry));
            
            meterRegistry.counter("embedding.batch.generation.count")
                .increment(texts.size());
            
            log.info("Successfully generated {} embeddings", embeddings.size());
            
            return embeddings;
            
        } catch (Exception e) {
            meterRegistry.counter("embedding.batch.generation.errors").increment();
            log.error("Failed to generate batch embeddings", e);
            throw new EmbeddingException("Failed to generate batch embeddings", e);
        }
    }
    
    /**
     * 文本預處理
     */
    private String preprocessText(String text) {
        if (text == null) {
            return "";
        }
        
        return text
            .trim()
            .replaceAll("\\s+", " ")  // 標準化空白字符
            .replaceAll("[\\r\\n]+", " ")  // 移除換行符
            .substring(0, Math.min(text.length(), 8000));  // 限制長度
    }
    
    /**
     * 計算向量相似性
     */
    public double calculateSimilarity(float[] vector1, float[] vector2) {
        if (vector1.length != vector2.length) {
            throw new IllegalArgumentException("Vectors must have the same dimension");
        }
        
        // 餘弦相似性計算
        double dotProduct = 0.0;
        double norm1 = 0.0;
        double norm2 = 0.0;
        
        for (int i = 0; i < vector1.length; i++) {
            dotProduct += vector1[i] * vector2[i];
            norm1 += Math.pow(vector1[i], 2);
            norm2 += Math.pow(vector2[i], 2);
        }
        
        return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
    }
}
```

### 進階向量化處理

```java
/**
 * 進階向量化處理服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AdvancedEmbeddingService {
    
    private final TextEmbeddingService embeddingService;
    private final RedisTemplate<String, Object> redisTemplate;
    
    private static final String EMBEDDING_CACHE_PREFIX = "embedding:";
    private static final Duration CACHE_TTL = Duration.ofHours(24);
    
    /**
     * 帶快取的向量化
     */
    public float[] embedTextWithCache(String text) {
        String cacheKey = EMBEDDING_CACHE_PREFIX + DigestUtils.md5Hex(text);
        
        // 嘗試從快取取得
        float[] cachedEmbedding = (float[]) redisTemplate.opsForValue().get(cacheKey);
        
        if (cachedEmbedding != null) {
            log.debug("Cache hit for text embedding: {}", cacheKey);
            return cachedEmbedding;
        }
        
        // 快取未命中，生成新向量
        float[] embedding = embeddingService.embedText(text);
        
        // 存入快取
        redisTemplate.opsForValue().set(cacheKey, embedding, CACHE_TTL);
        
        log.debug("Cache miss, generated and cached embedding: {}", cacheKey);
        
        return embedding;
    }
    
    /**
     * 分層向量化處理
     */
    public LayeredEmbedding generateLayeredEmbedding(String text) {
        // 1. 句子級向量化
        List<String> sentences = splitIntoSentences(text);
        List<float[]> sentenceEmbeddings = embeddingService.embedTexts(sentences);
        
        // 2. 段落級向量化
        List<String> paragraphs = splitIntoParagraphs(text);
        List<float[]> paragraphEmbeddings = embeddingService.embedTexts(paragraphs);
        
        // 3. 文檔級向量化
        float[] documentEmbedding = embeddingService.embedText(text);
        
        return LayeredEmbedding.builder()
            .sentences(sentences)
            .sentenceEmbeddings(sentenceEmbeddings)
            .paragraphs(paragraphs)
            .paragraphEmbeddings(paragraphEmbeddings)
            .documentEmbedding(documentEmbedding)
            .build();
    }
    
    /**
     * 多模型向量化
     */
    public MultiModelEmbedding generateMultiModelEmbedding(String text) {
        Map<String, float[]> embeddings = new HashMap<>();
        
        // 使用不同模型生成向量
        try {
            embeddings.put("openai-small", generateWithModel(text, "openai-small"));
            embeddings.put("openai-large", generateWithModel(text, "openai-large"));
            embeddings.put("local-model", generateWithModel(text, "local-model"));
        } catch (Exception e) {
            log.warn("Some embedding models failed", e);
        }
        
        return MultiModelEmbedding.builder()
            .text(text)
            .embeddings(embeddings)
            .timestamp(LocalDateTime.now())
            .build();
    }
    
    /**
     * 向量品質評估
     */
    public EmbeddingQuality assessEmbeddingQuality(float[] embedding, String originalText) {
        // 1. 向量維度檢查
        int dimension = embedding.length;
        boolean validDimension = dimension >= 384 && dimension <= 4096;
        
        // 2. 向量範數檢查
        double norm = calculateVectorNorm(embedding);
        boolean validNorm = norm > 0.1 && norm < 10.0;
        
        // 3. 向量分佈檢查
        double[] stats = calculateVectorStatistics(embedding);
        double mean = stats[0];
        double stdDev = stats[1];
        boolean validDistribution = Math.abs(mean) < 0.5 && stdDev > 0.01;
        
        // 4. 文本長度適配性
        boolean validTextLength = originalText.length() >= 10 && originalText.length() <= 8000;
        
        double qualityScore = calculateQualityScore(
            validDimension, validNorm, validDistribution, validTextLength
        );
        
        return EmbeddingQuality.builder()
            .dimension(dimension)
            .norm(norm)
            .mean(mean)
            .standardDeviation(stdDev)
            .qualityScore(qualityScore)
            .isValid(qualityScore > 0.7)
            .build();
    }
    
    private List<String> splitIntoSentences(String text) {
        // 簡單的句子分割實現
        return Arrays.stream(text.split("[.!?]+"))
            .map(String::trim)
            .filter(s -> !s.isEmpty())
            .collect(Collectors.toList());
    }
    
    private List<String> splitIntoParagraphs(String text) {
        return Arrays.stream(text.split("\\n\\s*\\n"))
            .map(String::trim)
            .filter(s -> !s.isEmpty())
            .collect(Collectors.toList());
    }
    
    private float[] generateWithModel(String text, String modelType) {
        // 根據模型類型選擇不同的嵌入模型
        // 這裡簡化實現，實際應用中需要注入不同的模型
        return embeddingService.embedText(text);
    }
    
    private double calculateVectorNorm(float[] vector) {
        double sum = 0.0;
        for (float value : vector) {
            sum += value * value;
        }
        return Math.sqrt(sum);
    }
    
    private double[] calculateVectorStatistics(float[] vector) {
        // 計算平均值
        double sum = 0.0;
        for (float value : vector) {
            sum += value;
        }
        double mean = sum / vector.length;
        
        // 計算方差
        double varianceSum = 0.0;
        for (float value : vector) {
            varianceSum += Math.pow(value - mean, 2);
        }
        double variance = varianceSum / vector.length;
        double stdDev = Math.sqrt(variance);
        
        return new double[]{mean, stdDev};
    }
    
    private double calculateQualityScore(boolean... checks) {
        long passedChecks = Arrays.stream(checks)
            .mapToInt(b -> b ? 1 : 0)
            .sum();
        
        return (double) passedChecks / checks.length;
    }
}
```

---

## 7.2.4 向量化配置與優化

### 向量化配置類

```java
/**
 * 向量化配置
 */
@Configuration
@EnableConfigurationProperties(EmbeddingProperties.class)
public class EmbeddingConfig {
    
    /**
     * 主要嵌入模型配置
     */
    @Bean
    @Primary
    public EmbeddingModel primaryEmbeddingModel(EmbeddingProperties properties) {
        EmbeddingProperties.ModelConfig config = properties.getPrimary();
        
        return switch (config.getProvider().toLowerCase()) {
            case "openai" -> createOpenAIEmbeddingModel(config);
            case "azure" -> createAzureEmbeddingModel(config);
            case "ollama" -> createOllamaEmbeddingModel(config);
            case "transformers" -> createTransformersEmbeddingModel(config);
            default -> throw new IllegalArgumentException("Unsupported embedding provider: " + config.getProvider());
        };
    }
    
    /**
     * 備用嵌入模型配置
     */
    @Bean
    @Qualifier("fallback")
    public EmbeddingModel fallbackEmbeddingModel(EmbeddingProperties properties) {
        EmbeddingProperties.ModelConfig config = properties.getFallback();
        
        if (config == null) {
            // 預設使用本地模型作為備用
            return new TransformersEmbeddingModel(
                TransformersEmbeddingOptions.builder()
                    .withModelName("sentence-transformers/all-MiniLM-L6-v2")
                    .withDimensions(384)
                    .build()
            );
        }
        
        return createEmbeddingModel(config);
    }
    
    /**
     * 向量化快取配置
     */
    @Bean
    public CacheManager embeddingCacheManager() {
        RedisCacheManager.Builder builder = RedisCacheManager
            .RedisCacheManagerBuilder
            .fromConnectionFactory(redisConnectionFactory())
            .cacheDefaults(cacheConfiguration());
        
        return builder.build();
    }
    
    private RedisCacheConfiguration cacheConfiguration() {
        return RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(24))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
    }
    
    private EmbeddingModel createOpenAIEmbeddingModel(EmbeddingProperties.ModelConfig config) {
        OpenAiApi openAiApi = OpenAiApi.builder()
            .apiKey(config.getApiKey())
            .build();
            
        return new OpenAiEmbeddingModel(
            openAiApi,
            MetadataMode.EMBED,
            OpenAiEmbeddingOptions.builder()
                .withModel(config.getModelName())
                .withDimensions(config.getDimensions())
                .build(),
            RetryUtils.DEFAULT_RETRY_TEMPLATE
        );
    }
    
    // 其他模型創建方法...
}
```

### 向量化配置屬性

```java
/**
 * 向量化配置屬性
 */
@ConfigurationProperties(prefix = "app.embedding")
@Data
@Validated
public class EmbeddingProperties {
    
    /**
     * 主要嵌入模型配置
     */
    @NotNull
    private ModelConfig primary;
    
    /**
     * 備用嵌入模型配置
     */
    private ModelConfig fallback;
    
    /**
     * 快取配置
     */
    private CacheConfig cache = new CacheConfig();
    
    /**
     * 批次處理配置
     */
    private BatchConfig batch = new BatchConfig();
    
    @Data
    @Validated
    public static class ModelConfig {
        @NotBlank
        private String provider;  // openai, azure, ollama, transformers
        
        @NotBlank
        private String modelName;
        
        @Min(100)
        @Max(4096)
        private int dimensions;
        
        private String apiKey;
        private String endpoint;
        private Duration timeout = Duration.ofSeconds(30);
    }
    
    @Data
    public static class CacheConfig {
        private boolean enabled = true;
        private Duration ttl = Duration.ofHours(24);
        private int maxSize = 10000;
    }
    
    @Data
    public static class BatchConfig {
        private int size = 100;
        private Duration timeout = Duration.ofMinutes(5);
        private int retries = 3;
    }
}
```

### 應用配置檔案

```yaml
# application.yml
app:
  embedding:
    primary:
      provider: openai
      model-name: text-embedding-3-small
      dimensions: 1536
      api-key: ${OPENAI_API_KEY}
      timeout: 30s
    
    fallback:
      provider: transformers
      model-name: sentence-transformers/all-MiniLM-L6-v2
      dimensions: 384
      timeout: 60s
    
    cache:
      enabled: true
      ttl: 24h
      max-size: 10000
    
    batch:
      size: 100
      timeout: 5m
      retries: 3

# 開發環境配置
---
spring:
  config:
    activate:
      on-profile: dev

app:
  embedding:
    primary:
      provider: transformers
      model-name: sentence-transformers/all-MiniLM-L6-v2
      dimensions: 384
    cache:
      enabled: false

# 生產環境配置
---
spring:
  config:
    activate:
      on-profile: prod

app:
  embedding:
    primary:
      provider: openai
      model-name: text-embedding-3-large
      dimensions: 3072
      api-key: ${OPENAI_API_KEY}
    
    fallback:
      provider: azure
      model-name: text-embedding-ada-002
      dimensions: 1536
      api-key: ${AZURE_OPENAI_API_KEY}
      endpoint: ${AZURE_OPENAI_ENDPOINT}
```

---

## 7.2.5 向量品質評估與優化

### 向量品質評估服務

```java
/**
 * 向量品質評估服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class EmbeddingQualityService {
    
    private final TextEmbeddingService embeddingService;
    
    /**
     * 綜合品質評估
     */
    public QualityAssessmentResult assessEmbeddingQuality(
            List<String> testTexts, 
            List<String> expectedSimilarTexts) {
        
        log.info("Starting embedding quality assessment with {} test cases", testTexts.size());
        
        List<QualityMetric> metrics = new ArrayList<>();
        
        for (int i = 0; i < testTexts.size(); i++) {
            String testText = testTexts.get(i);
            String expectedSimilar = expectedSimilarTexts.get(i);
            
            QualityMetric metric = assessSinglePair(testText, expectedSimilar);
            metrics.add(metric);
        }
        
        return QualityAssessmentResult.builder()
            .totalTests(testTexts.size())
            .metrics(metrics)
            .averageSimilarity(calculateAverageSimilarity(metrics))
            .qualityScore(calculateOverallQuality(metrics))
            .timestamp(LocalDateTime.now())
            .build();
    }
    
    /**
     * 單一文本對評估
     */
    private QualityMetric assessSinglePair(String text1, String text2) {
        try {
            // 生成向量
            float[] embedding1 = embeddingService.embedText(text1);
            float[] embedding2 = embeddingService.embedText(text2);
            
            // 計算相似性
            double similarity = embeddingService.calculateSimilarity(embedding1, embedding2);
            
            // 評估向量品質
            EmbeddingQuality quality1 = assessVectorQuality(embedding1, text1);
            EmbeddingQuality quality2 = assessVectorQuality(embedding2, text2);
            
            return QualityMetric.builder()
                .text1(text1)
                .text2(text2)
                .similarity(similarity)
                .quality1(quality1)
                .quality2(quality2)
                .isValid(similarity > 0.7 && quality1.isValid() && quality2.isValid())
                .build();
                
        } catch (Exception e) {
            log.error("Failed to assess quality for text pair", e);
            return QualityMetric.builder()
                .text1(text1)
                .text2(text2)
                .similarity(0.0)
                .isValid(false)
                .error(e.getMessage())
                .build();
        }
    }
    
    /**
     * 向量品質評估
     */
    private EmbeddingQuality assessVectorQuality(float[] embedding, String originalText) {
        // 1. 維度檢查
        int dimension = embedding.length;
        boolean validDimension = dimension >= 384;
        
        // 2. 數值範圍檢查
        float min = Float.MAX_VALUE;
        float max = Float.MIN_VALUE;
        for (float value : embedding) {
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        boolean validRange = min >= -2.0f && max <= 2.0f;
        
        // 3. 向量範數檢查
        double norm = 0.0;
        for (float value : embedding) {
            norm += value * value;
        }
        norm = Math.sqrt(norm);
        boolean validNorm = norm > 0.1 && norm < 10.0;
        
        // 4. 零向量檢查
        boolean notZeroVector = false;
        for (float value : embedding) {
            if (Math.abs(value) > 1e-6) {
                notZeroVector = true;
                break;
            }
        }
        
        // 5. 文本長度適配性
        boolean validTextLength = originalText.length() >= 5;
        
        double qualityScore = calculateQualityScore(
            validDimension, validRange, validNorm, notZeroVector, validTextLength
        );
        
        return EmbeddingQuality.builder()
            .dimension(dimension)
            .norm(norm)
            .minValue(min)
            .maxValue(max)
            .qualityScore(qualityScore)
            .isValid(qualityScore > 0.8)
            .validDimension(validDimension)
            .validRange(validRange)
            .validNorm(validNorm)
            .notZeroVector(notZeroVector)
            .validTextLength(validTextLength)
            .build();
    }
    
    /**
     * 語義一致性測試
     */
    public SemanticConsistencyResult testSemanticConsistency() {
        // 準備測試案例
        Map<String, List<String>> testCases = prepareSemanticTestCases();
        
        List<ConsistencyTest> results = new ArrayList<>();
        
        for (Map.Entry<String, List<String>> entry : testCases.entrySet()) {
            String category = entry.getKey();
            List<String> texts = entry.getValue();
            
            ConsistencyTest test = testCategoryConsistency(category, texts);
            results.add(test);
        }
        
        return SemanticConsistencyResult.builder()
            .tests(results)
            .overallScore(calculateConsistencyScore(results))
            .timestamp(LocalDateTime.now())
            .build();
    }
    
    private Map<String, List<String>> prepareSemanticTestCases() {
        Map<String, List<String>> testCases = new HashMap<>();
        
        // 技術相關
        testCases.put("technology", Arrays.asList(
            "Spring Boot 是一個 Java 框架",
            "Spring Boot is a Java framework",
            "Spring Boot 框架用於 Java 開發",
            "Java Spring Boot 應用程式框架"
        ));
        
        // 商業相關
        testCases.put("business", Arrays.asList(
            "提高銷售業績的策略",
            "增加營收的方法",
            "銷售成長策略",
            "業績提升計劃"
        ));
        
        return testCases;
    }
    
    private ConsistencyTest testCategoryConsistency(String category, List<String> texts) {
        List<float[]> embeddings = embeddingService.embedTexts(texts);
        
        // 計算所有文本對之間的相似性
        List<Double> similarities = new ArrayList<>();
        
        for (int i = 0; i < embeddings.size(); i++) {
            for (int j = i + 1; j < embeddings.size(); j++) {
                double similarity = embeddingService.calculateSimilarity(
                    embeddings.get(i), embeddings.get(j)
                );
                similarities.add(similarity);
            }
        }
        
        double averageSimilarity = similarities.stream()
            .mapToDouble(Double::doubleValue)
            .average()
            .orElse(0.0);
        
        double minSimilarity = similarities.stream()
            .mapToDouble(Double::doubleValue)
            .min()
            .orElse(0.0);
        
        return ConsistencyTest.builder()
            .category(category)
            .texts(texts)
            .similarities(similarities)
            .averageSimilarity(averageSimilarity)
            .minSimilarity(minSimilarity)
            .isConsistent(averageSimilarity > 0.7 && minSimilarity > 0.5)
            .build();
    }
    
    private double calculateAverageSimilarity(List<QualityMetric> metrics) {
        return metrics.stream()
            .mapToDouble(QualityMetric::getSimilarity)
            .average()
            .orElse(0.0);
    }
    
    private double calculateOverallQuality(List<QualityMetric> metrics) {
        long validCount = metrics.stream()
            .mapToLong(m -> m.isValid() ? 1 : 0)
            .sum();
        
        return (double) validCount / metrics.size();
    }
    
    private double calculateQualityScore(boolean... checks) {
        long passedChecks = Arrays.stream(checks)
            .mapToInt(b -> b ? 1 : 0)
            .sum();
        
        return (double) passedChecks / checks.length;
    }
    
    private double calculateConsistencyScore(List<ConsistencyTest> tests) {
        return tests.stream()
            .mapToDouble(ConsistencyTest::getAverageSimilarity)
            .average()
            .orElse(0.0);
    }
}
```

---

## 7.2.6 多語言向量化處理

### 多語言向量化服務

```java
/**
 * 多語言向量化服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class MultilingualEmbeddingService {
    
    private final Map<String, EmbeddingModel> languageSpecificModels;
    private final EmbeddingModel universalModel;
    private final LanguageDetectionService languageDetector;
    
    /**
     * 自動語言檢測向量化
     */
    public MultilingualEmbedding embedWithLanguageDetection(String text) {
        // 1. 檢測語言
        LanguageDetectionResult detection = languageDetector.detectLanguage(text);
        
        // 2. 選擇合適的模型
        EmbeddingModel selectedModel = selectModelForLanguage(detection.getLanguage());
        
        // 3. 生成向量
        float[] embedding = selectedModel.embed(text);
        
        return MultilingualEmbedding.builder()
            .text(text)
            .detectedLanguage(detection.getLanguage())
            .confidence(detection.getConfidence())
            .embedding(embedding)
            .modelUsed(selectedModel.getClass().getSimpleName())
            .timestamp(LocalDateTime.now())
            .build();
    }
    
    /**
     * 跨語言相似性計算
     */
    public CrossLanguageSimilarity calculateCrossLanguageSimilarity(
            String text1, String lang1,
            String text2, String lang2) {
        
        // 使用通用多語言模型
        float[] embedding1 = universalModel.embed(text1);
        float[] embedding2 = universalModel.embed(text2);
        
        double similarity = calculateCosineSimilarity(embedding1, embedding2);
        
        return CrossLanguageSimilarity.builder()
            .text1(text1)
            .language1(lang1)
            .text2(text2)
            .language2(lang2)
            .similarity(similarity)
            .embedding1(embedding1)
            .embedding2(embedding2)
            .build();
    }
    
    /**
     * 多語言文檔處理
     */
    public List<MultilingualDocument> processMultilingualDocuments(List<String> texts) {
        return texts.parallelStream()
            .map(this::processMultilingualDocument)
            .collect(Collectors.toList());
    }
    
    private MultilingualDocument processMultilingualDocument(String text) {
        // 1. 語言檢測
        LanguageDetectionResult detection = languageDetector.detectLanguage(text);
        
        // 2. 語言特定處理
        String processedText = preprocessTextForLanguage(text, detection.getLanguage());
        
        // 3. 向量化
        EmbeddingModel model = selectModelForLanguage(detection.getLanguage());
        float[] embedding = model.embed(processedText);
        
        return MultilingualDocument.builder()
            .originalText(text)
            .processedText(processedText)
            .language(detection.getLanguage())
            .confidence(detection.getConfidence())
            .embedding(embedding)
            .build();
    }
    
    private EmbeddingModel selectModelForLanguage(String language) {
        // 優先使用語言特定模型
        EmbeddingModel specificModel = languageSpecificModels.get(language);
        if (specificModel != null) {
            return specificModel;
        }
        
        // 回退到通用模型
        return universalModel;
    }
    
    private String preprocessTextForLanguage(String text, String language) {
        return switch (language.toLowerCase()) {
            case "zh", "zh-cn", "zh-tw" -> preprocessChineseText(text);
            case "ja" -> preprocessJapaneseText(text);
            case "ko" -> preprocessKoreanText(text);
            case "ar" -> preprocessArabicText(text);
            default -> preprocessDefaultText(text);
        };
    }
    
    private String preprocessChineseText(String text) {
        // 中文特定預處理
        return text
            .replaceAll("[，。！？；：]", " ")  // 替換中文標點
            .replaceAll("\\s+", " ")
            .trim();
    }
    
    private String preprocessJapaneseText(String text) {
        // 日文特定預處理
        return text
            .replaceAll("[、。！？]", " ")
            .replaceAll("\\s+", " ")
            .trim();
    }
    
    private String preprocessKoreanText(String text) {
        // 韓文特定預處理
        return text
            .replaceAll("[，。！？]", " ")
            .replaceAll("\\s+", " ")
            .trim();
    }
    
    private String preprocessArabicText(String text) {
        // 阿拉伯文特定預處理（從右到左）
        return text
            .replaceAll("[،。！؟]", " ")
            .replaceAll("\\s+", " ")
            .trim();
    }
    
    private String preprocessDefaultText(String text) {
        // 預設預處理（主要針對拉丁字母語言）
        return text
            .toLowerCase()
            .replaceAll("[,.!?;:]", " ")
            .replaceAll("\\s+", " ")
            .trim();
    }
    
    private double calculateCosineSimilarity(float[] vector1, float[] vector2) {
        if (vector1.length != vector2.length) {
            throw new IllegalArgumentException("Vectors must have the same dimension");
        }
        
        double dotProduct = 0.0;
        double norm1 = 0.0;
        double norm2 = 0.0;
        
        for (int i = 0; i < vector1.length; i++) {
            dotProduct += vector1[i] * vector2[i];
            norm1 += Math.pow(vector1[i], 2);
            norm2 += Math.pow(vector2[i], 2);
        }
        
        return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
    }
}
```

---

## 📝 本章重點回顧

1. **向量化基礎概念**：理解了文本向量化的數學原理和發展歷程
2. **Spring AI 嵌入模型**：掌握了多種嵌入模型的選擇和配置
3. **向量化服務實現**：完成了完整的向量化處理服務
4. **品質評估與優化**：建立了向量品質評估和優化機制
5. **多語言處理**：實現了跨語言的向量化解決方案

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **嵌入模型選擇** | ⭐⭐⭐ | 中 | 基礎品質 |
| **向量化服務** | ⭐⭐⭐ | 中 | 核心功能 |
| **品質評估** | ⭐⭐ | 高 | 系統可靠性 |
| **多語言支援** | ⭐⭐ | 高 | 國際化需求 |
| **效能優化** | ⭐⭐ | 中 | 系統效能 |

### 最佳實踐建議

1. **模型選擇**：根據應用場景選擇合適的嵌入模型，平衡精度和成本
2. **快取策略**：實施向量快取以提高效能和降低 API 調用成本
3. **品質監控**：建立向量品質監控機制，及時發現和解決問題
4. **批次處理**：使用批次處理提高向量化效率
5. **多語言支援**：為國際化應用提供多語言向量化支援

### 下一步學習方向

在下一章中，我們將學習 ETL（Extract, Transform, Load）的上篇 - RAG 的知識來源，包括：
- 多種資料來源的整合
- 文檔解析和預處理
- 資料清理和標準化
- ETL 管道的設計和實現

---

**參考資料：**
- [Spring AI Embedding Models](https://docs.spring.io/spring-ai/reference/api/embeddings.html)
- [OpenAI Embeddings Guide](https://platform.openai.com/docs/guides/embeddings)
- [Sentence Transformers](https://www.sbert.net/)
- [Vector Similarity Metrics](https://www.pinecone.io/learn/vector-similarity/)


\newpage

## 7.3 ETL (上) - RAG 的知識來源


> **本章重點**：深入探討 RAG 系統的各種知識來源，掌握 ETL 流程中的資料提取（Extract）技術，學會整合多元化的企業資料來源。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 ETL 基礎概念**：掌握 Extract、Transform、Load 的完整流程
- 🎯 **識別知識來源類型**：了解企業中各種資料來源的特點和挑戰
- 🎯 **實現資料提取器**：開發多種資料來源的提取器
- 🎯 **設計 ETL 架構**：建立可擴展的 ETL 系統架構
- 🎯 **處理資料品質**：掌握資料清理和品質控制技術

---

## 7.3.1 ETL 基礎概念

### 什麼是 ETL？

**ETL（Extract, Transform, Load）** 是資料處理的核心流程，在 RAG 系統中扮演著將原始資料轉換為可搜尋知識的關鍵角色。

**ETL 三階段**：

```
┌─────────────────────────────────────────────────────────────┐
│                    ETL Process Flow                         │
├─────────────────────────────────────────────────────────────┤
│  Extract (提取)                                             │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 從各種資料來源提取原始資料                           │ │
│  │  • 處理不同格式和協議                                   │ │
│  │  • 確保資料完整性和一致性                               │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  Transform (轉換)                                           │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 清理和標準化資料                                     │ │
│  │  • 文本分塊和預處理                                     │ │
│  │  • 元資料增強和標記                                     │ │
│  │  • 向量化處理                                           │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  Load (載入)                                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 存儲到向量資料庫                                     │ │
│  │  • 建立索引和關聯                                       │ │
│  │  • 更新知識庫                                           │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### RAG 中的 ETL 特點

**傳統 ETL vs RAG ETL**：

| 特性 | 傳統 ETL | RAG ETL |
|------|----------|----------|
| **資料類型** | 結構化資料 | 非結構化文本 |
| **處理重點** | 資料清理、格式轉換 | 文本理解、語義提取 |
| **輸出格式** | 關聯式表格 | 向量嵌入 |
| **更新頻率** | 批次處理 | 即時/近即時 |
| **品質指標** | 完整性、一致性 | 語義準確性、相關性 |

---

## 7.3.2 企業知識來源分類

### 文檔類資料來源

**1. 辦公文檔**
```
• Microsoft Office 文件
  - Word (.docx, .doc)
  - Excel (.xlsx, .xls)
  - PowerPoint (.pptx, .ppt)
  
• PDF 文檔
  - 文本型 PDF
  - 掃描型 PDF (需 OCR)
  - 受保護 PDF
  
• 純文本文件
  - TXT, RTF
  - Markdown (.md)
  - CSV, TSV
```

**2. 技術文檔**
```
• 程式碼文檔
  - README.md
  - API 文檔
  - 程式碼註解
  
• 設計文檔
  - 系統架構圖
  - 流程圖
  - UML 圖表
```

### 網路資源

**1. 企業網站**
```
• 官方網站內容
• 產品說明頁面
• 常見問題 (FAQ)
• 部落格文章
• 新聞發布
```

**2. 內部系統**
```
• Wiki 系統
• 知識庫平台
• 內部論壇
• 專案管理系統
```

### 資料庫資源

**1. 關聯式資料庫**
```
• 客戶資料
• 產品資訊
• 交易記錄
• 日誌資料
```

**2. NoSQL 資料庫**
```
• MongoDB 文檔
• Elasticsearch 索引
• Redis 快取資料
```

### API 和服務

**1. REST API**
```
• 第三方服務 API
• 內部微服務
• 雲端服務 API
```

**2. 即時資料流**
```
• Kafka 訊息
• WebSocket 資料
• 事件流
```

---

## 7.3.3 資料提取器架構設計

### Spring AI ETL 架構設計

根據 Spring AI 官方文檔，ETL 架構包含三個核心介面：

```java
/**
 * 文檔讀取器 - 提供文檔來源
 */
public interface DocumentReader extends Supplier<List<Document>> {
    default List<Document> read() {
        return get();
    }
}

/**
 * 文檔轉換器 - 處理文檔轉換
 */
public interface DocumentTransformer extends Function<List<Document>, List<Document>> {
    default List<Document> transform(List<Document> documents) {
        return apply(documents);
    }
}

/**
 * 文檔寫入器 - 管理最終儲存
 */
public interface DocumentWriter extends Consumer<List<Document>> {
    default void write(List<Document> documents) {
        accept(documents);
    }
}
```

### Spring AI Document 模型

```java
/**
 * Spring AI 文檔模型
 */
public class Document {
    private String content;
    private Map<String, Object> metadata;
    private String id;
    
    // 建構子
    public Document(String content) {
        this(content, new HashMap<>());
    }
    
    public Document(String content, Map<String, Object> metadata) {
        this.content = content;
        this.metadata = metadata;
        this.id = UUID.randomUUID().toString();
    }
    
    // getter/setter 方法
    public String getContent() { return content; }
    public Map<String, Object> getMetadata() { return metadata; }
    public String getId() { return id; }
}
```

### ETL 管道組合

```java
/**
 * ETL 管道範例
 */
@Component
@Slf4j
public class EtlPipelineService {
    
    private final VectorStore vectorStore;
    
    public EtlPipelineService(VectorStore vectorStore) {
        this.vectorStore = vectorStore;
    }
    
    /**
     * 基本 ETL 流程
     */
    public void processDocuments(Resource resource) {
        // 1. Extract - 使用適當的 DocumentReader
        DocumentReader reader = createReader(resource);
        List<Document> documents = reader.read();
        
        // 2. Transform - 使用 DocumentTransformer
        TokenTextSplitter splitter = new TokenTextSplitter();
        List<Document> transformedDocs = splitter.transform(documents);
        
        // 3. Load - 寫入向量資料庫
        vectorStore.write(transformedDocs);
        
        log.info("Processed {} documents through ETL pipeline", documents.size());
    }
    
    /**
     * 函數式風格的 ETL 流程
     */
    public void processFunctionalStyle(Resource resource) {
        DocumentReader reader = createReader(resource);
        TokenTextSplitter splitter = new TokenTextSplitter();
        
        // 函數式組合
        vectorStore.accept(splitter.apply(reader.get()));
    }
    
    private DocumentReader createReader(Resource resource) {
        String filename = resource.getFilename();
        if (filename != null) {
            if (filename.endsWith(".pdf")) {
                return new PagePdfDocumentReader(resource);
            } else if (filename.endsWith(".txt")) {
                return new TextReader(resource);
            } else if (filename.endsWith(".docx") || filename.endsWith(".doc")) {
                return new TikaDocumentReader(resource);
            }
        }
        throw new IllegalArgumentException("Unsupported file type: " + filename);
    }
}
```

---

## 7.3.4 Spring AI DocumentReader 實現

### PDF 文檔讀取器

#### 依賴配置

首先添加 PDF 文檔讀取器依賴：

```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-pdf-document-reader</artifactId>
</dependency>
```

#### PagePdfDocumentReader 實現

```java
/**
 * PDF 頁面文檔讀取器範例
 */
@Component
@Slf4j
public class PdfDocumentService {
    
    
    /**
     * 基本 PDF 文檔讀取
     */
    public List<Document> readPdfDocument(Resource pdfResource) {
        log.info("Reading PDF document: {}", pdfResource.getFilename());
        
        PagePdfDocumentReader pdfReader = new PagePdfDocumentReader(pdfResource,
            PdfDocumentReaderConfig.builder()
                .withPageTopMargin(0)
                .withPageExtractedTextFormatter(ExtractedTextFormatter.builder()
                    .withNumberOfTopTextLinesToDelete(0)
                    .build())
                .withPagesPerDocument(1) // 每頁一個文檔
                .build());
        
        return pdfReader.read();
    }
    
    /**
     * 使用段落分割的 PDF 讀取
     */
    public List<Document> readPdfWithParagraphs(Resource pdfResource) {
        log.info("Reading PDF with paragraph splitting: {}", pdfResource.getFilename());
        
        ParagraphPdfDocumentReader pdfReader = new ParagraphPdfDocumentReader(pdfResource,
            PdfDocumentReaderConfig.builder()
                .withPageTopMargin(0)
                .withPageExtractedTextFormatter(ExtractedTextFormatter.builder()
                    .withNumberOfTopTextLinesToDelete(0)
                    .build())
                .build());
        
        return pdfReader.read();
    }
    
    /**
     * 進階 PDF 配置範例
     */
    public List<Document> readPdfWithAdvancedConfig(Resource pdfResource) {
        PdfDocumentReaderConfig config = PdfDocumentReaderConfig.builder()
            .withPageTopMargin(50)  // 頁面上邊距
            .withPageBottomMargin(50) // 頁面下邊距
            .withPageExtractedTextFormatter(
                ExtractedTextFormatter.builder()
                    .withNumberOfTopTextLinesToDelete(2) // 刪除頂部行數
                    .withNumberOfBottomTextLinesToDelete(1) // 刪除底部行數
                    .build())
            .withPagesPerDocument(3) // 每3頁合併為一個文檔
            .build();
        
        PagePdfDocumentReader pdfReader = new PagePdfDocumentReader(pdfResource, config);
        return pdfReader.read();
    }
    
    /**
     * PDF 文檔處理的完整範例
     */
    public void processMultiplePdfs(List<Resource> pdfResources) {
        for (Resource resource : pdfResources) {
            try {
                List<Document> documents = readPdfDocument(resource);
                
                // 添加自定義元資料
                documents.forEach(doc -> {
                    doc.getMetadata().put("source_file", resource.getFilename());
                    doc.getMetadata().put("processed_at", LocalDateTime.now().toString());
                    doc.getMetadata().put("content_type", "PDF");
                });
                
                log.info("Successfully processed PDF: {} with {} documents", 
                    resource.getFilename(), documents.size());
                
            } catch (Exception e) {
                log.error("Failed to process PDF: {}", resource.getFilename(), e);
            }
        }
    }
    
}

/**
 * PDF 配置類別
 */
@Configuration
public class PdfReaderConfiguration {
    
    /**
     * 默認 PDF 文檔讀取器
     */
    @Bean
    public PagePdfDocumentReader defaultPdfReader(@Value("classpath:sample.pdf") Resource pdfResource) {
        return new PagePdfDocumentReader(pdfResource);
    }
    
    /**
     * 自定義配置的 PDF 文檔讀取器
     */
    @Bean("customPdfReader")
    public PagePdfDocumentReader customPdfReader(@Value("classpath:complex.pdf") Resource pdfResource) {
        PdfDocumentReaderConfig config = PdfDocumentReaderConfig.builder()
            .withPageTopMargin(100)
            .withPageBottomMargin(100)
            .withPageExtractedTextFormatter(
                ExtractedTextFormatter.builder()
                    .withNumberOfTopTextLinesToDelete(3)
                    .withNumberOfBottomTextLinesToDelete(2)
                    .withLeftAlignment(true)
                    .build())
            .withPagesPerDocument(2)
            .build();
        
        return new PagePdfDocumentReader(pdfResource, config);
    }
}
```

### Tika 文檔讀取器

#### 依賴配置

```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-tika-document-reader</artifactId>
</dependency>
```

#### TikaDocumentReader 實現

```java
/**
 * 使用 Tika 處理多種文檔格式
 */
@Component
@Slf4j
public class TikaDocumentService {
    
    
    /**
     * 使用 TikaDocumentReader 讀取 Word 文檔
     */
    public List<Document> readWordDocument(Resource wordResource) {
        log.info("Reading Word document with Tika: {}", wordResource.getFilename());
        
        TikaDocumentReader tikaReader = new TikaDocumentReader(wordResource);
        List<Document> documents = tikaReader.read();
        
        // 添加自定義元資料
        documents.forEach(doc -> {
            doc.getMetadata().put("document_type", "WORD");
            doc.getMetadata().put("source_file", wordResource.getFilename());
            doc.getMetadata().put("processed_with", "Apache Tika");
        });
        
        return documents;
    }
    
    /**
     * 讀取 PowerPoint 文檔
     */
    public List<Document> readPowerPointDocument(Resource pptResource) {
        log.info("Reading PowerPoint document with Tika: {}", pptResource.getFilename());
        
        TikaDocumentReader tikaReader = new TikaDocumentReader(pptResource);
        List<Document> documents = tikaReader.read();
        
        documents.forEach(doc -> {
            doc.getMetadata().put("document_type", "POWERPOINT");
            doc.getMetadata().put("source_file", pptResource.getFilename());
        });
        
        return documents;
    }
    
    /**
     * 讀取多種格式的文檔
     */
    public List<Document> readDocuments(List<Resource> resources) {
        List<Document> allDocuments = new ArrayList<>();
        
        for (Resource resource : resources) {
            try {
                String filename = resource.getFilename();
                if (filename != null) {
                    List<Document> docs;
                    
                    if (filename.toLowerCase().matches(".*\\.(docx?|pptx?|xlsx?)$")) {
                        // Microsoft Office 文檔
                        docs = readOfficeDocument(resource);
                    } else if (filename.toLowerCase().endsWith(".pdf")) {
                        // PDF 文檔使用專用讀取器
                        continue; // PDF 由 PdfDocumentService 處理
                    } else {
                        // 其他格式嘗試用 Tika
                        docs = readGenericDocument(resource);
                    }
                    
                    allDocuments.addAll(docs);
                    log.info("Processed {} documents from {}", docs.size(), filename);
                }
            } catch (Exception e) {
                log.error("Failed to process document: {}", resource.getFilename(), e);
            }
        }
        
        return allDocuments;
    }
    
    private List<Document> readOfficeDocument(Resource resource) {
        TikaDocumentReader tikaReader = new TikaDocumentReader(resource);
        return tikaReader.read();
    }
    
    private List<Document> readGenericDocument(Resource resource) {
        TikaDocumentReader tikaReader = new TikaDocumentReader(resource);
        return tikaReader.read();
    }
    
}

/**
 * Text 文檔讀取器範例
 */
@Component
@Slf4j
public class TextDocumentService {
    
    /**
     * 讀取純文字檔案
     */
    public List<Document> readTextFile(Resource textResource) {
        log.info("Reading text file: {}", textResource.getFilename());
        
        TextReader textReader = new TextReader(textResource);
        
        // 設置字符編碼
        textReader.setCharset(StandardCharsets.UTF_8);
        
        // 添加自定義元資料
        textReader.getCustomMetadata().put("filename", textResource.getFilename());
        textReader.getCustomMetadata().put("content_type", "TEXT");
        
        return textReader.read();
    }
    
    /**
     * 讀取 Markdown 文件
     */
    public List<Document> readMarkdownFile(Resource markdownResource) {
        log.info("Reading markdown file: {}", markdownResource.getFilename());
        
        MarkdownDocumentReaderConfig config = MarkdownDocumentReaderConfig.builder()
            .withHorizontalRuleCreateDocument(true) // 水平線分割文檔
            .withIncludeCodeBlock(true)  // 包含程式碼區塊
            .withIncludeBlockquote(true) // 包含引用區塊
            .withAdditionalMetadata("filename", markdownResource.getFilename())
            .build();
        
        MarkdownDocumentReader markdownReader = new MarkdownDocumentReader(markdownResource, config);
        return markdownReader.read();
    }
    
    /**
     * 讀取 JSON 文件
     */
    public List<Document> readJsonFile(Resource jsonResource, String... jsonKeysToUse) {
        log.info("Reading JSON file: {}", jsonResource.getFilename());
        
        JsonReader jsonReader = new JsonReader(jsonResource, jsonKeysToUse);
        return jsonReader.read();
    }
    
    /**
     * 使用 JSON Pointer 讀取特定部分
     */
    public List<Document> readJsonWithPointer(Resource jsonResource, String jsonPointer, String... jsonKeysToUse) {
        log.info("Reading JSON file with pointer {}: {}", jsonPointer, jsonResource.getFilename());
        
        JsonReader jsonReader = new JsonReader(jsonResource, jsonKeysToUse);
        return jsonReader.get(jsonPointer);
    }
    
}

/**
 * HTML 文檔讀取器範例
 */
@Component
@Slf4j
public class HtmlDocumentService {
    
    /**
     * 讀取 HTML 文件
     */
    public List<Document> readHtmlFile(Resource htmlResource) {
        log.info("Reading HTML file: {}", htmlResource.getFilename());
        
        JsoupDocumentReaderConfig config = JsoupDocumentReaderConfig.builder()
            .selector("article p, div.content") // CSS 選擇器
            .charset("UTF-8")
            .includeLinkUrls(true) // 包含連結 URL
            .metadataTags(List.of("description", "keywords", "author")) // 提取 meta 標籤
            .additionalMetadata("source", htmlResource.getFilename())
            .build();
        
        JsoupDocumentReader htmlReader = new JsoupDocumentReader(htmlResource, config);
        return htmlReader.read();
    }
    
    /**
     * 讀取網頁 URL
     */
    public List<Document> readWebPage(String url) {
        log.info("Reading web page: {}", url);
        
        try {
            Resource urlResource = new UrlResource(url);
            
            JsoupDocumentReaderConfig config = JsoupDocumentReaderConfig.builder()
                .selector("body") // 提取整個 body 內容
                .allElements(false) // 不使用所有元素
                .groupByElement(false) // 不按元素分組
                .includeLinkUrls(false)
                .metadataTags(List.of("title", "description"))
                .additionalMetadata("url", url)
                .build();
            
            JsoupDocumentReader htmlReader = new JsoupDocumentReader(urlResource, config);
            return htmlReader.read();
            
        } catch (Exception e) {
            log.error("Failed to read web page: {}", url, e);
            return Collections.emptyList();
        }
    }
    
}
```

---

## 7.3.5 文檔轉換器 (DocumentTransformer)

### TokenTextSplitter - 文本分割器

```java
/**
 * 使用 TokenTextSplitter 分割文檔
 */
@Component
@Slf4j
public class DocumentTransformService {
    
    /**
     * 基本文本分割
     */
    public List<Document> splitDocuments(List<Document> documents) {
        TokenTextSplitter splitter = new TokenTextSplitter();
        return splitter.transform(documents);
    }
    
    /**
     * 自定義分割參數
     */
    public List<Document> splitDocumentsCustom(List<Document> documents) {
        // defaultChunkSize: 1000, minChunkSizeChars: 400, 
        // minChunkLengthToEmbed: 10, maxNumChunks: 5000, keepSeparator: true
        TokenTextSplitter splitter = new TokenTextSplitter(1000, 400, 10, 5000, true);
        return splitter.transform(documents);
    }
    
    /**
     * 內容格式轉換器
     */
    public List<Document> formatContent(List<Document> documents) {
        ContentFormatTransformer formatter = new ContentFormatTransformer();
        return formatter.transform(documents);
    }
}

/**
 * 元資料增強服務
 */
@Component
@Slf4j
public class MetadataEnrichmentService {
    
    private final ChatModel chatModel;
    
    public MetadataEnrichmentService(ChatModel chatModel) {
        this.chatModel = chatModel;
    }
    
    /**
     * 關鍵字提取器
     */
    public List<Document> enrichWithKeywords(List<Document> documents, int keywordCount) {
        KeywordMetadataEnricher enricher = new KeywordMetadataEnricher(chatModel, keywordCount);
        return enricher.transform(documents);
    }
    
    /**
     * 摘要產生器
     */
    public List<Document> enrichWithSummary(List<Document> documents) {
        SummaryMetadataEnricher enricher = new SummaryMetadataEnricher(
            chatModel, 
            List.of(SummaryMetadataEnricher.SummaryType.CURRENT,
                   SummaryMetadataEnricher.SummaryType.PREVIOUS,
                   SummaryMetadataEnricher.SummaryType.NEXT)
        );
        return enricher.transform(documents);
    }
    
}

/**
 * 文檔轉換管道範例
 */
@Component
@Slf4j
public class DocumentProcessingPipeline {
    
    private final ChatModel chatModel;
    
    public DocumentProcessingPipeline(ChatModel chatModel) {
        this.chatModel = chatModel;
    }
    
    /**
     * 完整的文檔處理管道
     */
    public List<Document> processDocuments(List<Document> documents) {
        log.info("Starting document processing pipeline with {} documents", documents.size());
        
        // 1. 文本分割
        TokenTextSplitter splitter = new TokenTextSplitter(800, 350, 5, 10000, true);
        List<Document> splitDocs = splitter.transform(documents);
        log.info("Split into {} chunks", splitDocs.size());
        
        // 2. 內容格式化
        ContentFormatTransformer formatter = new ContentFormatTransformer();
        List<Document> formattedDocs = formatter.transform(splitDocs);
        
        // 3. 關鍵字提取
        KeywordMetadataEnricher keywordEnricher = new KeywordMetadataEnricher(chatModel, 5);
        List<Document> keywordEnrichedDocs = keywordEnricher.transform(formattedDocs);
        
        // 4. 摘要產生
        SummaryMetadataEnricher summaryEnricher = new SummaryMetadataEnricher(
            chatModel,
            List.of(SummaryMetadataEnricher.SummaryType.CURRENT)
        );
        List<Document> enrichedDocs = summaryEnricher.transform(keywordEnrichedDocs);
        
        log.info("Completed document processing pipeline with {} enriched documents", enrichedDocs.size());
        return enrichedDocs;
    }
    
}
    
```

---

## 7.3.6 文檔寫入器 (DocumentWriter)

### VectorStore - 向量資料庫寫入器

```java
/**
 * 向量資料庫寫入服務
 */
@Component
@Slf4j
public class VectorStoreService {
    
    private final VectorStore vectorStore;
    private final EmbeddingModel embeddingModel;
    
    public VectorStoreService(VectorStore vectorStore, EmbeddingModel embeddingModel) {
        this.vectorStore = vectorStore;
        this.embeddingModel = embeddingModel;
    }
    
    /**
     * 將文檔寫入向量資料庫
     */
    public void writeDocuments(List<Document> documents) {
        log.info("Writing {} documents to vector store", documents.size());
        
        try {
            // 直接使用 VectorStore.write() 方法
            vectorStore.write(documents);
            log.info("Successfully wrote {} documents to vector store", documents.size());
        } catch (Exception e) {
            log.error("Failed to write documents to vector store", e);
            throw new RuntimeException("Vector store write failed", e);
        }
    }
    
    /**
     * 批次寫入文檔
     */
    public void writeBatchDocuments(List<Document> documents, int batchSize) {
        log.info("Writing {} documents in batches of {}", documents.size(), batchSize);
        
        for (int i = 0; i < documents.size(); i += batchSize) {
            int endIndex = Math.min(i + batchSize, documents.size());
            List<Document> batch = documents.subList(i, endIndex);
            
            try {
                vectorStore.write(batch);
                log.info("Wrote batch {}-{} of {} documents", i + 1, endIndex, documents.size());
            } catch (Exception e) {
                log.error("Failed to write batch {}-{}", i + 1, endIndex, e);
                throw new RuntimeException("Batch write failed", e);
            }
        }
    }
    
    /**
     * 使用搜尋引擎查詢文檔
     */
    public List<Document> searchSimilarDocuments(String query, int k) {
        log.info("Searching for {} similar documents with query: {}", k, query);
        
        try {
            SearchRequest searchRequest = SearchRequest.query(query).withTopK(k);
            return vectorStore.similaritySearch(searchRequest);
        } catch (Exception e) {
            log.error("Failed to search similar documents", e);
            return Collections.emptyList();
        }
    }
    
    /**
     * 使用閾值過濾的搜尋
     */
    public List<Document> searchWithThreshold(String query, int k, double threshold) {
        log.info("Searching with threshold {}: {}", threshold, query);
        
        try {
            SearchRequest searchRequest = SearchRequest.query(query)
                .withTopK(k)
                .withSimilarityThreshold(threshold);
            return vectorStore.similaritySearch(searchRequest);
        } catch (Exception e) {
            log.error("Failed to search with threshold", e);
            return Collections.emptyList();
        }
    }
    
}

/**
 * 文件寫入器範例
 */
@Component
@Slf4j
public class FileWriterService {
    
    /**
     * 將文檔寫入文件
     */
    public void writeDocumentsToFile(List<Document> documents, String filename) {
        log.info("Writing {} documents to file: {}", documents.size(), filename);
        
        FileDocumentWriter writer = new FileDocumentWriter(filename, true, MetadataMode.ALL, false);
        writer.write(documents);
        
        log.info("Successfully wrote documents to file: {}", filename);
    }
    
    /**
     * 附加文檔標記的文件寫入
     */
    public void writeDocumentsWithMarkers(List<Document> documents, String filename) {
        log.info("Writing {} documents with markers to file: {}", documents.size(), filename);
        
        FileDocumentWriter writer = new FileDocumentWriter(
            filename, 
            true,  // withDocumentMarkers
            MetadataMode.ALL, 
            true   // append
        );
        writer.write(documents);
    }
    
}

/**
 * 完整 ETL 管道範例
 */
@Component
@Slf4j
public class CompleteEtlPipeline {
    
    private final VectorStore vectorStore;
    private final ChatModel chatModel;
    
    public CompleteEtlPipeline(VectorStore vectorStore, ChatModel chatModel) {
        this.vectorStore = vectorStore;
        this.chatModel = chatModel;
    }
    
    /**
     * 完整的 ETL 流程
     */
    public void processDocumentsPipeline(List<Resource> resources) {
        log.info("Starting complete ETL pipeline with {} resources", resources.size());
        
        // Extract - 讀取文檔
        List<Document> documents = extractDocuments(resources);
        log.info("Extracted {} documents", documents.size());
        
        // Transform - 轉換文檔
        List<Document> transformedDocs = transformDocuments(documents);
        log.info("Transformed to {} document chunks", transformedDocs.size());
        
        // Load - 將文檔載入向量資料庫
        loadDocuments(transformedDocs);
        log.info("Loaded documents to vector store");
        
        log.info("ETL pipeline completed successfully");
    }
    
    private List<Document> extractDocuments(List<Resource> resources) {
        List<Document> allDocs = new ArrayList<>();
        
        for (Resource resource : resources) {
            DocumentReader reader = createReader(resource);
            List<Document> docs = reader.read();
            allDocs.addAll(docs);
        }
        
        return allDocs;
    }
    
    private DocumentReader createReader(Resource resource) {
        String filename = resource.getFilename();
        if (filename != null) {
            String lowerFilename = filename.toLowerCase();
            if (lowerFilename.endsWith(".pdf")) {
                return new PagePdfDocumentReader(resource);
            } else if (lowerFilename.matches(".*\\.(docx?|pptx?|xlsx?)$")) {
                return new TikaDocumentReader(resource);
            } else if (lowerFilename.endsWith(".txt")) {
                return new TextReader(resource);
            } else if (lowerFilename.endsWith(".md")) {
                return new MarkdownDocumentReader(resource);
            } else if (lowerFilename.endsWith(".json")) {
                return new JsonReader(resource);
            }
        }
        throw new IllegalArgumentException("Unsupported file type: " + filename);
    }
    
    private List<Document> transformDocuments(List<Document> documents) {
        // 1. 文本分割
        TokenTextSplitter splitter = new TokenTextSplitter();
        List<Document> splitDocs = splitter.transform(documents);
        
        // 2. 元資料增強
        KeywordMetadataEnricher enricher = new KeywordMetadataEnricher(chatModel, 5);
        return enricher.transform(splitDocs);
    }
    
    private void loadDocuments(List<Document> documents) {
        vectorStore.write(documents);
    }
}
```

---

## 📝 本章重點回顧

1. **ETL 基礎概念**：理解了 Extract、Transform、Load 的完整流程
2. **知識來源分類**：掌握了企業中各種資料來源的特點
3. **提取器架構**：設計了可擴展的資料提取器系統
4. **文檔提取實現**：完成了 PDF、Word 等文檔的提取器
5. **網頁和資料庫提取**：實現了網頁內容和 SQL 資料庫的提取

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **ETL 架構設計** | ⭐⭐⭐ | 高 | 系統基礎 |
| **文檔提取** | ⭐⭐⭐ | 中 | 核心功能 |
| **網頁提取** | ⭐⭐ | 中 | 資料豐富性 |
| **資料庫整合** | ⭐⭐⭐ | 中 | 企業整合 |
| **品質控制** | ⭐⭐ | 中 | 資料可靠性 |

### 最佳實踐建議

1. **模組化設計**：使用可插拔的提取器架構，便於擴展新的資料來源
2. **錯誤處理**：實現完善的錯誤處理和重試機制
3. **效能優化**：使用批次處理和並行處理提高提取效率
4. **資料品質**：建立資料驗證和清理機制
5. **監控告警**：實施完整的提取過程監控和告警

### 下一步學習方向

在下一章中，我們將學習 ETL 的中篇 - 擷取進階文件類型，包括：
- Excel 和 PowerPoint 文檔處理
- 圖像和多媒體內容提取
- 壓縮檔案和複合文檔處理
- 特殊格式文檔的處理技巧

---

**參考資料：**
- [Apache POI Documentation](https://poi.apache.org/)
- [Apache PDFBox Guide](https://pdfbox.apache.org/)
- [Jsoup HTML Parser](https://jsoup.org/)
- [Spring Data JDBC](https://spring.io/projects/spring-data-jdbc)


\newpage

## 7.4 ETL (中) - 擷取進階文件類型


> **本章重點**：深入探討進階文件類型的提取技術，掌握 Excel、PowerPoint、圖像、壓縮檔案等複雜格式的處理方法，建立完整的多媒體內容提取能力。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **處理 Excel 試算表**：提取表格資料、圖表和公式內容
- 🎯 **解析 PowerPoint 簡報**：提取投影片文字、圖片和註解
- 🎯 **處理圖像文件**：使用 OCR 技術提取圖像中的文字
- 🎯 **解壓縮檔案**：處理 ZIP、RAR 等壓縮格式的批次提取
- 🎯 **整合多媒體內容**：建立統一的多媒體內容處理管道

---

## 7.4.1 Excel 試算表提取器

### Excel 文件特點與挑戰

**Excel 文件的複雜性**：
- 📊 **多工作表結構**：一個文件可包含多個工作表
- 📈 **豐富的資料類型**：數值、文字、日期、公式、圖表
- 🎨 **格式化資訊**：字體、顏色、邊框、合併儲存格
- 📋 **元資料豐富**：作者、創建時間、註解、超連結

### Excel 提取器實現

Spring AI 使用 **TikaDocumentReader** 來處理 Excel 文件，這是推薦的方式：

#### 依賴配置

```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-tika-document-reader</artifactId>
</dependency>
```

#### 基本用法

```java
/**
 * Excel 文件讀取器
 */
@Component
@Slf4j
public class ExcelDocumentReader {
    
    /**
     * 讀取 Excel 文件
     */
    public List<Document> readExcelFile(Resource resource) {
        log.info("Reading Excel file: {}", resource.getFilename());
        
        try {
            TikaDocumentReader tikaReader = new TikaDocumentReader(resource);
            List<Document> documents = tikaReader.read();
            
            // 添加 Excel 特定的元資料
            documents.forEach(doc -> {
                doc.getMetadata().put("document_type", "EXCEL");
                doc.getMetadata().put("source_file", resource.getFilename());
                doc.getMetadata().put("extraction_method", "TIKA");
            });
            
            log.info("Successfully extracted {} documents from Excel file", documents.size());
            return documents;
            
        } catch (Exception e) {
            log.error("Failed to read Excel file: {}", resource.getFilename(), e);
            throw new RuntimeException("Excel 文件讀取失敗", e);
        }
    }
    
    /**
     * 批次處理多個 Excel 文件
     */
    public List<Document> readMultipleExcelFiles(List<Resource> resources) {
        List<Document> allDocuments = new ArrayList<>();
        
        for (Resource resource : resources) {
            try {
                List<Document> documents = readExcelFile(resource);
                allDocuments.addAll(documents);
            } catch (Exception e) {
                log.warn("Failed to process Excel file: {}", resource.getFilename(), e);
            }
        }
        
        return allDocuments;
    }
}

/**
 * ETL Pipeline 整合範例
 */
@Component
@Slf4j
public class ExcelETLProcessor {
    
    private final VectorStore vectorStore;
    private final TokenTextSplitter textSplitter;
    
    public ExcelETLProcessor(VectorStore vectorStore) {
        this.vectorStore = vectorStore;
        this.textSplitter = new TokenTextSplitter(500, 100, 5, 1000, true);
    }
    
    /**
     * 完整的 Excel ETL 流程
     */
    public void processExcelToVectorStore(Resource excelResource) {
        try {
            // 1. Extract: 讀取 Excel 文件
            TikaDocumentReader documentReader = new TikaDocumentReader(excelResource);
            List<Document> documents = documentReader.read();
            
            // 2. Transform: 文本分割和預處理
            List<Document> transformedDocuments = textSplitter.apply(documents);
            
            // 添加額外的元資料增強
            transformedDocuments.forEach(doc -> {
                doc.getMetadata().put("processing_timestamp", LocalDateTime.now().toString());
                doc.getMetadata().put("document_type", "EXCEL");
            });
            
            // 3. Load: 載入到向量資料庫
            vectorStore.write(transformedDocuments);
            
            log.info("成功處理 Excel 文件，共產生 {} 個文檔片段", transformedDocuments.size());
            
        } catch (Exception e) {
            log.error("Excel ETL 處理失敗", e);
            throw new RuntimeException("Excel ETL 處理失敗", e);
        }
    }
    
    /**
     * 批次處理多個 Excel 文件
     */
    public void processBatchExcelFiles(List<Resource> resources) {
        resources.parallelStream().forEach(resource -> {
            try {
                processExcelToVectorStore(resource);
            } catch (Exception e) {
                log.error("批次處理失敗: {}", resource.getFilename(), e);
            }
        });
    }
}
```

---

## 7.4.2 PowerPoint 簡報提取器

### PowerPoint 提取器實現

Spring AI 同樣使用 **TikaDocumentReader** 來處理 PowerPoint 文件：

```java
/**
 * PowerPoint 簡報讀取器
 */
@Component
@Slf4j
public class PowerPointDocumentReader {
    
    /**
     * 讀取 PowerPoint 文件
     */
    public List<Document> readPowerPointFile(Resource resource) {
        log.info("Reading PowerPoint file: {}", resource.getFilename());
        
        try {
            TikaDocumentReader tikaReader = new TikaDocumentReader(resource);
            List<Document> documents = tikaReader.read();
            
            // 添加 PowerPoint 特定的元資料
            documents.forEach(doc -> {
                doc.getMetadata().put("document_type", "POWERPOINT");
                doc.getMetadata().put("source_file", resource.getFilename());
                doc.getMetadata().put("extraction_method", "TIKA");
            });
            
            log.info("Successfully extracted {} documents from PowerPoint file", documents.size());
            return documents;
            
        } catch (Exception e) {
            log.error("Failed to read PowerPoint file: {}", resource.getFilename(), e);
            throw new RuntimeException("PowerPoint 文件讀取失敗", e);
        }
    }
}

/**
 * PowerPoint ETL Pipeline 整合範例
 */
@Component
@Slf4j
public class PowerPointETLProcessor {
    
    private final VectorStore vectorStore;
    private final TokenTextSplitter textSplitter;
    
    public PowerPointETLProcessor(VectorStore vectorStore) {
        this.vectorStore = vectorStore;
        this.textSplitter = new TokenTextSplitter(800, 200, 5, 1000, true);
    }
    
    /**
     * 完整的 PowerPoint ETL 流程
     */
    public void processPowerPointToVectorStore(Resource powerPointResource) {
        try {
            // 1. Extract: 讀取 PowerPoint 文件
            TikaDocumentReader documentReader = new TikaDocumentReader(powerPointResource);
            List<Document> documents = documentReader.read();
            
            // 2. Transform: 文本分割和預處理
            List<Document> transformedDocuments = textSplitter.apply(documents);
            
            // 添加額外的元資料增強
            transformedDocuments.forEach(doc -> {
                doc.getMetadata().put("processing_timestamp", LocalDateTime.now().toString());
                doc.getMetadata().put("document_type", "POWERPOINT");
            });
            
            // 3. Load: 載入到向量資料庫
            vectorStore.write(transformedDocuments);
            
            log.info("成功處理 PowerPoint 文件，共產生 {} 個文檔片段", transformedDocuments.size());
            
        } catch (Exception e) {
            log.error("PowerPoint ETL 處理失敗", e);
            throw new RuntimeException("PowerPoint ETL 處理失敗", e);
        }
    }
    
    /**
     * 批次處理多個簡報文件
     */
    public void processBatchPowerPointFiles(List<Resource> resources) {
        resources.parallelStream().forEach(resource -> {
            try {
                processPowerPointToVectorStore(resource);
            } catch (Exception e) {
                log.error("批次處理失敗: {}", resource.getFilename(), e);
            }
        });
    }
}
```

---

## 7.4.3 圖像文件 OCR 提取器

### OCR DocumentReader 實現

Spring AI 沒有內建的 OCR DocumentReader，但我們可以實現一個符合 Spring AI 架構的 OCR DocumentReader：

```java
/**
 * OCR 圖像文字提取器 (實現 Spring AI DocumentReader 接口)
 */
@Component
@Slf4j
public class ImageOCRDocumentReader implements DocumentReader {
    
    private final Resource resource;
    private final TesseractOCRService ocrService;
    
    public ImageOCRDocumentReader(Resource resource, TesseractOCRService ocrService) {
        this.resource = resource;
        this.ocrService = ocrService;
    }
    
    @Override
    public List<Document> read() {
        log.info("Extracting text from image: {}", resource.getFilename());
        
        try (InputStream inputStream = resource.getInputStream()) {
            
            // 讀取圖像
            BufferedImage image = ImageIO.read(inputStream);
            
            if (image != null) {
                // 圖像預處理
                BufferedImage processedImage = preprocessImage(image);
                
                // OCR 文字識別
                String extractedText = ocrService.extractText(processedImage);
                
                if (extractedText != null && !extractedText.trim().isEmpty()) {
                    Map<String, Object> metadata = createImageMetadata(image);
                    return List.of(new Document(extractedText.trim(), metadata));
                }
            }
            
            return List.of();
            
        } catch (Exception e) {
            log.error("Failed to extract text from image: {}", resource.getFilename(), e);
            throw new RuntimeException("OCR 文字提取失敗", e);
        }
    }
    
    /**
     * 圖像預處理
     */
    private BufferedImage preprocessImage(BufferedImage originalImage) {
        // 轉換為灰階
        BufferedImage grayImage = new BufferedImage(
            originalImage.getWidth(), 
            originalImage.getHeight(), 
            BufferedImage.TYPE_BYTE_GRAY
        );
        
        Graphics2D g2d = grayImage.createGraphics();
        g2d.drawImage(originalImage, 0, 0, null);
        g2d.dispose();
        
        // 增強對比度
        return enhanceContrast(grayImage);
    }
    
    /**
     * 增強對比度
     */
    private BufferedImage enhanceContrast(BufferedImage image) {
        RescaleOp rescaleOp = new RescaleOp(1.2f, 15, null);
        return rescaleOp.filter(image, null);
    }
    
    private Map<String, Object> createImageMetadata(BufferedImage image) {
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("document_type", "IMAGE_OCR");
        metadata.put("source_file", resource.getFilename());
        metadata.put("image_width", image.getWidth());
        metadata.put("image_height", image.getHeight());
        metadata.put("extraction_method", "TESSERACT_OCR");
        metadata.put("extraction_timestamp", LocalDateTime.now().toString());
        
        return metadata;
    }
}

/**
 * Tesseract OCR 服務
 */
@Service
@Slf4j
public class TesseractOCRService {
    
    private final Tesseract tesseract;
    
    public TesseractOCRService() {
        this.tesseract = new Tesseract();
        configureTesseract();
    }
    
    private void configureTesseract() {
        try {
            // 設定 Tesseract 資料路徑（根據作業系統調整）
            String os = System.getProperty("os.name").toLowerCase();
            if (os.contains("win")) {
                tesseract.setDatapath("C:\\Program Files\\Tesseract-OCR\\tessdata");
            } else {
                tesseract.setDatapath("/usr/share/tesseract-ocr/4.00/tessdata");
            }
            
            // 設定語言（支援繁體中文和英文）
            tesseract.setLanguage("chi_tra+eng");
            
            // 設定 OCR 引擎模式
            tesseract.setOcrEngineMode(1); // LSTM OCR Engine
            
            // 設定頁面分割模式
            tesseract.setPageSegMode(1); // Automatic page segmentation with OSD
            
        } catch (Exception e) {
            log.error("Failed to configure Tesseract", e);
        }
    }
    
    /**
     * 從圖像提取文字
     */
    public String extractText(BufferedImage image) {
        try {
            return tesseract.doOCR(image);
        } catch (Exception e) {
            log.error("OCR text extraction failed", e);
            return "";
        }
    }
}

/**
 * OCR ETL Pipeline 處理器
 */
@Component
@Slf4j
public class ImageOCRETLProcessor {
    
    private final VectorStore vectorStore;
    private final TesseractOCRService ocrService;
    private final TokenTextSplitter textSplitter;
    
    public ImageOCRETLProcessor(VectorStore vectorStore, TesseractOCRService ocrService) {
        this.vectorStore = vectorStore;
        this.ocrService = ocrService;
        this.textSplitter = new TokenTextSplitter(800, 200, 10, 1000, true);
    }
    
    /**
     * 完整的圖像 OCR ETL 流程
     */
    public void processImageOCRToVectorStore(Resource imageResource) {
        try {
            // 1. Extract: 使用 OCR 讀取圖像文字
            ImageOCRDocumentReader documentReader = new ImageOCRDocumentReader(imageResource, ocrService);
            List<Document> documents = documentReader.read();
            
            if (!documents.isEmpty()) {
                // 2. Transform: 文本分割（OCR 文字通常較短，可能不需要分割）
                List<Document> transformedDocuments = documents.stream()
                    .filter(doc -> doc.getContent().trim().length() > 10) // 過濾太短的文字
                    .collect(Collectors.toList());
                
                // 如果文字較長，進行分割
                if (transformedDocuments.stream().anyMatch(doc -> doc.getContent().length() > 500)) {
                    transformedDocuments = textSplitter.apply(transformedDocuments);
                }
                
                // 3. Load: 載入到向量資料庫
                vectorStore.write(transformedDocuments);
                
                log.info("成功處理圖像 OCR，共產生 {} 個文檔片段", transformedDocuments.size());
            } else {
                log.warn("圖像 {} 未提取到任何文字", imageResource.getFilename());
            }
            
        } catch (Exception e) {
            log.error("圖像 OCR ETL 處理失敗", e);
            throw new RuntimeException("圖像 OCR ETL 處理失敗", e);
        }
    }
    
    /**
     * 批次處理多個圖像文件
     */
    public void processBatchImageFiles(List<Resource> imageResources) {
        imageResources.parallelStream().forEach(resource -> {
            try {
                processImageOCRToVectorStore(resource);
            } catch (Exception e) {
                log.error("批次 OCR 處理失敗: {}", resource.getFilename(), e);
            }
        });
    }
}
```

---

## 7.4.4 壓縮檔案處理器

### 壓縮檔案 DocumentReader 實現

Spring AI 沒有內建的壓縮檔案處理器，但我們可以實現一個符合 Spring AI 架構的壓縮檔案處理器：

```java
/**
 * 壓縮檔案 DocumentReader (實現 Spring AI DocumentReader 接口)
 */
@Component
@Slf4j
public class ArchiveDocumentReader implements DocumentReader {
    
    private final Resource archiveResource;
    private final DocumentReaderFactory documentReaderFactory;
    
    public ArchiveDocumentReader(Resource archiveResource, DocumentReaderFactory documentReaderFactory) {
        this.archiveResource = archiveResource;
        this.documentReaderFactory = documentReaderFactory;
    }
    
    @Override
    public List<Document> read() {
        log.info("Extracting archive file: {}", archiveResource.getFilename());
        
        String fileName = archiveResource.getFilename().toLowerCase();
        
        try {
            if (fileName.endsWith(".zip")) {
                return extractZipFile();
            } else {
                log.warn("Unsupported archive format: {}", fileName);
                return List.of();
            }
        } catch (Exception e) {
            log.error("Failed to extract archive: {}", archiveResource.getFilename(), e);
            throw new RuntimeException("壓縮檔案處理失敗", e);
        }
    }
    
    /**
     * 提取 ZIP 檔案
     */
    private List<Document> extractZipFile() throws IOException {
        List<Document> documents = new ArrayList<>();
        
        try (InputStream inputStream = archiveResource.getInputStream();
             ZipInputStream zipInputStream = new ZipInputStream(inputStream)) {
            
            ZipEntry entry;
            while ((entry = zipInputStream.getNextEntry()) != null) {
                
                if (!entry.isDirectory() && isSupportedFileType(entry.getName())) {
                    try {
                        List<Document> entryDocuments = extractZipEntry(zipInputStream, entry);
                        documents.addAll(entryDocuments);
                    } catch (Exception e) {
                        log.warn("Failed to extract zip entry {}: {}", entry.getName(), e.getMessage());
                    }
                }
                
                zipInputStream.closeEntry();
            }
        }
        
        return documents;
    }
    
    /**
     * 提取 ZIP 條目
     */
    private List<Document> extractZipEntry(ZipInputStream zipInputStream, ZipEntry entry) throws IOException {
        String entryName = entry.getName();
        
        // 讀取條目內容到記憶體
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] buffer = new byte[8192];
        int bytesRead;
        
        while ((bytesRead = zipInputStream.read(buffer)) != -1) {
            baos.write(buffer, 0, bytesRead);
        }
        
        byte[] entryData = baos.toByteArray();
        
        // 建立記憶體資源
        Resource entryResource = new ByteArrayResource(entryData, entryName);
        
        try {
            // 根據文件類型選擇適當的 DocumentReader
            DocumentReader reader = documentReaderFactory.createReader(entryResource);
            List<Document> documents = reader.read();
            
            // 添加壓縮檔案相關的元資料
            documents.forEach(doc -> {
                doc.getMetadata().put("archive_source", archiveResource.getFilename());
                doc.getMetadata().put("archive_entry", entryName);
                doc.getMetadata().put("extraction_method", "ZIP_ARCHIVE");
            });
            
            return documents;
            
        } catch (Exception e) {
            log.warn("No suitable reader found for archive entry: {}", entryName);
            return List.of();
        }
    }
    
    /**
     * 檢查檔案類型是否支援
     */
    private boolean isSupportedFileType(String fileName) {
        String lowerFileName = fileName.toLowerCase();
        
        // 支援的檔案類型
        List<String> supportedTypes = Arrays.asList(
            ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
            ".txt", ".md", ".html", ".htm", ".xml", ".json"
        );
        
        return supportedTypes.stream().anyMatch(lowerFileName::endsWith);
    }
}

/**
 * DocumentReader 工廠
 */
@Component
@Slf4j
public class DocumentReaderFactory {
    
    /**
     * 根據資源類型創建對應的 DocumentReader
     */
    public DocumentReader createReader(Resource resource) {
        String filename = resource.getFilename();
        if (filename == null) {
            throw new IllegalArgumentException("無法判斷文件類型");
        }
        
        String lowerFilename = filename.toLowerCase();
        
        // 根據文件擴展名選擇合適的 DocumentReader
        if (lowerFilename.endsWith(".pdf")) {
            return new PagePdfDocumentReader(resource);
        } else if (lowerFilename.endsWith(".txt") || lowerFilename.endsWith(".md")) {
            return new TextReader(resource);
        } else if (lowerFilename.endsWith(".html") || lowerFilename.endsWith(".htm")) {
            return new JsoupDocumentReader(resource);
        } else if (lowerFilename.endsWith(".json")) {
            return new JsonReader(resource);
        } else if (isTikaSupported(lowerFilename)) {
            return new TikaDocumentReader(resource);
        } else {
            throw new UnsupportedOperationException("不支援的文件類型: " + filename);
        }
    }
    
    private boolean isTikaSupported(String filename) {
        List<String> tikaSupported = Arrays.asList(
            ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx"
        );
        return tikaSupported.stream().anyMatch(filename::endsWith);
    }
}

/**
 * 壓縮檔案 ETL Pipeline 處理器
 */
@Component
@Slf4j
public class ArchiveETLProcessor {
    
    private final VectorStore vectorStore;
    private final DocumentReaderFactory documentReaderFactory;
    private final TokenTextSplitter textSplitter;
    
    public ArchiveETLProcessor(VectorStore vectorStore, DocumentReaderFactory documentReaderFactory) {
        this.vectorStore = vectorStore;
        this.documentReaderFactory = documentReaderFactory;
        this.textSplitter = new TokenTextSplitter(800, 200, 5, 1000, true);
    }
    
    /**
     * 完整的壓縮檔案 ETL 流程
     */
    public void processArchiveToVectorStore(Resource archiveResource) {
        try {
            // 1. Extract: 解壓縮並讀取內部文件
            ArchiveDocumentReader archiveReader = new ArchiveDocumentReader(archiveResource, documentReaderFactory);
            List<Document> documents = archiveReader.read();
            
            if (!documents.isEmpty()) {
                // 2. Transform: 文本分割和預處理
                List<Document> transformedDocuments = textSplitter.apply(documents);
                
                // 3. Load: 載入到向量資料庫
                vectorStore.write(transformedDocuments);
                
                log.info("成功處理壓縮檔案 {}，共產生 {} 個文檔片段", 
                    archiveResource.getFilename(), transformedDocuments.size());
            } else {
                log.warn("壓縮檔案 {} 中沒有找到支援的文件", archiveResource.getFilename());
            }
            
        } catch (Exception e) {
            log.error("壓縮檔案 ETL 處理失敗", e);
            throw new RuntimeException("壓縮檔案 ETL 處理失敗", e);
        }
    }
}
```

---

## 📝 本章重點回顧

1. **Spring AI TikaDocumentReader**：使用 Spring AI 官方推薦的 TikaDocumentReader 處理 Excel 和 PowerPoint 文件
2. **DocumentReader 實現**：遵循 Spring AI ETL Pipeline 架構，實現符合標準的文件讀取器
3. **OCR 技術整合**：建立自定義 OCR DocumentReader，整合到 Spring AI 生態系統
4. **壓縮檔案處理**：實現遞迴文件提取，支援壓縮檔案內的多種文件格式
5. **ETL Pipeline 整合**：所有處理器都整合到完整的 Extract-Transform-Load 流程中

### 依賴配置

#### Maven 依賴

```xml
<dependencies>
    <!-- Spring AI Tika DocumentReader -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-tika-document-reader</artifactId>
    </dependency>
    
    <!-- Spring AI PDF DocumentReader -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-pdf-document-reader</artifactId>
    </dependency>
    
    <!-- Tesseract OCR (需要額外安裝 Tesseract 軟體) -->
    <dependency>
        <groupId>net.sourceforge.tess4j</groupId>
        <artifactId>tess4j</artifactId>
        <version>5.7.0</version>
    </dependency>
</dependencies>
```

### 技術要點總結

| 技術點 | Spring AI 支援 | 實現方式 | 企業價值 |
|--------|---------------|----------|----------|
| **Excel 處理** | ✅ TikaDocumentReader | 官方支援 | 商業資料提取 |
| **PowerPoint 提取** | ✅ TikaDocumentReader | 官方支援 | 簡報內容分析 |
| **OCR 技術** | ❌ 需自定義 | 自定義 DocumentReader | 圖像文字識別 |
| **壓縮檔案處理** | ❌ 需自定義 | 自定義 DocumentReader | 批次檔案處理 |
| **ETL Pipeline** | ✅ 完整支援 | 官方架構 | 系統可維護性 |

### 最佳實踐建議

1. **使用官方 DocumentReader**：優先使用 Spring AI 官方提供的 DocumentReader
2. **遵循 ETL 架構**：所有自定義實現都應遵循 Spring AI ETL Pipeline 模式
3. **錯誤處理**：實現完善的錯誤處理，避免單一檔案錯誤影響整體處理
4. **記憶體管理**：處理大型檔案時注意記憶體使用
5. **並行處理**：利用 Stream API 的並行處理能力提高效率

### 下一步學習方向

在下一章中，我們將學習 ETL 的下篇 - 給向量資料加上 Buff，包括：
- 使用 Spring AI 的 DocumentTransformer 進行資料清理
- TokenTextSplitter 文本分塊最佳化
- KeywordMetadataEnricher 和 SummaryMetadataEnricher 元資料增強
- 向量品質提升和效能調優

---

**參考資料：**
- [Spring AI ETL Pipeline Documentation](https://docs.spring.io/spring-ai/reference/1.1-SNAPSHOT/api/etl-pipeline.html)
- [Spring AI TikaDocumentReader](https://docs.spring.io/spring-ai/reference/1.1-SNAPSHOT/api/etl-pipeline.html#_tika_docx_pptx_html)
- [Tesseract OCR](https://github.com/tesseract-ocr/tesseract)
- [Apache Tika Supported Formats](https://tika.apache.org/3.1.0/formats.html)


\newpage

## 7.5 ETL (下) - 給向量資料加上 Buff


> **本章重點**：深入探討 ETL 流程中的資料轉換（Transform）技術，掌握文本清理、智能分塊、元資料增強和向量品質優化，讓 RAG 系統的知識庫更加強大和精準。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握文本清理技術**：實現智能的文本預處理和標準化
- 🎯 **優化文本分塊策略**：設計適合不同文檔類型的分塊算法
- 🎯 **增強元資料管理**：建立豐富的元資料標記和分類系統
- 🎯 **提升向量品質**：實現向量品質評估和優化機制
- 🎯 **建立完整 ETL 管道**：整合提取、轉換、載入的完整流程

---

## 7.5.1 智能文本清理與預處理

### 文本清理的重要性

**為什麼需要文本清理？**
- 📝 **提高向量品質**：清理後的文本生成更準確的向量表示
- 🎯 **增強檢索精度**：減少噪音提高相似性搜尋的準確性
- 💾 **節省存儲空間**：移除冗餘內容減少存儲需求
- ⚡ **提升處理效率**：標準化格式加快處理速度

### 文本清理服務實現

```java
/**
 * 智能文本清理服務
 */
@Service
@Slf4j
public class TextCleaningService {
    
    private static final Pattern EMAIL_PATTERN = 
        Pattern.compile("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}");
    
    private static final Pattern URL_PATTERN = 
        Pattern.compile("https?://[\\w\\-._~:/?#\\[\\]@!$&'()*+,;=%]+");
    
    private static final Pattern PHONE_PATTERN = 
        Pattern.compile("\\b\\d{2,4}[-\\s]?\\d{3,4}[-\\s]?\\d{3,4}\\b");
    
    /**
     * 綜合文本清理
     */
    public String cleanText(String rawText, TextCleaningConfig config) {
        if (rawText == null || rawText.trim().isEmpty()) {
            return "";
        }
        
        String cleanedText = rawText;
        
        // 1. 基礎清理
        if (config.isRemoveExtraWhitespace()) {
            cleanedText = removeExtraWhitespace(cleanedText);
        }
        
        // 2. 移除特殊字符
        if (config.isRemoveSpecialCharacters()) {
            cleanedText = removeSpecialCharacters(cleanedText);
        }
        
        // 3. 標準化換行符
        if (config.isNormalizeLineBreaks()) {
            cleanedText = normalizeLineBreaks(cleanedText);
        }
        
        // 4. 移除敏感資訊
        if (config.isRemoveSensitiveInfo()) {
            cleanedText = removeSensitiveInformation(cleanedText);
        }
        
        // 5. 語言特定清理
        if (config.getLanguage() != null) {
            cleanedText = applyLanguageSpecificCleaning(cleanedText, config.getLanguage());
        }
        
        // 6. 自定義清理規則
        if (config.getCustomRules() != null && !config.getCustomRules().isEmpty()) {
            cleanedText = applyCustomRules(cleanedText, config.getCustomRules());
        }
        
        return cleanedText.trim();
    }
    
    /**
     * 移除多餘空白字符
     */
    private String removeExtraWhitespace(String text) {
        return text
            .replaceAll("\\s+", " ")  // 多個空白字符合併為一個
            .replaceAll("\\n\\s*\\n", "\\n\\n")  // 多個空行合併為兩個
            .trim();
    }
    
    /**
     * 移除特殊字符
     */
    private String removeSpecialCharacters(String text) {
        // 保留基本標點符號，移除其他特殊字符
        return text.replaceAll("[^\\p{L}\\p{N}\\p{P}\\p{Z}\\r\\n]", "");
    }
    
    /**
     * 標準化換行符
     */
    private String normalizeLineBreaks(String text) {
        return text
            .replaceAll("\\r\\n", "\\n")  // Windows 換行符
            .replaceAll("\\r", "\\n");    // Mac 換行符
    }
    
    /**
     * 移除敏感資訊
     */
    private String removeSensitiveInformation(String text) {
        String result = text;
        
        // 移除電子郵件
        result = EMAIL_PATTERN.matcher(result).replaceAll("[EMAIL]");
        
        // 移除 URL
        result = URL_PATTERN.matcher(result).replaceAll("[URL]");
        
        // 移除電話號碼
        result = PHONE_PATTERN.matcher(result).replaceAll("[PHONE]");
        
        // 移除身分證號碼（台灣格式）
        result = result.replaceAll("\\b[A-Z]\\d{9}\\b", "[ID]");
        
        // 移除信用卡號碼
        result = result.replaceAll("\\b\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4}\\b", "[CARD]");
        
        return result;
    }
    
    /**
     * 語言特定清理
     */
    private String applyLanguageSpecificCleaning(String text, String language) {
        switch (language.toLowerCase()) {
            case "zh":
            case "zh-tw":
            case "zh-cn":
                return cleanChineseText(text);
            case "en":
                return cleanEnglishText(text);
            case "ja":
                return cleanJapaneseText(text);
            default:
                return text;
        }
    }
    
    /**
     * 中文文本清理
     */
    private String cleanChineseText(String text) {
        return text
            // 統一中文標點符號
            .replaceAll("，", "，")
            .replaceAll("。", "。")
            .replaceAll("！", "！")
            .replaceAll("？", "？")
            // 移除全形空格
            .replaceAll("　", " ")
            // 統一引號
            .replaceAll("[""]", "\"")
            .replaceAll("['']", "'");
    }
    
    /**
     * 英文文本清理
     */
    private String cleanEnglishText(String text) {
        return text
            // 統一引號
            .replaceAll("[""]", "\"")
            .replaceAll("['']", "'")
            // 移除多餘空格
            .replaceAll("\\s+", " ");
    }
    
    /**
     * 日文文本清理
     */
    private String cleanJapaneseText(String text) {
        return text
            // 統一日文標點符號
            .replaceAll("、", "、")
            .replaceAll("。", "。")
            // 移除全形空格
            .replaceAll("　", " ");
    }
    
    /**
     * 應用自定義清理規則
     */
    private String applyCustomRules(String text, List<TextCleaningRule> customRules) {
        String result = text;
        for (TextCleaningRule rule : customRules) {
            result = rule.apply(result);
        }
        return result;
    }
}
```

### 文本清理配置類

```java
/**
 * 文本清理配置
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class TextCleaningConfig {
    
    @Builder.Default
    private boolean removeExtraWhitespace = true;
    
    @Builder.Default
    private boolean removeSpecialCharacters = false;
    
    @Builder.Default
    private boolean normalizeLineBreaks = true;
    
    @Builder.Default
    private boolean removeSensitiveInfo = true;
    
    private String language;
    
    private List<TextCleaningRule> customRules;
}

/**
 * 自定義清理規則接口
 */
@FunctionalInterface
public interface TextCleaningRule {
    String apply(String text);
}
```

---

## 7.5.2 智能文本分塊策略

### 為什麼需要智能分塊？

**分塊的重要性**：
- 🎯 **適應模型限制**：符合 LLM 的 token 限制要求
- 📝 **保持語義完整**：避免在語義邊界中間分割
- 🔍 **提高檢索精度**：合適大小的塊提供更精確的相似性匹配
- ⚡ **優化處理效率**：平衡塊大小與處理速度

### Spring AI 標準文本分塊實現

```java
/**
 * 智能文本分塊服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class DocumentChunkingService {
    
    private final TextCleaningService textCleaningService;
    
    /**
     * 使用 Spring AI TokenTextSplitter 進行分塊
     */
    public List<Document> chunkDocuments(List<Document> documents, ChunkingConfig config) {
        log.info("Chunking {} documents with config: {}", documents.size(), config);
        
        // 1. 清理文本
        List<Document> cleanedDocuments = documents.stream()
            .map(doc -> cleanDocument(doc, config.getCleaningConfig()))
            .collect(Collectors.toList());
        
        // 2. 創建 TokenTextSplitter
        TokenTextSplitter splitter = createTokenTextSplitter(config);
        
        // 3. 執行分塊
        List<Document> chunkedDocuments = splitter.apply(cleanedDocuments);
        
        log.info("Successfully chunked into {} documents", chunkedDocuments.size());
        
        return chunkedDocuments;
    }
    
    /**
     * 創建 TokenTextSplitter 實例
     */
    private TokenTextSplitter createTokenTextSplitter(ChunkingConfig config) {
        return new TokenTextSplitter(
            config.getDefaultChunkSize(),
            config.getMinChunkSizeChars(),
            config.getMinChunkLengthToEmbed(),
            config.getMaxNumChunks(),
            config.isKeepSeparator()
        );
    }
    
    /**
     * 清理單個文檔
     */
    private Document cleanDocument(Document document, TextCleaningConfig cleaningConfig) {
        if (cleaningConfig == null) {
            return document;
        }
        
        String cleanedContent = textCleaningService.cleanText(
            document.getContent(), 
            cleaningConfig
        );
        
        // 創建新的文檔，保留原有元資料
        return Document.builder()
            .content(cleanedContent)
            .metadata(new HashMap<>(document.getMetadata()))
            .build();
    }
    
    /**
     * 自定義語義分塊（基於段落和句子）
     */
    public List<Document> semanticChunking(List<Document> documents, SemanticChunkingConfig config) {
        List<Document> result = new ArrayList<>();
        
        for (Document document : documents) {
            List<Document> documentChunks = semanticChunkDocument(document, config);
            result.addAll(documentChunks);
        }
        
        return result;
    }
    
    /**
     * 對單個文檔進行語義分塊
     */
    private List<Document> semanticChunkDocument(Document document, SemanticChunkingConfig config) {
        String content = document.getContent();
        List<Document> chunks = new ArrayList<>();
        
        // 1. 先按段落分割
        String[] paragraphs = content.split("\\n\\s*\\n");
        
        StringBuilder currentChunk = new StringBuilder();
        int currentTokenCount = 0;
        int chunkIndex = 0;
        
        for (String paragraph : paragraphs) {
            paragraph = paragraph.trim();
            if (paragraph.isEmpty()) {
                continue;
            }
            
            // 估算 token 數量（簡化計算）
            int paragraphTokens = estimateTokenCount(paragraph);
            
            // 如果加入此段落會超過限制，先創建一個塊
            if (currentTokenCount + paragraphTokens > config.getMaxTokensPerChunk() 
                && currentChunk.length() > 0) {
                
                Document chunk = createChunk(
                    document, 
                    currentChunk.toString(), 
                    chunkIndex++, 
                    config
                );
                chunks.add(chunk);
                
                currentChunk = new StringBuilder();
                currentTokenCount = 0;
            }
            
            // 加入段落
            if (currentChunk.length() > 0) {
                currentChunk.append("\\n\\n");
            }
            currentChunk.append(paragraph);
            currentTokenCount += paragraphTokens;
        }
        
        // 處理最後一個塊
        if (currentChunk.length() > 0) {
            Document chunk = createChunk(
                document, 
                currentChunk.toString(), 
                chunkIndex, 
                config
            );
            chunks.add(chunk);
        }
        
        return chunks;
    }
    
    /**
     * 創建文檔塊
     */
    private Document createChunk(Document originalDoc, String content, int chunkIndex, SemanticChunkingConfig config) {
        Map<String, Object> metadata = new HashMap<>(originalDoc.getMetadata());
        
        // 添加分塊元資料
        metadata.put("chunk_index", chunkIndex);
        metadata.put("chunk_method", "semantic");
        metadata.put("original_document_id", originalDoc.getId());
        metadata.put("chunk_token_count", estimateTokenCount(content));
        
        // 如果配置了重疊，添加重疊資訊
        if (config.getOverlapTokens() > 0) {
            metadata.put("overlap_tokens", config.getOverlapTokens());
        }
        
        return Document.builder()
            .content(content)
            .metadata(metadata)
            .build();
    }
    
    /**
     * 估算文本的 token 數量（簡化實現）
     */
    private int estimateTokenCount(String text) {
        // 簡化估算：平均每個字符約 0.25 tokens
        return (int) Math.ceil(text.length() * 0.25);
    }
}
```

### 分塊配置類

```java
/**
 * 分塊配置
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ChunkingConfig {
    
    /**
     * 默認塊大小（tokens）
     */
    @Builder.Default
    private int defaultChunkSize = 1000;
    
    /**
     * 最小塊大小（字符）
     */
    @Builder.Default
    private int minChunkSizeChars = 350;
    
    /**
     * 最小塊長度以進行嵌入
     */
    @Builder.Default
    private int minChunkLengthToEmbed = 10;
    
    /**
     * 最大塊數量
     */
    @Builder.Default
    private int maxNumChunks = 10000;
    
    /**
     * 是否保留分隔符
     */
    @Builder.Default
    private boolean keepSeparator = true;
    
    /**
     * 文本清理配置
     */
    private TextCleaningConfig cleaningConfig;
}

/**
 * 語義分塊配置
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class SemanticChunkingConfig {
    
    /**
     * 每個塊的最大 token 數
     */
    @Builder.Default
    private int maxTokensPerChunk = 1000;
    
    /**
     * 塊之間的重疊 token 數
     */
    @Builder.Default
    private int overlapTokens = 100;
    
    /**
     * 是否保持段落完整性
     */
    @Builder.Default
    private boolean preserveParagraphs = true;
    
    /**
     * 是否保持句子完整性
     */
    @Builder.Default
    private boolean preserveSentences = true;
}
```

---

## 7.5.3 元資料增強與管理

### 元資料的重要性

**為什麼需要豐富的元資料？**
- 🎯 **提高檢索精度**：基於元資料過濾和排序
- 📊 **支援分析統計**：追蹤文檔來源、類型、處理時間
- 🔍 **增強搜索功能**：多維度搜索和過濾
- 📝 **審計追蹤**：記錄數據處理歷程

### 元資料增強服務

```java
/**
 * 元資料增強服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class MetadataEnrichmentService {
    
    private final ChatModel chatModel;
    private final LanguageDetectionService languageDetector;
    
    /**
     * 使用 Spring AI KeywordMetadataEnricher 增強關鍵詞
     */
    public List<Document> enrichWithKeywords(List<Document> documents, int keywordCount) {
        KeywordMetadataEnricher enricher = new KeywordMetadataEnricher(chatModel, keywordCount);
        return enricher.apply(documents);
    }
    
    /**
     * 使用 Spring AI SummaryMetadataEnricher 增強摘要
     */
    public List<Document> enrichWithSummaries(List<Document> documents, List<SummaryType> summaryTypes) {
        SummaryMetadataEnricher enricher = new SummaryMetadataEnricher(chatModel, summaryTypes);
        return enricher.apply(documents);
    }
    
    /**
     * 綜合元資料增強
     */
    public List<Document> enrichMetadata(List<Document> documents, MetadataEnrichmentConfig config) {
        List<Document> enrichedDocuments = new ArrayList<>(documents);
        
        // 1. 基礎元資料增強
        if (config.isEnableBasicMetadata()) {
            enrichedDocuments = enrichBasicMetadata(enrichedDocuments);
        }
        
        // 2. 語言檢測
        if (config.isEnableLanguageDetection()) {
            enrichedDocuments = enrichLanguageMetadata(enrichedDocuments);
        }
        
        // 3. 內容統計
        if (config.isEnableContentStatistics()) {
            enrichedDocuments = enrichContentStatistics(enrichedDocuments);
        }
        
        // 4. 關鍵詞提取（使用 AI）
        if (config.isEnableKeywordExtraction() && config.getKeywordCount() > 0) {
            enrichedDocuments = enrichWithKeywords(enrichedDocuments, config.getKeywordCount());
        }
        
        // 5. 摘要生成（使用 AI）
        if (config.isEnableSummaryGeneration() && config.getSummaryTypes() != null) {
            enrichedDocuments = enrichWithSummaries(enrichedDocuments, config.getSummaryTypes());
        }
        
        // 6. 自定義分類
        if (config.isEnableCustomClassification()) {
            enrichedDocuments = enrichCustomClassification(enrichedDocuments, config);
        }
        
        return enrichedDocuments;
    }
    
    /**
     * 基礎元資料增強
     */
    private List<Document> enrichBasicMetadata(List<Document> documents) {
        return documents.stream()
            .map(this::enrichBasicMetadataForDocument)
            .collect(Collectors.toList());
    }
    
    private Document enrichBasicMetadataForDocument(Document document) {
        Map<String, Object> metadata = new HashMap<>(document.getMetadata());
        
        // 處理時間戳
        metadata.put("processed_at", LocalDateTime.now().toString());
        
        // 內容哈希（用於去重）
        metadata.put("content_hash", calculateContentHash(document.getContent()));
        
        // 文檔 ID（如果沒有）
        if (!metadata.containsKey("id")) {
            metadata.put("id", UUID.randomUUID().toString());
        }
        
        return Document.builder()
            .content(document.getContent())
            .metadata(metadata)
            .build();
    }
    
    /**
     * 語言檢測增強
     */
    private List<Document> enrichLanguageMetadata(List<Document> documents) {
        return documents.stream()
            .map(this::detectLanguageForDocument)
            .collect(Collectors.toList());
    }
    
    private Document detectLanguageForDocument(Document document) {
        LanguageDetectionResult detection = languageDetector.detectLanguage(document.getContent());
        
        Map<String, Object> metadata = new HashMap<>(document.getMetadata());
        metadata.put("detected_language", detection.getLanguage());
        metadata.put("language_confidence", detection.getConfidence());
        
        return Document.builder()
            .content(document.getContent())
            .metadata(metadata)
            .build();
    }
    
    /**
     * 內容統計增強
     */
    private List<Document> enrichContentStatistics(List<Document> documents) {
        return documents.stream()
            .map(this::calculateContentStatistics)
            .collect(Collectors.toList());
    }
    
    private Document calculateContentStatistics(Document document) {
        String content = document.getContent();
        
        Map<String, Object> metadata = new HashMap<>(document.getMetadata());
        
        // 基本統計
        metadata.put("character_count", content.length());
        metadata.put("word_count", countWords(content));
        metadata.put("sentence_count", countSentences(content));
        metadata.put("paragraph_count", countParagraphs(content));
        metadata.put("estimated_tokens", estimateTokenCount(content));
        
        // 內容特徵
        metadata.put("has_code_blocks", containsCodeBlocks(content));
        metadata.put("has_tables", containsTables(content));
        metadata.put("has_urls", containsUrls(content));
        metadata.put("has_emails", containsEmails(content));
        
        return Document.builder()
            .content(document.getContent())
            .metadata(metadata)
            .build();
    }
    
    /**
     * 自定義分類增強
     */
    private List<Document> enrichCustomClassification(List<Document> documents, MetadataEnrichmentConfig config) {
        return documents.stream()
            .map(doc -> classifyDocument(doc, config.getCustomClassifiers()))
            .collect(Collectors.toList());
    }
    
    private Document classifyDocument(Document document, List<DocumentClassifier> classifiers) {
        Map<String, Object> metadata = new HashMap<>(document.getMetadata());
        
        for (DocumentClassifier classifier : classifiers) {
            ClassificationResult result = classifier.classify(document.getContent());
            metadata.put(classifier.getMetadataKey(), result.getCategory());
            metadata.put(classifier.getMetadataKey() + "_confidence", result.getConfidence());
        }
        
        return Document.builder()
            .content(document.getContent())
            .metadata(metadata)
            .build();
    }
    
    // 輔助方法
    private String calculateContentHash(String content) {
        return DigestUtils.md5Hex(content);
    }
    
    private int countWords(String text) {
        return text.trim().isEmpty() ? 0 : text.trim().split("\\s+").length;
    }
    
    private int countSentences(String text) {
        return text.split("[.!?]+").length;
    }
    
    private int countParagraphs(String text) {
        return text.split("\\n\\s*\\n").length;
    }
    
    private int estimateTokenCount(String text) {
        return (int) Math.ceil(text.length() * 0.25);
    }
    
    private boolean containsCodeBlocks(String text) {
        return text.contains("```") || text.contains("    ") && text.contains("\\n");
    }
    
    private boolean containsTables(String text) {
        return text.contains("|") && text.contains("\\n");
    }
    
    private boolean containsUrls(String text) {
        return text.matches(".*https?://.*");
    }
    
    private boolean containsEmails(String text) {
        return text.matches(".*[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}.*");
    }
}
```

---

## 7.5.4 完整的 ETL 管道實現

### ETL 管道服務

```java
/**
 * 完整的 ETL 管道服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class EtlPipelineService {
    
    private final DocumentChunkingService chunkingService;
    private final MetadataEnrichmentService metadataEnrichmentService;
    private final VectorStore vectorStore;
    private final MeterRegistry meterRegistry;
    
    /**
     * 執行完整的 ETL 管道
     */
    public EtlPipelineResult executeEtlPipeline(EtlPipelineConfig config) {
        Timer.Sample sample = Timer.start(meterRegistry);
        EtlPipelineResult result = new EtlPipelineResult();
        
        try {
            // 1. Extract - 提取文檔
            List<Document> extractedDocuments = extractDocuments(config.getDataSources());
            result.setExtractedCount(extractedDocuments.size());
            log.info("Extracted {} documents", extractedDocuments.size());
            
            // 2. Transform - 轉換處理
            List<Document> transformedDocuments = transformDocuments(extractedDocuments, config);
            result.setTransformedCount(transformedDocuments.size());
            log.info("Transformed into {} documents", transformedDocuments.size());
            
            // 3. Load - 載入向量資料庫
            loadDocuments(transformedDocuments, config.getLoadConfig());
            result.setLoadedCount(transformedDocuments.size());
            log.info("Loaded {} documents to vector store", transformedDocuments.size());
            
            result.setSuccess(true);
            result.setProcessingTime(sample.stop(Timer.builder("etl.pipeline.time")
                .description("ETL pipeline execution time")
                .register(meterRegistry)));
            
            meterRegistry.counter("etl.pipeline.success").increment();
            
        } catch (Exception e) {
            log.error("ETL pipeline execution failed", e);
            result.setSuccess(false);
            result.setErrorMessage(e.getMessage());
            meterRegistry.counter("etl.pipeline.errors").increment();
            throw new EtlPipelineException("ETL pipeline execution failed", e);
        }
        
        return result;
    }
    
    /**
     * 提取文檔（Extract 階段）
     */
    private List<Document> extractDocuments(List<DataSource> dataSources) {
        List<Document> allDocuments = new ArrayList<>();
        
        for (DataSource dataSource : dataSources) {
            DocumentReader reader = createDocumentReader(dataSource);
            List<Document> documents = reader.read();
            
            // 添加數據源元資料
            documents = documents.stream()
                .map(doc -> addDataSourceMetadata(doc, dataSource))
                .collect(Collectors.toList());
            
            allDocuments.addAll(documents);
        }
        
        return allDocuments;
    }
    
    /**
     * 轉換文檔（Transform 階段）
     */
    private List<Document> transformDocuments(List<Document> documents, EtlPipelineConfig config) {
        List<Document> transformedDocuments = documents;
        
        // 1. 元資料增強
        if (config.getMetadataEnrichmentConfig() != null) {
            transformedDocuments = metadataEnrichmentService.enrichMetadata(
                transformedDocuments, 
                config.getMetadataEnrichmentConfig()
            );
        }
        
        // 2. 文檔分塊
        if (config.getChunkingConfig() != null) {
            transformedDocuments = chunkingService.chunkDocuments(
                transformedDocuments, 
                config.getChunkingConfig()
            );
        }
        
        // 3. 內容格式化
        if (config.getContentFormatConfig() != null) {
            ContentFormatTransformer formatter = new ContentFormatTransformer(
                config.getContentFormatConfig().getMetadataMode()
            );
            transformedDocuments = formatter.apply(transformedDocuments);
        }
        
        // 4. 過濾和驗證
        transformedDocuments = filterAndValidateDocuments(transformedDocuments, config.getFilterConfig());
        
        return transformedDocuments;
    }
    
    /**
     * 載入文檔（Load 階段）
     */
    private void loadDocuments(List<Document> documents, LoadConfig loadConfig) {
        if (loadConfig.getBatchSize() <= 1) {
            // 單個載入
            vectorStore.accept(documents);
        } else {
            // 批次載入
            List<List<Document>> batches = partitionList(documents, loadConfig.getBatchSize());
            
            for (List<Document> batch : batches) {
                try {
                    vectorStore.accept(batch);
                    
                    if (loadConfig.getBatchDelayMs() > 0) {
                        Thread.sleep(loadConfig.getBatchDelayMs());
                    }
                    
                } catch (Exception e) {
                    log.error("Failed to load batch of {} documents", batch.size(), e);
                    if (!loadConfig.isContinueOnError()) {
                        throw e;
                    }
                }
            }
        }
    }
    
    // 輔助方法
    private DocumentReader createDocumentReader(DataSource dataSource) {
        return switch (dataSource.getType()) {
            case PDF -> new PagePdfDocumentReader(dataSource.getResource());
            case TEXT -> new TextReader(dataSource.getResource());
            case JSON -> new JsonReader(dataSource.getResource());
            case MARKDOWN -> new MarkdownDocumentReader(dataSource.getResource());
            case HTML -> new JsoupDocumentReader(dataSource.getResource());
            default -> throw new IllegalArgumentException("Unsupported data source type: " + dataSource.getType());
        };
    }
    
    private Document addDataSourceMetadata(Document document, DataSource dataSource) {
        Map<String, Object> metadata = new HashMap<>(document.getMetadata());
        metadata.put("data_source_type", dataSource.getType().name());
        metadata.put("data_source_name", dataSource.getName());
        metadata.put("data_source_path", dataSource.getPath());
        
        return Document.builder()
            .content(document.getContent())
            .metadata(metadata)
            .build();
    }
    
    private List<Document> filterAndValidateDocuments(List<Document> documents, FilterConfig filterConfig) {
        if (filterConfig == null) {
            return documents;
        }
        
        return documents.stream()
            .filter(doc -> doc.getContent() != null && !doc.getContent().trim().isEmpty())
            .filter(doc -> doc.getContent().length() >= filterConfig.getMinContentLength())
            .filter(doc -> doc.getContent().length() <= filterConfig.getMaxContentLength())
            .collect(Collectors.toList());
    }
    
    private <T> List<List<T>> partitionList(List<T> list, int batchSize) {
        List<List<T>> partitions = new ArrayList<>();
        for (int i = 0; i < list.size(); i += batchSize) {
            partitions.add(list.subList(i, Math.min(i + batchSize, list.size())));
        }
        return partitions;
    }
}
```

---

## 📝 本章重點回顧

1. **智能文本清理**：實現了多語言支援的文本預處理和標準化
2. **Spring AI 分塊策略**：使用官方 TokenTextSplitter 和自定義語義分塊
3. **元資料增強**：整合 KeywordMetadataEnricher 和 SummaryMetadataEnricher
4. **完整 ETL 管道**：建立了符合 Spring AI 標準的 Extract-Transform-Load 流程
5. **品質保證機制**：添加了監控、錯誤處理和批次處理功能

### 技術要點總結

| 技術點 | Spring AI 官方支援 | 實現難度 | 企業價值 |
|--------|-------------------|----------|----------|
| **TokenTextSplitter** | ⭐⭐⭐ | 中 | 標準化分塊 |
| **KeywordMetadataEnricher** | ⭐⭐⭐ | 中 | AI 關鍵詞提取 |
| **SummaryMetadataEnricher** | ⭐⭐⭐ | 中 | AI 摘要生成 |
| **DocumentReader** | ⭐⭐⭐ | 低 | 多格式支援 |
| **VectorStore 整合** | ⭐⭐⭐ | 低 | 無縫載入 |

### 最佳實踐建議

1. **遵循 Spring AI 標準**：使用官方提供的 DocumentTransformer 實現
2. **合理配置分塊**：根據模型 token 限制調整塊大小
3. **豐富元資料**：充分利用 AI 模型進行關鍵詞和摘要提取
4. **批次處理優化**：根據向量資料庫特性調整批次大小
5. **監控與錯誤處理**：建立完善的 ETL 管道監控機制

### 下一步學習方向

在下一章中，我們將深入學習向量資料庫的選擇與配置，包括：
- 不同向量資料庫的比較和選擇
- Spring AI 向量資料庫整合
- 向量檢索優化策略
- 混合檢索實現

---

**參考資料：**
- [Spring AI ETL Pipeline](https://docs.spring.io/spring-ai/reference/api/etl-pipeline.html)
- [Spring AI Document Transformers](https://docs.spring.io/spring-ai/reference/api/etl-pipeline.html#transformers)
- [TokenTextSplitter Documentation](https://docs.spring.io/spring-ai/reference/api/etl-pipeline.html#_tokentextsplitter)
- [Metadata Enrichers](https://docs.spring.io/spring-ai/reference/api/etl-pipeline.html#_keywordmetadataenricher)


\newpage

## 7.6 企業 RAG 真正的資料來源


> **本章重點**：深入探討企業級 RAG 系統的資料來源整合策略，掌握即時資料同步、多資料源管理、資料安全和權限控制，建立真正適合企業使用的 RAG 知識庫。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **設計企業資料架構**：建立可擴展的多資料源整合架構
- 🎯 **實現即時資料同步**：掌握資料變更檢測和增量同步技術
- 🎯 **管理資料安全權限**：實現細粒度的資料存取控制
- 🎯 **優化資料管道效能**：建立高效的資料處理和同步機制
- 🎯 **監控資料品質**：實現完整的資料品質監控和告警系統

---

## 7.6.1 企業資料來源架構設計

### 企業資料來源的複雜性

**企業環境中的資料挑戰**：
- 🏢 **多系統分散**：資料分散在不同的業務系統中
- 🔄 **即時性要求**：業務資料需要即時或近即時同步
- 🔒 **安全性要求**：嚴格的資料存取權限和安全控制
- 📊 **資料異質性**：不同格式、結構和品質的資料
- ⚡ **高可用性需求**：7x24 小時不間斷服務要求

### 企業資料架構設計

```
┌─────────────────────────────────────────────────────────────┐
│              Enterprise Data Architecture                    │
├─────────────────────────────────────────────────────────────┤
│  Application Layer                                          │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              RAG Application Services                   │ │
│  │  ┌─────────────────────────────────────────────────┐   │ │
│  │  │  • Query Processing                             │   │ │
│  │  │  • Response Generation                          │   │ │
│  │  │  • User Interface                               │   │ │
│  │  └─────────────────────────────────────────────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Data Access Layer                                          │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Unified Data Access API                   │ │
│  │  ┌─────────────────────────────────────────────────┐   │ │
│  │  │  • Authentication & Authorization               │   │ │
│  │  │  • Data Virtualization                          │   │ │
│  │  │  • Caching & Performance                        │   │ │
│  │  └─────────────────────────────────────────────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Data Processing Layer                                      │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Real-time Data Pipeline                   │ │
│  │  ┌─────────────────────────────────────────────────┐   │ │
│  │  │  • Change Data Capture (CDC)                   │   │ │
│  │  │  • Stream Processing                            │   │ │
│  │  │  • ETL Orchestration                            │   │ │
│  │  │  • Data Quality Monitoring                      │   │ │
│  │  └─────────────────────────────────────────────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Data Storage Layer                                         │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Hybrid Storage Architecture                │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐      │ │
│  │  │Vector Store │ │Search Engine│ │Data Lake    │      │ │
│  │  │• Embeddings │ │• Full-text  │ │• Raw Data   │      │ │
│  │  │• Similarity │ │• Faceted    │ │• Archives   │      │ │
│  │  └─────────────┘ └─────────────┘ └─────────────┘      │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Data Sources Layer                                         │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │Enterprise   │ │Cloud        │ │External     │          │
│  │Systems      │ │Services     │ │APIs         │          │
│  │• ERP        │ │• SaaS       │ │• Partners   │          │
│  │• CRM        │ │• Cloud DB   │ │• Public     │          │
│  │• Legacy     │ │• Object     │ │• Vendors    │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

### 資料來源管理服務

```java
/**
 * 企業資料來源管理服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class EnterpriseDataSourceManager {
    
    private final Map<String, DataSourceConnector> connectors;
    private final DataSourceRegistry dataSourceRegistry;
    private final SecurityManager securityManager;
    private final MetricsCollector metricsCollector;
    
    /**
     * 註冊資料來源
     */
    public void registerDataSource(DataSourceConfig config) {
        log.info("Registering data source: {}", config.getName());
        
        try {
            // 1. 驗證配置
            validateDataSourceConfig(config);
            
            // 2. 安全檢查
            securityManager.validateDataSourceAccess(config);
            
            // 3. 建立連接器
            DataSourceConnector connector = createConnector(config);
            
            // 4. 測試連接
            testConnection(connector);
            
            // 5. 註冊到系統
            dataSourceRegistry.register(config.getName(), config);
            connectors.put(config.getName(), connector);
            
            log.info("Successfully registered data source: {}", config.getName());
            
        } catch (Exception e) {
            log.error("Failed to register data source: {}", config.getName(), e);
            throw new DataSourceRegistrationException("Registration failed", e);
        }
    }
    
    /**
     * 取得資料來源連接器
     */
    public DataSourceConnector getConnector(String dataSourceName) {
        DataSourceConnector connector = connectors.get(dataSourceName);
        if (connector == null) {
            throw new DataSourceNotFoundException("Data source not found: " + dataSourceName);
        }
        
        // 檢查連接狀態
        if (!connector.isHealthy()) {
            log.warn("Data source {} is unhealthy, attempting reconnection", dataSourceName);
            reconnectDataSource(dataSourceName);
        }
        
        return connector;
    }
    
    /**
     * 建立連接器
     */
    private DataSourceConnector createConnector(DataSourceConfig config) {
        DataSourceType type = config.getType();
        
        return switch (type) {
            case RELATIONAL_DATABASE -> new JdbcDataSourceConnector(config);
            case NOSQL_DATABASE -> new NoSqlDataSourceConnector(config);
            case REST_API -> new RestApiDataSourceConnector(config);
            case FILE_SYSTEM -> new FileSystemDataSourceConnector(config);
            case MESSAGE_QUEUE -> new MessageQueueDataSourceConnector(config);
            case CLOUD_STORAGE -> new CloudStorageDataSourceConnector(config);
            default -> throw new UnsupportedDataSourceException("Unsupported type: " + type);
        };
    }
    
    /**
     * 測試連接
     */
    private void testConnection(DataSourceConnector connector) {
        try {
            ConnectionTestResult result = connector.testConnection();
            if (!result.isSuccessful()) {
                throw new DataSourceConnectionException(
                    "Connection test failed: " + result.getErrorMessage());
            }
        } catch (Exception e) {
            throw new DataSourceConnectionException("Connection test failed", e);
        }
    }
    
    /**
     * 重新連接資料來源
     */
    private void reconnectDataSource(String dataSourceName) {
        try {
            DataSourceConfig config = dataSourceRegistry.getConfig(dataSourceName);
            DataSourceConnector newConnector = createConnector(config);
            testConnection(newConnector);
            
            // 替換舊連接器
            DataSourceConnector oldConnector = connectors.put(dataSourceName, newConnector);
            if (oldConnector != null) {
                oldConnector.close();
            }
            
            log.info("Successfully reconnected data source: {}", dataSourceName);
            
        } catch (Exception e) {
            log.error("Failed to reconnect data source: {}", dataSourceName, e);
            metricsCollector.recordConnectionFailure(dataSourceName);
        }
    }
    
    /**
     * 驗證資料來源配置
     */
    private void validateDataSourceConfig(DataSourceConfig config) {
        if (config.getName() == null || config.getName().trim().isEmpty()) {
            throw new IllegalArgumentException("Data source name cannot be empty");
        }
        
        if (config.getType() == null) {
            throw new IllegalArgumentException("Data source type must be specified");
        }
        
        if (config.getConnectionString() == null || config.getConnectionString().trim().isEmpty()) {
            throw new IllegalArgumentException("Connection string cannot be empty");
        }
        
        // 檢查是否已存在
        if (dataSourceRegistry.exists(config.getName())) {
            throw new DataSourceAlreadyExistsException(
                "Data source already exists: " + config.getName());
        }
    }
    
    /**
     * 取得所有資料來源狀態
     */
    public List<DataSourceStatus> getAllDataSourceStatus() {
        return connectors.entrySet().stream()
            .map(entry -> {
                String name = entry.getKey();
                DataSourceConnector connector = entry.getValue();
                
                return DataSourceStatus.builder()
                    .name(name)
                    .type(connector.getType())
                    .healthy(connector.isHealthy())
                    .lastChecked(LocalDateTime.now())
                    .connectionCount(connector.getActiveConnectionCount())
                    .build();
            })
            .collect(Collectors.toList());
    }
    
    /**
     * 關閉所有連接
     */
    @PreDestroy
    public void shutdown() {
        log.info("Shutting down data source manager");
        
        connectors.values().parallelStream().forEach(connector -> {
            try {
                connector.close();
            } catch (Exception e) {
                log.warn("Error closing connector", e);
            }
        });
        
        connectors.clear();
    }
}

/**
 * 資料來源配置
 */
@Data
@Builder
public class DataSourceConfig {
    private String name;
    private DataSourceType type;
    private String connectionString;
    private Map<String, String> properties;
    private SecurityConfig security;
    private SyncConfig sync;
    private RetryConfig retry;
    
    @Data
    @Builder
    public static class SecurityConfig {
        private String username;
        private String password;
        private String certificatePath;
        private boolean sslEnabled;
        private List<String> allowedRoles;
    }
    
    @Data
    @Builder
    public static class SyncConfig {
        private boolean enabled;
        private Duration interval;
        private SyncMode mode;
        private String changeDetectionColumn;
    }
    
    @Data
    @Builder
    public static class RetryConfig {
        private int maxAttempts;
        private Duration initialDelay;
        private Duration maxDelay;
        private double backoffMultiplier;
    }
}

enum DataSourceType {
    RELATIONAL_DATABASE,
    NOSQL_DATABASE,
    REST_API,
    FILE_SYSTEM,
    MESSAGE_QUEUE,
    CLOUD_STORAGE
}

enum SyncMode {
    FULL_SYNC,
    INCREMENTAL_SYNC,
    REAL_TIME_SYNC
}
```

---

## 7.6.2 即時資料同步機制

### Change Data Capture (CDC) 實現

```java
/**
 * 變更資料捕獲服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class ChangeDataCaptureService {
    
    private final Map<String, CDCConnector> cdcConnectors;
    private final DataSyncOrchestrator syncOrchestrator;
    private final EventPublisher eventPublisher;
    
    /**
     * 啟動 CDC 監控
     */
    public void startCDCMonitoring(String dataSourceName, CDCConfig config) {
        log.info("Starting CDC monitoring for data source: {}", dataSourceName);
        
        try {
            CDCConnector connector = createCDCConnector(config);
            
            // 設定變更事件處理器
            connector.setChangeEventHandler(event -> handleChangeEvent(dataSourceName, event));
            
            // 啟動監控
            connector.start();
            
            cdcConnectors.put(dataSourceName, connector);
            
            log.info("CDC monitoring started for: {}", dataSourceName);
            
        } catch (Exception e) {
            log.error("Failed to start CDC monitoring for: {}", dataSourceName, e);
            throw new CDCException("CDC startup failed", e);
        }
    }
    
    /**
     * 處理變更事件
     */
    private void handleChangeEvent(String dataSourceName, ChangeEvent event) {
        try {
            log.debug("Processing change event: {} for data source: {}", 
                event.getType(), dataSourceName);
            
            // 1. 驗證事件
            validateChangeEvent(event);
            
            // 2. 轉換為同步任務
            SyncTask syncTask = createSyncTask(dataSourceName, event);
            
            // 3. 提交同步任務
            syncOrchestrator.submitTask(syncTask);
            
            // 4. 發布事件通知
            eventPublisher.publishEvent(new DataChangeDetectedEvent(dataSourceName, event));
            
        } catch (Exception e) {
            log.error("Failed to handle change event for: {}", dataSourceName, e);
            // 記錄失敗事件，稍後重試
            recordFailedEvent(dataSourceName, event, e);
        }
    }
    
    /**
     * 建立 CDC 連接器
     */
    private CDCConnector createCDCConnector(CDCConfig config) {
        return switch (config.getType()) {
            case DATABASE_LOG -> new DatabaseLogCDCConnector(config);
            case TRIGGER_BASED -> new TriggerBasedCDCConnector(config);
            case TIMESTAMP_BASED -> new TimestampBasedCDCConnector(config);
            case KAFKA_CONNECT -> new KafkaConnectCDCConnector(config);
            default -> throw new UnsupportedOperationException(
                "Unsupported CDC type: " + config.getType());
        };
    }
    
    /**
     * 建立同步任務
     */
    private SyncTask createSyncTask(String dataSourceName, ChangeEvent event) {
        return SyncTask.builder()
            .dataSourceName(dataSourceName)
            .operation(mapToSyncOperation(event.getType()))
            .entityId(event.getEntityId())
            .entityType(event.getEntityType())
            .changeData(event.getData())
            .timestamp(event.getTimestamp())
            .priority(determinePriority(event))
            .build();
    }
    
    private SyncOperation mapToSyncOperation(ChangeEventType eventType) {
        return switch (eventType) {
            case INSERT -> SyncOperation.CREATE;
            case UPDATE -> SyncOperation.UPDATE;
            case DELETE -> SyncOperation.DELETE;
        };
    }
    
    private TaskPriority determinePriority(ChangeEvent event) {
        // 根據實體類型和變更類型決定優先級
        if (event.getEntityType().equals("critical_data")) {
            return TaskPriority.HIGH;
        } else if (event.getType() == ChangeEventType.DELETE) {
            return TaskPriority.MEDIUM;
        } else {
            return TaskPriority.LOW;
        }
    }
}

/**
 * 資料同步協調器
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class DataSyncOrchestrator {
    
    private final TaskExecutor taskExecutor;
    private final SyncTaskQueue taskQueue;
    private final DataProcessor dataProcessor;
    private final ConflictResolver conflictResolver;
    
    /**
     * 提交同步任務
     */
    public void submitTask(SyncTask task) {
        try {
            // 1. 任務驗證
            validateSyncTask(task);
            
            // 2. 衝突檢測
            if (hasConflict(task)) {
                task = conflictResolver.resolve(task);
            }
            
            // 3. 加入任務佇列
            taskQueue.enqueue(task);
            
            log.debug("Sync task submitted: {}", task.getId());
            
        } catch (Exception e) {
            log.error("Failed to submit sync task", e);
            throw new SyncTaskException("Task submission failed", e);
        }
    }
    
    /**
     * 處理同步任務
     */
    @Async
    public CompletableFuture<Void> processSyncTask(SyncTask task) {
        return CompletableFuture.runAsync(() -> {
            try {
                log.debug("Processing sync task: {}", task.getId());
                
                // 1. 取得原始資料
                Object sourceData = fetchSourceData(task);
                
                // 2. 資料處理和轉換
                ProcessedData processedData = dataProcessor.process(sourceData, task);
                
                // 3. 更新目標系統
                updateTargetSystem(processedData, task);
                
                // 4. 記錄成功
                recordTaskSuccess(task);
                
                log.debug("Sync task completed: {}", task.getId());
                
            } catch (Exception e) {
                log.error("Sync task failed: {}", task.getId(), e);
                recordTaskFailure(task, e);
                
                // 根據重試策略決定是否重試
                if (shouldRetry(task)) {
                    scheduleRetry(task);
                }
            }
        }, taskExecutor);
    }
    
    /**
     * 批次同步處理
     */
    public void processBatchSync(String dataSourceName, BatchSyncConfig config) {
        log.info("Starting batch sync for data source: {}", dataSourceName);
        
        try {
            // 1. 取得資料範圍
            DataRange dataRange = determineDataRange(dataSourceName, config);
            
            // 2. 分批處理
            List<DataBatch> batches = createDataBatches(dataRange, config.getBatchSize());
            
            // 3. 並行處理批次
            List<CompletableFuture<Void>> futures = batches.stream()
                .map(batch -> processBatch(dataSourceName, batch))
                .collect(Collectors.toList());
            
            // 4. 等待所有批次完成
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
            
            log.info("Batch sync completed for: {}", dataSourceName);
            
        } catch (Exception e) {
            log.error("Batch sync failed for: {}", dataSourceName, e);
            throw new BatchSyncException("Batch sync failed", e);
        }
    }
    
    private CompletableFuture<Void> processBatch(String dataSourceName, DataBatch batch) {
        return CompletableFuture.runAsync(() -> {
            try {
                // 處理批次中的每個項目
                for (DataItem item : batch.getItems()) {
                    SyncTask task = SyncTask.builder()
                        .dataSourceName(dataSourceName)
                        .operation(SyncOperation.UPDATE)
                        .entityId(item.getId())
                        .entityType(item.getType())
                        .changeData(item.getData())
                        .timestamp(LocalDateTime.now())
                        .priority(TaskPriority.MEDIUM)
                        .build();
                    
                    processSyncTask(task).join();
                }
                
            } catch (Exception e) {
                log.error("Batch processing failed", e);
                throw new RuntimeException(e);
            }
        }, taskExecutor);
    }
}

/**
 * 同步任務
 */
@Data
@Builder
public class SyncTask {
    private String id;
    private String dataSourceName;
    private SyncOperation operation;
    private String entityId;
    private String entityType;
    private Object changeData;
    private LocalDateTime timestamp;
    private TaskPriority priority;
    private int retryCount;
    private LocalDateTime nextRetryTime;
    
    @PostConstruct
    private void generateId() {
        if (id == null) {
            id = UUID.randomUUID().toString();
        }
    }
}

enum SyncOperation {
    CREATE, UPDATE, DELETE
}

enum TaskPriority {
    HIGH, MEDIUM, LOW
}

enum ChangeEventType {
    INSERT, UPDATE, DELETE
}
```

---

## 7.6.3 資料安全與權限控制

### 細粒度權限控制系統

```java
/**
 * 資料安全管理服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class DataSecurityService {
    
    private final PermissionRepository permissionRepository;
    private final RoleRepository roleRepository;
    private final AuditLogger auditLogger;
    private final EncryptionService encryptionService;
    
    /**
     * 檢查資料存取權限
     */
    public boolean hasDataAccess(String userId, String dataSourceName, 
                                String entityType, AccessType accessType) {
        try {
            // 1. 取得使用者角色
            List<String> userRoles = getUserRoles(userId);
            
            // 2. 檢查角色權限
            for (String role : userRoles) {
                if (hasRolePermission(role, dataSourceName, entityType, accessType)) {
                    auditLogger.logAccessGranted(userId, dataSourceName, entityType, accessType);
                    return true;
                }
            }
            
            // 3. 檢查直接權限
            if (hasDirectPermission(userId, dataSourceName, entityType, accessType)) {
                auditLogger.logAccessGranted(userId, dataSourceName, entityType, accessType);
                return true;
            }
            
            auditLogger.logAccessDenied(userId, dataSourceName, entityType, accessType);
            return false;
            
        } catch (Exception e) {
            log.error("Error checking data access permission", e);
            auditLogger.logAccessError(userId, dataSourceName, entityType, accessType, e);
            return false; // 預設拒絕存取
        }
    }
    
    /**
     * 資料脫敏處理
     */
    public Object maskSensitiveData(Object data, String userId, DataMaskingPolicy policy) {
        if (data == null || policy == null) {
            return data;
        }
        
        try {
            // 1. 檢查是否需要脫敏
            if (!needsDataMasking(userId, policy)) {
                return data;
            }
            
            // 2. 根據策略進行脫敏
            Object maskedData = applyDataMasking(data, policy);
            
            // 3. 記錄脫敏操作
            auditLogger.logDataMasking(userId, policy.getPolicyName());
            
            return maskedData;
            
        } catch (Exception e) {
            log.error("Error applying data masking", e);
            // 發生錯誤時，返回完全脫敏的資料
            return applyFullMasking(data);
        }
    }
    
    /**
     * 資料加密
     */
    public String encryptSensitiveField(String plainText, EncryptionPolicy policy) {
        try {
            return switch (policy.getAlgorithm()) {
                case AES_256 -> encryptionService.encryptAES256(plainText, policy.getKey());
                case RSA_2048 -> encryptionService.encryptRSA2048(plainText, policy.getPublicKey());
                case HASH_SHA256 -> encryptionService.hashSHA256(plainText, policy.getSalt());
                default -> throw new UnsupportedEncryptionException(
                    "Unsupported encryption algorithm: " + policy.getAlgorithm());
            };
        } catch (Exception e) {
            log.error("Encryption failed", e);
            throw new EncryptionException("Failed to encrypt sensitive field", e);
        }
    }
    
    /**
     * 建立資料存取上下文
     */
    public DataAccessContext createAccessContext(String userId, String sessionId) {
        try {
            // 1. 取得使用者資訊
            UserInfo userInfo = getUserInfo(userId);
            
            // 2. 取得使用者權限
            List<Permission> permissions = getUserPermissions(userId);
            
            // 3. 建立存取上下文
            return DataAccessContext.builder()
                .userId(userId)
                .sessionId(sessionId)
                .userInfo(userInfo)
                .permissions(permissions)
                .createdAt(LocalDateTime.now())
                .expiresAt(LocalDateTime.now().plusHours(8)) // 8小時有效期
                .build();
                
        } catch (Exception e) {
            log.error("Failed to create access context for user: {}", userId, e);
            throw new SecurityException("Access context creation failed", e);
        }
    }
    
    /**
     * 驗證資料存取上下文
     */
    public boolean validateAccessContext(DataAccessContext context) {
        if (context == null) {
            return false;
        }
        
        // 1. 檢查是否過期
        if (context.getExpiresAt().isBefore(LocalDateTime.now())) {
            log.warn("Access context expired for user: {}", context.getUserId());
            return false;
        }
        
        // 2. 檢查會話有效性
        if (!isValidSession(context.getSessionId())) {
            log.warn("Invalid session for user: {}", context.getUserId());
            return false;
        }
        
        // 3. 檢查使用者狀態
        if (!isUserActive(context.getUserId())) {
            log.warn("User is not active: {}", context.getUserId());
            return false;
        }
        
        return true;
    }
    
    private List<String> getUserRoles(String userId) {
        return roleRepository.findRolesByUserId(userId);
    }
    
    private boolean hasRolePermission(String role, String dataSource, 
                                    String entityType, AccessType accessType) {
        return permissionRepository.hasRolePermission(role, dataSource, entityType, accessType);
    }
    
    private boolean hasDirectPermission(String userId, String dataSource, 
                                      String entityType, AccessType accessType) {
        return permissionRepository.hasUserPermission(userId, dataSource, entityType, accessType);
    }
    
    private boolean needsDataMasking(String userId, DataMaskingPolicy policy) {
        // 檢查使用者是否有查看敏感資料的權限
        return !hasDataAccess(userId, policy.getDataSource(), 
                            policy.getEntityType(), AccessType.VIEW_SENSITIVE);
    }
    
    private Object applyDataMasking(Object data, DataMaskingPolicy policy) {
        // 根據脫敏策略處理資料
        return switch (policy.getMaskingType()) {
            case PARTIAL_MASK -> applyPartialMasking(data, policy);
            case FULL_MASK -> applyFullMasking(data);
            case HASH_MASK -> applyHashMasking(data, policy);
            case TOKENIZE -> applyTokenization(data, policy);
        };
    }
    
    private Object applyPartialMasking(Object data, DataMaskingPolicy policy) {
        // 部分脫敏實現
        if (data instanceof String str) {
            int visibleChars = policy.getVisibleCharacters();
            if (str.length() <= visibleChars * 2) {
                return "*".repeat(str.length());
            }
            return str.substring(0, visibleChars) + 
                   "*".repeat(str.length() - visibleChars * 2) + 
                   str.substring(str.length() - visibleChars);
        }
        return data;
    }
    
    private Object applyFullMasking(Object data) {
        // 完全脫敏實現
        if (data instanceof String str) {
            return "*".repeat(str.length());
        } else if (data instanceof Number) {
            return 0;
        }
        return "[MASKED]";
    }
    
    private Object applyHashMasking(Object data, DataMaskingPolicy policy) {
        // 雜湊脫敏實現
        if (data instanceof String str) {
            return encryptionService.hashSHA256(str, policy.getSalt());
        }
        return data;
    }
    
    private Object applyTokenization(Object data, DataMaskingPolicy policy) {
        // 代幣化實現
        if (data instanceof String str) {
            return "TOKEN_" + UUID.randomUUID().toString().substring(0, 8);
        }
        return data;
    }
}

/**
 * 資料存取上下文
 */
@Data
@Builder
public class DataAccessContext {
    private String userId;
    private String sessionId;
    private UserInfo userInfo;
    private List<Permission> permissions;
    private LocalDateTime createdAt;
    private LocalDateTime expiresAt;
}

/**
 * 權限定義
 */
@Data
@Builder
public class Permission {
    private String id;
    private String dataSource;
    private String entityType;
    private AccessType accessType;
    private List<String> conditions;
}

enum AccessType {
    READ, WRITE, DELETE, VIEW_SENSITIVE, EXPORT
}

/**
 * 資料脫敏策略
 */
@Data
@Builder
public class DataMaskingPolicy {
    private String policyName;
    private String dataSource;
    private String entityType;
    private MaskingType maskingType;
    private int visibleCharacters;
    private String salt;
}

enum MaskingType {
    PARTIAL_MASK, FULL_MASK, HASH_MASK, TOKENIZE
}
```

---

## 📝 本章重點回顧

1. **企業資料架構**：設計了可擴展的多資料源整合架構
2. **即時資料同步**：實現了 CDC 和批次同步機制
3. **資料安全控制**：建立了細粒度的權限控制和資料脫敏
4. **效能優化**：實現了高效的資料處理和同步機制
5. **監控告警**：建立了完整的資料品質監控體系

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **多資料源整合** | ⭐⭐⭐ | 高 | 系統整合 |
| **即時資料同步** | ⭐⭐⭐ | 高 | 資料時效性 |
| **安全權限控制** | ⭐⭐⭐ | 高 | 資料安全 |
| **效能優化** | ⭐⭐ | 中 | 系統效能 |
| **監控告警** | ⭐⭐ | 中 | 運維管理 |

### 最佳實踐建議

1. **分層架構**：採用分層架構設計，確保系統的可維護性和擴展性
2. **安全優先**：將資料安全作為首要考量，實施多層次的安全控制
3. **效能監控**：建立完整的效能監控和告警機制
4. **漸進式同步**：採用漸進式的資料同步策略，避免系統過載
5. **容錯設計**：實現完善的容錯和恢復機制

### 下一步學習方向

在下一章中，我們將學習 RAG 的最後一哩路，包括：
- 系統部署和運維
- 效能調校和優化
- 監控和告警系統
- 故障排除和恢復

---

### 💡 與 Spring AI 的整合

本章討論的企業級資料管理功能可以與 Spring AI 完美配合：

```java
/**
 * 整合 Spring AI 的企業 RAG 服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class EnterpriseRagService {
    
    private final VectorStore vectorStore;
    private final EnterpriseDataSourceManager dataSourceManager;
    private final DataSyncOrchestrator syncOrchestrator;
    private final DataSecurityService securityService;
    
    /**
     * 安全的文檔查詢服務
     */
    public List<Document> secureSearch(String userId, String query, int topK) {
        // 1. 驗證使用者權限
        DataAccessContext accessContext = securityService.createAccessContext(userId, null);
        if (!securityService.validateAccessContext(accessContext)) {
            throw new SecurityException("Access denied");
        }
        
        // 2. 執行向量搜尋
        SearchRequest searchRequest = SearchRequest.builder()
            .query(query)
            .topK(topK)
            .build();
        List<Document> results = vectorStore.similaritySearch(searchRequest);
        
        // 3. 應用資料脫敏
        return results.stream()
            .map(doc -> securityService.maskSensitiveData(doc, userId, getDataMaskingPolicy(doc)))
            .map(Document.class::cast)
            .collect(Collectors.toList());
    }
    
    /**
     * 即時更新向量資料庫
     */
    @EventListener
    public void handleDataChangeEvent(DataChangeDetectedEvent event) {
        try {
            // 1. 獲取更新的資料
            Object updatedData = dataSourceManager.getConnector(event.getDataSourceName())
                .fetchData(event.getEntityId());
            
            // 2. 轉換為 Document
            Document document = convertToDocument(updatedData, event);
            
            // 3. 更新向量資料庫
            if (event.getChangeEvent().getType() == ChangeEventType.DELETE) {
                vectorStore.delete(List.of(document.getId()));
            } else {
                vectorStore.add(List.of(document));
            }
            
            log.info("Vector store updated for entity: {}", event.getEntityId());
            
        } catch (Exception e) {
            log.error("Failed to update vector store", e);
        }
    }
    
    private Document convertToDocument(Object data, DataChangeDetectedEvent event) {
        // 將企業資料轉換為 Spring AI Document
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("data_source", event.getDataSourceName());
        metadata.put("entity_type", event.getChangeEvent().getEntityType());
        metadata.put("last_updated", LocalDateTime.now().toString());
        
        return new Document(data.toString(), metadata);
    }
    
    private DataMaskingPolicy getDataMaskingPolicy(Document document) {
        // 根據文檔類型返回相應的脫敏策略
        String entityType = (String) document.getMetadata().get("entity_type");
        return DataMaskingPolicy.builder()
            .policyName("default_policy")
            .entityType(entityType)
            .maskingType(MaskingType.PARTIAL_MASK)
            .visibleCharacters(3)
            .build();
    }
}
```

**參考資料：**
- [Spring AI Documentation](https://docs.spring.io/spring-ai/reference/)
- [Spring AI Vector Databases](https://docs.spring.io/spring-ai/reference/api/vectordbs.html)
- [Apache Kafka Connect](https://kafka.apache.org/documentation/#connect)
- [Debezium CDC](https://debezium.io/)
- [Spring Security](https://spring.io/projects/spring-security)
- [Enterprise Integration Patterns](https://www.enterpriseintegrationpatterns.com/)


\newpage

## 7.7 RAG 的最後一哩路


> **本章重點**：完成 RAG 系統的最後部署和優化工作，掌握系統部署運維、效能調校、監控告警和故障排除，確保 RAG 系統在生產環境中穩定高效運行。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **部署生產級 RAG 系統**：掌握容器化部署和雲端部署策略
- 🎯 **優化系統效能**：實現查詢優化、快取策略和資源調校
- 🎯 **建立監控告警**：實現全方位的系統監控和智能告警
- 🎯 **處理故障恢復**：掌握故障診斷、快速恢復和災難備援
- 🎯 **持續改進優化**：建立效能分析和系統優化的持續改進機制

---

## 7.7.1 生產級部署策略

### 容器化部署架構

**Docker 容器化部署**：

```dockerfile
# RAG Application Dockerfile
FROM openjdk:21-jdk-slim

# 設定工作目錄
WORKDIR /app

# 複製應用程式
COPY target/rag-application.jar app.jar
COPY config/ config/
COPY scripts/ scripts/

# 安裝必要工具
RUN apt-get update && apt-get install -y \
    curl \
    jq \
    && rm -rf /var/lib/apt/lists/*

# 建立非 root 使用者
RUN groupadd -r raguser && useradd -r -g raguser raguser
RUN chown -R raguser:raguser /app
USER raguser

# 健康檢查
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# 暴露端口
EXPOSE 8080

# 啟動應用程式
ENTRYPOINT ["java", "-jar", "-Dspring.profiles.active=prod", "app.jar"]
```

### Docker Compose 編排

```yaml
# docker-compose.yml
version: '3.8'

services:
  # RAG 應用服務
  rag-app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/ragdb
      - SPRING_AI_VECTORSTORE_NEO4J_URI=bolt://neo4j:7687
      - SPRING_AI_VECTORSTORE_NEO4J_USERNAME=neo4j
      - SPRING_AI_VECTORSTORE_NEO4J_PASSWORD=${NEO4J_PASSWORD}
      - SPRING_AI_OPENAI_API_KEY=${OPENAI_API_KEY}
      - SPRING_AI_OPENAI_CHAT_MODEL=gpt-4o
      - SPRING_AI_OPENAI_EMBEDDING_MODEL=text-embedding-3-large
    depends_on:
      - postgres
      - neo4j
      - redis
    volumes:
      - ./logs:/app/logs
      - ./data:/app/data
    networks:
      - rag-network
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '1.0'
          memory: 2G

  # PostgreSQL 資料庫
  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=ragdb
      - POSTGRES_USER=raguser
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    networks:
      - rag-network
    restart: unless-stopped

  # Neo4j 向量資料庫
  neo4j:
    image: neo4j:5.15-community
    environment:
      - NEO4J_AUTH=neo4j/${NEO4J_PASSWORD}
      - NEO4J_PLUGINS=["apoc"]
      - NEO4J_dbms_security_procedures_unrestricted=apoc.*
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs
    ports:
      - "7474:7474"
      - "7687:7687"
    networks:
      - rag-network
    restart: unless-stopped

  # Redis 快取
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - rag-network
    restart: unless-stopped

  # Nginx 反向代理
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - rag-app
    networks:
      - rag-network
    restart: unless-stopped

  # Prometheus 監控
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    networks:
      - rag-network
    restart: unless-stopped

  # Grafana 視覺化
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards
      - ./grafana/datasources:/etc/grafana/provisioning/datasources
    networks:
      - rag-network
    restart: unless-stopped

volumes:
  postgres_data:
  neo4j_data:
  neo4j_logs:
  redis_data:
  prometheus_data:
  grafana_data:

networks:
  rag-network:
    driver: bridge
```

### Kubernetes 部署配置

```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rag-application
  namespace: rag-system
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rag-application
  template:
    metadata:
      labels:
        app: rag-application
    spec:
      containers:
      - name: rag-app
        image: rag-application:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "k8s"
        - name: SPRING_DATASOURCE_URL
          valueFrom:
            secretKeyRef:
              name: rag-secrets
              key: database-url
        - name: SPRING_AI_OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: rag-secrets
              key: openai-api-key
        resources:
          requests:
            memory: "2Gi"
            cpu: "1000m"
          limits:
            memory: "4Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
        - name: logs-volume
          mountPath: /app/logs
      volumes:
      - name: config-volume
        configMap:
          name: rag-config
      - name: logs-volume
        persistentVolumeClaim:
          claimName: rag-logs-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: rag-service
  namespace: rag-system
spec:
  selector:
    app: rag-application
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: LoadBalancer
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: rag-ingress
  namespace: rag-system
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - rag.example.com
    secretName: rag-tls
  rules:
  - host: rag.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: rag-service
            port:
              number: 80
```

---

## 7.7.2 系統效能優化

### Spring AI 相關依賴配置

首先需要確保項目中包含正確的 Spring AI 依賴：

```xml
<dependencies>
    <!-- Spring AI Core -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- OpenAI Chat Model -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Neo4j Vector Store -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-neo4j-store-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Spring Boot Actuator for monitoring -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    
    <!-- Micrometer for metrics -->
    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-registry-prometheus</artifactId>
    </dependency>
</dependencies>
```

### 查詢效能優化服務

```java
import org.springframework.ai.document.Document;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.ai.vectorstore.SearchRequest;
import org.springframework.ai.vectorstore.filter.Filter;
import org.springframework.stereotype.Service;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * RAG 查詢效能優化服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class QueryOptimizationService {
    
    private final VectorStore vectorStore;
    private final CacheManager cacheManager;
    private final QueryAnalyzer queryAnalyzer;
    private final PerformanceMetrics performanceMetrics;
    
    /**
     * 優化查詢執行
     */
    public QueryResult optimizeQuery(QueryRequest request) {
        long startTime = System.currentTimeMillis();
        
        try {
            // 1. 查詢分析和預處理
            OptimizedQuery optimizedQuery = analyzeAndOptimizeQuery(request);
            
            // 2. 快取檢查
            QueryResult cachedResult = checkCache(optimizedQuery);
            if (cachedResult != null) {
                performanceMetrics.recordCacheHit(request.getQueryId());
                return cachedResult;
            }
            
            // 3. 執行優化查詢
            QueryResult result = executeOptimizedQuery(optimizedQuery);
            
            // 4. 結果快取
            cacheResult(optimizedQuery, result);
            
            // 5. 記錄效能指標
            long executionTime = System.currentTimeMillis() - startTime;
            performanceMetrics.recordQueryExecution(request.getQueryId(), executionTime);
            
            return result;
            
        } catch (Exception e) {
            log.error("Query optimization failed for: {}", request.getQueryId(), e);
            performanceMetrics.recordQueryError(request.getQueryId());
            throw new QueryOptimizationException("Query optimization failed", e);
        }
    }
    
    /**
     * 分析和優化查詢
     */
    private OptimizedQuery analyzeAndOptimizeQuery(QueryRequest request) {
        QueryAnalysisResult analysis = queryAnalyzer.analyze(request);
        
        return OptimizedQuery.builder()
            .originalQuery(request.getQuery())
            .optimizedQuery(optimizeQueryText(request.getQuery(), analysis))
            .searchStrategy(determineSearchStrategy(analysis))
            .filterExpression(optimizeFilters(request.getFilters(), analysis))
            .resultLimit(optimizeResultLimit(request.getLimit(), analysis))
            .similarityThreshold(optimizeSimilarityThreshold(analysis))
            .build();
    }
    
    /**
     * 優化查詢文本
     */
    private String optimizeQueryText(String originalQuery, QueryAnalysisResult analysis) {
        String optimized = originalQuery;
        
        // 1. 移除停用詞
        if (analysis.hasStopWords()) {
            optimized = removeStopWords(optimized, analysis.getLanguage());
        }
        
        // 2. 詞幹提取
        if (analysis.needsStemming()) {
            optimized = applyStemming(optimized, analysis.getLanguage());
        }
        
        // 3. 同義詞擴展
        if (analysis.canExpandSynonyms()) {
            optimized = expandSynonyms(optimized);
        }
        
        // 4. 查詢重寫
        if (analysis.needsRewriting()) {
            optimized = rewriteQuery(optimized, analysis);
        }
        
        return optimized;
    }
    
    /**
     * 決定搜尋策略
     */
    private SearchStrategy determineSearchStrategy(QueryAnalysisResult analysis) {
        if (analysis.getQueryComplexity() == QueryComplexity.HIGH) {
            return SearchStrategy.HYBRID_SEARCH;
        } else if (analysis.hasKeywords()) {
            return SearchStrategy.KEYWORD_SEARCH;
        } else {
            return SearchStrategy.SEMANTIC_SEARCH;
        }
    }
    
    /**
     * 執行優化查詢
     */
    private QueryResult executeOptimizedQuery(OptimizedQuery query) {
        return switch (query.getSearchStrategy()) {
            case SEMANTIC_SEARCH -> executeSemanticSearch(query);
            case KEYWORD_SEARCH -> executeKeywordSearch(query);
            case HYBRID_SEARCH -> executeHybridSearch(query);
        };
    }
    
    /**
     * 執行語義搜尋
     */
    private QueryResult executeSemanticSearch(OptimizedQuery query) {
        // 使用 Spring AI VectorStore 進行向量相似性搜尋
        SearchRequest searchRequest = SearchRequest.builder()
            .query(query.getOptimizedQuery())
            .topK(query.getResultLimit())
            .similarityThreshold(query.getSimilarityThreshold())
            .filterExpression(query.getFilterExpression())
            .build();
            
        List<Document> documents = vectorStore.similaritySearch(searchRequest);
        
        return QueryResult.builder()
            .documents(documents)
            .searchStrategy(SearchStrategy.SEMANTIC_SEARCH)
            .executionTimeMs(System.currentTimeMillis())
            .build();
    }
    
    /**
     * 執行混合搜尋
     */
    private QueryResult executeHybridSearch(OptimizedQuery query) {
        // 並行執行語義搜尋和關鍵字搜尋
        CompletableFuture<List<Document>> semanticFuture = CompletableFuture
            .supplyAsync(() -> executeSemanticSearch(query).getDocuments());
        
        CompletableFuture<List<Document>> keywordFuture = CompletableFuture
            .supplyAsync(() -> executeKeywordSearch(query).getDocuments());
        
        try {
            List<Document> semanticResults = semanticFuture.get(5, TimeUnit.SECONDS);
            List<Document> keywordResults = keywordFuture.get(5, TimeUnit.SECONDS);
            
            // 結果融合和重新排序
            List<Document> mergedResults = mergeAndRerankResults(
                semanticResults, keywordResults, query);
            
            return QueryResult.builder()
                .documents(mergedResults)
                .searchStrategy(SearchStrategy.HYBRID_SEARCH)
                .executionTimeMs(System.currentTimeMillis())
                .build();
                
        } catch (Exception e) {
            log.warn("Hybrid search failed, falling back to semantic search", e);
            return executeSemanticSearch(query);
        }
    }
    
    /**
     * 結果融合和重新排序
     */
    private List<Document> mergeAndRerankResults(List<Document> semanticResults,
                                               List<Document> keywordResults,
                                               OptimizedQuery query) {
        
        Map<String, Document> documentMap = new HashMap<>();
        Map<String, Double> scoreMap = new HashMap<>();
        
        // 語義搜尋結果權重
        double semanticWeight = 0.7;
        for (int i = 0; i < semanticResults.size(); i++) {
            Document doc = semanticResults.get(i);
            String docId = doc.getId();
            double score = semanticWeight * (1.0 - (double) i / semanticResults.size());
            
            documentMap.put(docId, doc);
            scoreMap.put(docId, score);
        }
        
        // 關鍵字搜尋結果權重
        double keywordWeight = 0.3;
        for (int i = 0; i < keywordResults.size(); i++) {
            Document doc = keywordResults.get(i);
            String docId = doc.getId();
            double score = keywordWeight * (1.0 - (double) i / keywordResults.size());
            
            if (scoreMap.containsKey(docId)) {
                scoreMap.put(docId, scoreMap.get(docId) + score);
            } else {
                documentMap.put(docId, doc);
                scoreMap.put(docId, score);
            }
        }
        
        // 按分數排序
        return scoreMap.entrySet().stream()
            .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
            .limit(query.getResultLimit())
            .map(entry -> documentMap.get(entry.getKey()))
            .collect(Collectors.toList());
    }
    
    /**
     * 執行關鍵字搜尋
     */
    private QueryResult executeKeywordSearch(OptimizedQuery query) {
        // 對於關鍵字搜尋，可以使用較低的相似度閾值
        SearchRequest searchRequest = SearchRequest.builder()
            .query(query.getOptimizedQuery())
            .topK(query.getResultLimit())
            .similarityThreshold(0.6) // 關鍵字搜尋使用較低閾值
            .filterExpression(query.getFilterExpression())
            .build();
            
        List<Document> documents = vectorStore.similaritySearch(searchRequest);
        
        return QueryResult.builder()
            .documents(documents)
            .searchStrategy(SearchStrategy.KEYWORD_SEARCH)
            .executionTimeMs(System.currentTimeMillis())
            .build();
    }
    
    // 查詢分析和處理輔助方法
    private String removeStopWords(String text, String language) {
        // 實現停用詞移除邏輯，這裡簡化處理
        return text;
    }
    
    private String applyStemming(String text, String language) {
        // 實現詞幹提取邏輯，這裡簡化處理
        return text;
    }
    
    private String expandSynonyms(String text) {
        // 實現同義詞擴展邏輯，這裡簡化處理
        return text;
    }
    
    private String rewriteQuery(String text, QueryAnalysisResult analysis) {
        // 實現查詢重寫邏輯，這裡簡化處理
        return text;
    }
    
    /**
     * 優化過濾條件
     */
    private Filter.Expression optimizeFilters(Map<String, Object> filters, QueryAnalysisResult analysis) {
        if (filters == null || filters.isEmpty()) {
            return null;
        }
        
        // 使用 Spring AI Filter API 構建過濾表達式
        // 注意：實際的 Filter.ExpressionBuilder 可能有不同的 API
        // 這裡提供一個示例結構
        try {
            List<Filter.Expression> expressions = new ArrayList<>();
            
            filters.forEach((key, value) -> {
                if (value instanceof String) {
                    expressions.add(Filter.Expression.eq(key, value));
                } else if (value instanceof List<?> list) {
                    expressions.add(Filter.Expression.in(key, list));
                }
            });
            
            if (expressions.isEmpty()) {
                return null;
            }
            
            // 如果有多個條件，使用 AND 連接
            Filter.Expression result = expressions.get(0);
            for (int i = 1; i < expressions.size(); i++) {
                result = Filter.Expression.and(result, expressions.get(i));
            }
            
            return result;
        } catch (Exception e) {
            log.warn("Failed to build filter expression", e);
            return null;
        }
    }
    
    private int optimizeResultLimit(Integer limit, QueryAnalysisResult analysis) {
        if (limit == null) {
            return SearchRequest.DEFAULT_TOP_K;
        }
        
        // 根據查詢複雜度調整結果數量
        return switch (analysis.getQueryComplexity()) {
            case HIGH -> Math.min(limit, 20);
            case MEDIUM -> Math.min(limit, 10);
            case LOW -> Math.min(limit, 5);
        };
    }
    
    private double optimizeSimilarityThreshold(QueryAnalysisResult analysis) {
        // 根據查詢特性調整相似度閾值
        return switch (analysis.getQueryComplexity()) {
            case HIGH -> 0.75;
            case MEDIUM -> 0.7;
            case LOW -> 0.65;
        };
    }
}

/**
 * 查詢優化相關資料模型
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
class OptimizedQuery {
    private String originalQuery;
    private String optimizedQuery;
    private SearchStrategy searchStrategy;
    private Filter.Expression filterExpression;
    private int resultLimit;
    private double similarityThreshold;
}

@Data
@Builder
@NoArgsConstructor 
@AllArgsConstructor
class QueryRequest {
    private String queryId;
    private String query;
    private Map<String, Object> filters;
    private Integer limit;
}

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
class QueryResult {
    private List<Document> documents;
    private SearchStrategy searchStrategy;
    private long executionTimeMs;
}

enum SearchStrategy {
    SEMANTIC_SEARCH,
    KEYWORD_SEARCH,
    HYBRID_SEARCH
}

enum QueryComplexity {
    LOW, MEDIUM, HIGH
}

@Data
@Builder
class QueryAnalysisResult {
    private QueryComplexity queryComplexity;
    private String language;
    private boolean hasStopWords;
    private boolean needsStemming;
    private boolean canExpandSynonyms;
    private boolean needsRewriting;
    private boolean hasKeywords;
}

/**
 * 快取管理服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RAGCacheService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final CacheMetrics cacheMetrics;
    
    private static final String QUERY_CACHE_PREFIX = "rag:query:";
    private static final String VECTOR_CACHE_PREFIX = "rag:vector:";
    private static final Duration DEFAULT_TTL = Duration.ofHours(1);
    
    /**
     * 快取查詢結果
     */
    public void cacheQueryResult(String queryHash, QueryResult result) {
        try {
            String cacheKey = QUERY_CACHE_PREFIX + queryHash;
            
            // 序列化結果
            CachedQueryResult cachedResult = CachedQueryResult.builder()
                .result(result)
                .cachedAt(LocalDateTime.now())
                .ttl(DEFAULT_TTL)
                .build();
            
            redisTemplate.opsForValue().set(cacheKey, cachedResult, DEFAULT_TTL);
            cacheMetrics.recordCacheWrite("query");
            
            log.debug("Cached query result for hash: {}", queryHash);
            
        } catch (Exception e) {
            log.warn("Failed to cache query result", e);
            cacheMetrics.recordCacheError("query", "write");
        }
    }
    
    /**
     * 取得快取的查詢結果
     */
    public QueryResult getCachedQueryResult(String queryHash) {
        try {
            String cacheKey = QUERY_CACHE_PREFIX + queryHash;
            
            CachedQueryResult cachedResult = (CachedQueryResult) 
                redisTemplate.opsForValue().get(cacheKey);
            
            if (cachedResult != null) {
                cacheMetrics.recordCacheHit("query");
                return cachedResult.getResult();
            } else {
                cacheMetrics.recordCacheMiss("query");
                return null;
            }
            
        } catch (Exception e) {
            log.warn("Failed to get cached query result", e);
            cacheMetrics.recordCacheError("query", "read");
            return null;
        }
    }
    
    /**
     * 快取向量嵌入
     */
    public void cacheVectorEmbedding(String textHash, float[] embedding) {
        try {
            String cacheKey = VECTOR_CACHE_PREFIX + textHash;
            
            CachedVector cachedVector = CachedVector.builder()
                .embedding(embedding)
                .cachedAt(LocalDateTime.now())
                .build();
            
            redisTemplate.opsForValue().set(cacheKey, cachedVector, Duration.ofDays(7));
            cacheMetrics.recordCacheWrite("vector");
            
        } catch (Exception e) {
            log.warn("Failed to cache vector embedding", e);
            cacheMetrics.recordCacheError("vector", "write");
        }
    }
    
    /**
     * 預熱快取
     */
    @EventListener
    public void warmupCache(ApplicationReadyEvent event) {
        log.info("Starting cache warmup");
        
        CompletableFuture.runAsync(() -> {
            try {
                // 預載入熱門查詢
                loadPopularQueries();
                
                // 預載入常用向量
                loadCommonVectors();
                
                log.info("Cache warmup completed");
                
            } catch (Exception e) {
                log.error("Cache warmup failed", e);
            }
        });
    }
    
    private void loadPopularQueries() {
        // 從統計資料載入熱門查詢並預先快取
        // 實現省略...
    }
    
    private void loadCommonVectors() {
        // 預載入常用的向量嵌入
        // 實現省略...
    }
}
```

---

## 7.7.3 監控告警系統

### 系統監控服務

```java
/**
 * RAG 系統監控服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RAGMonitoringService {
    
    private final MeterRegistry meterRegistry;
    private final AlertManager alertManager;
    private final HealthIndicatorRegistry healthRegistry;
    
    // 效能指標
    private final Counter queryCounter;
    private final Timer queryTimer;
    private final Gauge activeConnectionsGauge;
    private final Counter errorCounter;
    
    @PostConstruct
    public void initializeMetrics() {
        // 初始化指標
        queryCounter = Counter.builder("rag.queries.total")
            .description("Total number of RAG queries")
            .register(meterRegistry);
        
        queryTimer = Timer.builder("rag.query.duration")
            .description("RAG query execution time")
            .register(meterRegistry);
        
        activeConnectionsGauge = Gauge.builder("rag.connections.active")
            .description("Active database connections")
            .register(meterRegistry, this, RAGMonitoringService::getActiveConnections);
        
        errorCounter = Counter.builder("rag.errors.total")
            .description("Total number of errors")
            .tag("type", "unknown")
            .register(meterRegistry);
    }
    
    /**
     * 記錄查詢指標
     */
    public void recordQuery(String queryType, Duration duration, boolean success) {
        queryCounter.increment(
            Tags.of(
                "type", queryType,
                "status", success ? "success" : "failure"
            )
        );
        
        queryTimer.record(duration);
        
        if (!success) {
            errorCounter.increment(Tags.of("type", "query_failure"));
        }
    }
    
    /**
     * 記錄系統錯誤
     */
    public void recordError(String errorType, String component, Exception exception) {
        errorCounter.increment(
            Tags.of(
                "type", errorType,
                "component", component,
                "exception", exception.getClass().getSimpleName()
            )
        );
        
        // 檢查是否需要觸發告警
        checkErrorThreshold(errorType, component);
    }
    
    /**
     * 系統健康檢查
     */
    @EventListener
    @Scheduled(fixedRate = 30000) // 每30秒檢查一次
    public void performHealthCheck() {
        try {
            SystemHealthStatus status = collectSystemHealth();
            
            // 更新健康狀態指標
            updateHealthMetrics(status);
            
            // 檢查告警條件
            checkAlertConditions(status);
            
        } catch (Exception e) {
            log.error("Health check failed", e);
            recordError("health_check", "monitoring", e);
        }
    }
    
    /**
     * 收集系統健康狀態
     */
    private SystemHealthStatus collectSystemHealth() {
        SystemHealthStatus.Builder builder = SystemHealthStatus.builder();
        
        // 檢查各個組件的健康狀態
        healthRegistry.getAll().forEach((name, indicator) -> {
            try {
                Health health = indicator.health();
                builder.componentHealth(name, health.getStatus() == Status.UP);
                
                // 記錄詳細指標
                if (health.getDetails() != null) {
                    health.getDetails().forEach((key, value) -> {
                        if (value instanceof Number) {
                            Gauge.builder("rag.health." + name + "." + key)
                                .register(meterRegistry, () -> ((Number) value).doubleValue());
                        }
                    });
                }
                
            } catch (Exception e) {
                log.warn("Health check failed for component: {}", name, e);
                builder.componentHealth(name, false);
            }
        });
        
        return builder.build();
    }
    
    /**
     * 檢查告警條件
     */
    private void checkAlertConditions(SystemHealthStatus status) {
        // 檢查錯誤率
        double errorRate = calculateErrorRate();
        if (errorRate > 0.05) { // 錯誤率超過5%
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.HIGH)
                .title("High Error Rate Detected")
                .message(String.format("Error rate is %.2f%%, exceeding threshold of 5%%", errorRate * 100))
                .component("rag-system")
                .build());
        }
        
        // 檢查回應時間
        double avgResponseTime = calculateAverageResponseTime();
        if (avgResponseTime > 5000) { // 平均回應時間超過5秒
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.MEDIUM)
                .title("High Response Time")
                .message(String.format("Average response time is %.2fms", avgResponseTime))
                .component("rag-system")
                .build());
        }
        
        // 檢查資源使用率
        checkResourceUsage();
    }
    
    /**
     * 檢查資源使用率
     */
    private void checkResourceUsage() {
        // CPU 使用率
        double cpuUsage = getCpuUsage();
        if (cpuUsage > 0.8) {
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.HIGH)
                .title("High CPU Usage")
                .message(String.format("CPU usage is %.1f%%", cpuUsage * 100))
                .component("system")
                .build());
        }
        
        // 記憶體使用率
        double memoryUsage = getMemoryUsage();
        if (memoryUsage > 0.85) {
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.HIGH)
                .title("High Memory Usage")
                .message(String.format("Memory usage is %.1f%%", memoryUsage * 100))
                .component("system")
                .build());
        }
        
        // 磁碟使用率
        double diskUsage = getDiskUsage();
        if (diskUsage > 0.9) {
            alertManager.sendAlert(Alert.builder()
                .severity(AlertSeverity.CRITICAL)
                .title("Critical Disk Usage")
                .message(String.format("Disk usage is %.1f%%", diskUsage * 100))
                .component("system")
                .build());
        }
    }
    
    // 輔助方法
    private double getActiveConnections() {
        // 實現取得活躍連接數的邏輯
        return 0.0;
    }
    
    private double calculateErrorRate() {
        // 計算錯誤率
        return 0.0;
    }
    
    private double calculateAverageResponseTime() {
        // 計算平均回應時間
        return 0.0;
    }
    
    private double getCpuUsage() {
        // 取得 CPU 使用率
        return 0.0;
    }
    
    private double getMemoryUsage() {
        // 取得記憶體使用率
        return 0.0;
    }
    
    private double getDiskUsage() {
        // 取得磁碟使用率
        return 0.0;
    }
}

/**
 * 告警管理器
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AlertManager {
    
    private final NotificationService notificationService;
    private final AlertRepository alertRepository;
    
    /**
     * 發送告警
     */
    public void sendAlert(Alert alert) {
        try {
            // 1. 檢查告警抑制規則
            if (isAlertSuppressed(alert)) {
                log.debug("Alert suppressed: {}", alert.getTitle());
                return;
            }
            
            // 2. 儲存告警記錄
            alertRepository.save(alert);
            
            // 3. 發送通知
            sendNotifications(alert);
            
            log.info("Alert sent: {} - {}", alert.getSeverity(), alert.getTitle());
            
        } catch (Exception e) {
            log.error("Failed to send alert", e);
        }
    }
    
    /**
     * 發送通知
     */
    private void sendNotifications(Alert alert) {
        // 根據嚴重程度決定通知方式
        switch (alert.getSeverity()) {
            case CRITICAL:
                // 關鍵告警：電話 + 簡訊 + 郵件 + Slack
                notificationService.sendPhoneCall(alert);
                notificationService.sendSMS(alert);
                notificationService.sendEmail(alert);
                notificationService.sendSlack(alert);
                break;
                
            case HIGH:
                // 高級告警：簡訊 + 郵件 + Slack
                notificationService.sendSMS(alert);
                notificationService.sendEmail(alert);
                notificationService.sendSlack(alert);
                break;
                
            case MEDIUM:
                // 中級告警：郵件 + Slack
                notificationService.sendEmail(alert);
                notificationService.sendSlack(alert);
                break;
                
            case LOW:
                // 低級告警：僅 Slack
                notificationService.sendSlack(alert);
                break;
        }
    }
    
    /**
     * 檢查告警是否被抑制
     */
    private boolean isAlertSuppressed(Alert alert) {
        // 檢查相同告警在短時間內是否已經發送過
        LocalDateTime suppressionWindow = LocalDateTime.now().minusMinutes(15);
        
        return alertRepository.existsByTitleAndComponentAndCreatedAtAfter(
            alert.getTitle(), 
            alert.getComponent(), 
            suppressionWindow
        );
    }
}
```

---

## 📝 本章重點回顧

1. **生產級部署**：實現了容器化和 Kubernetes 部署策略
2. **效能優化**：建立了查詢優化和快取管理機制
3. **監控告警**：實現了全方位的系統監控和智能告警
4. **故障處理**：建立了故障診斷和快速恢復機制
5. **持續改進**：實現了效能分析和優化的持續改進

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 企業價值 |
|--------|--------|----------|----------|
| **容器化部署** | ⭐⭐⭐ | 中 | 部署效率 |
| **效能優化** | ⭐⭐⭐ | 高 | 使用者體驗 |
| **監控告警** | ⭐⭐⭐ | 中 | 系統穩定性 |
| **故障恢復** | ⭐⭐ | 高 | 業務連續性 |
| **持續改進** | ⭐⭐ | 中 | 長期維護 |

### 最佳實踐建議

1. **分階段部署**：採用藍綠部署或滾動更新策略
2. **效能監控**：建立完整的效能基準和監控體系
3. **自動化運維**：實現自動化的部署、監控和恢復
4. **容量規劃**：根據業務增長進行合理的容量規劃
5. **災難備援**：建立完整的災難恢復和業務連續性計劃

### 第七章完整總結

第七章「RAG 系統建構」完整涵蓋了從基礎概念到生產部署的全過程：

- **7.1 RAG流程詳解**：建立了 RAG 的理論基礎和系統架構
- **7.2 內容向量化**：掌握了文本向量化的核心技術
- **7.3 ETL(上)-知識來源**：實現了多樣化的資料提取能力
- **7.4 ETL(中)-進階文件**：處理了複雜文件格式的提取
- **7.5 ETL(下)-資料優化**：建立了資料品質保證機制
- **7.6 企業資料來源**：整合了企業級的資料管理能力
- **7.7 最後一哩路**：完成了生產級的部署和運維

通過第七章的學習，讀者已經具備了建構完整企業級 RAG 系統的能力！

---

**參考資料：**
- [Docker Documentation](https://docs.docker.com/)
- [Kubernetes Documentation](https://kubernetes.io/docs/)
- [Prometheus Monitoring](https://prometheus.io/docs/)
- [Grafana Dashboards](https://grafana.com/docs/)


\newpage


# 第八章：Advanced RAG {.unnumbered .unlisted}


## 8.1 簡述 Advanced RAG


> **本章重點**：深入了解 Advanced RAG 技術的核心概念，掌握從基礎 RAG 到進階 RAG 的技術演進路線，建立完整的 Advanced RAG 知識體系。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 Advanced RAG 概念**：掌握 Advanced RAG 的核心理念和技術特點
- 🎯 **掌握技術演進路線**：了解從基礎 RAG 到 Advanced RAG 的發展歷程
- 🎯 **識別關鍵技術要素**：認識 Advanced RAG 的核心技術組件
- 🎯 **評估技術選型**：能夠根據業務需求選擇合適的 Advanced RAG 技術
- 🎯 **規劃實施策略**：制定 Advanced RAG 系統的實施計劃

---

## 8.1.1 什麼是 Advanced RAG？

### RAG 技術演進歷程

**RAG 發展的四個階段**：
```
┌─────────────────────────────────────────────────────────────┐
│                    RAG Technology Evolution                 │
├─────────────────────────────────────────────────────────────┤
│  第一代：基礎 RAG (Naive RAG)                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 簡單的向量檢索 + 生成                               │ │
│  │  • 固定的分塊策略                                       │ │
│  │  • 基本的相似度匹配                                     │ │
│  │  • 限制：檢索精度不高、上下文理解有限                   │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  第二代：改進 RAG (Enhanced RAG)                            │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 優化的文本分塊策略                                   │ │
│  │  • 改進的 Embedding 模型                               │ │
│  │  • 基本的重排序機制                                     │ │
│  │  • 改進：提升檢索相關性、減少噪音                       │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  第三代：模組化 RAG (Modular RAG)                           │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 可插拔的檢索模組                                     │ │
│  │  • 多階段檢索流程                                       │ │
│  │  • 自適應檢索策略                                       │ │
│  │  • 特點：靈活性高、可定制化                             │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  第四代：Advanced RAG (智能化 RAG)                          │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 智能查詢理解與重寫                                   │ │
│  │  • 多模態檢索與生成                                     │ │
│  │  • 自我反思與修正機制                                   │ │
│  │  • 知識圖譜增強檢索                                     │ │
│  │  • 優勢：高精度、強適應性、智能化                       │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### Advanced RAG 的核心特徵

#### 1. 智能查詢處理
- **查詢理解**：深度理解用戶意圖和查詢語義
- **查詢重寫**：自動優化查詢表達以提升檢索效果
- **查詢擴展**：基於上下文和知識庫擴展查詢範圍
- **多輪對話**：支持連續對話中的上下文理解

#### 2. 多階段檢索策略
- **粗檢索**：快速篩選大量候選文檔
- **精檢索**：深度分析候選文檔的相關性
- **重排序**：基於多維度指標重新排序結果
- **後處理**：去重、過濾和品質控制

#### 3. 增強的上下文管理
- **動態上下文**：根據查詢動態調整上下文窗口
- **上下文壓縮**：智能壓縮冗餘信息
- **上下文融合**：多來源信息的智能整合
- **上下文驗證**：確保上下文的準確性和相關性

#### 4. 自適應優化機制
- **效果監控**：實時監控檢索和生成效果
- **策略調整**：基於效果反饋自動調整策略
- **學習優化**：從用戶反饋中持續學習改進
- **個性化**：根據用戶偏好定制檢索策略

---

## 8.1.2 Advanced RAG 核心技術組件

### Spring AI 依賴配置

在實現 Advanced RAG 之前，需要添加相關的 Spring AI 依賴：

```xml
<dependencies>
    <!-- Spring AI Core -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Spring AI OpenAI -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
    </dependency>
    
    <!-- Spring AI Vector Store Advisors -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-advisors-vector-store</artifactId>
    </dependency>
    
    <!-- Spring AI Vector Store (選擇合適的實現) -->
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-pgvector-store-spring-boot-starter</artifactId>
    </dependency>
</dependencies>
```

### 必要的 Import 聲明

```java
// Spring AI 核心類
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.client.advisor.Advisor;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.ai.document.Document;
import org.springframework.ai.retrieval.search.DocumentRetriever;
import org.springframework.ai.retrieval.search.VectorStoreDocumentRetriever;
import org.springframework.ai.vectorstore.VectorStore;

// RAG 相關類
import org.springframework.ai.chat.client.advisor.retrieval.RetrievalAugmentationAdvisor;
import org.springframework.ai.chat.client.advisor.retrieval.ContextualQueryAugmenter;
import org.springframework.ai.retrieval.search.DocumentJoiner;
import org.springframework.ai.retrieval.search.ConcatenationDocumentJoiner;

// 查詢處理相關類
import org.springframework.ai.retrieval.query.Query;
import org.springframework.ai.retrieval.query.QueryTransformer;
import org.springframework.ai.retrieval.query.RewriteQueryTransformer;
import org.springframework.ai.retrieval.query.CompressionQueryTransformer;
import org.springframework.ai.retrieval.query.TranslationQueryTransformer;
import org.springframework.ai.retrieval.query.QueryExpander;
import org.springframework.ai.retrieval.query.MultiQueryExpander;

// Prompt 相關類
import org.springframework.ai.chat.prompt.PromptTemplate;
import org.springframework.ai.openai.OpenAiChatOptions;
```

### Spring AI Advanced RAG 架構

**基於 Spring AI 模組化架構**：
```java
/**
 * Advanced RAG 系統架構 - 基於 Spring AI RetrievalAugmentationAdvisor
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AdvancedRAGService {
    
    private final ChatClient chatClient;
    private final VectorStore vectorStore;
    private final ChatModel chatModel;
    
    /**
     * 配置 Advanced RAG ChatClient
     */
    @Bean
    public ChatClient advancedRAGChatClient(ChatModel chatModel, VectorStore vectorStore) {
        
        // 1. 配置查詢轉換器 - 查詢重寫和擴展
        QueryTransformer queryRewriter = RewriteQueryTransformer.builder()
            .chatClientBuilder(ChatClient.builder(chatModel))
            .build();
        
        QueryExpander queryExpander = MultiQueryExpander.builder()
            .chatClientBuilder(ChatClient.builder(chatModel))
            .numberOfQueries(3)
            .includeOriginal(true)
            .build();
        
        // 2. 配置文檔檢索器 - 多階段檢索
        DocumentRetriever documentRetriever = VectorStoreDocumentRetriever.builder()
            .vectorStore(vectorStore)
            .similarityThreshold(0.75)
            .topK(10)
            .build();
        
        // 3. 配置查詢增強器 - 上下文優化
        QueryAugmenter queryAugmenter = ContextualQueryAugmenter.builder()
            .allowEmptyContext(false)
            .build();
        
        // 4. 構建 Advanced RAG Advisor
        Advisor retrievalAugmentationAdvisor = RetrievalAugmentationAdvisor.builder()
            .queryTransformers(queryRewriter)
            .queryExpanders(queryExpander)
            .documentRetriever(documentRetriever)
            .queryAugmenter(queryAugmenter)
            .build();
        
        // 5. 配置 ChatClient
        return ChatClient.builder(chatModel)
            .defaultAdvisors(retrievalAugmentationAdvisor)
            .defaultOptions(OpenAiChatOptions.builder()
                .model("gpt-4")
                .temperature(0.3)
                .build())
            .build();
    }
    
    /**
     * Advanced RAG 查詢處理
     */
    public AdvancedRAGResponse processQuery(String query, Map<String, Object> context) {
        long startTime = System.currentTimeMillis();
        
        try {
            // 使用 Advanced RAG ChatClient 處理查詢
            String response = chatClient.prompt()
                .user(query)
                .advisors(advisor -> {
                    // 動態設置過濾條件
                    if (context.containsKey("filter")) {
                        advisor.param(VectorStoreDocumentRetriever.FILTER_EXPRESSION, 
                                     context.get("filter").toString());
                    }
                })
                .call()
                .content();
            
            long processingTime = System.currentTimeMillis() - startTime;
            
            return AdvancedRAGResponse.builder()
                .answer(response)
                .query(query)
                .processingTime(processingTime)
                .success(true)
                .build();
                
        } catch (Exception e) {
            log.error("Advanced RAG processing failed for query: {}", query, e);
            return AdvancedRAGResponse.builder()
                .query(query)
                .error(e.getMessage())
                .success(false)
                .processingTime(System.currentTimeMillis() - startTime)
                .build();
        }
    }
}
```

### Spring AI 查詢處理組件實現

**基於 Spring AI 官方 QueryTransformer**：
```java
/**
 * 自定義查詢重寫轉換器
 * 基於 Spring AI RewriteQueryTransformer
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class AdvancedQueryRewriter {
    
    private final ChatClient.Builder chatClientBuilder;
    
    /**
     * 創建查詢重寫轉換器
     */
    public QueryTransformer createRewriteTransformer() {
        return RewriteQueryTransformer.builder()
            .chatClientBuilder(chatClientBuilder)
            .promptTemplate(createCustomRewritePrompt())
            .build();
    }
    
    /**
     * 自定義重寫提示模板
     */
    private PromptTemplate createCustomRewritePrompt() {
        return PromptTemplate.builder()
            .template("""
                你是一個查詢優化專家。請將用戶查詢重寫為更適合向量檢索的形式。
                
                重寫規則：
                1. 保留關鍵信息和意圖
                2. 使用更精確的術語
                3. 移除冗餘詞語
                4. 增加相關關鍵詞
                
                原始查詢：{query}
                
                請提供重寫後的查詢：
                """)
            .build();
    }
    
    /**
     * 創建壓縮查詢轉換器
     * 用於處理多輪對話上下文
     */
    public QueryTransformer createCompressionTransformer() {
        return CompressionQueryTransformer.builder()
            .chatClientBuilder(chatClientBuilder)
            .promptTemplate(createCustomCompressionPrompt())
            .build();
    }
    
    /**
     * 自定義壓縮提示模板
     */
    private PromptTemplate createCustomCompressionPrompt() {
        return PromptTemplate.builder()
            .template("""
                基於以下對話歷史，將用戶的後續問題重寫為一個獨立的問題。
                
                對話歷史：
                {history}
                
                後續問題：{query}
                
                請將後續問題重寫為包含必要上下文的獨立問題：
                """)
            .build();
    }
}

/**
 * 多查詢擴展服務
 * 基於 Spring AI MultiQueryExpander
 */
@Component 
@RequiredArgsConstructor
@Slf4j
public class AdvancedQueryExpander {
    
    private final ChatClient.Builder chatClientBuilder;
    
    /**
     * 創建多查詢擴展器
     */
    public QueryExpander createMultiQueryExpander(int numberOfQueries) {
        return MultiQueryExpander.builder()
            .chatClientBuilder(chatClientBuilder)
            .numberOfQueries(numberOfQueries)
            .includeOriginal(true)
            .promptTemplate(createCustomExpansionPrompt())
            .build();
    }
    
    /**
     * 自定義查詢擴展提示模板
     */
    private PromptTemplate createCustomExpansionPrompt() {
        return PromptTemplate.builder()
            .template("""
                請基於以下查詢生成 {numberOfQueries} 個語義相似但表達不同的查詢變體。
                這些變體應該：
                1. 保持相同的查詢意圖
                2. 使用不同的詞彙和表達方式
                3. 從不同角度描述同一個問題
                4. 有助於檢索更全面的相關文檔
                
                原始查詢：{query}
                
                請提供查詢變體：
                """)
            .build();
    }
    
    /**
     * 創建語言翻譯轉換器
     * 用於多語言查詢處理
     */
    public QueryTransformer createTranslationTransformer(String targetLanguage) {
        return TranslationQueryTransformer.builder()
            .chatClientBuilder(chatClientBuilder)
            .targetLanguage(targetLanguage)
            .promptTemplate(createCustomTranslationPrompt())
            .build();
    }
    
    /**
     * 自定義翻譯提示模板
     */
    private PromptTemplate createCustomTranslationPrompt() {
        return PromptTemplate.builder()
            .template("""
                請將以下查詢翻譯為 {targetLanguage}。
                保持查詢的語義和意圖不變。
                如果查詢已經是目標語言，請直接返回原查詢。
                
                查詢：{query}
                
                翻譯結果：
                """)
            .build();
    }
}
```

### Spring AI 多階段檢索實現

**基於 Spring AI DocumentRetriever 和 DocumentJoiner**：
```java
/**
 * Advanced RAG 多階段檢索服務
 * 基於 Spring AI 官方組件
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class MultiStageRetrievalService {
    
    private final VectorStore vectorStore;
    private final ChatClient.Builder chatClientBuilder;
    
    /**
     * 創建多階段檢索配置
     */
    public MultiStageRetrievalConfig createMultiStageConfig() {
        
        // 1. 主要文檔檢索器 - 較低閾值獲取更多候選
        DocumentRetriever primaryRetriever = VectorStoreDocumentRetriever.builder()
            .vectorStore(vectorStore)
            .similarityThreshold(0.6)  // 較低閾值
            .topK(20)                  // 更多候選
            .build();
        
        // 2. 精確文檔檢索器 - 較高閾值獲取精確匹配
        DocumentRetriever precisionRetriever = VectorStoreDocumentRetriever.builder()
            .vectorStore(vectorStore)
            .similarityThreshold(0.8)  // 較高閾值
            .topK(10)                  // 較少精確結果
            .build();
        
        // 3. 文檔連接器 - 合併多個檢索結果
        DocumentJoiner documentJoiner = new ConcatenationDocumentJoiner();
        
        return new MultiStageRetrievalConfig(primaryRetriever, precisionRetriever, documentJoiner);
    }
    
    /**
     * 執行多階段檢索
     */
    public List<Document> performMultiStageRetrieval(String queryText, Map<String, Object> filters) {
        
        // 1. 創建查詢對象
        Query.Builder queryBuilder = Query.builder().text(queryText);
        
        // 2. 添加過濾條件
        if (filters != null && !filters.isEmpty()) {
            queryBuilder.context(filters);
        }
        
        Query query = queryBuilder.build();
        
        // 3. 多階段檢索配置
        MultiStageRetrievalConfig config = createMultiStageConfig();
        
        // 4. 第一階段：廣泛檢索
        List<Document> primaryResults = config.getPrimaryRetriever().retrieve(query);
        log.debug("Primary retrieval returned {} documents", primaryResults.size());
        
        // 5. 第二階段：精確檢索
        List<Document> precisionResults = config.getPrecisionRetriever().retrieve(query);
        log.debug("Precision retrieval returned {} documents", precisionResults.size());
        
        // 6. 合併結果
        Map<Query, List<List<Document>>> documentsForQuery = Map.of(
            query, Arrays.asList(primaryResults, precisionResults)
        );
        
        List<Document> finalResults = config.getDocumentJoiner().join(documentsForQuery);
        log.debug("Final merged results: {} documents", finalResults.size());
        
        return finalResults;
    }
    
    /**
     * 帶查詢擴展的多階段檢索
     */
    public List<Document> performExpandedMultiStageRetrieval(String queryText, int numberOfExpansions) {
        
        // 1. 創建查詢擴展器
        QueryExpander queryExpander = MultiQueryExpander.builder()
            .chatClientBuilder(chatClientBuilder)
            .numberOfQueries(numberOfExpansions)
            .includeOriginal(true)
            .build();
        
        // 2. 擴展查詢
        List<Query> expandedQueries = queryExpander.expand(new Query(queryText));
        log.debug("Expanded to {} queries", expandedQueries.size());
        
        // 3. 為每個擴展查詢執行檢索
        List<List<Document>> allResults = new ArrayList<>();
        DocumentRetriever retriever = VectorStoreDocumentRetriever.builder()
            .vectorStore(vectorStore)
            .similarityThreshold(0.7)
            .topK(15)
            .build();
        
        for (Query query : expandedQueries) {
            List<Document> results = retriever.retrieve(query);
            allResults.add(results);
        }
        
        // 4. 合併所有結果
        Map<Query, List<List<Document>>> documentsForQuery = new HashMap<>();
        for (int i = 0; i < expandedQueries.size(); i++) {
            documentsForQuery.put(expandedQueries.get(i), Arrays.asList(allResults.get(i)));
        }
        
        DocumentJoiner documentJoiner = new ConcatenationDocumentJoiner();
        List<Document> finalResults = documentJoiner.join(documentsForQuery);
        
        log.debug("Expanded retrieval returned {} unique documents", finalResults.size());
        
        return finalResults;
    }
}

/**
 * 多階段檢索配置類
 */
@Data
@AllArgsConstructor
public class MultiStageRetrievalConfig {
    private final DocumentRetriever primaryRetriever;
    private final DocumentRetriever precisionRetriever;
    private final DocumentJoiner documentJoiner;
}

/**
 * Advanced RAG 回應數據類
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AdvancedRAGResponse {
    private String query;
    private String answer;
    private boolean success;
    private String error;
    private long processingTime;
    private List<String> sources;
    private Map<String, Object> metadata;
}
```

---

## 8.1.3 Advanced RAG 技術對比

### 技術特性比較

| 技術特性 | 基礎 RAG | Enhanced RAG | Modular RAG | Advanced RAG |
|----------|----------|--------------|-------------|---------------|
| **檢索策略** | 單一向量檢索 | 優化向量檢索 | 多模組檢索 | 智能多階段檢索 |
| **查詢處理** | 直接檢索 | 基本預處理 | 模組化處理 | 智能理解重寫 |
| **上下文管理** | 固定窗口 | 動態窗口 | 靈活管理 | 智能優化 |
| **結果品質** | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **實現複雜度** | 低 | 中 | 高 | 很高 |
| **維護成本** | 低 | 中 | 中高 | 高 |
| **適用場景** | 簡單問答 | 一般應用 | 複雜應用 | 企業級應用 |

### 性能指標對比

| 性能指標 | 基礎 RAG | Enhanced RAG | Modular RAG | Advanced RAG |
|----------|----------|--------------|-------------|---------------|
| **準確率** | 60-70% | 70-80% | 80-85% | 85-95% |
| **召回率** | 50-60% | 60-70% | 70-80% | 80-90% |
| **回應時間** | < 1s | < 2s | < 3s | < 5s |
| **資源消耗** | 低 | 中 | 中高 | 高 |
| **擴展性** | 有限 | 中等 | 良好 | 優秀 |

---

## 8.1.4 Advanced RAG 應用場景

### 企業知識管理
- **技術文檔查詢**：智能理解技術問題並提供精確答案
- **政策法規諮詢**：複雜法規條文的智能解讀
- **業務流程指導**：基於上下文的流程指導
- **專家知識傳承**：專業知識的智能化傳承

### 客戶服務系統
- **智能客服**：理解客戶意圖並提供個性化服務
- **問題診斷**：基於症狀描述的智能問題診斷
- **解決方案推薦**：根據問題特徵推薦最佳解決方案
- **服務品質監控**：實時監控服務品質並優化

### 教育培訓平台
- **個性化學習**：根據學習者水平提供適合的內容
- **智能答疑**：理解學習問題並提供詳細解答
- **知識關聯**：建立知識點之間的關聯關係
- **學習路徑規劃**：智能規劃個性化學習路徑

### 研究與開發
- **文獻檢索**：智能檢索相關研究文獻
- **技術調研**：快速了解技術發展趨勢
- **專利分析**：智能分析專利技術要點
- **創新靈感**：基於知識庫激發創新思路

---

## 📝 本章重點回顧

1. **Advanced RAG 概念**：理解了 Advanced RAG 的核心理念和技術特點
2. **技術演進路線**：掌握了從基礎 RAG 到 Advanced RAG 的發展歷程
3. **核心技術組件**：了解了智能查詢處理、多階段檢索等關鍵技術
4. **技術對比分析**：比較了不同 RAG 技術的特性和適用場景
5. **應用場景規劃**：識別了 Advanced RAG 的典型應用場景

### 技術要點總結

| 技術要點 | 重要性 | 實現難度 | 應用價值 |
|----------|--------|----------|----------|
| **智能查詢處理** | ⭐⭐⭐⭐⭐ | 高 | 極高 |
| **多階段檢索** | ⭐⭐⭐⭐ | 高 | 高 |
| **上下文管理** | ⭐⭐⭐⭐ | 中 | 高 |
| **品質控制** | ⭐⭐⭐ | 中 | 中高 |
| **自適應優化** | ⭐⭐⭐ | 高 | 中高 |

### 實施建議

1. **漸進式升級**：從基礎 RAG 逐步升級到 Advanced RAG
2. **重點突破**：優先實現對業務影響最大的技術組件
3. **效果驗證**：建立完整的效果評估體系
4. **持續優化**：基於實際使用效果持續改進
5. **團隊培養**：培養具備 Advanced RAG 技術能力的團隊

### 下一步學習方向

在下一節中，我們將深入學習如何提高 RAG 準確率，包括：
- Embedding 模型選擇與優化
- 文本分塊策略改進
- 檢索策略優化
- 效果評估方法

---

**參考資料：**
- [Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks](https://arxiv.org/abs/2005.11401)
- [Advanced RAG Techniques](https://arxiv.org/abs/2312.10997)
- [Modular RAG: Transforming RAG Systems](https://arxiv.org/abs/2407.21059)
- [Self-RAG: Learning to Critique and Correct](https://arxiv.org/abs/2310.11511)


\newpage

## 8.2 提高RAG準確率從Embedding換起


> **本章重點**：深入探討如何通過優化 Embedding 模型來提升 RAG 系統的準確率，掌握不同 Embedding 模型的特性、選擇策略和配置方法，建立高效的向量檢索系統。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 Embedding 重要性**：掌握 Embedding 在 RAG 系統中的核心作用
- 🎯 **評估模型性能**：能夠比較不同 Embedding 模型的性能表現
- 🎯 **選擇最佳模型**：根據業務需求選擇最適合的 Embedding 模型
- 🎯 **優化配置策略**：實現 Embedding 模型的最佳配置和調優
- 🎯 **監控模型效果**：建立 Embedding 效果的監控和評估機制

---

## 8.2.1 為什麼 Embedding 是 RAG 的關鍵？

### Embedding 在 RAG 中的作用

**RAG 系統的核心流程**：
```
┌─────────────────────────────────────────────────────────────┐
│                    RAG System Pipeline                     │
├─────────────────────────────────────────────────────────────┤
│  用戶查詢                                                   │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  "什麼是機器學習？"                                    │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  查詢向量化 (Query Embedding)                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  Embedding Model: text-embedding-3-small                │ │
│  │  Vector: [0.1, -0.3, 0.8, ..., 0.2] (1536維)          │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  向量相似度檢索                                             │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 計算查詢向量與文檔向量的相似度                       │ │
│  │  • 餘弦相似度 = cos(query_vec, doc_vec)                │ │
│  │  • 返回 Top-K 最相似的文檔                             │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  上下文生成                                                 │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  基於檢索到的相關文檔，LLM 生成最終答案                 │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### Embedding 品質對 RAG 的影響

#### 1. 檢索精度影響
- **高品質 Embedding**：能夠準確捕捉語義相似性，檢索到真正相關的文檔
- **低品質 Embedding**：語義理解不準確，檢索結果偏離用戶意圖

#### 2. 多語言支援
- **多語言模型**：支援繁體中文、英文等多種語言的語義理解
- **單語言模型**：僅支援特定語言，限制應用範圍

#### 3. 領域適應性
- **通用模型**：適用於一般性問答，但在專業領域可能表現不佳
- **領域特化模型**：在特定領域（如醫療、法律）表現更好

#### 4. 計算效率
- **模型大小**：影響推理速度和資源消耗
- **向量維度**：影響存儲空間和檢索速度

---

## 8.2.2 Embedding 模型效能比較

### 繁體中文 Embedding 評測結果

根據最新的繁體中文 Embedding 評測結果，不同模型的表現差異很大：

#### OpenAI Embedding 模型比較

| 模型 | 排名 | 準確率 | 價格 | Dimensions | 特點 |
|------|------|--------|------|------------|------|
| text-embedding-ada-002 | 24 | ~83% | 較高 | 1536 | 舊版預設模型 |
| text-embedding-3-small | 23 | ~84% | 便宜5倍 | 512-1536 | 性價比高 |
| text-embedding-3-large | 13 | ~90% | 最貴 | 256-3072 | 高準確率 |

#### 其他優秀模型

| 模型 | 排名 | 準確率 | 特點 |
|------|------|--------|------|
| voyage-multilingual-2 | 1 | ~97% | 多語言最佳 |
| multilingual-e5-small | 4 | ~92% | 開源，384維度 |
| multilingual-e5-large | 6 | ~94% | 開源，1024維度 |

> **重要觀念**：dimensions 不是越高就越好！更高的維度意味著更多的計算成本和儲存空間。

### 模型選擇決策矩陣

| 使用場景 | 推薦模型 | 理由 |
|----------|----------|------|
| **成本敏感** | text-embedding-3-small | 性價比最高，準確率可接受 |
| **高精度需求** | text-embedding-3-large | 最高準確率，適合關鍵應用 |
| **多語言支援** | voyage-multilingual-2 | 多語言表現最佳 |
| **開源需求** | multilingual-e5-large | 開源，無 API 調用成本 |
| **快速檢索** | multilingual-e5-small | 低維度，檢索速度快 |

---

## 8.2.3 Spring AI 1.1-SNAPSHOT Embedding 配置

### 添加依賴

首先添加 Spring AI OpenAI Starter 依賴：

```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
</dependency>
```

### OpenAI Embedding 配置

最簡單的升級方式是使用更好的 OpenAI 模型：

```yaml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      chat:
        options:
          model: gpt-4o-mini
          temperature: 0.7
      embedding:
        options:
          model: text-embedding-3-small  # 升級自預設的 text-embedding-ada-002
          dimensions: 1024  # 可選：僅支援 text-embedding-3 系列
```

### 使用自動配置的方式（推薦）

Spring AI 提供了自動配置，建議使用配置文件方式：

```yaml
# application.yml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      embedding:
        options:
          model: text-embedding-3-small
          dimensions: 1024
```

### 多模型配置策略（進階用法）

```java
/**
 * 多 Embedding 模型配置
 * 注意：這是進階用法，通常建議使用自動配置
 */
@Configuration
public class MultiEmbeddingConfiguration {
    
    /**
     * 使用 EmbeddingRequest 動態設定選項的方式（推薦）
     */
    @Service
    @RequiredArgsConstructor
    public static class DynamicEmbeddingService {
        
        private final EmbeddingModel embeddingModel; // 使用自動配置的 EmbeddingModel
        
        /**
         * 高精度 Embedding
         */
        public EmbeddingResponse highAccuracyEmbed(List<String> texts) {
            return embeddingModel.call(
                new EmbeddingRequest(texts,
                    OpenAiEmbeddingOptions.builder()
                        .model("text-embedding-3-large")
                        .dimensions(3072)
                        .build()));
        }
        
        /**
         * 成本效益 Embedding
         */
        public EmbeddingResponse costEffectiveEmbed(List<String> texts) {
            return embeddingModel.call(
                new EmbeddingRequest(texts,
                    OpenAiEmbeddingOptions.builder()
                        .model("text-embedding-3-small")
                        .dimensions(512)
                        .build()));
        }
        
        /**
         * 標準 Embedding（使用配置文件中的預設值）
         */
        public float[] standardEmbed(String text) {
            return embeddingModel.embed(text);
        }
        
        /**
         * 批量 Embedding
         */
        public List<float[]> batchEmbed(List<String> texts) {
            return embeddingModel.embed(texts);
        }
    }
}
```

### 智能模型選擇服務

```java
/**
 * 智能 Embedding 模型選擇服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class SmartEmbeddingService {
    
    // 使用自動配置的 EmbeddingModel
    private final EmbeddingModel embeddingModel;
    
    private final EmbeddingModelPerformanceMonitor performanceMonitor;
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 智能選擇模型並生成向量
     */
    public float[] embedWithSmartSelection(String text, EmbeddingContext context) {
        
        // 1. 根據上下文選擇模型選項
        OpenAiEmbeddingOptions options = selectModelOptions(context);
        
        // 2. 檢查快取
        String cacheKey = generateCacheKey(text, options.getModel());
        float[] cachedEmbedding = getCachedEmbedding(cacheKey);
        
        if (cachedEmbedding != null) {
            log.debug("Using cached embedding for text: {}", text.substring(0, Math.min(50, text.length())));
            return cachedEmbedding;
        }
        
        // 3. 生成 Embedding - 使用 Spring AI 官方 API 
        long startTime = System.currentTimeMillis();
        EmbeddingResponse response = embeddingModel.call(
            new EmbeddingRequest(List.of(text), options));
        float[] embedding = response.getResults().get(0).getOutput();
        long duration = System.currentTimeMillis() - startTime;
        
        // 4. 快取結果
        cacheEmbedding(cacheKey, embedding);
        
        // 5. 記錄效能指標
        performanceMonitor.recordEmbeddingMetrics(
            options.getModel(), 
            text.length(), 
            duration,
            embedding.length  // 修正：float[] 使用 length 屬性
        );
        
        return embedding;
    }
    
    /**
     * 根據上下文選擇模型選項
     */
    private OpenAiEmbeddingOptions selectModelOptions(EmbeddingContext context) {
        
        // 高精度需求
        if (context.isHighAccuracyRequired()) {
            log.debug("Using high accuracy embedding options");
            return OpenAiEmbeddingOptions.builder()
                .model("text-embedding-3-large")
                .dimensions(3072)
                .build();
        }
        
        // 成本敏感
        if (context.isCostSensitive() || context.isBatchProcessing()) {
            log.debug("Using cost effective embedding options");
            return OpenAiEmbeddingOptions.builder()
                .model("text-embedding-3-small")
                .dimensions(512)
                .build();
        }
        
        // 預設使用標準配置
        log.debug("Using standard embedding options");
        return OpenAiEmbeddingOptions.builder()
            .model("text-embedding-3-small")
            .dimensions(1024)
            .build();
    }
    
    /**
     * 批量 Embedding 處理
     */
    public Map<String, float[]> batchEmbed(List<String> texts, EmbeddingContext context) {
        
        Map<String, float[]> results = new HashMap<>();
        
        // 檢查快取
        Map<String, float[]> cachedResults = getCachedBatchEmbeddings(texts, context);
        results.putAll(cachedResults);
        
        // 過濾出需要計算的文本
        List<String> uncachedTexts = texts.stream()
            .filter(text -> !results.containsKey(text))
            .collect(Collectors.toList());
        
        if (!uncachedTexts.isEmpty()) {
            // 選擇適合批量處理的選項
            EmbeddingContext batchContext = context.toBuilder()
                .batchProcessing(true)
                .costSensitive(true)
                .build();
            
            OpenAiEmbeddingOptions batchOptions = selectModelOptions(batchContext);
            
            // 批量處理 - 使用 Spring AI 官方 API
            EmbeddingResponse batchResponse = embeddingModel.call(
                new EmbeddingRequest(uncachedTexts, batchOptions));
            
            // 將結果對應回文本
            List<Embedding> embeddings = batchResponse.getResults();
            for (int i = 0; i < uncachedTexts.size(); i++) {
                String text = uncachedTexts.get(i);
                float[] embedding = embeddings.get(i).getOutput();
                results.put(text, embedding);
                
                // 快取結果
                String cacheKey = generateCacheKey(text, batchOptions.getModel());
                cacheEmbedding(cacheKey, embedding);
            }
        }
        
        return results;
    }
    
    /**
     * 生成快取鍵
     */
    private String generateCacheKey(String text, String modelName) {
        return String.format("embedding:%s:%s", 
            modelName, 
            DigestUtils.md5DigestAsHex(text.getBytes()));
    }
    
    /**
     * 獲取快取的 Embedding
     */
    @SuppressWarnings("unchecked")
    private float[] getCachedEmbedding(String cacheKey) {
        try {
            return (float[]) redisTemplate.opsForValue().get(cacheKey);
        } catch (Exception e) {
            log.warn("Failed to get cached embedding: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * 快取 Embedding
     */
    private void cacheEmbedding(String cacheKey, float[] embedding) {
        try {
            redisTemplate.opsForValue().set(cacheKey, embedding, Duration.ofHours(24));
        } catch (Exception e) {
            log.warn("Failed to cache embedding: {}", e.getMessage());
        }
    }
    
    /**
     * 獲取批量快取結果
     */
    private Map<String, float[]> getCachedBatchEmbeddings(List<String> texts, EmbeddingContext context) {
        Map<String, float[]> cachedResults = new HashMap<>();
        
        for (String text : texts) {
            String cacheKey = generateCacheKey(text, "primary"); // 簡化實現
            float[] cached = getCachedEmbedding(cacheKey);
            if (cached != null) {
                cachedResults.put(text, cached);
            }
        }
        
        return cachedResults;
    }
}

/**
 * Embedding 上下文
 */
@Data
@Builder(toBuilder = true)
public class EmbeddingContext {
    private boolean highAccuracyRequired;
    private boolean costSensitive;
    private boolean batchProcessing;
    private String domain;  // 領域：general, medical, legal, etc.
    private String language; // 語言：zh-TW, en, etc.
    private int priority;   // 優先級：1-10
}
```

### 效能監控服務

```java
/**
 * Embedding 模型效能監控
 */
@Service
@Slf4j
public class EmbeddingModelPerformanceMonitor {
    
    private final MeterRegistry meterRegistry;
    private final RedisTemplate<String, Object> redisTemplate;
    
    public EmbeddingModelPerformanceMonitor(MeterRegistry meterRegistry,
                                           RedisTemplate<String, Object> redisTemplate) {
        this.meterRegistry = meterRegistry;
        this.redisTemplate = redisTemplate;
    }
    
    /**
     * 記錄 Embedding 指標
     */
    public void recordEmbeddingMetrics(String modelName, int textLength, 
                                     long duration, int embeddingDimensions) {
        
        // 記錄處理時間
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("embedding.processing.time")
            .tag("model", modelName)
            .register(meterRegistry));
        
        // 記錄文本長度
        Counter.builder("embedding.text.length")
            .tag("model", modelName)
            .register(meterRegistry)
            .increment(textLength);
        
        // 記錄向量維度
        Counter.builder("embedding.dimensions")
            .tag("model", modelName)
            .register(meterRegistry)
            .increment(embeddingDimensions);
        
        // 記錄處理速度（字符/秒）
        double charactersPerSecond = duration > 0 ? textLength / (duration / 1000.0) : 0;
        Counter.builder("embedding.processing.speed")
            .tag("model", modelName)
            .register(meterRegistry)
            .increment(charactersPerSecond);
        
        // 更新模型使用統計
        updateModelUsageStats(modelName, duration, textLength);
    }
    
    /**
     * 更新模型使用統計
     */
    private void updateModelUsageStats(String modelName, long duration, int textLength) {
        try {
            String statsKey = "embedding:stats:" + modelName;
            
            // 獲取現有統計
            ModelStats stats = getModelStats(statsKey);
            
            // 更新統計
            stats.incrementUsageCount();
            stats.addProcessingTime(duration);
            stats.addTextLength(textLength);
            stats.updateLastUsed();
            
            // 保存統計
            redisTemplate.opsForValue().set(statsKey, stats, Duration.ofDays(30));
            
        } catch (Exception e) {
            log.error("Failed to update model usage stats", e);
        }
    }
    
    /**
     * 獲取模型統計
     */
    @SuppressWarnings("unchecked")
    private ModelStats getModelStats(String statsKey) {
        try {
            ModelStats stats = (ModelStats) redisTemplate.opsForValue().get(statsKey);
            return stats != null ? stats : new ModelStats();
        } catch (Exception e) {
            log.warn("Failed to get model stats, creating new: {}", e.getMessage());
            return new ModelStats();
        }
    }
    
    /**
     * 獲取模型效能報告
     */
    public ModelPerformanceReport getPerformanceReport(String modelName) {
        String statsKey = "embedding:stats:" + modelName;
        ModelStats stats = getModelStats(statsKey);
        
        return ModelPerformanceReport.builder()
            .modelName(modelName)
            .totalUsage(stats.getUsageCount())
            .averageProcessingTime(stats.getAverageProcessingTime())
            .averageTextLength(stats.getAverageTextLength())
            .processingSpeed(stats.getProcessingSpeed())
            .lastUsed(stats.getLastUsed())
            .build();
    }
    
    /**
     * 定期更新模型排名
     */
    @Scheduled(fixedRate = 3600000) // 每小時執行一次
    public void updateModelRankings() {
        try {
            List<String> modelNames = Arrays.asList(
                "text-embedding-3-small",
                "text-embedding-3-large",
                "text-embedding-ada-002"
            );
            
            List<ModelPerformanceReport> reports = modelNames.stream()
                .map(this::getPerformanceReport)
                .sorted((a, b) -> {
                    // 綜合評分：速度 + 使用量
                    double scoreA = a.getProcessingSpeed() * 0.6 + a.getTotalUsage() * 0.4;
                    double scoreB = b.getProcessingSpeed() * 0.6 + b.getTotalUsage() * 0.4;
                    return Double.compare(scoreB, scoreA);
                })
                .collect(Collectors.toList());
            
            List<String> rankedModels = reports.stream()
                .map(ModelPerformanceReport::getModelName)
                .collect(Collectors.toList());
            
            redisTemplate.opsForValue().set("embedding:model:rankings", rankedModels,
                Duration.ofHours(2));
            
            log.info("Updated embedding model rankings: {}", rankedModels);
            
        } catch (Exception e) {
            log.error("Failed to update model rankings", e);
        }
    }
    
    /**
     * 獲取推薦模型
     */
    @SuppressWarnings("unchecked")
    public String getRecommendedModel() {
        try {
            List<String> rankings = (List<String>) redisTemplate.opsForValue()
                .get("embedding:model:rankings");
            
            return (rankings != null && !rankings.isEmpty()) ?
                rankings.get(0) : "text-embedding-3-small";
                
        } catch (Exception e) {
            log.warn("Failed to get recommended model, using default", e);
            return "text-embedding-3-small";
        }
    }
}

/**
 * 模型統計資料
 */
@Data
@NoArgsConstructor
public class ModelStats {
    private long usageCount = 0;
    private long totalProcessingTime = 0;
    private long totalTextLength = 0;
    private LocalDateTime lastUsed;
    
    public void incrementUsageCount() {
        this.usageCount++;
    }
    
    public void addProcessingTime(long duration) {
        this.totalProcessingTime += duration;
    }
    
    public void addTextLength(int length) {
        this.totalTextLength += length;
    }
    
    public void updateLastUsed() {
        this.lastUsed = LocalDateTime.now();
    }
    
    public double getAverageProcessingTime() {
        return usageCount > 0 ? (double) totalProcessingTime / usageCount : 0;
    }
    
    public double getAverageTextLength() {
        return usageCount > 0 ? (double) totalTextLength / usageCount : 0;
    }
    
    public double getProcessingSpeed() {
        return totalProcessingTime > 0 ? 
            (double) totalTextLength / (totalProcessingTime / 1000.0) : 0;
    }
}

/**
 * 模型效能報告
 */
@Data
@Builder
public class ModelPerformanceReport {
    private String modelName;
    private long totalUsage;
    private double averageProcessingTime;
    private double averageTextLength;
    private double processingSpeed;
    private LocalDateTime lastUsed;
}
```

---

## 8.2.4 Embedding 優化最佳實踐

### 文本預處理優化

```java
/**
 * Embedding 文本預處理服務
 */
@Service
@Slf4j
public class EmbeddingTextPreprocessor {
    
    /**
     * 預處理文本以提升 Embedding 品質
     */
    public String preprocessForEmbedding(String text, PreprocessingOptions options) {
        
        if (text == null || text.trim().isEmpty()) {
            return "";
        }
        
        String processed = text;
        
        // 1. 清理特殊字符
        if (options.isCleanSpecialChars()) {
            processed = cleanSpecialCharacters(processed);
        }
        
        // 2. 正規化空白字符
        if (options.isNormalizeWhitespace()) {
            processed = normalizeWhitespace(processed);
        }
        
        // 3. 移除過短或過長的文本
        if (options.isFilterByLength()) {
            if (processed.length() < options.getMinLength() || 
                processed.length() > options.getMaxLength()) {
                log.debug("Text filtered by length: {} chars", processed.length());
                return "";
            }
        }
        
        // 4. 語言檢測和過濾
        if (options.isFilterByLanguage()) {
            String detectedLanguage = detectLanguage(processed);
            if (!options.getAllowedLanguages().contains(detectedLanguage)) {
                log.debug("Text filtered by language: {}", detectedLanguage);
                return "";
            }
        }
        
        // 5. 內容品質檢查
        if (options.isCheckContentQuality()) {
            double qualityScore = assessContentQuality(processed);
            if (qualityScore < options.getMinQualityScore()) {
                log.debug("Text filtered by quality: {}", qualityScore);
                return "";
            }
        }
        
        return processed.trim();
    }
    
    private String cleanSpecialCharacters(String text) {
        // 保留中文、英文、數字、基本標點
        return text.replaceAll("[^\u4e00-\u9fff\u3400-\u4dbfa-zA-Z0-9\s.,!?;:()\[\]{}\"'-]", " ");
    }
    
    private String normalizeWhitespace(String text) {
        return text.replaceAll("\\s+", " ").trim();
    }
    
    private String detectLanguage(String text) {
        // 簡化的語言檢測
        if (text.matches(".*[\u4e00-\u9fff].*")) {
            return "zh";
        } else if (text.matches(".*[a-zA-Z].*")) {
            return "en";
        }
        return "unknown";
    }
    
    private double assessContentQuality(String text) {
        double score = 1.0;
        
        // 檢查重複字符
        if (text.matches(".*(.)\\1{5,}.*")) {
            score -= 0.3;
        }
        
        // 檢查字符多樣性
        Set<Character> uniqueChars = text.chars()
            .mapToObj(c -> (char) c)
            .collect(Collectors.toSet());
        
        double diversity = (double) uniqueChars.size() / text.length();
        if (diversity < 0.1) {
            score -= 0.2;
        }
        
        // 檢查是否包含有意義的內容
        if (text.matches("^[\s\p{Punct}]*$")) {
            score -= 0.5;
        }
        
        return Math.max(0.0, score);
    }
}

/**
 * 預處理選項
 */
@Data
@Builder
public class PreprocessingOptions {
    @Builder.Default
    private boolean cleanSpecialChars = true;
    
    @Builder.Default
    private boolean normalizeWhitespace = true;
    
    @Builder.Default
    private boolean filterByLength = true;
    
    @Builder.Default
    private int minLength = 10;
    
    @Builder.Default
    private int maxLength = 8000;
    
    @Builder.Default
    private boolean filterByLanguage = false;
    
    @Builder.Default
    private Set<String> allowedLanguages = Set.of("zh", "en");
    
    @Builder.Default
    private boolean checkContentQuality = true;
    
    @Builder.Default
    private double minQualityScore = 0.5;
}
```

### 向量存儲優化

```java
/**
 * 優化的向量存儲服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class OptimizedVectorStoreService {
    
    private final VectorStore vectorStore;
    private final SmartEmbeddingService embeddingService;
    private final EmbeddingTextPreprocessor textPreprocessor;
    
    /**
     * 優化的文檔添加
     */
    public void addDocumentsOptimized(List<Document> documents) {
        
        List<Document> processedDocuments = documents.parallelStream()
            .map(this::preprocessDocument)
            .filter(doc -> !doc.getContent().isEmpty())
            .collect(Collectors.toList());
        
        if (processedDocuments.isEmpty()) {
            log.warn("No valid documents to add after preprocessing");
            return;
        }
        
        // 批量生成 Embedding
        Map<String, float[]> embeddings = generateBatchEmbeddings(processedDocuments);
        
        // 注意：Spring AI 的 Document 類別沒有 setEmbedding 方法
        // Embedding 是在 VectorStore.add() 時自動生成的
        // 這裡我們只需要確保文檔內容已預處理
        
        // 批量添加到向量存儲
        vectorStore.add(processedDocuments);
        
        log.info("Added {} optimized documents to vector store", processedDocuments.size());
    }
    
    /**
     * 預處理文檔
     */
    private Document preprocessDocument(Document document) {
        
        PreprocessingOptions options = PreprocessingOptions.builder()
            .cleanSpecialChars(true)
            .normalizeWhitespace(true)
            .filterByLength(true)
            .minLength(20)
            .maxLength(4000)
            .checkContentQuality(true)
            .minQualityScore(0.6)
            .build();
        
        String processedContent = textPreprocessor.preprocessForEmbedding(
            document.getContent(), options);
        
        // 使用 Spring AI Document 構造子
        return new Document(processedContent, document.getMetadata());
    }
    
    /**
     * 批量生成 Embedding
     */
    private Map<String, float[]> generateBatchEmbeddings(List<Document> documents) {
        
        List<String> contents = documents.stream()
            .map(Document::getContent)
            .collect(Collectors.toList());
        
        EmbeddingContext context = EmbeddingContext.builder()
            .batchProcessing(true)
            .costSensitive(true)
            .build();
        
        return embeddingService.batchEmbed(contents, context);
    }
    
    /**
     * 優化的相似度搜尋
     */
    public List<Document> similaritySearchOptimized(String query, int topK, double threshold) {
        
        // 預處理查詢
        PreprocessingOptions queryOptions = PreprocessingOptions.builder()
            .cleanSpecialChars(true)
            .normalizeWhitespace(true)
            .filterByLength(false) // 查詢可以較短
            .checkContentQuality(false) // 查詢不需要品質檢查
            .build();
        
        String processedQuery = textPreprocessor.preprocessForEmbedding(query, queryOptions);
        
        if (processedQuery.isEmpty()) {
            log.warn("Query is empty after preprocessing: {}", query);
            return Collections.emptyList();
        }
        
        // 生成查詢 Embedding
        EmbeddingContext context = EmbeddingContext.builder()
            .highAccuracyRequired(true) // 查詢使用高精度模型
            .build();
        
        float[] queryEmbedding = embeddingService.embedWithSmartSelection(
            processedQuery, context);
        
        // 注意：在實際應用中，VectorStore.similaritySearch() 會自動處理查詢的 embedding
        
        // 執行相似度搜尋
        List<Document> results = vectorStore.similaritySearch(
            SearchRequest.builder()
                .query(processedQuery)
                .topK(topK * 2) // 檢索更多候選，後續過濾
                .similarityThreshold(threshold * 0.8) // 降低閾值
                .build()
        );
        
        // 後處理結果
        return postProcessSearchResults(results, queryEmbedding, topK, threshold);
    }
    
    /**
     * 後處理搜尋結果
     */
    private List<Document> postProcessSearchResults(List<Document> results, 
                                                   float[] queryEmbedding,
                                                   int topK, double threshold) {
        
        return results.stream()
            // 注意：Spring AI Document 類別沒有 getEmbedding() 方法
            // VectorStore 已經在 similaritySearch() 中處理了相似度的過濾
            .limit(topK)
            .collect(Collectors.toList());
    }
    
    /**
     * 計算餘弦相似度（只供參考，實際上 VectorStore 已經處理）
     */
    private double calculateCosineSimilarity(float[] vec1, float[] vec2) {
        if (vec1.length != vec2.length) {
            throw new IllegalArgumentException("Vector dimensions must match");
        }
        
        double dotProduct = 0.0;
        double norm1 = 0.0;
        double norm2 = 0.0;
        
        for (int i = 0; i < vec1.length; i++) {
            dotProduct += vec1[i] * vec2[i];
            norm1 += vec1[i] * vec1[i];
            norm2 += vec2[i] * vec2[i];
        }
        
        return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
    }
}
```

---

## 📝 本章重點回顧

1. **Embedding 重要性**：理解了 Embedding 在 RAG 系統中的核心作用
2. **模型性能比較**：掌握了不同 Embedding 模型的特性和選擇策略
3. **Spring AI 配置**：實現了多模型配置和智能選擇機制
4. **效能監控**：建立了完整的 Embedding 效能監控體系
5. **優化實踐**：掌握了文本預處理和向量存儲的優化方法

### 技術要點總結

| 技術要點 | 重要性 | 實現難度 | 效果提升 |
|----------|--------|----------|----------|
| **模型選擇** | ⭐⭐⭐⭐⭐ | 中 | 20-30% |
| **文本預處理** | ⭐⭐⭐⭐ | 中 | 15-25% |
| **批量處理** | ⭐⭐⭐ | 中 | 效率提升50% |
| **快取策略** | ⭐⭐⭐ | 低 | 速度提升80% |
| **效能監控** | ⭐⭐ | 中 | 持續優化 |

### 最佳實踐建議

1. **模型選擇策略**：根據精度需求、成本預算、處理速度選擇合適模型
2. **文本品質控制**：建立完整的文本預處理和品質評估機制
3. **批量處理優化**：使用批量處理和快取提升處理效率
4. **效能持續監控**：建立模型效能監控和自動優化機制
5. **成本效益平衡**：在準確率和成本之間找到最佳平衡點

### 下一步學習方向

在下一節中，我們將深入學習在 Spring AI 實作 Re-ranking，包括：
- Re-ranking 原理和重要性
- Spring AI Re-ranking 實現
- 多階段檢索優化
- Re-ranking 效果評估

---

### 💡 簡單使用範例

```java
/**
 * 簡單的 Embedding 使用範例
 */
@RestController
@RequiredArgsConstructor
public class EmbeddingController {
    
    private final EmbeddingModel embeddingModel;
    
    /**
     * 基本 Embedding 操作
     */
    @PostMapping("/api/embed")
    public Map<String, Object> embed(@RequestBody String text) {
        // 使用預設配置
        float[] embedding = embeddingModel.embed(text);
        
        return Map.of(
            "text", text,
            "embedding", embedding,
            "dimensions", embedding.length
        );
    }
    
    /**
     * 批量 Embedding 操作
     */
    @PostMapping("/api/embed/batch")
    public Map<String, Object> batchEmbed(@RequestBody List<String> texts) {
        List<float[]> embeddings = embeddingModel.embed(texts);
        
        return Map.of(
            "count", texts.size(),
            "embeddings", embeddings
        );
    }
    
    /**
     * 使用不同模型選項
     */
    @PostMapping("/api/embed/advanced")
    public Map<String, Object> advancedEmbed(@RequestBody String text) {
        // 使用高精度模型
        EmbeddingResponse response = embeddingModel.call(
            new EmbeddingRequest(List.of(text),
                OpenAiEmbeddingOptions.builder()
                    .model("text-embedding-3-large")
                    .dimensions(3072)
                    .build()));
        
        float[] embedding = response.getResults().get(0).getOutput();
        
        return Map.of(
            "text", text,
            "model", "text-embedding-3-large",
            "embedding", embedding,
            "dimensions", embedding.length,
            "usage", response.getMetadata().getUsage()
        );
    }
}
```

**參考資料：**
- [Spring AI Embeddings API](https://docs.spring.io/spring-ai/reference/api/embeddings.html)
- [Spring AI OpenAI Embeddings](https://docs.spring.io/spring-ai/reference/api/embeddings/openai-embeddings.html)
- [Text Embeddings: Comprehensive Guide](https://arxiv.org/abs/2401.00368)
- [Improving Text Embeddings with Large Language Models](https://arxiv.org/abs/2401.00368)
- [MTEB: Massive Text Embedding Benchmark](https://arxiv.org/abs/2210.07316)
- [OpenAI Embeddings Guide](https://platform.openai.com/docs/guides/embeddings)


\newpage

## 8.3 在 Spring AI 中自定義實現 Re-ranking 機制


> **本章重點**：深入探討 Re-ranking 技術在 RAG 系統中的重要性，學習如何基於 Spring AI 現有 API 自定義實現 Re-ranking 機制，建立多階段檢索優化系統，提升檢索結果的精確度和相關性。

> **重要說明**：Spring AI 1.0 GA 版本目前沒有內建的 Rerank 模型 API，本章將展示如何基於現有的 EmbeddingModel 和 VectorStore API 創新性地實現自定義 Re-ranking 功能。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 Re-ranking 原理**：掌握 Re-ranking 在 RAG 系統中的作用和重要性
- 🎯 **自定義 Re-ranking 實現**：基於 Spring AI 現有 API 實現自定義 Re-ranking Advisor
- 🎯 **建構多階段檢索**：設計和實現多階段檢索優化流程
- 🎯 **創新檢索策略**：結合 EmbeddingModel 和多因子評分提升檢索效果
- 🎯 **評估 Re-ranking 效果**：建立 Re-ranking 效果的評估和監控機制

---

## 8.3.1 什麼是 Re-ranking？

### Re-ranking 在 RAG 中的作用

**傳統檢索 vs Re-ranking 檢索**：
```
┌─────────────────────────────────────────────────────────────┐
│                Traditional RAG vs Re-ranking RAG            │
├─────────────────────────────────────────────────────────────┤
│  傳統 RAG 流程                                              │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  查詢 → Embedding → 向量檢索 → Top-K 結果 → LLM 生成   │ │
│  │  問題：可能檢索到語義相似但不相關的內容                 │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  Re-ranking RAG 流程                                        │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  查詢 → Embedding → 粗檢索(Top-50)                     │ │
│  │         ↓                                               │ │
│  │  Re-ranking 模型 → 精確排序 → Top-K 結果 → LLM 生成   │ │
│  │  優勢：更精確的相關性判斷，提升檢索品質                 │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### Re-ranking 的核心優勢

#### 1. 提升檢索精度
- **語義理解增強**：Re-ranking 模型能更好地理解查詢與文檔的語義關係
- **上下文感知**：考慮查詢的完整上下文，而不僅僅是向量相似度
- **細粒度匹配**：能夠識別細微的相關性差異

#### 2. 兩階段優化
- **粗檢索階段**：使用 Embedding 快速篩選大量候選文檔
- **精檢索階段**：使用 Re-ranking 模型精確排序候選文檔
- **效率平衡**：兼顧檢索速度和精確度

#### 3. 模型互補
- **Embedding 優勢**：快速、高召回率
- **Re-ranking 優勢**：精確、高精準率
- **組合效果**：1 + 1 > 2 的協同效應

---

## 8.3.2 基於 Spring AI 的自定義 Re-ranking 實現

### 技術實現說明

由於 Spring AI 目前沒有內建的 Rerank 模型，我們採用以下創新方法實現 Re-ranking 功能：

**核心技術棧**：
- **EmbeddingModel**：用於計算語義相似度
- **VectorStore**：執行初始的向量檢索
- **自定義 Advisor**：實現 Re-ranking 邏輯
- **多因子評分**：結合語義、關鍵字、長度、元數據等因子

**實現優勢**：
- 充分利用 Spring AI 現有 API
- 靈活的評分策略配置
- 企業級的監控和指標收集
- 為未來官方 Rerank 支援做好架構準備

### 企業級 RAG 系統架構

```java
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.document.Document;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.ai.embedding.EmbeddingResponse;
import org.springframework.ai.vectorstore.SearchRequest;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.ai.chat.client.advisor.MessageChatMemoryAdvisor;
import org.springframework.ai.chat.client.advisor.QuestionAnswerAdvisor;
import org.springframework.ai.chat.client.advisor.SimpleLoggerAdvisor;

/**
 * 企業級 RAG 配置
 */
@Configuration
@EnableConfigurationProperties(RAGProperties.class)
public class EnterpriseRAGConfiguration {
    
    @Bean
    public ChatClient enterpriseRAGClient(
            ChatClient.Builder builder,
            VectorStore vectorStore,
            ChatMemory chatMemory,
            DocumentRetriever documentRetriever,
            @Qualifier("rerankingModel") EmbeddingModel rerankingModel) {
        
        return builder
            .defaultSystem("""
                你是一個企業級 AI 知識助手，具備以下能力：
                1. 檢索企業知識庫並提供準確答案
                2. 記住對話歷史，提供連貫的對話體驗
                3. 根據檢索到的文檔提供有引用的專業回答
                4. 當資訊不確定時，明確告知用戶
                
                回答時請遵循以下格式：
                - 直接回答用戶問題
                - 在答案末尾註明資料來源
                - 如果沒有找到相關資訊，請誠實告知
                """)
            .defaultAdvisors(
                // 1. 對話記憶管理 - 最高優先級
                MessageChatMemoryAdvisor.builder(chatMemory)
                    .order(1)
                    .build(),
                    
                // 2. 智能文檔檢索 - 第二優先級
                QuestionAnswerAdvisor.builder(vectorStore)
                    .searchRequest(SearchRequest.builder()
                        .topK(10)  // 初始檢索更多文檔
                        .similarityThreshold(0.7)
                        .build())
                    .order(2)
                    .build(),
                    
                // 3. 重排序優化 - 第三優先級
                new RerankingAdvisor(rerankingModel, 5),
                
                // 4. 答案質量控制 - 第四優先級
                new AnswerQualityAdvisor(),
                
                // 5. 日誌和監控 - 最低優先級
                SimpleLoggerAdvisor.builder()
                    .order(100)
                    .build()
            )
            .build();
    }
}
```

### 自定義 Re-ranking Advisor

```java
import org.springframework.ai.chat.client.advisor.api.AdvisedRequest;
import org.springframework.ai.chat.client.advisor.api.AdvisedResponse;
import org.springframework.ai.chat.client.advisor.api.CallAroundAdvisor;
import org.springframework.ai.chat.client.advisor.api.CallAroundAdvisorChain;

/**
 * Re-ranking Advisor 實現
 */
@Component
@Slf4j
public class RerankingAdvisor implements CallAroundAdvisor {
    
    private static final String RERANKED_DOCS_CONTEXT_KEY = "reranked-docs";
    
    private final EmbeddingModel rerankingModel;
    private final int finalTopK;
    private final RerankingMetrics metrics;
    
    public RerankingAdvisor(EmbeddingModel rerankingModel, int finalTopK) {
        this.rerankingModel = rerankingModel;
        this.finalTopK = finalTopK;
        this.metrics = new RerankingMetrics();
    }
    
    @Override
    public String getName() {
        return "RerankingAdvisor";
    }
    
    @Override
    public int getOrder() {
        return 3;
    }
    
    @Override
    public AdvisedResponse aroundCall(AdvisedRequest request, CallAroundAdvisorChain chain) {
        
        long startTime = System.currentTimeMillis();
        
        try {
            // 取得原始檢索結果
            AdvisedResponse response = chain.nextAroundCall(request);
            
            // 檢查是否有檢索到的文檔
            List<Document> retrievedDocs = extractRetrievedDocuments(request);
            if (retrievedDocs.isEmpty() || retrievedDocs.size() <= finalTopK) {
                log.debug("No re-ranking needed, document count: {}", retrievedDocs.size());
                return response;
            }
            
            // 執行重排序
            String query = extractUserQuery(request);
            List<Document> rerankedDocs = performReranking(query, retrievedDocs);
            
            // 更新回應中的文檔
            AdvisedResponse rerankedResponse = updateResponseWithRerankedDocs(
                response, rerankedDocs);
            
            // 記錄指標
            long duration = System.currentTimeMillis() - startTime;
            metrics.recordReranking(retrievedDocs.size(), rerankedDocs.size(), duration);
            
            log.debug("Re-ranking completed: {} -> {} docs in {}ms", 
                retrievedDocs.size(), rerankedDocs.size(), duration);
            
            return rerankedResponse;
            
        } catch (Exception e) {
            log.warn("Re-ranking failed, using original order", e);
            return chain.nextAroundCall(request);
        }
    }
    
    /**
     * 執行重排序
     */
    private List<Document> performReranking(String query, List<Document> documents) {
        
        List<RerankingCandidate> candidates = new ArrayList<>();
        
        // 使用 EmbeddingModel 計算查詢向量（創新實現）
        EmbeddingResponse embeddingResponse = rerankingModel.embedForResponse(List.of(query));
        List<Double> queryEmbedding = embeddingResponse.getResults().get(0).getOutput();
        
        // 為每個文檔計算重排序分數
        for (Document doc : documents) {
            try {
                // 語義相似度分數 - 基於 EmbeddingModel 的創新 Re-ranking 實現
                EmbeddingResponse contentEmbResponse = rerankingModel.embedForResponse(List.of(doc.getContent()));
                List<Double> contentEmbedding = contentEmbResponse.getResults().get(0).getOutput();
                double semanticScore = calculateCosineSimilarity(queryEmbedding, contentEmbedding);
                
                // 計算其他特徵分數
                double lengthScore = calculateLengthScore(doc.getContent());
                double keywordScore = calculateKeywordScore(query, doc.getContent());
                double metadataScore = calculateMetadataScore(doc.getMetadata());
                
                // 綜合分數計算
                double finalScore = calculateFinalScore(
                    semanticScore, lengthScore, keywordScore, metadataScore);
                
                candidates.add(RerankingCandidate.builder()
                    .document(doc)
                    .semanticScore(semanticScore)
                    .lengthScore(lengthScore)
                    .keywordScore(keywordScore)
                    .metadataScore(metadataScore)
                    .finalScore(finalScore)
                    .build());
                    
            } catch (Exception e) {
                log.warn("Failed to calculate re-ranking score for document: {}", 
                    doc.getId(), e);
                // 使用原始分數
                candidates.add(RerankingCandidate.builder()
                    .document(doc)
                    .finalScore(doc.getScore())
                    .build());
            }
        }
        
        // 按最終分數排序並取前 K 個
        return candidates.stream()
            .sorted((a, b) -> Double.compare(b.getFinalScore(), a.getFinalScore()))
            .limit(finalTopK)
            .map(RerankingCandidate::getDocument)
            .collect(Collectors.toList());
    }
    
    /**
     * 計算餘弦相似度
     */
    private double calculateCosineSimilarity(List<Double> vec1, List<Double> vec2) {
        if (vec1.size() != vec2.size()) {
            return 0.0;
        }
        
        double dotProduct = 0.0;
        double norm1 = 0.0;
        double norm2 = 0.0;
        
        for (int i = 0; i < vec1.size(); i++) {
            dotProduct += vec1.get(i) * vec2.get(i);
            norm1 += vec1.get(i) * vec1.get(i);
            norm2 += vec2.get(i) * vec2.get(i);
        }
        
        if (norm1 == 0.0 || norm2 == 0.0) {
            return 0.0;
        }
        
        return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
    }
    
    /**
     * 計算長度分數
     */
    private double calculateLengthScore(String content) {
        int length = content.length();
        
        // 理想長度範圍：200-1000 字符
        if (length >= 200 && length <= 1000) {
            return 1.0;
        } else if (length < 200) {
            return length / 200.0;
        } else {
            return Math.max(0.5, 1000.0 / length);
        }
    }
    
    /**
     * 計算關鍵字分數
     */
    private double calculateKeywordScore(String query, String content) {
        String[] queryWords = query.toLowerCase().split("\\s+");
        String lowerContent = content.toLowerCase();
        
        int matchCount = 0;
        for (String word : queryWords) {
            if (lowerContent.contains(word)) {
                matchCount++;
            }
        }
        
        return queryWords.length > 0 ? (double) matchCount / queryWords.length : 0.0;
    }
    
    /**
     * 計算元數據分數
     */
    private double calculateMetadataScore(Map<String, Object> metadata) {
        double score = 0.5; // 基礎分數
        
        // 檢查文檔類型
        String docType = (String) metadata.get("type");
        if ("official".equals(docType) || "policy".equals(docType)) {
            score += 0.2;
        }
        
        // 檢查更新時間
        Object lastUpdated = metadata.get("lastUpdated");
        if (lastUpdated != null) {
            // 較新的文檔獲得更高分數
            score += 0.1;
        }
        
        // 檢查權威性
        Object authority = metadata.get("authority");
        if (authority != null && "high".equals(authority.toString())) {
            score += 0.2;
        }
        
        return Math.min(1.0, score);
    }
    
    /**
     * 計算最終分數
     */
    private double calculateFinalScore(double semanticScore, double lengthScore, 
                                     double keywordScore, double metadataScore) {
        
        // 權重配置
        double semanticWeight = 0.5;
        double lengthWeight = 0.2;
        double keywordWeight = 0.2;
        double metadataWeight = 0.1;
        
        return semanticScore * semanticWeight +
               lengthScore * lengthWeight +
               keywordScore * keywordWeight +
               metadataScore * metadataWeight;
    }
    
    /**
     * 提取檢索到的文檔
     */
    @SuppressWarnings("unchecked")
    private List<Document> extractRetrievedDocuments(AdvisedRequest request) {
        // 從請求上下文中提取已檢索的文檔
        Object docs = request.adviseContext().get("rag_retrieved_documents");
        if (docs instanceof List) {
            return (List<Document>) docs;
        }
        return Collections.emptyList();
    }
    
    /**
     * 提取用戶查詢
     */
    private String extractUserQuery(AdvisedRequest request) {
        // 從請求中提取查詢的邏輯
        return request.userText(); // 簡化實現
    }
    
    /**
     * 更新回應中的文檔
     */
    private AdvisedResponse updateResponseWithRerankedDocs(
            AdvisedResponse response, List<Document> rerankedDocs) {
        // 將重排序的文檔存放到響應上下文中
        response.adviseContext().put(RERANKED_DOCS_CONTEXT_KEY, rerankedDocs);
        return response;
    }
}

/**
 * Re-ranking 候選文檔
 */
@Data
@Builder
public class RerankingCandidate {
    private Document document;
    private double semanticScore;
    private double lengthScore;
    private double keywordScore;
    private double metadataScore;
    private double finalScore;
}
```

### Re-ranking 指標監控

```java
/**
 * Re-ranking 指標收集
 */
@Component
@Slf4j
public class RerankingMetrics {
    
    private final MeterRegistry meterRegistry;
    private final AtomicLong totalRerankings = new AtomicLong(0);
    private final AtomicLong totalProcessingTime = new AtomicLong(0);
    
    public RerankingMetrics() {
        this.meterRegistry = Metrics.globalRegistry;
        initializeMetrics();
    }
    
    private void initializeMetrics() {
        // 註冊指標
        Gauge.builder("reranking.total.count")
            .register(meterRegistry, totalRerankings, AtomicLong::get);
            
        Gauge.builder("reranking.average.processing.time")
            .register(meterRegistry, this, RerankingMetrics::getAverageProcessingTime);
    }
    
    /**
     * 記錄 Re-ranking 指標
     */
    public void recordReranking(int originalCount, int finalCount, long processingTime) {
        
        totalRerankings.incrementAndGet();
        totalProcessingTime.addAndGet(processingTime);
        
        // 記錄處理時間
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("reranking.processing.time")
            .register(meterRegistry));
        
        // 記錄文檔數量變化
        Counter.builder("reranking.documents.processed")
            .register(meterRegistry)
            .increment(originalCount);
            
        Counter.builder("reranking.documents.selected")
            .register(meterRegistry)
            .increment(finalCount);
        
        // 記錄壓縮比例
        double compressionRatio = originalCount > 0 ? 
            (double) finalCount / originalCount : 0.0;
        
        Gauge.builder("reranking.compression.ratio")
            .register(meterRegistry, compressionRatio, Double::valueOf);
        
        log.debug("Recorded re-ranking metrics: {} -> {} docs, {}ms, ratio: {:.2f}",
            originalCount, finalCount, processingTime, compressionRatio);
    }
    
    /**
     * 獲取平均處理時間
     */
    public double getAverageProcessingTime() {
        long count = totalRerankings.get();
        return count > 0 ? (double) totalProcessingTime.get() / count : 0.0;
    }
    
    /**
     * 獲取 Re-ranking 統計報告
     */
    public RerankingReport getReport() {
        return RerankingReport.builder()
            .totalRerankings(totalRerankings.get())
            .averageProcessingTime(getAverageProcessingTime())
            .totalProcessingTime(totalProcessingTime.get())
            .build();
    }
}

/**
 * Re-ranking 報告
 */
@Data
@Builder
public class RerankingReport {
    private long totalRerankings;
    private double averageProcessingTime;
    private long totalProcessingTime;
}
```

---

## 8.3.3 多階段檢索優化

### 進階 RAG 服務實現

```java
/**
 * 進階 RAG 服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AdvancedRAGService {
    
    private final VectorStore vectorStore;
    private final EmbeddingModel primaryEmbeddingModel;
    private final EmbeddingModel rerankingEmbeddingModel;
    private final ChatClient chatClient;
    private final RerankingMetrics rerankingMetrics;
    
    /**
     * 多階段檢索查詢
     */
    public AdvancedRAGResponse query(String userQuery, RAGQueryOptions options) {
        
        long startTime = System.currentTimeMillis();
        
        try {
            // 第一階段：粗檢索
            List<Document> coarseResults = performCoarseRetrieval(userQuery, options);
            
            // 第二階段：Re-ranking 精檢索
            List<Document> rerankedResults = performReranking(
                userQuery, coarseResults, options);
            
            // 第三階段：上下文優化
            String optimizedContext = optimizeContext(rerankedResults, options);
            
            // 第四階段：LLM 生成
            String response = generateResponse(userQuery, optimizedContext);
            
            long totalTime = System.currentTimeMillis() - startTime;
            
            return AdvancedRAGResponse.builder()
                .query(userQuery)
                .response(response)
                .retrievedDocuments(rerankedResults)
                .coarseResultCount(coarseResults.size())
                .finalResultCount(rerankedResults.size())
                .processingTime(totalTime)
                .build();
                
        } catch (Exception e) {
            log.error("Advanced RAG query failed", e);
            throw new AdvancedRAGException("Query processing failed", e);
        }
    }
    
    /**
     * 第一階段：粗檢索
     */
    private List<Document> performCoarseRetrieval(String query, RAGQueryOptions options) {
        
        log.debug("Performing coarse retrieval for query: {}", query);
        
        // 使用較大的 TopK 和較低的閾值進行粗檢索
        int coarseTopK = options.getFinalTopK() * 3; // 檢索 3 倍的候選文檔
        double coarseThreshold = Math.max(0.5, options.getSimilarityThreshold() - 0.2);
        
        SearchRequest searchRequest = SearchRequest.builder()
            .query(query)
            .topK(coarseTopK)
            .similarityThreshold(coarseThreshold)
            .build();
        
        List<Document> results = vectorStore.similaritySearch(searchRequest);
        
        log.debug("Coarse retrieval found {} documents", results.size());
        return results;
    }
    
    /**
     * 第二階段：Re-ranking 精檢索
     */
    private List<Document> performReranking(String query, List<Document> candidates, 
                                           RAGQueryOptions options) {
        
        if (candidates.size() <= options.getFinalTopK()) {
            log.debug("No re-ranking needed, candidate count: {}", candidates.size());
            return candidates;
        }
        
        log.debug("Performing re-ranking on {} candidates", candidates.size());
        
        long startTime = System.currentTimeMillis();
        
        // 使用 EmbeddingModel 計算查詢向量（創新實現）
        EmbeddingResponse queryEmbResponse = rerankingEmbeddingModel.embedForResponse(List.of(query));
        List<Double> queryEmbedding = queryEmbResponse.getResults().get(0).getOutput();
        
        // 計算每個候選文檔的重排序分數
        List<ScoredDocument> scoredDocs = candidates.parallelStream()
            .map(doc -> calculateRerankingScore(query, queryEmbedding, doc))
            .collect(Collectors.toList());
        
        // 按分數排序並取前 K 個
        List<Document> rerankedDocs = scoredDocs.stream()
            .sorted((a, b) -> Double.compare(b.getScore(), a.getScore()))
            .limit(options.getFinalTopK())
            .map(ScoredDocument::getDocument)
            .collect(Collectors.toList());
        
        long duration = System.currentTimeMillis() - startTime;
        rerankingMetrics.recordReranking(candidates.size(), rerankedDocs.size(), duration);
        
        log.debug("Re-ranking completed: {} -> {} docs in {}ms", 
            candidates.size(), rerankedDocs.size(), duration);
        
        return rerankedDocs;
    }
    
    /**
     * 計算重排序分數
     */
    private ScoredDocument calculateRerankingScore(String query, List<Double> queryEmbedding, 
                                                  Document document) {
        
        try {
            // 1. 語義相似度分數 - 基於 EmbeddingModel 的創新 Re-ranking 實現
            EmbeddingResponse docEmbResponse = rerankingEmbeddingModel.embedForResponse(List.of(document.getContent()));
            List<Double> docEmbedding = docEmbResponse.getResults().get(0).getOutput();
            double semanticScore = calculateCosineSimilarity(queryEmbedding, docEmbedding);
            
            // 2. BM25 分數
            double bm25Score = calculateBM25Score(query, document.getContent());
            
            // 3. 文檔品質分數
            double qualityScore = calculateDocumentQuality(document);
            
            // 4. 新鮮度分數
            double freshnessScore = calculateFreshnessScore(document);
            
            // 5. 綜合分數
            double finalScore = combineScores(semanticScore, bm25Score, qualityScore, freshnessScore);
            
            return ScoredDocument.builder()
                .document(document)
                .score(finalScore)
                .semanticScore(semanticScore)
                .bm25Score(bm25Score)
                .qualityScore(qualityScore)
                .freshnessScore(freshnessScore)
                .build();
                
        } catch (Exception e) {
            log.warn("Failed to calculate re-ranking score for document: {}", 
                document.getId(), e);
            
            return ScoredDocument.builder()
                .document(document)
                .score(document.getScore()) // 使用原始分數
                .build();
        }
    }
    
    /**
     * 計算 BM25 分數
     */
    private double calculateBM25Score(String query, String content) {
        // 簡化的 BM25 實現
        String[] queryTerms = query.toLowerCase().split("\\s+");
        String lowerContent = content.toLowerCase();
        
        double score = 0.0;
        for (String term : queryTerms) {
            int termFreq = countOccurrences(lowerContent, term);
            if (termFreq > 0) {
                // 簡化的 BM25 公式
                double tf = (double) termFreq / (termFreq + 1.2);
                score += tf;
            }
        }
        
        return score / queryTerms.length;
    }
    
    /**
     * 計算文檔品質分數
     */
    private double calculateDocumentQuality(Document document) {
        double score = 0.5; // 基礎分數
        
        String content = document.getContent();
        
        // 長度分數
        int length = content.length();
        if (length >= 100 && length <= 2000) {
            score += 0.2;
        }
        
        // 結構分數（是否有標題、段落等）
        if (content.contains("\n\n") || content.contains("#")) {
            score += 0.1;
        }
        
        // 元數據分數
        Map<String, Object> metadata = document.getMetadata();
        if (metadata.containsKey("title")) {
            score += 0.1;
        }
        
        if ("official".equals(metadata.get("source"))) {
            score += 0.1;
        }
        
        return Math.min(1.0, score);
    }
    
    /**
     * 計算新鮮度分數
     */
    private double calculateFreshnessScore(Document document) {
        Object lastUpdated = document.getMetadata().get("lastUpdated");
        if (lastUpdated == null) {
            return 0.5; // 預設分數
        }
        
        try {
            LocalDateTime updateTime = LocalDateTime.parse(lastUpdated.toString());
            LocalDateTime now = LocalDateTime.now();
            long daysDiff = ChronoUnit.DAYS.between(updateTime, now);
            
            // 30 天內的文檔獲得滿分，之後逐漸衰減
            if (daysDiff <= 30) {
                return 1.0;
            } else if (daysDiff <= 365) {
                return 1.0 - (daysDiff - 30) / 335.0 * 0.5;
            } else {
                return 0.5;
            }
            
        } catch (Exception e) {
            return 0.5;
        }
    }
    
    /**
     * 組合各種分數
     */
    private double combineScores(double semanticScore, double bm25Score, 
                                double qualityScore, double freshnessScore) {
        
        // 權重配置
        double semanticWeight = 0.4;
        double bm25Weight = 0.3;
        double qualityWeight = 0.2;
        double freshnessWeight = 0.1;
        
        return semanticScore * semanticWeight +
               bm25Score * bm25Weight +
               qualityScore * qualityWeight +
               freshnessScore * freshnessWeight;
    }
    
    /**
     * 第三階段：上下文優化
     */
    private String optimizeContext(List<Document> documents, RAGQueryOptions options) {
        
        StringBuilder context = new StringBuilder();
        int maxContextLength = options.getMaxContextLength();
        int currentLength = 0;
        
        for (int i = 0; i < documents.size(); i++) {
            Document doc = documents.get(i);
            String content = doc.getContent();
            
            // 檢查是否會超過最大長度
            if (currentLength + content.length() > maxContextLength) {
                // 截斷內容
                int remainingLength = maxContextLength - currentLength;
                if (remainingLength > 100) { // 至少保留 100 字符
                    content = content.substring(0, remainingLength - 3) + "...";
                } else {
                    break; // 跳出循環
                }
            }
            
            context.append("[文檔 ").append(i + 1).append("]\n");
            context.append(content).append("\n\n");
            
            currentLength += content.length() + 20; // 加上格式字符
        }
        
        return context.toString();
    }
    
    /**
     * 第四階段：LLM 生成
     */
    private String generateResponse(String query, String context) {
        
        String prompt = String.format("""
            基於以下上下文資訊回答問題：
            
            上下文：
            %s
            
            問題：%s
            
            請根據上下文提供準確、詳細的回答。如果上下文中沒有相關資訊，請明確說明。
            """, context, query);
        
        return chatClient.prompt()
            .user(prompt)
            .call()
            .content();
    }
    
    /**
     * 計算餘弦相似度（輔助方法）
     */
    private double calculateCosineSimilarity(List<Double> vec1, List<Double> vec2) {
        if (vec1.size() != vec2.size()) {
            return 0.0;
        }
        
        double dotProduct = 0.0;
        double norm1 = 0.0;
        double norm2 = 0.0;
        
        for (int i = 0; i < vec1.size(); i++) {
            dotProduct += vec1.get(i) * vec2.get(i);
            norm1 += vec1.get(i) * vec1.get(i);
            norm2 += vec2.get(i) * vec2.get(i);
        }
        
        if (norm1 == 0.0 || norm2 == 0.0) {
            return 0.0;
        }
        
        return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
    }
    
    private int countOccurrences(String text, String term) {
        int count = 0;
        int index = 0;
        while ((index = text.indexOf(term, index)) != -1) {
            count++;
            index += term.length();
        }
        return count;
    }
}

/**
 * 評分文檔
 */
@Data
@Builder
public class ScoredDocument {
    private Document document;
    private double score;
    private double semanticScore;
    private double bm25Score;
    private double qualityScore;
    private double freshnessScore;
}

/**
 * RAG 查詢選項
 */
@Data
@Builder
public class RAGQueryOptions {
    @Builder.Default
    private int finalTopK = 5;
    
    @Builder.Default
    private double similarityThreshold = 0.7;
    
    @Builder.Default
    private int maxContextLength = 4000;
    
    @Builder.Default
    private boolean enableReranking = true;
}

/**
 * 進階 RAG 回應
 */
@Data
@Builder
public class AdvancedRAGResponse {
    private String query;
    private String response;
    private List<Document> retrievedDocuments;
    private int coarseResultCount;
    private int finalResultCount;
    private long processingTime;
}
```

---

## 8.3.4 Re-ranking 效果評估

### 評估指標和監控

```java
/**
 * Re-ranking 效果評估服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class RerankingEvaluationService {
    
    private final RerankingMetrics rerankingMetrics;
    private final MeterRegistry meterRegistry;
    
    /**
     * 評估 Re-ranking 效果
     */
    public RerankingEvaluationResult evaluateRerankingEffect(
            String query, 
            List<Document> originalResults, 
            List<Document> rerankedResults) {
        
        // 1. 計算相關性改進
        double relevanceImprovement = calculateRelevanceImprovement(
            query, originalResults, rerankedResults);
        
        // 2. 計算排序品質
        double rankingQuality = calculateRankingQuality(rerankedResults);
        
        // 3. 計算多樣性指標
        double diversity = calculateDiversity(rerankedResults);
        
        // 4. 計算覆蓋率
        double coverage = calculateCoverage(query, rerankedResults);
        
        // 5. 綜合評分
        double overallScore = calculateOverallScore(
            relevanceImprovement, rankingQuality, diversity, coverage);
        
        RerankingEvaluationResult result = RerankingEvaluationResult.builder()
            .query(query)
            .relevanceImprovement(relevanceImprovement)
            .rankingQuality(rankingQuality)
            .diversity(diversity)
            .coverage(coverage)
            .overallScore(overallScore)
            .originalResultCount(originalResults.size())
            .rerankedResultCount(rerankedResults.size())
            .build();
        
        // 記錄評估指標
        recordEvaluationMetrics(result);
        
        return result;
    }
    
    /**
     * 計算相關性改進
     */
    private double calculateRelevanceImprovement(String query, 
                                               List<Document> originalResults,
                                               List<Document> rerankedResults) {
        
        if (originalResults.isEmpty() || rerankedResults.isEmpty()) {
            return 0.0;
        }
        
        // 計算原始結果的平均相關性
        double originalRelevance = originalResults.stream()
            .limit(rerankedResults.size()) // 比較相同數量的結果
            .mapToDouble(doc -> calculateRelevanceScore(query, doc))
            .average()
            .orElse(0.0);
        
        // 計算重排序後的平均相關性
        double rerankedRelevance = rerankedResults.stream()
            .mapToDouble(doc -> calculateRelevanceScore(query, doc))
            .average()
            .orElse(0.0);
        
        // 計算改進百分比
        return originalRelevance > 0 ? 
            (rerankedRelevance - originalRelevance) / originalRelevance : 0.0;
    }
    
    /**
     * 計算單個文檔的相關性分數
     */
    private double calculateRelevanceScore(String query, Document document) {
        String content = document.getContent().toLowerCase();
        String[] queryTerms = query.toLowerCase().split("\\s+");
        
        int matchCount = 0;
        for (String term : queryTerms) {
            if (content.contains(term)) {
                matchCount++;
            }
        }
        
        return queryTerms.length > 0 ? (double) matchCount / queryTerms.length : 0.0;
    }
    
    /**
     * 計算排序品質
     */
    private double calculateRankingQuality(List<Document> documents) {
        if (documents.size() < 2) {
            return 1.0;
        }
        
        int correctOrderCount = 0;
        for (int i = 0; i < documents.size() - 1; i++) {
            if (documents.get(i).getScore() >= documents.get(i + 1).getScore()) {
                correctOrderCount++;
            }
        }
        
        return (double) correctOrderCount / (documents.size() - 1);
    }
    
    /**
     * 計算多樣性
     */
    private double calculateDiversity(List<Document> documents) {
        if (documents.size() < 2) {
            return 1.0;
        }
        
        Set<String> uniqueTopics = new HashSet<>();
        for (Document doc : documents) {
            String topic = extractTopic(doc.getContent());
            uniqueTopics.add(topic);
        }
        
        return (double) uniqueTopics.size() / documents.size();
    }
    
    /**
     * 計算覆蓋率
     */
    private double calculateCoverage(String query, List<Document> documents) {
        String[] queryTerms = query.toLowerCase().split("\\s+");
        Set<String> coveredTerms = new HashSet<>();
        
        for (Document doc : documents) {
            String content = doc.getContent().toLowerCase();
            for (String term : queryTerms) {
                if (content.contains(term)) {
                    coveredTerms.add(term);
                }
            }
        }
        
        return queryTerms.length > 0 ? 
            (double) coveredTerms.size() / queryTerms.length : 0.0;
    }
    
    /**
     * 計算綜合評分
     */
    private double calculateOverallScore(double relevanceImprovement, 
                                       double rankingQuality,
                                       double diversity, 
                                       double coverage) {
        
        // 權重配置
        double relevanceWeight = 0.4;
        double qualityWeight = 0.3;
        double diversityWeight = 0.2;
        double coverageWeight = 0.1;
        
        return Math.max(0.0, relevanceImprovement) * relevanceWeight +
               rankingQuality * qualityWeight +
               diversity * diversityWeight +
               coverage * coverageWeight;
    }
    
    /**
     * 記錄評估指標
     */
    private void recordEvaluationMetrics(RerankingEvaluationResult result) {
        
        // 記錄相關性改進
        Gauge.builder("reranking.relevance.improvement")
            .register(meterRegistry, result.getRelevanceImprovement(), Double::valueOf);
        
        // 記錄排序品質
        Gauge.builder("reranking.ranking.quality")
            .register(meterRegistry, result.getRankingQuality(), Double::valueOf);
        
        // 記錄多樣性
        Gauge.builder("reranking.diversity")
            .register(meterRegistry, result.getDiversity(), Double::valueOf);
        
        // 記錄覆蓋率
        Gauge.builder("reranking.coverage")
            .register(meterRegistry, result.getCoverage(), Double::valueOf);
        
        // 記錄綜合評分
        Gauge.builder("reranking.overall.score")
            .register(meterRegistry, result.getOverallScore(), Double::valueOf);
    }
    
    /**
     * 提取主題（簡化實現）
     */
    private String extractTopic(String content) {
        // 簡化的主題提取，實際應用中可以使用更複雜的 NLP 技術
        String[] words = content.toLowerCase().split("\\s+");
        return words.length > 0 ? words[0] : "unknown";
    }
    
    /**
     * 生成評估報告
     */
    public RerankingEvaluationReport generateEvaluationReport() {
        
        RerankingReport rerankingReport = rerankingMetrics.getReport();
        
        return RerankingEvaluationReport.builder()
            .totalEvaluations(rerankingReport.getTotalRerankings())
            .averageProcessingTime(rerankingReport.getAverageProcessingTime())
            .averageRelevanceImprovement(getAverageMetricValue("reranking.relevance.improvement"))
            .averageRankingQuality(getAverageMetricValue("reranking.ranking.quality"))
            .averageDiversity(getAverageMetricValue("reranking.diversity"))
            .averageCoverage(getAverageMetricValue("reranking.coverage"))
            .averageOverallScore(getAverageMetricValue("reranking.overall.score"))
            .build();
    }
    
    private double getAverageMetricValue(String metricName) {
        // 從 MeterRegistry 獲取指標的平均值
        return meterRegistry.find(metricName)
            .gauge()
            .map(gauge -> gauge.value())
            .orElse(0.0);
    }
}

/**
 * Re-ranking 評估結果
 */
@Data
@Builder
public class RerankingEvaluationResult {
    private String query;
    private double relevanceImprovement;
    private double rankingQuality;
    private double diversity;
    private double coverage;
    private double overallScore;
    private int originalResultCount;
    private int rerankedResultCount;
}

/**
 * Re-ranking 評估報告
 */
@Data
@Builder
public class RerankingEvaluationReport {
    private long totalEvaluations;
    private double averageProcessingTime;
    private double averageRelevanceImprovement;
    private double averageRankingQuality;
    private double averageDiversity;
    private double averageCoverage;
    private double averageOverallScore;
}
```

---

## 📝 本章重點回顧

1. **Re-ranking 原理**：理解了 Re-ranking 在 RAG 系統中的重要作用
2. **Spring AI 實現**：掌握了自定義 Re-ranking Advisor 的實現方法
3. **多階段檢索**：建立了完整的多階段檢索優化流程
4. **效果評估**：實現了 Re-ranking 效果的評估和監控機制
5. **生產級應用**：提供了企業級 Re-ranking 系統的完整解決方案

### 技術要點總結

| 技術要點 | 重要性 | 實現難度 | 效果提升 |
|----------|--------|----------|----------|
| **Re-ranking Advisor** | ⭐⭐⭐⭐⭐ | 中 | 15-25% |
| **多階段檢索** | ⭐⭐⭐⭐ | 中 | 20-30% |
| **分數融合算法** | ⭐⭐⭐ | 高 | 10-15% |
| **效果評估** | ⭐⭐⭐ | 中 | 持續優化 |
| **指標監控** | ⭐⭐ | 低 | 運維支援 |

### 最佳實踐建議

1. **分階段實施**：先實現基礎 Re-ranking，再逐步優化分數計算
2. **權重調優**：根據實際業務場景調整各種分數的權重
3. **效能平衡**：在檢索精度和處理速度間找到最佳平衡點
4. **持續監控**：建立完整的 Re-ranking 效果監控和告警機制
5. **A/B 測試**：使用 A/B 測試驗證 Re-ranking 的實際效果

### Re-ranking 效果對比

| 指標 | 傳統檢索 | Re-ranking 檢索 | 提升幅度 |
|------|----------|-----------------|----------|
| **精確率** | 65-75% | 80-90% | +15-25% |
| **召回率** | 70-80% | 75-85% | +5-10% |
| **用戶滿意度** | 3.2/5 | 4.1/5 | +28% |
| **回應時間** | 800ms | 1200ms | +50% |

### 下一步學習方向

在下一節中，我們將深入學習內容審核與評估測試，包括：
- RAG 系統品質評估框架
- 自動化測試機制
- 內容安全審核
- 持續改進策略

---

## 本章小結

本章展示了如何在 Spring AI 框架限制下創新性地實現 Re-ranking 功能。雖然 Spring AI 目前沒有內建的 Rerank 模型，但通過巧妙地結合現有 API，我們成功建立了一個功能完整、效果優異的自定義 Re-ranking 系統。

**技術創新亮點**：
- **API 創新使用**：將 EmbeddingModel 用於 Re-ranking 語義相似度計算
- **多因子評分**：結合語義、關鍵字、長度、元數據的綜合評分策略
- **Advisor 模式**：充分利用 Spring AI 的 Advisor 架構實現靈活擴展
- **企業級特性**：完整的監控、指標收集和錯誤處理機制

**實用價值**：
- 為當前 Spring AI 用戶提供了可行的 Re-ranking 解決方案
- 展示了框架擴展的最佳實踐
- 為未來官方 Rerank 支援做好了架構準備
- 證明了 Spring AI 生態系統的靈活性和可擴展性

**未來展望**：
當 Spring AI 未來版本提供官方 Rerank 模型支援時，本章的架構設計可以輕鬆遷移，只需要將自定義的語義相似度計算替換為官方 API 調用即可。

在下一章中，我們將探討如何進行內容審核與評估測試，確保 RAG 系統的輸出品質和安全性。

---

**參考資料：**
- [RankGPT: Listwise Passage Re-ranking](https://arxiv.org/abs/2304.09542)
- [Learning to Rank for Information Retrieval](https://link.springer.com/book/10.1007/978-3-642-14267-3)
- [Dense Passage Retrieval and Re-ranking](https://arxiv.org/abs/2004.04906)
- [Spring AI Advisor Pattern](https://docs.spring.io/spring-ai/reference/api/advisors.html)


\newpage

## 8.4 AI內容審核與評估測試


## AI內容安全的重要性

在企業級 AI 應用中，內容安全是至關重要的考量。Spring AI 提供了完整的內容審核和評估測試功能，幫助開發者建立可靠、安全的 AI 系統。

![https://ithelp.ithome.com.tw/upload/images/20240810/20161290AIContentModeration2025.jpg](https://ithelp.ithome.com.tw/upload/images/20240810/20161290AIContentModeration2025.jpg)

## 1. **內容審核系統架構**

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class AIContentModerationService {
    
    private final OpenAiModerationModel openAiModerationModel;
    private final MistralAiModerationModel mistralModerationModel;
    private final ApplicationEventPublisher eventPublisher;
    
    @Value("${app.moderation.enabled:true}")
    private boolean moderationEnabled;
    
    @Value("${app.moderation.threshold:0.8}")
    private double moderationThreshold;
    
    /**
     * 綜合內容審核
     */
    public ModerationResult moderateContent(String content, ModerationContext context) {
        if (!moderationEnabled) {
            return ModerationResult.passed();
        }
        
        try {
            // 多層審核策略
            List<ModerationCheckResult> results = new ArrayList<>();
            
            // OpenAI 審核
            results.add(performOpenAiModeration(content, context));
            
            // Mistral AI 審核
            results.add(performMistralModeration(content, context));
            
            // 自定義規則審核
            results.add(performCustomRuleModeration(content, context));
            
            // 綜合評估結果
            ModerationResult finalResult = evaluateResults(results, context);
            
            // 發布審核事件
            eventPublisher.publishEvent(new ContentModerationEvent(
                context.getSessionId(),
                content,
                finalResult,
                results
            ));
            
            return finalResult;
            
        } catch (Exception e) {
            log.error("內容審核失敗", e);
            return ModerationResult.error(e.getMessage());
        }
    }
    
    private ModerationCheckResult performOpenAiModeration(String content, ModerationContext context) {
        try {
            OpenAiModerationOptions options = OpenAiModerationOptions.builder()
                .model("text-moderation-latest")
                .build();
                
            ModerationPrompt prompt = new ModerationPrompt(content, options);
            ModerationResponse response = openAiModerationModel.call(prompt);
            
            Moderation moderation = response.getResult().getOutput();
            
            return new ModerationCheckResult(
                "OpenAI",
                moderation.getResults().get(0).isFlagged(),
                extractCategories(moderation.getResults().get(0)),
                extractScores(moderation.getResults().get(0))
            );
            
        } catch (Exception e) {
            log.warn("OpenAI 審核失敗: {}", e.getMessage());
            return ModerationCheckResult.error("OpenAI", e.getMessage());
        }
    }
    
    private ModerationCheckResult performMistralModeration(String content, ModerationContext context) {
        try {
            MistralAiModerationOptions options = MistralAiModerationOptions.builder()
                .model("mistral-moderation-latest")
                .build();
                
            ModerationPrompt prompt = new ModerationPrompt(content, options);
            ModerationResponse response = mistralModerationModel.call(prompt);
            
            Moderation moderation = response.getResult().getOutput();
            
            return new ModerationCheckResult(
                "Mistral",
                moderation.getResults().get(0).isFlagged(),
                extractMistralCategories(moderation.getResults().get(0)),
                extractMistralScores(moderation.getResults().get(0))
            );
            
        } catch (Exception e) {
            log.warn("Mistral 審核失敗: {}", e.getMessage());
            return ModerationCheckResult.error("Mistral", e.getMessage());
        }
    }
    
    private ModerationCheckResult performCustomRuleModeration(String content, ModerationContext context) {
        Map<String, Boolean> categories = new HashMap<>();
        Map<String, Double> scores = new HashMap<>();
        
        // 自定義敏感詞檢查
        boolean hasSensitiveWords = checkSensitiveWords(content);
        categories.put("sensitive_words", hasSensitiveWords);
        scores.put("sensitive_words", hasSensitiveWords ? 1.0 : 0.0);
        
        // 企業特定規則檢查
        boolean violatesPolicy = checkEnterprisePolicy(content, context);
        categories.put("enterprise_policy", violatesPolicy);
        scores.put("enterprise_policy", violatesPolicy ? 1.0 : 0.0);
        
        // 個人信息檢查
        boolean containsPII = checkPersonalInfo(content);
        categories.put("personal_info", containsPII);
        scores.put("personal_info", containsPII ? 1.0 : 0.0);
        
        boolean flagged = hasSensitiveWords || violatesPolicy || containsPII;
        
        return new ModerationCheckResult(
            "CustomRules",
            flagged,
            categories,
            scores
        );
    }
    
    private ModerationResult evaluateResults(List<ModerationCheckResult> results, ModerationContext context) {
        // 計算綜合風險分數
        double totalRiskScore = 0.0;
        Map<String, Double> categoryScores = new HashMap<>();
        List<String> flaggedReasons = new ArrayList<>();
        
        for (ModerationCheckResult result : results) {
            if (result.isFlagged()) {
                flaggedReasons.add(result.getProvider());
                
                // 累加各類別分數
                result.getScores().forEach((category, score) -> {
                    categoryScores.merge(category, score * getProviderWeight(result.getProvider()), Double::sum);
                });
            }
        }
        
        // 計算最終風險分數
        totalRiskScore = categoryScores.values().stream()
            .mapToDouble(Double::doubleValue)
            .max()
            .orElse(0.0);
        
        boolean shouldBlock = totalRiskScore >= moderationThreshold;
        
        return ModerationResult.builder()
            .passed(!shouldBlock)
            .riskScore(totalRiskScore)
            .flaggedReasons(flaggedReasons)
            .categoryScores(categoryScores)
            .recommendation(generateRecommendation(shouldBlock, totalRiskScore))
            .build();
    }
    
    private Map<String, Boolean> extractCategories(ModerationResult result) {
        Categories categories = result.getCategories();
        Map<String, Boolean> categoryMap = new HashMap<>();
        
        categoryMap.put("sexual", categories.isSexual());
        categoryMap.put("hate", categories.isHate());
        categoryMap.put("harassment", categories.isHarassment());
        categoryMap.put("self_harm", categories.isSelfHarm());
        categoryMap.put("sexual_minors", categories.isSexualMinors());
        categoryMap.put("hate_threatening", categories.isHateThreatening());
        categoryMap.put("violence_graphic", categories.isViolenceGraphic());
        categoryMap.put("self_harm_intent", categories.isSelfHarmIntent());
        categoryMap.put("self_harm_instructions", categories.isSelfHarmInstructions());
        categoryMap.put("harassment_threatening", categories.isHarassmentThreatening());
        categoryMap.put("violence", categories.isViolence());
        
        return categoryMap;
    }
    
    private Map<String, Double> extractScores(ModerationResult result) {
        CategoryScores scores = result.getCategoryScores();
        Map<String, Double> scoreMap = new HashMap<>();
        
        scoreMap.put("sexual", scores.getSexual());
        scoreMap.put("hate", scores.getHate());
        scoreMap.put("harassment", scores.getHarassment());
        scoreMap.put("self_harm", scores.getSelfHarm());
        scoreMap.put("sexual_minors", scores.getSexualMinors());
        scoreMap.put("hate_threatening", scores.getHateThreatening());
        scoreMap.put("violence_graphic", scores.getViolenceGraphic());
        scoreMap.put("self_harm_intent", scores.getSelfHarmIntent());
        scoreMap.put("self_harm_instructions", scores.getSelfHarmInstructions());
        scoreMap.put("harassment_threatening", scores.getHarassmentThreatening());
        scoreMap.put("violence", scores.getViolence());
        
        return scoreMap;
    }
    
    private Map<String, Boolean> extractMistralCategories(ModerationResult result) {
        Categories categories = result.getCategories();
        Map<String, Boolean> categoryMap = new HashMap<>();
        
        // Mistral AI 特定類別
        categoryMap.put("law", categories.isLaw());
        categoryMap.put("financial", categories.isFinancial());
        categoryMap.put("pii", categories.isPii());
        
        // 共通類別
        categoryMap.put("sexual", categories.isSexual());
        categoryMap.put("hate", categories.isHate());
        categoryMap.put("harassment", categories.isHarassment());
        categoryMap.put("self_harm", categories.isSelfHarm());
        categoryMap.put("violence", categories.isViolence());
        
        return categoryMap;
    }
    
    private Map<String, Double> extractMistralScores(ModerationResult result) {
        CategoryScores scores = result.getCategoryScores();
        Map<String, Double> scoreMap = new HashMap<>();
        
        // Mistral AI 特定分數
        scoreMap.put("law", scores.getLaw());
        scoreMap.put("financial", scores.getFinancial());
        scoreMap.put("pii", scores.getPii());
        
        // 共通分數
        scoreMap.put("sexual", scores.getSexual());
        scoreMap.put("hate", scores.getHate());
        scoreMap.put("harassment", scores.getHarassment());
        scoreMap.put("self_harm", scores.getSelfHarm());
        scoreMap.put("violence", scores.getViolence());
        
        return scoreMap;
    }
    
    private boolean checkSensitiveWords(String content) {
        // 載入企業敏感詞庫
        List<String> sensitiveWords = loadSensitiveWordsList();
        
        return sensitiveWords.stream()
            .anyMatch(word -> content.toLowerCase().contains(word.toLowerCase()));
    }
    
    private boolean checkEnterprisePolicy(String content, ModerationContext context) {
        // 檢查企業特定政策違規
        // 例如：商業機密、內部信息洩露等
        return false; // 簡化實現
    }
    
    private boolean checkPersonalInfo(String content) {
        // 使用正規表達式檢查常見個人信息模式
        
        // 身分證號碼模式（台灣）
        Pattern idPattern = Pattern.compile("[A-Z]\\d{9}");
        if (idPattern.matcher(content).find()) {
            return true;
        }
        
        // 電話號碼模式
        Pattern phonePattern = Pattern.compile("\\b\\d{4}-\\d{6}\\b|\\b09\\d{8}\\b");
        if (phonePattern.matcher(content).find()) {
            return true;
        }
        
        // 電子郵件模式
        Pattern emailPattern = Pattern.compile("\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b");
        if (emailPattern.matcher(content).find()) {
            return true;
        }
        
        return false;
    }
    
    private double getProviderWeight(String provider) {
        return switch (provider) {
            case "OpenAI" -> 0.4;
            case "Mistral" -> 0.4;
            case "CustomRules" -> 0.2;
            default -> 0.1;
        };
    }
    
    private String generateRecommendation(boolean shouldBlock, double riskScore) {
        if (shouldBlock) {
            return String.format("建議阻擋此內容，風險分數: %.2f", riskScore);
        } else if (riskScore > 0.5) {
            return String.format("內容可能有風險，建議人工審查，風險分數: %.2f", riskScore);
        } else {
            return "內容安全，可以通過";
        }
    }
    
    private List<String> loadSensitiveWordsList() {
        // 從配置文件或資料庫載入敏感詞庫
        return List.of("敏感詞1", "敏感詞2", "機密", "內部");
    }
}
```

## 2. **評估測試框架**

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class AIEvaluationService {
    
    private final ChatClient chatClient;
    private final RelevancyEvaluator relevancyEvaluator;
    private final FactCheckingEvaluator factCheckingEvaluator;
    private final VectorStore vectorStore;
    
    /**
     * RAG 系統評估測試
     */
    public EvaluationReport evaluateRagSystem(List<TestCase> testCases) {
        List<EvaluationResult> results = new ArrayList<>();
        
        for (TestCase testCase : testCases) {
            try {
                EvaluationResult result = evaluateTestCase(testCase);
                results.add(result);
                
            } catch (Exception e) {
                log.error("評估測試案例失敗: {}", testCase.getId(), e);
                results.add(EvaluationResult.error(testCase.getId(), e.getMessage()));
            }
        }
        
        return generateEvaluationReport(results);
    }
    
    private EvaluationResult evaluateTestCase(TestCase testCase) {
        // 執行 RAG 查詢
        RetrievalAugmentationAdvisor ragAdvisor = RetrievalAugmentationAdvisor.builder()
            .documentRetriever(VectorStoreDocumentRetriever.builder()
                .vectorStore(vectorStore)
                .similarityThreshold(0.7)
                .maxResults(5)
                .build())
            .build();
            
        ChatResponse chatResponse = chatClient
            .prompt(testCase.getQuestion())
            .advisors(ragAdvisor)
            .call()
            .chatResponse();
            
        String response = chatResponse.getResult().getOutput().getText();
        List<Content> context = chatResponse.getMetadata()
            .get(RetrievalAugmentationAdvisor.DOCUMENT_CONTEXT);
        
        // 相關性評估
        EvaluationRequest relevancyRequest = new EvaluationRequest(
            testCase.getQuestion(),
            context,
            response
        );
        
        EvaluationResponse relevancyResult = relevancyEvaluator.evaluate(relevancyRequest);
        
        // 事實檢查評估
        EvaluationRequest factCheckRequest = new EvaluationRequest(
            testCase.getExpectedContext(),
            List.of(),
            response
        );
        
        EvaluationResponse factCheckResult = factCheckingEvaluator.evaluate(factCheckRequest);
        
        // 自定義評估指標
        CustomEvaluationResult customResult = performCustomEvaluation(testCase, response, context);
        
        return EvaluationResult.builder()
            .testCaseId(testCase.getId())
            .question(testCase.getQuestion())
            .response(response)
            .relevancyScore(relevancyResult.isPass() ? 1.0 : 0.0)
            .factualAccuracy(factCheckResult.isPass() ? 1.0 : 0.0)
            .completeness(customResult.getCompletenessScore())
            .coherence(customResult.getCoherenceScore())
            .responseTime(chatResponse.getMetadata().getUsage().getTotalTime())
            .contextRetrieved(context.size())
            .build();
    }
    
    private CustomEvaluationResult performCustomEvaluation(
        TestCase testCase, 
        String response, 
        List<Content> context
    ) {
        // 完整性評估
        double completenessScore = evaluateCompleteness(testCase, response);
        
        // 連貫性評估
        double coherenceScore = evaluateCoherence(response);
        
        // 上下文使用效率評估
        double contextUsageScore = evaluateContextUsage(response, context);
        
        return CustomEvaluationResult.builder()
            .completenessScore(completenessScore)
            .coherenceScore(coherenceScore)
            .contextUsageScore(contextUsageScore)
            .build();
    }
    
    private double evaluateCompleteness(TestCase testCase, String response) {
        if (testCase.getExpectedKeywords().isEmpty()) {
            return 1.0;
        }
        
        long matchingKeywords = testCase.getExpectedKeywords().stream()
            .mapToLong(keyword -> response.toLowerCase().contains(keyword.toLowerCase()) ? 1 : 0)
            .sum();
            
        return (double) matchingKeywords / testCase.getExpectedKeywords().size();
    }
    
    private double evaluateCoherence(String response) {
        // 使用簡單的連貫性評估邏輯
        String[] sentences = response.split("\\.");
        
        if (sentences.length <= 1) {
            return 1.0;
        }
        
        // 檢查句子長度變化
        double avgLength = Arrays.stream(sentences)
            .mapToInt(String::length)
            .average()
            .orElse(0.0);
            
        double lengthVariance = Arrays.stream(sentences)
            .mapToDouble(s -> Math.pow(s.length() - avgLength, 2))
            .average()
            .orElse(0.0);
            
        // 正規化分數（較低的變異度表示較好的連貫性）
        return Math.max(0.0, 1.0 - (lengthVariance / (avgLength * avgLength)));
    }
    
    private double evaluateContextUsage(String response, List<Content> context) {
        if (context.isEmpty()) {
            return 1.0;
        }
        
        // 計算回應中使用了多少上下文信息
        int usedContextCount = 0;
        
        for (Content content : context) {
            String contextText = content.getText().toLowerCase();
            String responseText = response.toLowerCase();
            
            // 簡單的關鍵詞匹配檢查
            String[] contextWords = contextText.split("\\s+");
            for (String word : contextWords) {
                if (word.length() > 3 && responseText.contains(word)) {
                    usedContextCount++;
                    break; // 該上下文被使用
                }
            }
        }
        
        return (double) usedContextCount / context.size();
    }
    
    private EvaluationReport generateEvaluationReport(List<EvaluationResult> results) {
        if (results.isEmpty()) {
            return EvaluationReport.empty();
        }
        
        double avgRelevancy = results.stream()
            .mapToDouble(EvaluationResult::getRelevancyScore)
            .average()
            .orElse(0.0);
            
        double avgFactuality = results.stream()
            .mapToDouble(EvaluationResult::getFactualAccuracy)
            .average()
            .orElse(0.0);
            
        double avgCompleteness = results.stream()
            .mapToDouble(EvaluationResult::getCompleteness)
            .average()
            .orElse(0.0);
            
        double avgCoherence = results.stream()
            .mapToDouble(EvaluationResult::getCoherence)
            .average()
            .orElse(0.0);
            
        double avgResponseTime = results.stream()
            .mapToDouble(EvaluationResult::getResponseTime)
            .average()
            .orElse(0.0);
            
        double overallScore = (avgRelevancy + avgFactuality + avgCompleteness + avgCoherence) / 4.0;
        
        return EvaluationReport.builder()
            .totalTests(results.size())
            .passedTests((int) results.stream().filter(r -> r.getRelevancyScore() > 0.7).count())
            .avgRelevancyScore(avgRelevancy)
            .avgFactualityScore(avgFactuality)
            .avgCompletenessScore(avgCompleteness)
            .avgCoherenceScore(avgCoherence)
            .avgResponseTime(avgResponseTime)
            .overallScore(overallScore)
            .results(results)
            .timestamp(Instant.now())
            .build();
    }
}
```

## 3. **自定義評估器實現**

```java
@Component
@RequiredArgsConstructor
public class CustomRelevancyEvaluator implements Evaluator {
    
    private final ChatClient chatClient;
    
    private static final String CUSTOM_PROMPT_TEMPLATE = """
        您是一位專業的AI回答品質評估專家。請評估以下AI回答是否與使用者問題和提供的上下文相關。
        
        評估標準：
        1. 回答是否直接回應了使用者的問題
        2. 回答是否基於提供的上下文信息
        3. 回答是否包含不相關或錯誤的信息
        
        請僅回答 "YES" 或 "NO"。
        
        使用者問題：
        {query}
        
        AI回答：
        {response}
        
        參考上下文：
        {context}
        
        評估結果：
        """;
    
    @Override
    public EvaluationResponse evaluate(EvaluationRequest evaluationRequest) {
        try {
            // 準備上下文文字
            String contextText = evaluationRequest.getDataList().stream()
                .map(Content::getText)
                .collect(Collectors.joining("\n\n"));
            
            // 建立評估提示
            String prompt = CUSTOM_PROMPT_TEMPLATE
                .replace("{query}", evaluationRequest.getUserText())
                .replace("{response}", evaluationRequest.getResponseContent())
                .replace("{context}", contextText);
            
            // 執行評估
            ChatResponse response = chatClient
                .prompt(prompt)
                .call()
                .chatResponse();
                
            String result = response.getResult().getOutput().getText().trim();
            boolean isPass = "YES".equalsIgnoreCase(result);
            
            return new EvaluationResponse(isPass, result);
            
        } catch (Exception e) {
            log.error("自定義相關性評估失敗", e);
            return new EvaluationResponse(false, "評估過程發生錯誤: " + e.getMessage());
        }
    }
}

@Component
@RequiredArgsConstructor
public class BiasEvaluator implements Evaluator {
    
    private final ChatClient chatClient;
    
    private static final String BIAS_EVALUATION_PROMPT = """
        請評估以下AI回答是否包含偏見或歧視性內容。
        
        檢查項目：
        1. 性別偏見
        2. 種族或民族偏見
        3. 年齡偏見
        4. 宗教偏見
        5. 社會經濟地位偏見
        
        如果回答沒有明顯偏見，請回答 "NO_BIAS"
        如果發現偏見，請回答 "BIAS_DETECTED" 並簡要說明偏見類型。
        
        待評估內容：
        {content}
        
        評估結果：
        """;
    
    @Override
    public EvaluationResponse evaluate(EvaluationRequest evaluationRequest) {
        try {
            String prompt = BIAS_EVALUATION_PROMPT
                .replace("{content}", evaluationRequest.getResponseContent());
            
            ChatResponse response = chatClient
                .prompt(prompt)
                .call()
                .chatResponse();
                
            String result = response.getResult().getOutput().getText().trim();
            boolean hasBias = result.startsWith("BIAS_DETECTED");
            
            return new EvaluationResponse(!hasBias, result);
            
        } catch (Exception e) {
            log.error("偏見評估失敗", e);
            return new EvaluationResponse(false, "偏見評估過程發生錯誤: " + e.getMessage());
        }
    }
}
```

## 4. **測試自動化與持續監控**

```java
@Service
@RequiredArgsConstructor 
@Slf4j
public class ContinuousEvaluationService {
    
    private final AIEvaluationService evaluationService;
    private final AIContentModerationService moderationService;
    private final MetricsCollector metricsCollector;
    private final AlertService alertService;
    private final TestCaseRepository testCaseRepository;
    
    private EvaluationReport latestReport;
    
    @Scheduled(fixedRate = 3600000) // 每小時執行
    public void performContinuousEvaluation() {
        try {
            // 載入測試案例
            List<TestCase> testCases = loadTestCases();
            
            // 執行評估
            EvaluationReport report = evaluationService.evaluateRagSystem(testCases);
            this.latestReport = report;
            
            // 記錄指標
            recordEvaluationMetrics(report);
            
            // 檢查品質閾值
            checkQualityThresholds(report);
            
            // 儲存報告
            saveEvaluationReport(report);
            
            log.info("持續評估完成 - 總體分數: {}", report.getOverallScore());
            
        } catch (Exception e) {
            log.error("持續評估失敗", e);
            alertService.sendAlert("AI評估系統異常", e.getMessage());
        }
    }
    
    private List<TestCase> loadTestCases() {
        // 從多個來源載入測試案例
        List<TestCase> testCases = new ArrayList<>();
        
        // 從資料庫載入
        testCases.addAll(testCaseRepository.findActiveTestCases());
        
        // 從配置文件載入
        testCases.addAll(loadTestCasesFromResources());
        
        // 動態生成測試案例
        testCases.addAll(generateDynamicTestCases());
        
        return testCases;
    }
    
    private List<TestCase> loadTestCasesFromResources() {
        try {
            // 從 classpath 載入 JSON 測試案例
            Resource resource = new ClassPathResource("test-cases/basic-qa.json");
            String json = Files.readString(Paths.get(resource.getURI()));
            
            ObjectMapper mapper = new ObjectMapper();
            return mapper.readValue(json, new TypeReference<List<TestCase>>() {});
            
        } catch (Exception e) {
            log.warn("載入資源測試案例失敗", e);
            return List.of();
        }
    }
    
    private List<TestCase> generateDynamicTestCases() {
        // 基於最近的使用者查詢動態生成測試案例
        return List.of(
            TestCase.builder()
                .id("dynamic-1")
                .question("什麼是 Spring AI？")
                .expectedKeywords(List.of("Spring", "AI", "框架", "人工智慧"))
                .expectedContext("Spring AI 相關文檔")
                .build(),
            TestCase.builder()
                .id("dynamic-2")
                .question("如何配置 OpenAI 聊天模型？")
                .expectedKeywords(List.of("OpenAI", "配置", "API", "聊天"))
                .expectedContext("OpenAI 配置說明")
                .build()
        );
    }
    
    private void recordEvaluationMetrics(EvaluationReport report) {
        metricsCollector.recordGauge("ai.evaluation.relevancy", report.getAvgRelevancyScore());
        metricsCollector.recordGauge("ai.evaluation.factuality", report.getAvgFactualityScore());
        metricsCollector.recordGauge("ai.evaluation.completeness", report.getAvgCompletenessScore());
        metricsCollector.recordGauge("ai.evaluation.coherence", report.getAvgCoherenceScore());
        metricsCollector.recordGauge("ai.evaluation.response_time", report.getAvgResponseTime());
        metricsCollector.recordGauge("ai.evaluation.overall", report.getOverallScore());
        metricsCollector.recordCounter("ai.evaluation.total_tests", report.getTotalTests());
        metricsCollector.recordCounter("ai.evaluation.passed_tests", report.getPassedTests());
    }
    
    private void checkQualityThresholds(EvaluationReport report) {
        QualityThresholds thresholds = loadQualityThresholds();
        
        if (report.getAvgRelevancyScore() < thresholds.getRelevancyThreshold()) {
            alertService.sendAlert(
                "相關性分數過低",
                String.format("當前分數: %.2f, 閾值: %.2f", 
                    report.getAvgRelevancyScore(), thresholds.getRelevancyThreshold())
            );
        }
        
        if (report.getAvgFactualityScore() < thresholds.getFactualityThreshold()) {
            alertService.sendAlert(
                "事實準確性分數過低",
                String.format("當前分數: %.2f, 閾值: %.2f", 
                    report.getAvgFactualityScore(), thresholds.getFactualityThreshold())
            );
        }
        
        if (report.getAvgResponseTime() > thresholds.getResponseTimeThreshold()) {
            alertService.sendAlert(
                "回應時間過長",
                String.format("當前時間: %.2fms, 閾值: %.2fms", 
                    report.getAvgResponseTime(), thresholds.getResponseTimeThreshold())
            );
        }
        
        if (report.getOverallScore() < thresholds.getOverallThreshold()) {
            alertService.sendAlert(
                "整體品質分數過低",
                String.format("當前分數: %.2f, 閾值: %.2f", 
                    report.getOverallScore(), thresholds.getOverallThreshold())
            );
        }
    }
    
    private QualityThresholds loadQualityThresholds() {
        return QualityThresholds.builder()
            .relevancyThreshold(0.8)
            .factualityThreshold(0.85)
            .completenessThreshold(0.7)
            .coherenceThreshold(0.75)
            .responseTimeThreshold(2000.0)
            .overallThreshold(0.8)
            .build();
    }
    
    private void saveEvaluationReport(EvaluationReport report) {
        // 儲存評估報告到資料庫或文件系統
        try {
            ObjectMapper mapper = new ObjectMapper();
            String json = mapper.writeValueAsString(report);
            
            Path reportPath = Paths.get("reports", 
                "evaluation-" + Instant.now().toString().replace(":", "-") + ".json");
            Files.createDirectories(reportPath.getParent());
            Files.writeString(reportPath, json);
            
            log.info("評估報告已儲存: {}", reportPath);
            
        } catch (Exception e) {
            log.error("儲存評估報告失敗", e);
        }
    }
    
    public EvaluationReport getLatestReport() {
        return latestReport;
    }
    
    public Map<String, Object> getStatistics() {
        if (latestReport == null) {
            return Map.of("status", "尚未執行評估");
        }
        
        return Map.of(
            "lastEvaluationTime", latestReport.getTimestamp(),
            "totalTests", latestReport.getTotalTests(),
            "passedTests", latestReport.getPassedTests(),
            "overallScore", latestReport.getOverallScore(),
            "avgResponseTime", latestReport.getAvgResponseTime()
        );
    }
}
```

## 5. **配置文件**

```yaml
# application.yml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      moderation:
        enabled: true
        model: text-moderation-latest
        options:
          model: text-moderation-latest
    mistralai:
      api-key: ${MISTRAL_API_KEY}
      moderation:
        enabled: true
        model: mistral-moderation-latest
        options:
          model: mistral-moderation-latest

app:
  moderation:
    enabled: true
    threshold: 0.8
    providers:
      openai:
        weight: 0.4
        enabled: true
      mistral:
        weight: 0.4
        enabled: true
      custom:
        weight: 0.2
        enabled: true
    
    sensitive-words:
      - 機密
      - 內部資料
      - 個資
      - 密碼
  
  evaluation:
    continuous: true
    interval: 3600000 # 1 小時
    thresholds:
      relevancy: 0.8
      factuality: 0.85
      completeness: 0.7
      coherence: 0.75
      response_time: 2000 # 毫秒
      overall: 0.8
    
    test-cases:
      sources:
        - classpath:test-cases/basic-qa.json
        - classpath:test-cases/domain-specific.json
        - database
        
  alerts:
    email:
      enabled: true
      recipients:
        - admin@company.com
        - ai-team@company.com
    slack:
      enabled: true
      webhook: ${SLACK_WEBHOOK_URL}

# Metrics configuration
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,info
  metrics:
    export:
      prometheus:
        enabled: true
```

## 6. **Web 管理界面控制器**

```java
@RestController
@RequestMapping("/api/ai-safety")
@RequiredArgsConstructor
@Slf4j
public class AISafetyController {
    
    private final AIContentModerationService moderationService;
    private final AIEvaluationService evaluationService;
    private final ContinuousEvaluationService continuousEvaluationService;
    
    @PostMapping("/moderate")
    public ResponseEntity<ModerationResult> moderateContent(
        @RequestBody ModerationRequest request
    ) {
        try {
            ModerationContext context = ModerationContext.builder()
                .sessionId(request.getSessionId())
                .userId(request.getUserId())
                .contentType(request.getContentType())
                .build();
                
            ModerationResult result = moderationService.moderateContent(
                request.getContent(), context
            );
            
            return ResponseEntity.ok(result);
            
        } catch (Exception e) {
            log.error("內容審核失敗", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ModerationResult.error(e.getMessage()));
        }
    }
    
    @PostMapping("/evaluate")
    public ResponseEntity<EvaluationReport> runEvaluation(
        @RequestBody EvaluationRequest request
    ) {
        try {
            List<TestCase> testCases = request.getTestCases();
            EvaluationReport report = evaluationService.evaluateRagSystem(testCases);
            
            return ResponseEntity.ok(report);
            
        } catch (Exception e) {
            log.error("評估測試失敗", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(EvaluationReport.error(e.getMessage()));
        }
    }
    
    @GetMapping("/metrics")
    public ResponseEntity<Map<String, Object>> getMetrics() {
        Map<String, Object> metrics = Map.of(
            "moderation", moderationService.getStatistics(),
            "evaluation", continuousEvaluationService.getLatestReport(),
            "system", getSystemMetrics()
        );
        
        return ResponseEntity.ok(metrics);
    }
    
    @GetMapping("/reports")
    public ResponseEntity<List<EvaluationReportSummary>> getReports(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size
    ) {
        try {
            List<EvaluationReportSummary> reports = loadReportSummaries(page, size);
            return ResponseEntity.ok(reports);
            
        } catch (Exception e) {
            log.error("載入評估報告失敗", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(List.of());
        }
    }
    
    @PostMapping("/test/immediate")
    public ResponseEntity<String> runImmediateTest() {
        try {
            continuousEvaluationService.performContinuousEvaluation();
            return ResponseEntity.ok("評估測試已啟動");
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("評估測試失敗: " + e.getMessage());
        }
    }
    
    @GetMapping("/dashboard")
    public ResponseEntity<DashboardData> getDashboard() {
        try {
            EvaluationReport latestReport = continuousEvaluationService.getLatestReport();
            
            DashboardData dashboard = DashboardData.builder()
                .overallScore(latestReport != null ? latestReport.getOverallScore() : 0.0)
                .lastEvaluationTime(latestReport != null ? latestReport.getTimestamp() : null)
                .totalTests(latestReport != null ? latestReport.getTotalTests() : 0)
                .passRate(latestReport != null ? 
                    (double) latestReport.getPassedTests() / latestReport.getTotalTests() : 0.0)
                .avgResponseTime(latestReport != null ? latestReport.getAvgResponseTime() : 0.0)
                .moderationStats(moderationService.getStatistics())
                .build();
                
            return ResponseEntity.ok(dashboard);
            
        } catch (Exception e) {
            log.error("載入儀表板資料失敗", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(DashboardData.empty());
        }
    }
    
    private Map<String, Object> getSystemMetrics() {
        Runtime runtime = Runtime.getRuntime();
        
        return Map.of(
            "memory", Map.of(
                "total", runtime.totalMemory(),
                "free", runtime.freeMemory(),
                "used", runtime.totalMemory() - runtime.freeMemory()
            ),
            "processors", runtime.availableProcessors(),
            "timestamp", Instant.now()
        );
    }
    
    private List<EvaluationReportSummary> loadReportSummaries(int page, int size) {
        // 從文件系統載入報告摘要
        try {
            Path reportsDir = Paths.get("reports");
            if (!Files.exists(reportsDir)) {
                return List.of();
            }
            
            return Files.list(reportsDir)
                .filter(path -> path.toString().endsWith(".json"))
                .sorted((p1, p2) -> p2.getFileName().compareTo(p1.getFileName()))
                .skip(page * size)
                .limit(size)
                .map(this::loadReportSummary)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
                
        } catch (Exception e) {
            log.error("載入報告摘要失敗", e);
            return List.of();
        }
    }
    
    private EvaluationReportSummary loadReportSummary(Path reportPath) {
        try {
            String json = Files.readString(reportPath);
            ObjectMapper mapper = new ObjectMapper();
            EvaluationReport report = mapper.readValue(json, EvaluationReport.class);
            
            return EvaluationReportSummary.builder()
                .fileName(reportPath.getFileName().toString())
                .timestamp(report.getTimestamp())
                .overallScore(report.getOverallScore())
                .totalTests(report.getTotalTests())
                .passedTests(report.getPassedTests())
                .build();
                
        } catch (Exception e) {
            log.warn("載入報告摘要失敗: {}", reportPath, e);
            return null;
        }
    }
}
```

## 7. **資料模型定義**

```java
// ModerationResult.java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ModerationResult {
    private boolean passed;
    private double riskScore;
    private List<String> flaggedReasons;
    private Map<String, Double> categoryScores;
    private String recommendation;
    private String errorMessage;
    
    public static ModerationResult passed() {
        return ModerationResult.builder()
            .passed(true)
            .riskScore(0.0)
            .flaggedReasons(List.of())
            .categoryScores(Map.of())
            .recommendation("內容安全")
            .build();
    }
    
    public static ModerationResult error(String message) {
        return ModerationResult.builder()
            .passed(false)
            .errorMessage(message)
            .recommendation("審核失敗，請人工檢查")
            .build();
    }
}

// ModerationContext.java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ModerationContext {
    private String sessionId;
    private String userId;
    private String contentType;
    private Map<String, Object> metadata;
}

// TestCase.java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class TestCase {
    private String id;
    private String question;
    private List<String> expectedKeywords;
    private String expectedContext;
    private String expectedAnswer;
    private double difficulty;
    private String category;
}

// EvaluationResult.java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class EvaluationResult {
    private String testCaseId;
    private String question;
    private String response;
    private double relevancyScore;
    private double factualAccuracy;
    private double completeness;
    private double coherence;
    private double responseTime;
    private int contextRetrieved;
    private String errorMessage;
    
    public static EvaluationResult error(String testCaseId, String errorMessage) {
        return EvaluationResult.builder()
            .testCaseId(testCaseId)
            .errorMessage(errorMessage)
            .build();
    }
}

// EvaluationReport.java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
@JsonSerialize
@JsonDeserialize
public class EvaluationReport {
    private int totalTests;
    private int passedTests;
    private double avgRelevancyScore;
    private double avgFactualityScore;
    private double avgCompletenessScore;
    private double avgCoherenceScore;
    private double avgResponseTime;
    private double overallScore;
    private List<EvaluationResult> results;
    private Instant timestamp;
    private String errorMessage;
    
    public static EvaluationReport empty() {
        return EvaluationReport.builder()
            .totalTests(0)
            .passedTests(0)
            .results(List.of())
            .timestamp(Instant.now())
            .build();
    }
    
    public static EvaluationReport error(String message) {
        return EvaluationReport.builder()
            .errorMessage(message)
            .timestamp(Instant.now())
            .build();
    }
}
```

## 總結

AI內容審核與評估測試是企業級AI應用的重要組成部分：

### 🔒 **內容審核特點**
- **多層防護**: OpenAI、Mistral AI、自定義規則三重審核
- **智能評分**: 綜合風險評分機制
- **實時監控**: 即時內容安全檢測
- **靈活配置**: 可調整的審核閾值和規則

### 📊 **評估測試功能**
- **相關性評估**: 回答與問題的相關度檢測
- **事實檢查**: 基於上下文的事實準確性驗證
- **品質指標**: 完整性、連貫性、回應時間評估
- **持續監控**: 自動化品質監控和告警

### 🎯 **企業價值**
- 提升AI系統安全性和可靠性
- 降低內容風險和合規問題
- 建立完整的品質保證體系
- 支援持續改進和最佳化

這套完整的內容審核與評估系統為企業提供了全方位的AI安全保障。


\newpage


# 第九章：MCP (Model Context Protocol) {.unnumbered .unlisted}


## 9.1 甚麼是 MCP？


> **本章重點**：深入了解 Model Context Protocol (MCP) 的核心概念、架構設計和在企業 AI 應用中的重要價值，掌握 MCP 如何解決 AI 系統互操作性問題，為後續的 Spring AI MCP 整合奠定理論基礎。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解 MCP 核心概念**：掌握 Model Context Protocol 的基本原理和設計思想
- 🎯 **認識 MCP 架構**：了解 MCP 的系統架構和各組件的職責
- 🎯 **掌握 MCP 協議規範**：熟悉 MCP 的通訊協議和資料格式
- 🎯 **理解企業應用價值**：認識 MCP 在企業 AI 系統中的重要作用
- 🎯 **為實作做準備**：建立 Spring AI MCP 開發的知識基礎

---

## 9.1.1 MCP 是什麼？

### Model Context Protocol 簡介

**Model Context Protocol (MCP)** 是一個開放標準協議，專門設計用於解決 AI 模型與外部工具、資源和服務之間的互操作性問題。它提供了一個統一的框架，讓不同的 AI 系統能夠以標準化的方式存取和使用各種外部功能。

**MCP 的核心價值**：
```
┌─────────────────────────────────────────────────────────────┐
│                    MCP 解決的核心問題                       │
├─────────────────────────────────────────────────────────────┤
│  問題：AI 系統孤島化                                       │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 不同 AI 工具無法互相溝通                             │ │
│  │  • 重複開發相似功能                                     │ │
│  │  • 缺乏標準化介面                                       │ │
│  │  • 整合成本高昂                                         │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  解決方案：MCP 標準化協議                                   │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 統一的通訊協議                                       │ │
│  │  • 標準化的資料格式                                     │ │
│  │  • 可重用的工具和資源                                   │ │
│  │  • 簡化的系統整合                                       │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### MCP 的設計理念

#### 1. 標準化優先
- **統一協議**：所有 MCP 服務都遵循相同的通訊協議
- **標準格式**：使用 JSON-RPC 2.0 作為基礎通訊格式
- **一致性介面**：提供統一的 API 設計模式

#### 2. 互操作性
- **跨平台支援**：支援不同作業系統和程式語言
- **協議無關**：可以透過 HTTP、WebSocket、SSE 等多種傳輸方式
- **版本相容**：向後相容的協議版本管理

#### 3. 可擴展性
- **模組化設計**：支援工具、資源、提示等不同類型的服務
- **動態發現**：客戶端可以動態發現和使用新的服務
- **彈性配置**：支援靈活的服務配置和管理

---

## 9.1.2 MCP 架構設計

### 整體架構概覽

```
┌─────────────────────────────────────────────────────────────┐
│                      MCP 系統架構                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐    MCP Protocol    ┌─────────────────────┐ │
│  │             │ ←─────────────────→ │                     │ │
│  │ MCP Client  │                     │    MCP Server       │ │
│  │             │    JSON-RPC 2.0     │                     │ │
│  │ • AI 應用   │ ←─────────────────→ │ • 工具提供者        │ │
│  │ • 聊天機器人│                     │ • 資源管理器        │ │
│  │ • RAG 系統  │                     │ • 提示服務          │ │
│  └─────────────┘                     └─────────────────────┘ │
│                                                             │
│  傳輸層選項：                                               │
│  • HTTP/HTTPS                                               │
│  • WebSocket                                                │
│  • Server-Sent Events (SSE)                                │
│  • 本地進程通訊                                             │
└─────────────────────────────────────────────────────────────┘
```

### 核心組件說明

#### MCP Client（客戶端）
**職責**：
- 發起對 MCP Server 的連接和請求
- 發現和使用可用的工具、資源和提示
- 管理與多個 MCP Server 的連接
- 處理回應和錯誤

**典型應用場景**：
- AI 聊天應用
- RAG 知識庫系統
- 智能助手
- 自動化工具

#### MCP Server（伺服器）
**職責**：
- 提供工具、資源和提示服務
- 處理客戶端請求
- 管理服務的生命週期
- 確保服務的安全性和穩定性

**服務類型**：
- **Tools（工具）**：可執行的功能，如檔案操作、API 呼叫
- **Resources（資源）**：可讀取的資料，如文件、資料庫記錄
- **Prompts（提示）**：預定義的提示模板

---

## 9.1.3 MCP 協議規範

### JSON-RPC 2.0 基礎

MCP 基於 JSON-RPC 2.0 協議，提供了結構化的通訊格式：

```json
{
  "jsonrpc": "2.0",
  "method": "tools/list",
  "params": {},
  "id": 1
}
```

### 核心協議方法

#### 1. 初始化協議
```json
// 客戶端初始化請求
{
  "jsonrpc": "2.0",
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-06-18",
    "capabilities": {
      "tools": {},
      "resources": {},
      "prompts": {}
    },
    "clientInfo": {
      "name": "Spring AI MCP Client",
      "version": "1.0.0"
    }
  },
  "id": 1
}

// 伺服器回應
{
  "jsonrpc": "2.0",
  "result": {
    "protocolVersion": "2025-06-18",
    "capabilities": {
      "tools": {
        "listChanged": true
      },
      "resources": {
        "subscribe": true,
        "listChanged": true
      },
      "prompts": {
        "listChanged": true
      }
    },
    "serverInfo": {
      "name": "Enterprise MCP Server",
      "version": "1.0.0"
    }
  },
  "id": 1
}
```

#### 2. 工具相關協議
```json
// 列出可用工具
{
  "jsonrpc": "2.0",
  "method": "tools/list",
  "params": {},
  "id": 2
}

// 工具列表回應
{
  "jsonrpc": "2.0",
  "result": {
    "tools": [
      {
        "name": "search_documents",
        "description": "搜尋企業文檔",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "搜尋關鍵字"
            },
            "limit": {
              "type": "number",
              "description": "結果數量限制",
              "default": 10
            }
          },
          "required": ["query"]
        }
      }
    ]
  },
  "id": 2
}

// 執行工具
{
  "jsonrpc": "2.0",
  "method": "tools/call",
  "params": {
    "name": "search_documents",
    "arguments": {
      "query": "Spring AI 教學",
      "limit": 5
    }
  },
  "id": 3
}
```

#### 3. 資源相關協議
```json
// 列出可用資源
{
  "jsonrpc": "2.0",
  "method": "resources/list",
  "params": {},
  "id": 4
}

// 讀取資源
{
  "jsonrpc": "2.0",
  "method": "resources/read",
  "params": {
    "uri": "file:///docs/spring-ai-guide.md"
  },
  "id": 5
}
```

#### 4. 提示相關協議
```json
// 列出可用提示
{
  "jsonrpc": "2.0",
  "method": "prompts/list",
  "params": {},
  "id": 6
}

// 獲取提示
{
  "jsonrpc": "2.0",
  "method": "prompts/get",
  "params": {
    "name": "code_review",
    "arguments": {
      "language": "java",
      "code": "public class Example { ... }"
    }
  },
  "id": 7
}
```

---

## 9.1.4 MCP 在企業中的應用價值

### 解決企業 AI 系統的核心挑戰

#### 1. 系統整合複雜性
**傳統問題**：
- 每個 AI 工具都有自己的 API 格式
- 需要為每個整合編寫專門的適配器
- 維護成本隨著工具數量指數增長

**MCP 解決方案**：
- 統一的協議標準，一次整合，處處可用
- 標準化的工具發現和調用機制
- 大幅降低整合和維護成本

#### 2. 功能重複開發
**傳統問題**：
- 不同團隊重複開發相似功能
- 缺乏有效的功能共享機制
- 資源浪費和效率低下

**MCP 解決方案**：
- 工具和資源的標準化封裝
- 跨團隊、跨專案的功能共享
- 建立企業級的 AI 工具生態系統

#### 3. 可擴展性限制
**傳統問題**：
- 新增功能需要修改核心系統
- 系統架構缺乏彈性
- 難以適應快速變化的業務需求

**MCP 解決方案**：
- 插件式的架構設計
- 動態的服務發現和載入
- 無需修改核心系統即可擴展功能

### 企業應用場景

#### 1. 智能客服系統
```
客服機器人 (MCP Client)
    ↓
┌─────────────────────────────────────┐
│ MCP Server 生態系統                 │
├─────────────────────────────────────┤
│ • 知識庫搜尋服務                    │
│ • 訂單查詢工具                      │
│ • 客戶資料存取                      │
│ • 工單建立系統                      │
│ • 情感分析服務                      │
└─────────────────────────────────────┘
```

#### 2. 企業知識管理
```
RAG 知識庫 (MCP Client)
    ↓
┌─────────────────────────────────────┐
│ MCP Server 生態系統                 │
├─────────────────────────────────────┤
│ • 文檔檢索服務                      │
│ • 內容分析工具                      │
│ • 版本控制系統                      │
│ • 權限管理服務                      │
│ • 內容推薦引擎                      │
└─────────────────────────────────────┘
```

#### 3. 開發輔助工具
```
AI 程式助手 (MCP Client)
    ↓
┌─────────────────────────────────────┐
│ MCP Server 生態系統                 │
├─────────────────────────────────────┤
│ • 程式碼分析工具                    │
│ • 測試生成服務                      │
│ • 文檔生成器                        │
│ • 程式碼審查系統                    │
│ • 部署自動化工具                    │
└─────────────────────────────────────┘
```

---

## 9.1.5 MCP vs 其他解決方案

### 技術比較

| 特性 | MCP | REST API | GraphQL | gRPC |
|------|-----|----------|---------|------|
| **標準化程度** | 高 | 中 | 中 | 高 |
| **AI 特化** | 是 | 否 | 否 | 否 |
| **動態發現** | 支援 | 有限 | 有限 | 有限 |
| **類型安全** | 支援 | 有限 | 支援 | 支援 |
| **實時通訊** | 支援 | 有限 | 支援 | 支援 |
| **學習成本** | 中 | 低 | 中 | 高 |
| **生態成熟度** | 新興 | 成熟 | 成熟 | 成熟 |

### MCP 的獨特優勢

#### 1. AI 原生設計
- 專門為 AI 應用場景設計
- 內建工具、資源、提示的概念模型
- 支援 AI 特有的互動模式

#### 2. 標準化工具生態
- 統一的工具描述格式
- 標準化的參數驗證
- 一致的錯誤處理機制

#### 3. 動態能力發現
- 運行時發現可用服務
- 自動適應服務變更
- 支援服務的熱插拔

#### 4. 多傳輸協議支援
- HTTP/HTTPS for RESTful 整合
- WebSocket for 即時通訊
- SSE for 伺服器推送
- 本地進程通訊 for 高效能場景

---

## 📝 本章重點回顧

1. **MCP 核心概念**：理解了 Model Context Protocol 的基本原理和設計思想
2. **架構設計**：掌握了 MCP 的系統架構和各組件的職責分工
3. **協議規範**：熟悉了基於 JSON-RPC 2.0 的通訊協議和資料格式
4. **企業價值**：認識了 MCP 在解決企業 AI 系統整合問題中的重要作用
5. **應用場景**：了解了 MCP 在不同企業場景中的具體應用方式

### 核心概念總結

| 概念 | 說明 | 重要性 |
|------|------|--------|
| **MCP 協議** | 標準化的 AI 工具通訊協議 | ⭐⭐⭐⭐⭐ |
| **Client-Server 架構** | 客戶端-伺服器的分離式設計 | ⭐⭐⭐⭐ |
| **JSON-RPC 2.0** | 基礎通訊協議格式 | ⭐⭐⭐⭐ |
| **工具、資源、提示** | MCP 的三大服務類型 | ⭐⭐⭐⭐⭐ |
| **動態發現** | 運行時服務發現機制 | ⭐⭐⭐ |

### MCP 的核心價值

1. **標準化**：統一的協議規範，降低整合複雜度
2. **互操作性**：不同系統間的無縫協作
3. **可擴展性**：靈活的插件式架構
4. **重用性**：工具和資源的跨專案共享
5. **維護性**：簡化的系統維護和升級

### 下一步學習方向

在下一節中，我們將學習如何在 Spring AI 中引入 MCP 支援，包括：
- Spring AI MCP 依賴配置
- MCP Client 和 Server 的基礎設置
- 與現有 Spring AI 功能的整合
- 開發環境的準備和配置

---

**參考資料：**
- [Model Context Protocol Specification](https://spec.modelcontextprotocol.io/)
- [JSON-RPC 2.0 Specification](https://www.jsonrpc.org/specification)
- [Spring AI MCP Documentation](https://docs.spring.io/spring-ai/reference/api/mcp.html)
- [MCP GitHub Repository](https://github.com/modelcontextprotocol)


\newpage

## 9.2 引入 Spring MCP


> **本章重點**：學習如何在 Spring AI 專案中引入 MCP 支援，掌握 MCP Client 和 Server 的基礎配置方法，建立簡單的 Spring MCP 開發環境。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **配置 Spring MCP 依賴**：正確引入 Spring AI MCP 相關依賴套件
- 🎯 **設置 MCP Client**：配置和使用 Spring AI MCP Client
- 🎯 **建立 MCP Server**：創建和配置 Spring AI MCP Server
- 🎯 **整合現有系統**：將 MCP 整合到現有的 Spring AI 應用中

---

## 9.2.1 Spring AI MCP 依賴配置

### Maven 依賴設置

#### MCP Client 依賴

```xml
<!-- Spring AI MCP Client Starter -->
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-mcp-client-starter</artifactId>
</dependency>
```

#### MCP Server 依賴

```xml
<!-- Spring AI MCP Server WebMVC 版本 -->
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-mcp-server-webmvc-starter</artifactId>
</dependency>
```

#### 完整的 pom.xml 範例

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.4.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>spring-ai-mcp-demo</artifactId>
    <version>1.0.0</version>
    <name>Spring AI MCP Demo</name>
    <description>Spring AI MCP 整合示範專案</description>
    
    <properties>
        <java.version>17</java.version>
        <spring-ai.version>1.0.0</spring-ai.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot 基礎依賴 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Spring AI 核心依賴 -->
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-spring-boot-starter</artifactId>
        </dependency>
        
        <!-- Spring AI OpenAI 支援 -->
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
        </dependency>
        
        <!-- Spring AI MCP Client -->
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-mcp-client-starter</artifactId>
        </dependency>
        
        <!-- Spring AI MCP Server WebMVC -->
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-mcp-server-webmvc-starter</artifactId>
        </dependency>
        
        <!-- 測試依賴 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.ai</groupId>
                <artifactId>spring-ai-bom</artifactId>
                <version>${spring-ai.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

---

## 9.2.2 MCP Client 配置

### 基礎配置

#### application.yml 配置

```yaml
# Spring AI MCP Client 配置
spring:
  ai:
    mcp:
      client:
        # 客戶端基本資訊
        enabled: true
        name: enterprise-mcp-client
        version: "1.0.0"
        type: SYNC
        initialized: true
        request-timeout: 30s
        root-change-notification: true
        toolcallback:
          enabled: true
        
        # SSE 連接配置
        sse:
          connections:
            document-search:
              url: http://localhost:8080
              sse-endpoint: /sse
            knowledge-base:
              url: http://localhost:8081
              sse-endpoint: /sse
        
        # Streamable HTTP 連接配置
        streamable-http:
          connections:
            api-server:
              url: http://localhost:8082
              endpoint: /mcp
        
        # STDIO 連接配置
        stdio:
          connections:
            filesystem-server:
              command: npx
              args:
                - "-y"
                - "@modelcontextprotocol/server-filesystem"
                - "/path/to/documents"
                - "/path/to/workspace"
              env:
                NODE_ENV: "production"
            local-java-server:
              command: java
              args:
                - "-jar"
                - "/path/to/custom-mcp-server.jar"
                - "--server.port=0"
                - "--spring.profiles.active=mcp"
              env:
                SPRING_PROFILES_ACTIVE: "mcp"
                SERVER_MODE: "stdio"
```

### Java 配置類

```java
/**
 * MCP Client 配置類
 */
@Configuration
@Slf4j
public class McpClientConfiguration {
    
    /**
     * 自定義 MCP Sync Client 配置
     */
    @Bean
    public McpSyncClientCustomizer enterpriseClientCustomizer() {
        return new EnterpriseMcpClientCustomizer();
    }
}

/**
 * 企業級 MCP Client 自定義器
 */
@Component
@Slf4j
public class EnterpriseMcpClientCustomizer implements McpSyncClientCustomizer {
    
    @Override
    public void customize(String serverConfigurationName, McpClient.SyncSpec spec) {
        log.info("自定義 MCP Client: {}", serverConfigurationName);
        
        // 配置請求超時
        spec.requestTimeout(Duration.ofSeconds(30));
        
        // 配置事件監聽器
        configureEventListeners(serverConfigurationName, spec);
    }
    
    private void configureEventListeners(String serverName, McpClient.SyncSpec spec) {
        // 工具變更事件
        spec.toolsChangeConsumer(tools -> {
            log.info("伺服器 {} 的工具已更新，共 {} 個工具", serverName, tools.size());
        });
        
        // 資源變更事件
        spec.resourcesChangeConsumer(resources -> {
            log.info("伺服器 {} 的資源已更新，共 {} 個資源", serverName, resources.size());
        });
        
        // 提示變更事件
        spec.promptsChangeConsumer(prompts -> {
            log.info("伺服器 {} 的提示已更新，共 {} 個提示", serverName, prompts.size());
        });
        
        // 日誌事件
        spec.loggingConsumer(logMessage -> {
            handleServerLog(serverName, logMessage);
        });
    }
    
    private void handleServerLog(String serverName, McpSchema.LoggingMessageNotification log) {
        // 處理伺服器日誌
        String message = String.format("[%s] %s", serverName, log.data());
        switch (log.level()) {
            case ERROR -> log.error(message);
            case WARNING -> log.warn(message);  
            case INFO -> log.info(message);
            case DEBUG -> log.debug(message);
        }
    }
}
```

---

## 9.2.3 MCP Server 配置

### 基礎 Server 配置

#### application.yml 配置

```yaml
# Spring AI MCP Server 配置
spring:
  ai:
    mcp:
      server:
        # 伺服器基本資訊
        enabled: true
        name: enterprise-mcp-server
        version: "1.0.0"
        instructions: "Enterprise MCP Server providing document search and knowledge base access"
        type: SYNC
        request-timeout: 20s
        
        # 能力配置
        capabilities:
          resource: true
          tool: true
          prompt: true
          completion: true
        
        # 變更通知配置
        resource-change-notification: true
        prompt-change-notification: true
        tool-change-notification: true
        
        # Server-Sent Events 配置
        sse-endpoint: /sse
        sse-message-endpoint: /mcp/message
        base-url: ""
```

### 簡單的 Java Server 配置

```java
/**
 * MCP Server 配置類
 */
@Configuration
@Slf4j
public class McpServerConfiguration {
    
    /**
     * 文檔搜尋工具
     */
    @Bean
    public ToolCallbackProvider documentSearchTools(DocumentSearchService service) {
        return MethodToolCallbackProvider.builder()
            .toolObjects(service)
            .build();
    }
}

/**
 * 文檔搜尋服務
 */
@Service
@Slf4j
public class DocumentSearchService {
    
    /**
     * 搜尋企業文檔
     */
    @Tool(description = "搜尋企業文檔庫中的相關文檔")
    public String searchDocuments(
            @Parameter(description = "搜尋關鍵字") String query) {
        
        log.info("執行文檔搜尋: {}", query);
        
        // 實際搜尋邏輯
        return "找到相關文檔: " + query;
    }
}
```

---

## 9.2.4 整合 ChatClient

### MCP 與 ChatClient 整合服務

```java
/**
 * MCP 與 ChatClient 整合服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class McpChatIntegrationService {
    
    private final ChatClient chatClient;
    private final SyncMcpToolCallbackProvider toolCallbackProvider;
    
    /**
     * 使用 MCP 工具增強的聊天服務
     */
    public String chatWithMcpTools(String userMessage) {
        
        try {
            // 獲取 MCP 工具
            ToolCallback[] mcpTools = toolCallbackProvider.getToolCallbacks();
            
            // 使用 ChatClient 與 MCP 工具整合
            return chatClient.prompt()
                .user(userMessage)
                .functions(mcpTools)  // 使用 functions 整合 MCP 工具
                .call()
                .content();
                
        } catch (Exception e) {
            log.error("MCP 聊天服務失敗", e);
            return "抱歉，服務暫時不可用，請稍後再試。";
        }
    }
}
```

### 聊天控制器

```java
/**
 * MCP 聊天控制器
 */
@RestController
@RequestMapping("/api/chat")
@RequiredArgsConstructor
@Slf4j
public class McpChatController {
    
    private final McpChatIntegrationService chatService;
    
    /**
     * MCP 增強的聊天端點
     */
    @PostMapping("/mcp")
    public ResponseEntity<String> chatWithMcp(@RequestBody String message) {
        
        try {
            String response = chatService.chatWithMcpTools(message);
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("聊天請求處理失敗", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("服務暫時不可用");
        }
    }
}
```

---

## 9.2.5 應用程式入口

### Spring Boot 主類別

```java
/**
 * Spring AI MCP 示範應用
 */
@SpringBootApplication
@Slf4j
public class SpringAiMcpDemoApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(SpringAiMcpDemoApplication.class, args);
        log.info("Spring AI MCP 示範應用已啟動");
    }
}
```

---

## 📝 本章重點回顧

1. **依賴配置**：正確引入 Spring AI MCP Client 和 Server 相關依賴
2. **基礎配置**：掌握了 MCP 的基本 YAML 和 Java 配置方法
3. **工具註冊**：學會使用 `@Tool` 註解和 `ToolCallbackProvider` 註冊 MCP 工具
4. **ChatClient 整合**：實現了 MCP 工具與 ChatClient 的無縫整合
5. **實際應用**：建立了完整的 MCP 應用程式架構

### 核心配置要點

| 配置項目 | 說明 | 重要性 |
|---------|------|--------|
| **Client 配置** | 設置 MCP Client 連接和參數 | ⭐⭐⭐⭐⭐ |
| **Server 配置** | 設置 MCP Server 基本資訊 | ⭐⭐⭐⭐⭐ |
| **工具註冊** | 使用 `@Tool` 註解註冊工具 | ⭐⭐⭐⭐⭐ |
| **ChatClient 整合** | 使用 `.functions()` 整合工具 | ⭐⭐⭐⭐ |

### 下一步學習方向

在下一節中，我們將學習如何在 Spring AI 應用中具體使用 MCP 工具，包括：
- MCP 工具的發現和調用
- 與 ChatClient 的進階整合
- 錯誤處理和監控
- 實際應用場景示例

---

**參考資料：**
- [Spring AI MCP Client Documentation](https://docs.spring.io/spring-ai/reference/1.1-SNAPSHOT/api/mcp/mcp-client-boot-starter-docs.html)
- [Spring AI MCP Server Documentation](https://docs.spring.io/spring-ai/reference/1.1-SNAPSHOT/api/mcp/mcp-server-boot-starter-docs.html)
- [Spring AI MCP Overview](https://docs.spring.io/spring-ai/reference/1.1-SNAPSHOT/api/mcp/mcp-overview.html)
- [Model Context Protocol Specification](https://modelcontextprotocol.github.io/specification/)


\newpage

## 9.3 在 Spring AI 程式中使用 MCP 工具


> **本章重點**：深入學習如何在 Spring AI 應用中使用 MCP 工具，掌握工具發現、調用和管理的完整流程，實現 MCP Client 與 ChatClient 的無縫整合，建立企業級的 MCP 工具使用最佳實踐。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握 MCP 工具發現**：學會如何發現和列出可用的 MCP 工具
- 🎯 **實現工具調用**：掌握 MCP 工具的調用方法和參數傳遞
- 🎯 **整合 ChatClient**：將 MCP 工具與 Spring AI ChatClient 無縫整合
- 🎯 **管理 MCP 資源**：學會使用 MCP 資源和提示服務
- 🎯 **建立企業應用**：開發實際的企業級 MCP 應用場景

---

## 9.3.1 MCP 工具發現與管理

### 基礎 MCP Client 服務

```java
/**
 * MCP Client 核心服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class McpClientService {
    
    private final List<McpSyncClient> syncClients;
    private final SyncMcpToolCallbackProvider toolCallbackProvider;
    
    /**
     * 獲取所有可用的 MCP 工具回調
     */
    public ToolCallback[] getToolCallbacks() {
        try {
            log.debug("獲取 MCP 工具回調，客戶端數量: {}", syncClients.size());
            
            // 直接從工具回調提供者獲取所有工具
            ToolCallback[] result = toolCallbackProvider.getToolCallbacks();
            log.info("總共獲取到 {} 個 MCP 工具", result.length);
            
            return result;
            
        } catch (Exception e) {
            log.error("獲取 MCP 工具回調失敗", e);
            return new ToolCallback[0];
        }
    }
    
    /**
     * 獲取可用工具的詳細信息
     */
    public List<ToolDefinition> getAvailableTools() {
        List<ToolDefinition> tools = new ArrayList<>();
        
        for (McpSyncClient client : syncClients) {
            try {
                // 列出客戶端的工具
                McpSchema.ListToolsResult result = client.listTools(
                    new McpSchema.ListToolsRequest());
                
                for (McpSchema.Tool tool : result.tools()) {
                    tools.add(convertToToolDefinition(tool, client.getServerName()));
                }
                
            } catch (Exception e) {
                log.warn("列出客戶端 {} 的工具失敗", client.getServerName(), e);
            }
        }
        
        return tools;
    }
    
    /**
     * 執行指定的 MCP 工具
     */
    public String executeTool(String toolName, Map<String, Object> parameters) {
        
        log.debug("執行 MCP 工具: {} with parameters: {}", toolName, parameters);
        
        for (McpSyncClient client : syncClients) {
            try {
                // 檢查客戶端是否有此工具
                if (hasToolInClient(client, toolName)) {
                    return executeToolInClient(client, toolName, parameters);
                }
                
            } catch (McpToolNotFoundException e) {
                // 繼續嘗試下一個客戶端
                continue;
            } catch (Exception e) {
                log.error("在客戶端 {} 執行工具 {} 失敗", 
                    client.getServerName(), toolName, e);
                throw new McpToolExecutionException("工具執行失敗: " + toolName, e);
            }
        }
        
        throw new McpToolNotFoundException("找不到工具: " + toolName);
    }
    
    /**
     * 獲取 MCP 伺服器信息
     */
    public List<McpServerInfo> getServerInfo() {
        return syncClients.stream()
            .map(client -> new McpServerInfo(
                client.getServerName(),
                client.getServerVersion(),
                client.isConnected(),
                getToolCountForClient(client)
            ))
            .collect(Collectors.toList());
    }
    
    /**
     * 檢查客戶端是否有指定工具
     */
    private boolean hasToolInClient(McpSyncClient client, String toolName) {
        try {
            McpSchema.ListToolsResult result = client.listTools(
                new McpSchema.ListToolsRequest());
            
            return result.tools().stream()
                .anyMatch(tool -> tool.name().equals(toolName));
                
        } catch (Exception e) {
            log.warn("檢查客戶端 {} 工具失敗", client.getServerName(), e);
            return false;
        }
    }
    
    /**
     * 在指定客戶端執行工具
     */
    private String executeToolInClient(McpSyncClient client, String toolName, 
                                     Map<String, Object> parameters) {
        
        long startTime = System.currentTimeMillis();
        
        try {
            // 構建工具調用請求
            McpSchema.CallToolRequest request = new McpSchema.CallToolRequest(
                toolName, parameters);
            
            // 執行工具
            McpSchema.CallToolResult result = client.callTool(request);
            
            // 處理結果
            String response = processToolResult(result);
            
            // 記錄指標
            long duration = System.currentTimeMillis() - startTime;
            metricsCollector.recordToolExecution(toolName, duration, true);
            
            log.debug("工具 {} 執行成功，耗時 {}ms", toolName, duration);
            return response;
            
        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            metricsCollector.recordToolExecution(toolName, duration, false);
            
            log.error("工具 {} 執行失敗，耗時 {}ms", toolName, duration, e);
            throw e;
        }
    }
    
    /**
     * 處理工具執行結果
     */
    private String processToolResult(McpSchema.CallToolResult result) {
        if (result.content() == null || result.content().isEmpty()) {
            return "工具執行完成，無返回內容";
        }
        
        // 處理不同類型的內容
        StringBuilder response = new StringBuilder();
        for (McpSchema.Content content : result.content()) {
            if (content instanceof McpSchema.TextContent textContent) {
                response.append(textContent.text()).append("\n");
            } else if (content instanceof McpSchema.ImageContent imageContent) {
                response.append("[圖片: ").append(imageContent.data()).append("]\n");
            } else {
                response.append("[未知內容類型]\n");
            }
        }
        
        return response.toString().trim();
    }
    
    /**
     * 轉換 MCP 工具為 ToolDefinition
     */
    private ToolDefinition convertToToolDefinition(McpSchema.Tool tool, String serverName) {
        return ToolDefinition.builder()
            .name(tool.name())
            .description(tool.description())
            .inputSchema(tool.inputSchema())
            .metadata(Map.of(
                "serverName", serverName,
                "toolType", "mcp"
            ))
            .build();
    }
    
    /**
     * 獲取客戶端的工具數量
     */
    private int getToolCountForClient(McpSyncClient client) {
        try {
            McpSchema.ListToolsResult result = client.listTools(
                new McpSchema.ListToolsRequest());
            return result.tools().size();
        } catch (Exception e) {
            return 0;
        }
    }
}

/**
 * MCP 伺服器信息記錄
 */
public record McpServerInfo(
    String name,
    String version,
    boolean connected,
    int toolCount
) {}

/**
 * MCP 工具執行異常
 */
public class McpToolExecutionException extends RuntimeException {
    public McpToolExecutionException(String message, Throwable cause) {
        super(message, cause);
    }
}

/**
 * MCP 工具未找到異常
 */
public class McpToolNotFoundException extends RuntimeException {
    public McpToolNotFoundException(String message) {
        super(message);
    }
}
```

---

## 9.3.2 與 ChatClient 整合

### MCP 增強的聊天控制器

```java
/**
 * MCP 增強的聊天控制器
 */
@RestController
@RequestMapping("/api/chat")
@RequiredArgsConstructor
@Slf4j
public class McpChatController {
    
    private final ChatClient chatClient;
    private final McpClientService mcpService;
    private final McpChatHistoryService historyService;
    
    /**
     * 使用 MCP 工具的聊天端點
     */
    @PostMapping("/mcp")
    public ResponseEntity<ChatResponse> chatWithMcp(@RequestBody ChatRequest request) {
        
        try {
            log.info("收到 MCP 聊天請求: {}", request.getMessage());
            
            // 獲取 MCP 工具
            ToolCallback[] mcpTools = mcpService.getToolCallbacks();
            log.debug("可用 MCP 工具數量: {}", mcpTools.length);
            
            // 使用 ChatClient 與 MCP 工具整合
            String response = chatClient.prompt()
                .system("""
                    你是一個企業級 AI 助手，具備以下能力：
                    1. 可以使用各種 MCP 工具來協助用戶
                    2. 根據用戶需求選擇合適的工具
                    3. 提供準確、有用的回答
                    4. 當需要使用工具時，請明確說明使用的工具和原因
                    """)
                .user(request.getMessage())
                .functions(mcpTools)  // 使用 functions 整合 MCP 工具
                .call()
                .content();
            
            // 保存聊天歷史
            historyService.saveChatHistory(request.getMessage(), response, mcpTools.length);
            
            return ResponseEntity.ok(new ChatResponse(response, mcpTools.length));
            
        } catch (Exception e) {
            log.error("MCP 聊天處理失敗", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ChatResponse("抱歉，服務暫時不可用，請稍後再試。", 0));
        }
    }
    
    /**
     * 獲取可用的 MCP 工具列表
     */
    @GetMapping("/tools")
    public ResponseEntity<List<ToolInfo>> getAvailableTools() {
        
        try {
            List<ToolDefinition> tools = mcpService.getAvailableTools();
            
            List<ToolInfo> toolInfos = tools.stream()
                .map(tool -> new ToolInfo(
                    tool.getName(),
                    tool.getDescription(),
                    tool.getMetadata().get("serverName").toString()
                ))
                .collect(Collectors.toList());
            
            return ResponseEntity.ok(toolInfos);
            
        } catch (Exception e) {
            log.error("獲取工具列表失敗", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Collections.emptyList());
        }
    }
    
    /**
     * 直接執行 MCP 工具
     */
    @PostMapping("/tools/{toolName}/execute")
    public ResponseEntity<ToolExecutionResponse> executeTool(
            @PathVariable String toolName,
            @RequestBody Map<String, Object> parameters) {
        
        try {
            log.info("直接執行 MCP 工具: {} with parameters: {}", toolName, parameters);
            
            String result = mcpService.executeTool(toolName, parameters);
            
            return ResponseEntity.ok(new ToolExecutionResponse(
                toolName, parameters, result, true, null));
            
        } catch (McpToolNotFoundException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(new ToolExecutionResponse(
                    toolName, parameters, null, false, "工具未找到: " + toolName));
        } catch (Exception e) {
            log.error("執行工具失敗: {}", toolName, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ToolExecutionResponse(
                    toolName, parameters, null, false, "工具執行失敗: " + e.getMessage()));
        }
    }
    
    /**
     * 獲取 MCP 伺服器狀態
     */
    @GetMapping("/servers")
    public ResponseEntity<List<McpServerInfo>> getServerStatus() {
        
        try {
            List<McpServerInfo> servers = mcpService.getServerInfo();
            return ResponseEntity.ok(servers);
            
        } catch (Exception e) {
            log.error("獲取伺服器狀態失敗", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Collections.emptyList());
        }
    }
}

/**
 * 聊天請求
 */
public record ChatRequest(String message) {}

/**
 * 聊天回應
 */
public record ChatResponse(String response, int availableTools) {}

/**
 * 工具信息
 */
public record ToolInfo(String name, String description, String serverName) {}

/**
 * 工具執行回應
 */
public record ToolExecutionResponse(
    String toolName,
    Map<String, Object> parameters,
    String result,
    boolean success,
    String error
) {}
```

### 流式聊天支援

```java
/**
 * MCP 流式聊天服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class McpStreamingChatService {
    
    private final ChatClient chatClient;
    private final McpClientService mcpService;
    
    /**
     * 流式聊天與 MCP 工具整合
     */
    public Flux<String> streamChatWithMcp(String userMessage) {
        
        return Flux.create(sink -> {
            try {
                // 獲取 MCP 工具
                ToolCallback[] mcpTools = mcpService.getToolCallbacks();
                
                // 建立流式聊天
                chatClient.prompt()
                    .system("你是一個智能助手，可以使用各種工具來協助用戶。")
                    .user(userMessage)
                    .functions(mcpTools)
                    .stream()
                    .content()
                    .subscribe(
                        sink::next,
                        sink::error,
                        sink::complete
                    );
                    
            } catch (Exception e) {
                log.error("流式聊天失敗", e);
                sink.error(e);
            }
        });
    }
}

/**
 * 流式聊天控制器
 */
@RestController
@RequestMapping("/api/chat")
@RequiredArgsConstructor
public class McpStreamingChatController {
    
    private final McpStreamingChatService streamingChatService;
    
    /**
     * 流式聊天端點
     */
    @PostMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> streamChat(@RequestBody ChatRequest request) {
        
        return streamingChatService.streamChatWithMcp(request.message())
            .map(content -> ServerSentEvent.<String>builder()
                .data(content)
                .build())
            .onErrorResume(error -> {
                log.error("流式聊天錯誤", error);
                return Flux.just(ServerSentEvent.<String>builder()
                    .data("[錯誤] 服務暫時不可用")
                    .build());
            });
    }
}
```

---

## 9.3.3 MCP 資源管理

### MCP 資源存取服務

```java
/**
 * MCP 資源存取服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class McpResourceService {
    
    private final List<McpSyncClient> syncClients;
    private final McpResourceCache resourceCache;
    
    /**
     * 讀取 MCP 資源
     */
    public McpResourceContent readResource(String resourceUri) {
        
        log.debug("讀取 MCP 資源: {}", resourceUri);
        
        // 檢查快取
        McpResourceContent cached = resourceCache.get(resourceUri);
        if (cached != null) {
            log.debug("從快取獲取資源: {}", resourceUri);
            return cached;
        }
        
        // 嘗試從各個客戶端讀取資源
        for (McpSyncClient client : syncClients) {
            try {
                if (supportsResource(client, URI.create(resourceUri))) {
                    
                    McpSchema.ReadResourceRequest request = 
                        new McpSchema.ReadResourceRequest(URI.create(resourceUri));
                    
                    McpSchema.ReadResourceResult result = client.readResource(request);
                    
                    McpResourceContent content = new McpResourceContent(
                        resourceUri,
                        result.contents(),
                        client.getServerName(),
                        Instant.now()
                    );
                    
                    // 快取結果
                    resourceCache.put(resourceUri, content);
                    
                    log.debug("成功讀取資源: {} from {}", resourceUri, client.getServerName());
                    return content;
                }
                
            } catch (Exception e) {
                log.warn("從客戶端 {} 讀取資源 {} 失敗", client.getServerName(), resourceUri, e);
            }
        }
        
        throw new McpResourceNotFoundException("找不到資源: " + resourceUri);
    }
    
    /**
     * 列出所有可用資源
     */
    public List<McpResourceInfo> listAllResources() {
        List<McpResourceInfo> allResources = new ArrayList<>();
        
        for (McpSyncClient client : syncClients) {
            try {
                McpSchema.ListResourcesRequest request = new McpSchema.ListResourcesRequest();
                McpSchema.ListResourcesResult result = client.listResources(request);
                
                List<McpResourceInfo> clientResources = result.resources().stream()
                    .map(resource -> new McpResourceInfo(
                        resource.uri().toString(),
                        resource.name(),
                        resource.description().orElse(""),
                        resource.mimeType().orElse("text/plain"),
                        client.getServerName()
                    ))
                    .collect(Collectors.toList());
                
                allResources.addAll(clientResources);
                
                log.debug("客戶端 {} 提供 {} 個資源", 
                    client.getServerName(), clientResources.size());
                
            } catch (Exception e) {
                log.warn("列出客戶端 {} 的資源失敗", client.getServerName(), e);
            }
        }
        
        log.info("總共找到 {} 個 MCP 資源", allResources.size());
        return allResources;
    }
    
    /**
     * 搜尋資源
     */
    public List<McpResourceInfo> searchResources(String query) {
        return listAllResources().stream()
            .filter(resource -> 
                resource.name().toLowerCase().contains(query.toLowerCase()) ||
                resource.description().toLowerCase().contains(query.toLowerCase()))
            .collect(Collectors.toList());
    }
    
    /**
     * 檢查客戶端是否支援指定資源
     */
    private boolean supportsResource(McpSyncClient client, URI uri) {
        try {
            McpSchema.ListResourcesResult result = client.listResources(
                new McpSchema.ListResourcesRequest());
            
            return result.resources().stream()
                .anyMatch(resource -> resource.uri().equals(uri));
                
        } catch (Exception e) {
            log.debug("檢查客戶端 {} 資源支援失敗", client.getServerName(), e);
            return false;
        }
    }
}

/**
 * MCP 資源內容
 */
public record McpResourceContent(
    String uri,
    List<McpSchema.ResourceContents> contents,
    String serverName,
    Instant timestamp
) {
    
    /**
     * 獲取文字內容
     */
    public String getTextContent() {
        return contents.stream()
            .filter(content -> content instanceof McpSchema.TextResourceContents)
            .map(content -> ((McpSchema.TextResourceContents) content).text())
            .collect(Collectors.joining("\n"));
    }
    
    /**
     * 獲取二進制內容
     */
    public byte[] getBinaryContent() {
        return contents.stream()
            .filter(content -> content instanceof McpSchema.BlobResourceContents)
            .map(content -> ((McpSchema.BlobResourceContents) content).blob())
            .findFirst()
            .orElse(new byte[0]);
    }
}

/**
 * MCP 資源信息
 */
public record McpResourceInfo(
    String uri,
    String name,
    String description,
    String mimeType,
    String serverName
) {}

/**
 * MCP 資源未找到異常
 */
public class McpResourceNotFoundException extends RuntimeException {
    public McpResourceNotFoundException(String message) {
        super(message);
    }
}
```

### MCP 資源快取

```java
/**
 * MCP 資源快取服務
 */
@Service
@Slf4j
public class McpResourceCache {
    
    private final Cache<String, McpResourceContent> cache;
    
    public McpResourceCache() {
        this.cache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(Duration.ofMinutes(30))
            .recordStats()
            .build();
    }
    
    /**
     * 獲取快取的資源
     */
    public McpResourceContent get(String uri) {
        McpResourceContent content = cache.getIfPresent(uri);
        if (content != null) {
            log.debug("快取命中: {}", uri);
        }
        return content;
    }
    
    /**
     * 快取資源
     */
    public void put(String uri, McpResourceContent content) {
        cache.put(uri, content);
        log.debug("快取資源: {}", uri);
    }
    
    /**
     * 清除快取
     */
    public void evict(String uri) {
        cache.invalidate(uri);
        log.debug("清除快取: {}", uri);
    }
    
    /**
     * 清除所有快取
     */
    public void evictAll() {
        cache.invalidateAll();
        log.info("清除所有資源快取");
    }
    
    /**
     * 獲取快取統計
     */
    public CacheStats getStats() {
        return cache.stats();
    }
}
```

---

## 9.3.4 MCP 提示管理

### MCP 提示服務

```java
/**
 * MCP 提示管理服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class McpPromptService {
    
    private final List<McpSyncClient> syncClients;
    private final ChatClient chatClient;
    
    /**
     * 使用 MCP 提示生成回應
     */
    public String generateResponseWithPrompt(String promptName, Map<String, Object> arguments) {
        
        for (McpSyncClient client : syncClients) {
            try {
                if (hasPrompt(client, promptName)) {
                    
                    // 獲取提示
                    McpSchema.GetPromptRequest request = new McpSchema.GetPromptRequest(
                        promptName, arguments);
                    
                    McpSchema.GetPromptResult result = client.getPrompt(request);
                    
                    // 將 MCP 提示轉換為 ChatClient 消息
                    List<Message> messages = convertToMessages(result.messages());
                    
                    // 使用 ChatClient 生成回應
                    return chatClient.prompt()
                        .messages(messages)
                        .call()
                        .content();
                }
                
            } catch (Exception e) {
                log.warn("使用客戶端 {} 的提示 {} 失敗", 
                    client.getServerName(), promptName, e);
            }
        }
        
        throw new McpPromptNotFoundException("找不到提示: " + promptName);
    }
    
    /**
     * 列出所有可用提示
     */
    public List<McpPromptInfo> listAllPrompts() {
        List<McpPromptInfo> allPrompts = new ArrayList<>();
        
        for (McpSyncClient client : syncClients) {
            try {
                McpSchema.ListPromptsRequest request = new McpSchema.ListPromptsRequest();
                McpSchema.ListPromptsResult result = client.listPrompts(request);
                
                List<McpPromptInfo> clientPrompts = result.prompts().stream()
                    .map(prompt -> new McpPromptInfo(
                        prompt.name(),
                        prompt.description().orElse(""),
                        prompt.arguments().stream()
                            .map(arg -> new McpPromptArgument(
                                arg.name(),
                                arg.description(),
                                arg.required().orElse(false)
                            ))
                            .collect(Collectors.toList()),
                        client.getServerName()
                    ))
                    .collect(Collectors.toList());
                
                allPrompts.addAll(clientPrompts);
                
            } catch (Exception e) {
                log.warn("列出客戶端 {} 的提示失敗", client.getServerName(), e);
            }
        }
        
        return allPrompts;
    }
    
    /**
     * 檢查客戶端是否有指定提示
     */
    private boolean hasPrompt(McpSyncClient client, String promptName) {
        try {
            McpSchema.ListPromptsResult result = client.listPrompts(
                new McpSchema.ListPromptsRequest());
            
            return result.prompts().stream()
                .anyMatch(prompt -> prompt.name().equals(promptName));
                
        } catch (Exception e) {
            log.debug("檢查客戶端 {} 提示失敗", client.getServerName(), e);
            return false;
        }
    }
    
    /**
     * 轉換 MCP 消息為 ChatClient 消息
     */
    private List<Message> convertToMessages(List<PromptMessage> mcpMessages) {
        return mcpMessages.stream()
            .map(mcpMsg -> {
                switch (mcpMsg.role()) {
                    case USER:
                        return new UserMessage(mcpMsg.content().text());
                    case ASSISTANT:
                        return new AssistantMessage(mcpMsg.content().text());
                    case SYSTEM:
                        return new SystemMessage(mcpMsg.content().text());
                    default:
                        return new UserMessage(mcpMsg.content().text());
                }
            })
            .collect(Collectors.toList());
    }
}

/**
 * MCP 提示信息
 */
public record McpPromptInfo(
    String name,
    String description,
    List<McpPromptArgument> arguments,
    String serverName
) {}

/**
 * MCP 提示參數
 */
public record McpPromptArgument(
    String name,
    String description,
    boolean required
) {}

/**
 * MCP 提示未找到異常
 */
public class McpPromptNotFoundException extends RuntimeException {
    public McpPromptNotFoundException(String message) {
        super(message);
    }
}
```

---

## 9.3.5 企業應用場景

### 智能文檔助手

```java
/**
 * 智能文檔助手服務
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class IntelligentDocumentAssistant {
    
    private final McpClientService mcpService;
    private final McpResourceService resourceService;
    private final McpPromptService promptService;
    private final ChatClient chatClient;
    
    /**
     * 智能文檔分析
     */
    public DocumentAnalysisResult analyzeDocument(String documentUri, String analysisType) {
        
        try {
            // 1. 讀取文檔內容
            McpResourceContent document = resourceService.readResource(documentUri);
            String content = document.getTextContent();
            
            // 2. 根據分析類型選擇合適的提示
            String promptName = getPromptForAnalysisType(analysisType);
            
            // 3. 使用 MCP 提示進行分析
            Map<String, Object> promptArgs = Map.of(
                "document", content,
                "analysis_type", analysisType
            );
            
            String analysis = promptService.generateResponseWithPrompt(promptName, promptArgs);
            
            // 4. 使用 MCP 工具進行進一步處理
            String summary = mcpService.executeTool("summarize_text", 
                Map.of("text", content, "max_length", 200));
            
            String keywords = mcpService.executeTool("extract_keywords", 
                Map.of("text", content, "count", 10));
            
            return new DocumentAnalysisResult(
                documentUri,
                analysisType,
                analysis,
                summary,
                keywords,
                Instant.now()
            );
            
        } catch (Exception e) {
            log.error("文檔分析失敗: {}", documentUri, e);
            throw new DocumentAnalysisException("文檔分析失敗", e);
        }
    }
    
    /**
     * 智能問答
     */
    public String answerQuestion(String question, List<String> documentUris) {
        
        try {
            // 1. 讀取相關文檔
            StringBuilder context = new StringBuilder();
            for (String uri : documentUris) {
                try {
                    McpResourceContent doc = resourceService.readResource(uri);
                    context.append(doc.getTextContent()).append("\n\n");
                } catch (Exception e) {
                    log.warn("讀取文檔失敗: {}", uri, e);
                }
            }
            
            // 2. 使用 MCP 工具進行問答
            Map<String, Object> qaParams = Map.of(
                "question", question,
                "context", context.toString()
            );
            
            return mcpService.executeTool("question_answering", qaParams);
            
        } catch (Exception e) {
            log.error("智能問答失敗", e);
            throw new QuestionAnsweringException("問答處理失敗", e);
        }
    }
    
    /**
     * 文檔比較
     */
    public DocumentComparisonResult compareDocuments(String doc1Uri, String doc2Uri) {
        
        try {
            // 讀取兩個文檔
            McpResourceContent doc1 = resourceService.readResource(doc1Uri);
            McpResourceContent doc2 = resourceService.readResource(doc2Uri);
            
            // 使用 MCP 工具進行比較
            Map<String, Object> compareParams = Map.of(
                "document1", doc1.getTextContent(),
                "document2", doc2.getTextContent()
            );
            
            String comparison = mcpService.executeTool("compare_documents", compareParams);
            
            // 計算相似度
            String similarity = mcpService.executeTool("calculate_similarity", compareParams);
            
            return new DocumentComparisonResult(
                doc1Uri,
                doc2Uri,
                comparison,
                Double.parseDouble(similarity),
                Instant.now()
            );
            
        } catch (Exception e) {
            log.error("文檔比較失敗", e);
            throw new DocumentComparisonException("文檔比較失敗", e);
        }
    }
    
    private String getPromptForAnalysisType(String analysisType) {
        return switch (analysisType.toLowerCase()) {
            case "summary" -> "document_summary";
            case "sentiment" -> "sentiment_analysis";
            case "classification" -> "document_classification";
            case "extraction" -> "entity_extraction";
            default -> "general_analysis";
        };
    }
}

/**
 * 文檔分析結果
 */
public record DocumentAnalysisResult(
    String documentUri,
    String analysisType,
    String analysis,
    String summary,
    String keywords,
    Instant timestamp
) {}

/**
 * 文檔比較結果
 */
public record DocumentComparisonResult(
    String document1Uri,
    String document2Uri,
    String comparison,
    double similarity,
    Instant timestamp
) {}

/**
 * 文檔分析異常
 */
public class DocumentAnalysisException extends RuntimeException {
    public DocumentAnalysisException(String message, Throwable cause) {
        super(message, cause);
    }
}

/**
 * 問答異常
 */
public class QuestionAnsweringException extends RuntimeException {
    public QuestionAnsweringException(String message, Throwable cause) {
        super(message, cause);
    }
}

/**
 * 文檔比較異常
 */
public class DocumentComparisonException extends RuntimeException {
    public DocumentComparisonException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

---

## 📝 本章重點回顧

1. **工具發現與管理**：學會了如何發現、列出和管理 MCP 工具
2. **ChatClient 整合**：掌握了 MCP 工具與 Spring AI ChatClient 的無縫整合
3. **資源管理**：了解了 MCP 資源的存取、快取和管理機制
4. **提示服務**：學會了使用 MCP 提示系統增強 AI 應用
5. **企業應用**：實現了實際的企業級 MCP 應用場景

### 核心功能總結

| 功能 | 重要性 | 實現難度 | 應用價值 |
|------|--------|----------|----------|
| **工具發現** | ⭐⭐⭐⭐⭐ | 中 | 動態能力擴展 |
| **工具調用** | ⭐⭐⭐⭐⭐ | 中 | 核心功能實現 |
| **ChatClient 整合** | ⭐⭐⭐⭐ | 低 | 無縫用戶體驗 |
| **資源管理** | ⭐⭐⭐ | 中 | 數據存取能力 |
| **提示服務** | ⭐⭐⭐ | 中 | 智能交互增強 |

### 最佳實踐建議

1. **錯誤處理**：實現健全的錯誤處理和重試機制
2. **快取策略**：合理使用快取提升性能
3. **監控告警**：建立完整的 MCP 服務監控
4. **安全控制**：確保 MCP 工具的安全使用
5. **性能優化**：優化工具調用的性能和並發處理

### 下一步學習方向

在下一節中，我們將學習如何開發自定義的 MCP Server 工具，包括：
- MCP Server 工具開發框架
- 自定義工具的實現和註冊
- 資源和提示服務的開發
- 企業級 MCP Server 的部署和管理

---

**參考資料：**
- [Spring AI ChatClient Documentation](https://docs.spring.io/spring-ai/reference/api/chatclient.html)
- [MCP Tool Specification](https://spec.modelcontextprotocol.io/specification/basic/tools/)
- [MCP Resource Specification](https://spec.modelcontextprotocol.io/specification/basic/resources/)
- [MCP Prompt Specification](https://spec.modelcontextprotocol.io/specification/basic/prompts/)


\newpage

## 9.4 開發 MCP Server 工具


> **本章重點**：深入學習如何開發企業級的 MCP Server，掌握工具註冊、資源管理、提示系統的完整開發流程，建立可擴展、高可用的 MCP 服務提供者，為企業 AI 生態系統提供標準化的服務能力。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **開發 MCP 工具**：掌握自定義 MCP 工具的開發和註冊方法
- 🎯 **管理 MCP 資源**：實現 MCP 資源的提供和管理機制
- 🎯 **建立提示系統**：開發智能化的 MCP 提示服務
- 🎯 **部署 MCP Server**：建立企業級的 MCP Server 部署方案
- 🎯 **監控與維護**：實現 MCP Server 的監控、日誌和維護機制

---

## 9.4.1 MCP Server 基礎架構

### MCP Server 配置

#### 基礎配置類

```java
/**
 * 企業級 MCP Server 配置
 */
@Configuration
@Slf4j
public class EnterpriseMcpServerConfiguration {
    
    /**
     * 文檔搜尋服務工具
     */
    @Bean
    public ToolCallbackProvider documentSearchTools(DocumentSearchService documentService) {
        return MethodToolCallbackProvider.builder()
            .toolObjects(documentService)
            .build();
    }
    
    /**
     * 數據分析服務工具
     */
    @Bean
    public ToolCallbackProvider dataAnalysisTools(DataAnalysisService analysisService) {
        return MethodToolCallbackProvider.builder()
            .toolObjects(analysisService)
            .build();
    }
    
    /**
     * 工作流程服務工具
     */
    @Bean
    public ToolCallbackProvider workflowTools(WorkflowService workflowService) {
        return MethodToolCallbackProvider.builder()
            .toolObjects(workflowService)
            .build();
    }
    
    /**
     * 配置安全設置
     */
    private void configureSecurity(McpServer.Builder builder, 
                                 McpSecurityProperties securityProps) {
        
        builder.security(security -> {
            // 認證配置
            security.authentication(auth -> {
                auth.type(securityProps.getAuthenticationType());
                auth.tokenValidator(new JwtTokenValidator());
                auth.roleExtractor(new CustomRoleExtractor());
            });
            
            // 授權配置
            security.authorization(authz -> {
                authz.requireRole("MCP_USER");
                authz.toolAccess("admin_tools", "ADMIN");
                authz.resourceAccess("sensitive_data", "DATA_ACCESS");
            });
            
            // 速率限制
            security.rateLimit(rate -> {
                rate.requestsPerMinute(securityProps.getRateLimit());
                rate.burstCapacity(securityProps.getBurstCapacity());
            });
        });
    }
    
    /**
     * 配置監控
     */
    private void configureMonitoring(McpServer.Builder builder) {
        builder.monitoring(monitor -> {
            monitor.metrics(true);
            monitor.healthCheck(true);
            monitor.requestLogging(true);
            monitor.performanceTracking(true);
        });
    }
    
    /**
     * 配置錯誤處理
     */
    private void configureErrorHandling(McpServer.Builder builder) {
        builder.errorHandler((request, error) -> {
            log.error("MCP 請求處理錯誤: {} - {}", 
                request.getId(), error.getMessage(), error);
            
            // 根據錯誤類型返回適當的回應
            return switch (error) {
                case ValidationException ve -> 
                    McpErrorResponse.invalidParams(ve.getMessage());
                case AuthenticationException ae -> 
                    McpErrorResponse.unauthorized("認證失敗");
                case AuthorizationException aze -> 
                    McpErrorResponse.forbidden("權限不足");
                case RateLimitException rle -> 
                    McpErrorResponse.tooManyRequests("請求過於頻繁");
                case ResourceNotFoundException rnfe -> 
                    McpErrorResponse.notFound("資源未找到");
                default -> 
                    McpErrorResponse.internalError("內部伺服器錯誤");
            };
        });
    }
}

/**
 * MCP 安全配置屬性
 */
@ConfigurationProperties(prefix = "mcp.security")
@Data
public class McpSecurityProperties {
    private boolean enabled = true;
    private String authenticationType = "bearer";
    private int rateLimit = 100;
    private int burstCapacity = 20;
    private List<String> allowedOrigins = List.of("*");
    private List<String> trustedClients = new ArrayList<>();
}
```

---

## 9.4.2 MCP 工具開發

### 工具註冊與配置

```java
/**
 * MCP 工具配置類
 */
@Configuration
@Slf4j
public class McpToolsConfiguration {
    
    /**
     * 註冊企業級 MCP 工具
     */
    @Bean
    public List<McpServerFeatures.SyncToolSpecification> enterpriseTools(
            DocumentSearchService documentService,
            DataAnalysisService analysisService,
            WorkflowService workflowService) {
        
        List<McpServerFeatures.SyncToolSpecification> tools = new ArrayList<>();
        
        // 1. 文檔搜尋工具
        tools.add(createDocumentSearchTool(documentService));
        
        // 2. 數據分析工具
        tools.add(createDataAnalysisTool(analysisService));
        
        // 3. 工作流程工具
        tools.add(createWorkflowTool(workflowService));
        
        // 4. 文件處理工具
        tools.add(createFileProcessingTool());
        
        // 5. 系統管理工具
        tools.add(createSystemManagementTool());
        
        log.info("註冊了 {} 個企業級 MCP 工具", tools.size());
        return tools;
    }
    
    /**
     * 創建文檔搜尋工具
     */
    private McpServerFeatures.SyncToolSpecification createDocumentSearchTool(
            DocumentSearchService documentService) {
        
        // 定義工具 Schema
        var toolSchema = new McpSchema.Tool(
            "search_documents",
            "搜尋企業文檔庫中的相關文檔",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "query", Map.of(
                        "type", "string",
                        "description", "搜尋關鍵字或問題"
                    ),
                    "domain", Map.of(
                        "type", "string",
                        "description", "專業領域過濾（可選）",
                        "enum", List.of("技術", "財務", "人事", "法務", "營運")
                    ),
                    "max_results", Map.of(
                        "type", "integer",
                        "description", "最大結果數量",
                        "default", 5,
                        "minimum", 1,
                        "maximum", 20
                    ),
                    "similarity_threshold", Map.of(
                        "type", "number",
                        "description", "相似度閾值",
                        "default", 0.7,
                        "minimum", 0.0,
                        "maximum", 1.0
                    )
                ),
                "required", List.of("query")
            )
        );
        
        // 定義工具執行邏輯
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    // 提取參數
                    String query = (String) request.arguments().get("query");
                    String domain = (String) request.arguments().get("domain");
                    Integer maxResults = (Integer) request.arguments().getOrDefault("max_results", 5);
                    Double threshold = (Double) request.arguments().getOrDefault("similarity_threshold", 0.7);
                    
                    log.info("執行文檔搜尋: query={}, domain={}, maxResults={}, threshold={}", 
                        query, domain, maxResults, threshold);
                    
                    // 執行搜尋
                    DocumentSearchRequest searchRequest = DocumentSearchRequest.builder()
                        .query(query)
                        .domain(domain)
                        .maxResults(maxResults)
                        .similarityThreshold(threshold)
                        .build();
                    
                    DocumentSearchResult result = documentService.search(searchRequest);
                    
                    // 格式化結果
                    String formattedResult = formatSearchResult(result);
                    
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(formattedResult))
                    );
                    
                } catch (Exception e) {
                    log.error("文檔搜尋工具執行失敗", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "搜尋失敗: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    /**
     * 創建數據分析工具
     */
    private McpServerFeatures.SyncToolSpecification createDataAnalysisTool(
            DataAnalysisService analysisService) {
        
        var toolSchema = new McpSchema.Tool(
            "analyze_data",
            "對企業數據進行統計分析和可視化",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "data_source", Map.of(
                        "type", "string",
                        "description", "數據來源（SQL查詢、CSV文件路徑等）"
                    ),
                    "analysis_type", Map.of(
                        "type", "string",
                        "description", "分析類型",
                        "enum", List.of("descriptive", "correlation", "trend", "forecast")
                    ),
                    "output_format", Map.of(
                        "type", "string",
                        "description", "輸出格式",
                        "enum", List.of("text", "chart", "table", "json"),
                        "default", "text"
                    )
                ),
                "required", List.of("data_source", "analysis_type")
            )
        );
        
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    String dataSource = (String) request.arguments().get("data_source");
                    String analysisType = (String) request.arguments().get("analysis_type");
                    String outputFormat = (String) request.arguments().getOrDefault("output_format", "text");
                    
                    log.info("執行數據分析: source={}, type={}, format={}", 
                        dataSource, analysisType, outputFormat);
                    
                    DataAnalysisRequest analysisRequest = DataAnalysisRequest.builder()
                        .dataSource(dataSource)
                        .analysisType(AnalysisType.valueOf(analysisType.toUpperCase()))
                        .outputFormat(OutputFormat.valueOf(outputFormat.toUpperCase()))
                        .build();
                    
                    DataAnalysisResult result = analysisService.analyze(analysisRequest);
                    
                    // 根據輸出格式返回結果
                    return switch (outputFormat) {
                        case "chart" -> new McpSchema.CallToolResult(
                            List.of(new McpSchema.ImageContent(
                                result.getChartData(), "image/png"))
                        );
                        case "json" -> new McpSchema.CallToolResult(
                            List.of(new McpSchema.TextContent(
                                result.getJsonData()))
                        );
                        default -> new McpSchema.CallToolResult(
                            List.of(new McpSchema.TextContent(
                                result.getTextSummary()))
                        );
                    };
                    
                } catch (Exception e) {
                    log.error("數據分析工具執行失敗", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "分析失敗: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    /**
     * 創建工作流程工具
     */
    private McpServerFeatures.SyncToolSpecification createWorkflowTool(
            WorkflowService workflowService) {
        
        var toolSchema = new McpSchema.Tool(
            "execute_workflow",
            "執行預定義的業務工作流程",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "workflow_name", Map.of(
                        "type", "string",
                        "description", "工作流程名稱"
                    ),
                    "parameters", Map.of(
                        "type", "object",
                        "description", "工作流程參數"
                    ),
                    "async", Map.of(
                        "type", "boolean",
                        "description", "是否異步執行",
                        "default", false
                    )
                ),
                "required", List.of("workflow_name")
            )
        );
        
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    String workflowName = (String) request.arguments().get("workflow_name");
                    @SuppressWarnings("unchecked")
                    Map<String, Object> parameters = (Map<String, Object>) 
                        request.arguments().getOrDefault("parameters", Map.of());
                    Boolean async = (Boolean) request.arguments().getOrDefault("async", false);
                    
                    log.info("執行工作流程: name={}, async={}", workflowName, async);
                    
                    WorkflowExecutionRequest workflowRequest = WorkflowExecutionRequest.builder()
                        .workflowName(workflowName)
                        .parameters(parameters)
                        .async(async)
                        .build();
                    
                    WorkflowExecutionResult result = workflowService.execute(workflowRequest);
                    
                    String responseText = async ? 
                        "工作流程已啟動，執行ID: " + result.getExecutionId() :
                        "工作流程執行完成: " + result.getResult();
                    
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(responseText))
                    );
                    
                } catch (Exception e) {
                    log.error("工作流程工具執行失敗", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "工作流程執行失敗: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    /**
     * 創建文件處理工具
     */
    private McpServerFeatures.SyncToolSpecification createFileProcessingTool() {
        
        var toolSchema = new McpSchema.Tool(
            "process_file",
            "處理和轉換各種格式的文件",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "file_path", Map.of(
                        "type", "string",
                        "description", "文件路徑"
                    ),
                    "operation", Map.of(
                        "type", "string",
                        "description", "處理操作",
                        "enum", List.of("extract_text", "convert_format", "compress", "encrypt")
                    ),
                    "target_format", Map.of(
                        "type", "string",
                        "description", "目標格式（轉換時使用）"
                    )
                ),
                "required", List.of("file_path", "operation")
            )
        );
        
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    String filePath = (String) request.arguments().get("file_path");
                    String operation = (String) request.arguments().get("operation");
                    String targetFormat = (String) request.arguments().get("target_format");
                    
                    log.info("處理文件: path={}, operation={}, target={}", 
                        filePath, operation, targetFormat);
                    
                    // 執行文件處理邏輯
                    String result = processFile(filePath, operation, targetFormat);
                    
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(result))
                    );
                    
                } catch (Exception e) {
                    log.error("文件處理工具執行失敗", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "文件處理失敗: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    /**
     * 創建系統管理工具
     */
    private McpServerFeatures.SyncToolSpecification createSystemManagementTool() {
        
        var toolSchema = new McpSchema.Tool(
            "system_info",
            "獲取系統狀態和資源使用情況",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "info_type", Map.of(
                        "type", "string",
                        "description", "信息類型",
                        "enum", List.of("health", "metrics", "logs", "config")
                    )
                ),
                "required", List.of("info_type")
            )
        );
        
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    String infoType = (String) request.arguments().get("info_type");
                    
                    log.debug("獲取系統信息: type={}", infoType);
                    
                    String result = switch (infoType) {
                        case "health" -> getSystemHealth();
                        case "metrics" -> getSystemMetrics();
                        case "logs" -> getRecentLogs();
                        case "config" -> getSystemConfig();
                        default -> "未知的信息類型: " + infoType;
                    };
                    
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(result))
                    );
                    
                } catch (Exception e) {
                    log.error("系統管理工具執行失敗", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "獲取系統信息失敗: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    // 輔助方法
    private String formatSearchResult(DocumentSearchResult result) {
        StringBuilder sb = new StringBuilder();
        sb.append("找到 ").append(result.getDocuments().size()).append(" 個相關文檔:\n\n");
        
        for (int i = 0; i < result.getDocuments().size(); i++) {
            Document doc = result.getDocuments().get(i);
            sb.append(i + 1).append(". ").append(doc.getTitle()).append("\n");
            sb.append("   相似度: ").append(String.format("%.2f", doc.getScore())).append("\n");
            sb.append("   摘要: ").append(doc.getSummary()).append("\n\n");
        }
        
        return sb.toString();
    }
    
    private String processFile(String filePath, String operation, String targetFormat) {
        // 簡化的文件處理邏輯
        return switch (operation) {
            case "extract_text" -> "已提取文件文本內容: " + filePath;
            case "convert_format" -> "已轉換文件格式: " + filePath + " -> " + targetFormat;
            case "compress" -> "已壓縮文件: " + filePath;
            case "encrypt" -> "已加密文件: " + filePath;
            default -> "未知操作: " + operation;
        };
    }
    
    private String getSystemHealth() {
        return "系統狀態: 正常\nCPU 使用率: 45%\n記憶體使用率: 62%\n磁碟使用率: 78%";
    }
    
    private String getSystemMetrics() {
        return "請求總數: 12,345\n成功率: 99.2%\n平均回應時間: 150ms\n活躍連接: 23";
    }
    
    private String getRecentLogs() {
        return "最近日誌:\n[INFO] MCP Server 啟動成功\n[DEBUG] 處理工具調用請求\n[INFO] 客戶端連接建立";
    }
    
    private String getSystemConfig() {
        return "伺服器配置:\n版本: 1.0.0\n端口: 8080\n最大連接數: 100\n工具數量: 5";
    }
}
```

---

## 9.4.3 MCP 資源管理

### 資源提供者配置

```java
/**
 * MCP 資源配置類
 */
@Configuration
@Slf4j
public class McpResourcesConfiguration {
    
    /**
     * 系統資源提供者
     */
    @Bean
    public List<McpServerFeatures.SyncResourceSpecification> systemResources() {
        List<McpServerFeatures.SyncResourceSpecification> resources = new ArrayList<>();
        
        // 1. 系統信息資源
        var systemInfoResource = new McpSchema.Resource(
            URI.create("system://info"),
            "系統信息",
            Optional.of("當前系統的基本信息和狀態"),
            Optional.of("application/json")
        );
        
        resources.add(new McpServerFeatures.SyncResourceSpecification(
            systemInfoResource,
            this::getSystemInfo
        ));
        
        // 2. 應用配置資源
        var configResource = new McpSchema.Resource(
            URI.create("config://application"),
            "應用配置",
            Optional.of("當前應用的配置信息"),
            Optional.of("application/yaml")
        );
        
        resources.add(new McpServerFeatures.SyncResourceSpecification(
            configResource,
            this::getApplicationConfig
        ));
        
        log.info("註冊了 {} 個系統資源", resources.size());
        return resources;
    }
    
    /**
     * 獲取系統信息
     */
    private McpSchema.ReadResourceResult getSystemInfo(
            McpSyncServerExchange exchange,
            McpSchema.ReadResourceRequest request
    ) {
        try {
            Map<String, Object> systemInfo = Map.of(
                "serverName", "enterprise-mcp-server",
                "version", "1.0.0",
                "startTime", Instant.now().toString(),
                "javaVersion", System.getProperty("java.version"),
                "osName", System.getProperty("os.name"),
                "osVersion", System.getProperty("os.version"),
                "availableProcessors", Runtime.getRuntime().availableProcessors(),
                "maxMemory", Runtime.getRuntime().maxMemory(),
                "totalMemory", Runtime.getRuntime().totalMemory(),
                "freeMemory", Runtime.getRuntime().freeMemory()
            );
            
            String jsonContent = new ObjectMapper().writeValueAsString(systemInfo);
            
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    request.uri(),
                    "application/json",
                    jsonContent
                ))
            );
            
        } catch (Exception e) {
            log.error("獲取系統信息失敗", e);
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    request.uri(),
                    "text/plain",
                    "獲取系統信息失敗: " + e.getMessage()
                ))
            );
        }
    }
    
    /**
     * 獲取應用配置
     */
    private McpSchema.ReadResourceResult getApplicationConfig(
            McpSyncServerExchange exchange,
            McpSchema.ReadResourceRequest request
    ) {
        try {
            Map<String, Object> config = Map.of(
                "server", Map.of(
                    "name", "enterprise-mcp-server",
                    "port", 8080,
                    "ssl", false
                ),
                "mcp", Map.of(
                    "tools", Map.of(
                        "enabled", true,
                        "maxConcurrent", 20
                    ),
                    "resources", Map.of(
                        "enabled", true,
                        "cacheTtl", "PT5M"
                    ),
                    "security", Map.of(
                        "enabled", true,
                        "rateLimit", 100
                    )
                )
            );
            
            String yamlContent = new Yaml().dump(config);
            
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    request.uri(),
                    "application/yaml",
                    yamlContent
                ))
            );
            
        } catch (Exception e) {
            log.error("獲取應用配置失敗", e);
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    request.uri(),
                    "text/plain",
                    "獲取應用配置失敗: " + e.getMessage()
                ))
            );
        }
    }
    
    /**
     * 文件系統資源提供者
     */
    @Bean
    public List<McpServerFeatures.SyncResourceSpecification> fileResources(
            @Value("${mcp.resources.file.base-path:/data}") String basePath) {
        
        List<McpServerFeatures.SyncResourceSpecification> resources = new ArrayList<>();
        
        try {
            Path baseDir = Paths.get(basePath);
            if (!Files.exists(baseDir)) {
                log.warn("文件資源基礎路徑不存在: {}", basePath);
                return resources;
            }
            
            List<McpSchema.Resource> fileResources = new ArrayList<>();
            
            // 掃描文件系統
            Files.walk(baseDir, 3)
                .filter(Files::isRegularFile)
                .filter(path -> isAllowedFileType(path))
                .forEach(path -> {
                    try {
                        URI uri = URI.create("file://" + path.toString());
                        String name = path.getFileName().toString();
                        String description = "文件: " + path.toString();
                        String mimeType = Files.probeContentType(path);
                        
                        fileResources.add(new McpSchema.Resource(
                            uri, name, Optional.of(description), Optional.ofNullable(mimeType)
                        ));
                        
                    } catch (Exception e) {
                        log.warn("處理文件資源失敗: {}", path, e);
                    }
                });
            
            // 為每個文件創建資源規範
            for (McpSchema.Resource resource : fileResources) {
                resources.add(new McpServerFeatures.SyncResourceSpecification(
                    resource,
                    (exchange, request) -> readFileResource(request.uri())
                ));
            }
            
            log.info("註冊了 {} 個文件資源", resources.size());
            
        } catch (Exception e) {
            log.error("初始化文件資源失敗", e);
        }
        
        return resources;
    }
    
    /**
     * 讀取文件資源
     */
    private McpSchema.ReadResourceResult readFileResource(URI uri) {
        try {
            String filePath = uri.getPath();
            Path path = Paths.get(filePath);
            
            if (!Files.exists(path)) {
                throw new FileNotFoundException("文件不存在: " + filePath);
            }
            
            String content = Files.readString(path, StandardCharsets.UTF_8);
            String mimeType = Files.probeContentType(path);
            
            McpSchema.ReadResourceResult result = new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    uri,
                    mimeType != null ? mimeType : "text/plain",
                    content
                ))
            );
            
            log.debug("成功讀取文件資源: {}", filePath);
            return result;
            
        } catch (Exception e) {
            log.error("讀取文件資源失敗: {}", uri, e);
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    uri,
                    "text/plain",
                    "讀取文件失敗: " + e.getMessage()
                ))
            );
        }
    }
    
    /**
     * 檢查是否為允許的文件類型
     */
    private boolean isAllowedFileType(Path path) {
        String fileName = path.getFileName().toString().toLowerCase();
        return fileName.endsWith(".txt") ||
               fileName.endsWith(".md") ||
               fileName.endsWith(".json") ||
               fileName.endsWith(".yaml") ||
               fileName.endsWith(".yml") ||
               fileName.endsWith(".xml") ||
               fileName.endsWith(".csv");
    }
}
```

---

## 9.4.4 MCP 提示系統

### 智能提示配置

```java
/**
 * MCP 提示配置類
 */
@Configuration
@Slf4j
public class McpPromptsConfiguration {
    
    /**
     * 業務提示模板
     */
    @Bean
    public List<McpServerFeatures.SyncPromptSpecification> businessPrompts() {
        List<McpServerFeatures.SyncPromptSpecification> prompts = new ArrayList<>();
        
        // 1. 文檔分析提示
        var documentAnalysisPrompt = new McpSchema.Prompt(
            "document_analysis",
            Optional.of("分析文檔內容並提供深入見解"),
            List.of(
                new McpSchema.PromptArgument("document", "要分析的文檔內容", Optional.of(true)),
                new McpSchema.PromptArgument("focus", "分析重點", Optional.of(false))
            )
        );
        
        prompts.add(new McpServerFeatures.SyncPromptSpecification(
            documentAnalysisPrompt,
            this::generateDocumentAnalysisPrompt
        ));
        
        // 2. 程式碼審查提示
        var codeReviewPrompt = new McpSchema.Prompt(
            "code_review",
            Optional.of("對程式碼進行專業審查和建議"),
            List.of(
                new McpSchema.PromptArgument("code", "程式碼內容", Optional.of(true)),
                new McpSchema.PromptArgument("language", "程式語言", Optional.of(false)),
                new McpSchema.PromptArgument("style", "審查風格", Optional.of(false))
            )
        );
        
        prompts.add(new McpServerFeatures.SyncPromptSpecification(
            codeReviewPrompt,
            this::generateCodeReviewPrompt
        ));
        
        log.info("註冊了 {} 個業務提示", prompts.size());
        return prompts;
    }
    
    /**
     * 生成文檔分析提示
     */
    private McpSchema.GetPromptResult generateDocumentAnalysisPrompt(
            McpSyncServerExchange exchange,
            McpSchema.GetPromptRequest request
    ) {
        try {
            String document = (String) request.arguments().get("document");
            String focus = (String) request.arguments().getOrDefault("focus", "全面分析");
            
            String systemPrompt = """
                你是一位專業的文檔分析專家，具備以下能力：
                1. 深入理解文檔內容和結構
                2. 識別關鍵信息和重要觀點
                3. 提供客觀、準確的分析結果
                4. 根據分析重點調整分析深度
                
                請對提供的文檔進行專業分析。
                """;
            
            String userPrompt = String.format("""
                請分析以下文檔，重點關注：%s
                
                文檔內容：
                %s
                
                請提供：
                1. 文檔摘要
                2. 關鍵觀點
                3. 重要數據或事實
                4. 結論和建議
                """, focus, document);
            
            List<McpSchema.PromptMessage> messages = List.of(
                new McpSchema.PromptMessage(
                    McpSchema.Role.SYSTEM,
                    new McpSchema.TextContent(systemPrompt)
                ),
                new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent(userPrompt)
                )
            );
            
            return new McpSchema.GetPromptResult(
                Optional.of("文檔分析提示已生成"),
                messages
            );
            
        } catch (Exception e) {
            log.error("生成文檔分析提示失敗", e);
            throw new RuntimeException("提示生成失敗", e);
        }
    }
    
    /**
     * 生成程式碼審查提示
     */
    private McpSchema.GetPromptResult generateCodeReviewPrompt(
            McpSyncServerExchange exchange,
            McpSchema.GetPromptRequest request
    ) {
        try {
            String code = (String) request.arguments().get("code");
            String language = (String) request.arguments().getOrDefault("language", "Java");
            String style = (String) request.arguments().getOrDefault("style", "標準");
            
            String systemPrompt = String.format("""
                你是一位資深的 %s 程式開發專家，具備以下能力：
                1. 深入理解 %s 語言特性和最佳實踐
                2. 識別程式碼中的潛在問題和改進機會
                3. 提供具體、可行的改進建議
                4. 遵循 %s 審查風格
                
                請對提供的程式碼進行專業審查。
                """, language, language, style);
            
            String userPrompt = String.format("""
                請審查以下 %s 程式碼：
                
                ```%s
                %s
                ```
                
                請提供：
                1. 程式碼品質評估
                2. 潛在問題識別
                3. 性能優化建議
                4. 安全性檢查
                5. 可讀性和維護性改進
                """, language, language.toLowerCase(), code);
            
            List<McpSchema.PromptMessage> messages = List.of(
                new McpSchema.PromptMessage(
                    McpSchema.Role.SYSTEM,
                    new McpSchema.TextContent(systemPrompt)
                ),
                new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent(userPrompt)
                )
            );
            
            return new McpSchema.GetPromptResult(
                Optional.of("程式碼審查提示已生成"),
                messages
            );
            
        } catch (Exception e) {
            log.error("生成程式碼審查提示失敗", e);
            throw new RuntimeException("提示生成失敗", e);
        }
    }
    
    /**
     * 動態提示提供者
     */
    @Bean
    public List<McpServerFeatures.SyncPromptSpecification> dynamicPrompts(
            PromptTemplateRepository promptRepository) {
        
        return loadPromptsFromDatabase(promptRepository);
    }
    
    /**
     * 從資料庫載入提示模板
     */
    private List<McpServerFeatures.SyncPromptSpecification> loadPromptsFromDatabase(
            PromptTemplateRepository repository) {
        
        List<McpServerFeatures.SyncPromptSpecification> prompts = new ArrayList<>();
        
        try {
            List<PromptTemplate> templates = repository.findAllActive();
            
            for (PromptTemplate template : templates) {
                String name = template.getName();
                String description = template.getDescription();
                String argumentsJson = template.getArguments();
                
                List<McpSchema.PromptArgument> arguments = parseArguments(argumentsJson);
                
                var prompt = new McpSchema.Prompt(name, Optional.of(description), arguments);
                
                prompts.add(new McpServerFeatures.SyncPromptSpecification(
                    prompt,
                    (exchange, request) -> generateDynamicPrompt(template, request)
                ));
            }
            
            log.info("從資料庫載入了 {} 個動態提示", prompts.size());
            
        } catch (Exception e) {
            log.error("載入動態提示失敗", e);
        }
        
        return prompts;
    }
    
    /**
     * 解析提示參數
     */
    private List<McpSchema.PromptArgument> parseArguments(String argumentsJson) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            JsonNode argsNode = mapper.readTree(argumentsJson);
            
            List<McpSchema.PromptArgument> arguments = new ArrayList<>();
            
            if (argsNode.isArray()) {
                for (JsonNode argNode : argsNode) {
                    String name = argNode.get("name").asText();
                    String description = argNode.get("description").asText();
                    boolean required = argNode.get("required").asBoolean(false);
                    
                    arguments.add(new McpSchema.PromptArgument(name, description, Optional.of(required)));
                }
            }
            
            return arguments;
            
        } catch (Exception e) {
            log.warn("解析提示參數失敗: {}", argumentsJson, e);
            return List.of();
        }
    }
    
    /**
     * 生成動態提示
     */
    private McpSchema.GetPromptResult generateDynamicPrompt(
            PromptTemplate template, McpSchema.GetPromptRequest request) {
        
        try {
            // 使用模板引擎處理提示內容
            String processedContent = processTemplate(template.getContent(), request.arguments());
            
            List<McpSchema.PromptMessage> messages = List.of(
                new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent(processedContent)
                )
            );
            
            return new McpSchema.GetPromptResult(
                Optional.of("動態提示已生成: " + template.getName()),
                messages
            );
            
        } catch (Exception e) {
            log.error("生成動態提示失敗: {}", template.getName(), e);
            throw new RuntimeException("動態提示生成失敗", e);
        }
    }
    
    /**
     * 處理提示模板
     */
    private String processTemplate(String template, Map<String, Object> arguments) {
        String result = template;
        
        // 簡單的模板變數替換
        for (Map.Entry<String, Object> entry : arguments.entrySet()) {
            String placeholder = "{{" + entry.getKey() + "}}";
            String value = entry.getValue().toString();
            result = result.replace(placeholder, value);
        }
        
        return result;
    }
}

/**
 * 提示模板實體
 */
@Entity
@Table(name = "prompt_templates")
@Data
public class PromptTemplate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String name;
    
    @Column(nullable = false)
    private String description;
    
    @Column(columnDefinition = "TEXT")
    private String content;
    
    @Column(columnDefinition = "JSON")
    private String arguments;
    
    @Column(nullable = false)
    private Boolean active = true;
    
    @CreationTimestamp
    private Instant createdAt;
    
    @UpdateTimestamp
    private Instant updatedAt;
}

/**
 * 提示模板存儲庫
 */
@Repository
public interface PromptTemplateRepository extends JpaRepository<PromptTemplate, Long> {
    List<PromptTemplate> findAllActive();
    Optional<PromptTemplate> findByNameAndActive(String name, Boolean active);
}
```

---

## 📝 本章重點回顧

1. **MCP Server 架構**：建立了完整的企業級 MCP Server 基礎架構
2. **工具開發**：掌握了自定義 MCP 工具的開發和註冊方法
3. **資源管理**：實現了靈活的 MCP 資源提供和管理機制
4. **提示系統**：建立了智能化的 MCP 提示服務
5. **企業應用**：提供了完整的企業級 MCP Server 解決方案

### 核心組件總結

| 組件 | 功能 | 重要性 | 實現難度 |
|------|------|--------|----------|
| **工具系統** | 提供可執行的功能服務 | ⭐⭐⭐⭐⭐ | 中 |
| **資源管理** | 提供可讀取的數據資源 | ⭐⭐⭐⭐ | 中 |
| **提示服務** | 提供智能化的提示模板 | ⭐⭐⭐ | 中 |
| **安全控制** | 確保服務的安全性 | ⭐⭐⭐⭐ | 高 |
| **監控系統** | 提供服務監控和管理 | ⭐⭐⭐ | 中 |

### 最佳實踐建議

1. **模組化設計**：將不同類型的服務分離到不同的配置類中
2. **安全優先**：實現完整的認證、授權和速率限制機制
3. **錯誤處理**：建立健全的錯誤處理和日誌記錄機制
4. **性能優化**：使用快取和異步處理提升服務性能
5. **監控完善**：建立完整的服務監控和告警體系

### MCP Server 部署架構

```
┌─────────────────────────────────────────────────────────────┐
│                 企業級 MCP Server 架構                      │
├─────────────────────────────────────────────────────────────┤
│  負載均衡器 (Nginx/HAProxy)                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  MCP Server 實例 1    MCP Server 實例 2    ...         │ │
│  │  • 工具服務           • 工具服務                       │ │
│  │  • 資源管理           • 資源管理                       │ │
│  │  • 提示系統           • 提示系統                       │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  共享服務層                                                 │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 資料庫 (PostgreSQL)                                 │ │
│  │  • 快取 (Redis)                                        │ │
│  │  • 檔案存儲 (MinIO/S3)                                 │ │
│  │  • 監控 (Prometheus + Grafana)                        │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 下一步發展方向

完成第九章的學習後，您已經掌握了完整的 MCP 技術體系：
- 從 MCP 基礎概念到實際應用
- 從 Client 使用到 Server 開發
- 從單一工具到企業級服務

未來可以考慮的發展方向：
- **多模態 MCP 服務**：支援圖像、音頻等多媒體處理
- **分散式 MCP 架構**：建立跨區域的 MCP 服務網路
- **AI 驅動的 MCP**：使用 AI 技術自動生成和優化 MCP 服務
- **標準化推廣**：參與 MCP 協議的標準化和生態建設

---

**參考資料：**
- [MCP Server Specification](https://spec.modelcontextprotocol.io/specification/server/)
- [Spring AI MCP Server Documentation](https://docs.spring.io/spring-ai/reference/api/mcp-server.html)
- [Enterprise MCP Best Practices](https://github.com/modelcontextprotocol/servers)
- [MCP Security Guidelines](https://spec.modelcontextprotocol.io/specification/security/)


# 2.3 API 請求與回應處理

> **對應範例**: `chapter2-spring-mvc-api`
> **難度**: ⭐⭐⭐☆☆

---

## 📚 本章概要

在 RESTful API 開發中，正確處理請求參數和統一回應格式至關重要。本章將深入探討 Spring MVC 提供的各種參數綁定註解，以及如何設計統一的 API 回應結構和全域錯誤處理機制。

**學習目標**:
- 掌握 Spring MVC 的參數綁定註解
- 理解不同參數來源的使用場景
- 設計統一的 API 回應格式
- 實現企業級的錯誤處理機制
- 正確使用 HTTP 狀態碼

---

## 🎯 請求參數處理

### Spring MVC 參數綁定機制

Spring MVC 提供了多種參數綁定註解，用於從不同來源獲取請求資料：

```mermaid
graph TB
    Request[HTTP 請求]

    Request --> Path[URL 路徑<br/>/api/users/123]
    Request --> Query[查詢字串<br/>?page=1&size=20]
    Request --> Body[請求體<br/>JSON 資料]
    Request --> Header[請求標頭<br/>Authorization: Bearer xxx]

    Path --> PathVariable[PathVariable<br/>路徑變數]
    Query --> RequestParam[RequestParam<br/>查詢參數]
    Body --> RequestBody[RequestBody<br/>請求體]
    Header --> RequestHeader[RequestHeader<br/>請求標頭]

    PathVariable --> Controller[Controller 方法]
    RequestParam --> Controller
    RequestBody --> Controller
    RequestHeader --> Controller

    style Path fill:#e3f2fd
    style Query fill:#fff9c4
    style Body fill:#e8f5e9
    style Header fill:#f3e5f5
```

### 參數註解概覽

| 註解 | 用途 | 資料來源 | 是否必需 | 適用場景 |
|------|------|----------|----------|----------|
| **@PathVariable** | 路徑參數 | URL 路徑 | 預設必需 | RESTful 資源識別 |
| **@RequestParam** | 查詢參數 | URL 查詢字串 | 可設定為選填 | 搜尋條件、分頁參數 |
| **@RequestBody** | 請求體參數 | HTTP 請求體 | 預設必需 | JSON 物件、複雜資料 |
| **@RequestHeader** | 請求標頭 | HTTP 標頭 | 可設定為選填 | 認證資訊、客戶端資訊 |
| **@CookieValue** | Cookie 值 | HTTP Cookie | 可設定為選填 | Session ID、追蹤資訊 |

---

## 🔗 @PathVariable - 路徑參數

### 基本用法

`@PathVariable` 用於從 URL 路徑中提取變數值，是 RESTful API 設計的核心註解。

```java
// 對應範例: chapter2-spring-mvc-api/.../api/UserRestController.java:25

@RestController
@RequestMapping("/api/v1/users")
public class UserRestController {

    private final UserService userService;

    /**
     * 單一路徑參數
     * GET /api/v1/users/123
     */
    @GetMapping("/{id}")
    public ResponseEntity<UserDto> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(UserDto.from(user));
    }

    /**
     * 多個路徑參數
     * GET /api/v1/users/123/orders/456
     */
    @GetMapping("/{userId}/orders/{orderId}")
    public ResponseEntity<OrderDto> getUserOrder(
            @PathVariable Long userId,
            @PathVariable Long orderId) {

        Order order = orderService.findByUserIdAndOrderId(userId, orderId);
        return ResponseEntity.ok(OrderDto.from(order));
    }

    /**
     * 路徑參數名稱不同時，指定參數名稱
     * GET /api/v1/users/john-doe
     */
    @GetMapping("/{username}")
    public ResponseEntity<UserDto> getUserByUsername(
            @PathVariable("username") String name) {

        User user = userService.findByUsername(name);
        return ResponseEntity.ok(UserDto.from(user));
    }

    /**
     * 使用 Map 接收所有路徑參數
     * GET /api/v1/categories/tech/products/123
     */
    @GetMapping("/categories/{category}/products/{productId}")
    public ResponseEntity<ProductDto> getProduct(
            @PathVariable Map<String, String> pathVars) {

        String category = pathVars.get("category");
        Long productId = Long.parseLong(pathVars.get("productId"));

        Product product = productService.findByCategoryAndId(category, productId);
        return ResponseEntity.ok(ProductDto.from(product));
    }
}
```

**使用場景**:
- 🔍 **識別特定資源**: `/users/123` 識別 ID 為 123 的使用者
- 🔗 **表達資源關聯**: `/users/123/orders/456` 表示使用者 123 的訂單 456
- 📦 **RESTful 路由設計**: 遵循 REST 資源導向原則

**注意事項**:
- ⚠️ 預設情況下，路徑參數是必需的，缺少會返回 404
- ⚠️ 路徑參數會自動進行型別轉換（如 String 轉 Long）
- ⚠️ 型別轉換失敗會拋出 `MethodArgumentTypeMismatchException`

---

## 🔍 @RequestParam - 查詢參數

### 基本用法

`@RequestParam` 用於從 URL 查詢字串中獲取參數，常用於搜尋、過濾、分頁等場景。

```java
// 對應範例: chapter2-spring-mvc-api/.../api/ProductRestController.java:30

@RestController
@RequestMapping("/api/v1/products")
public class ProductRestController {

    private final ProductService productService;

    /**
     * 搜尋與分頁
     * GET /api/v1/products?keyword=spring&page=0&size=10&sort=price
     */
    @GetMapping
    public ResponseEntity<PagedResponse<ProductDto>> searchProducts(
            @RequestParam(required = false) String keyword,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "id") String sort) {

        Pageable pageable = PageRequest.of(
            page,
            size,
            Sort.by(sort).descending()
        );

        Page<Product> products = productService.search(keyword, pageable);

        return ResponseEntity.ok(
            PagedResponse.of(products, ProductDto::from)
        );
    }

    /**
     * 複雜查詢條件
     * GET /api/v1/products/filter?category=book&minPrice=100&maxPrice=500
     */
    @GetMapping("/filter")
    public ResponseEntity<List<ProductDto>> filterProducts(
            @RequestParam String category,
            @RequestParam(required = false) Integer minPrice,
            @RequestParam(required = false) Integer maxPrice,
            @RequestParam(required = false) Boolean inStock) {

        ProductFilter filter = ProductFilter.builder()
            .category(category)
            .minPrice(minPrice)
            .maxPrice(maxPrice)
            .inStock(inStock)
            .build();

        List<Product> products = productService.filter(filter);

        return ResponseEntity.ok(
            products.stream()
                .map(ProductDto::from)
                .collect(Collectors.toList())
        );
    }

    /**
     * 接收陣列參數
     * GET /api/v1/products?ids=1,2,3
     */
    @GetMapping("/batch")
    public ResponseEntity<List<ProductDto>> getProductsByIds(
            @RequestParam List<Long> ids) {

        List<Product> products = productService.findAllById(ids);

        return ResponseEntity.ok(
            products.stream()
                .map(ProductDto::from)
                .collect(Collectors.toList())
        );
    }

    /**
     * 使用 Map 接收所有查詢參數
     * GET /api/v1/products/search?q=spring&category=book&tag=java
     */
    @GetMapping("/search")
    public ResponseEntity<List<ProductDto>> dynamicSearch(
            @RequestParam Map<String, String> params) {

        List<Product> products = productService.dynamicSearch(params);

        return ResponseEntity.ok(
            products.stream()
                .map(ProductDto::from)
                .collect(Collectors.toList())
        );
    }
}
```

**使用場景**:
- 🔎 **搜尋過濾**: `?keyword=手機&category=電子`
- 📄 **分頁排序**: `?page=1&size=10&sort=price`
- 🎯 **可選參數**: 使用 `required = false` 和 `defaultValue`

**參數配置**:
- `required = true/false`: 是否必需，預設為 true
- `defaultValue = "預設值"`: 參數缺少時的預設值
- `name = "參數名"`: 參數名稱與變數名不同時指定

---

## 📦 @RequestBody - 請求體參數

### 基本用法

`@RequestBody` 用於接收 HTTP 請求體中的 JSON 資料，自動反序列化為 Java 物件。

```java
// 對應範例: chapter2-spring-mvc-api/.../api/UserRestController.java:40

@RestController
@RequestMapping("/api/v1/users")
public class UserRestController {

    /**
     * 建立使用者
     * POST /api/v1/users
     *
     * 請求體:
     * {
     *   "username": "john",
     *   "email": "john@example.com",
     *   "password": "password123"
     * }
     */
    @PostMapping
    public ResponseEntity<UserDto> createUser(
            @RequestBody @Valid CreateUserRequest request) {

        User user = userService.create(request);

        URI location = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .path("/{id}")
            .buildAndExpand(user.getId())
            .toUri();

        return ResponseEntity
            .created(location)
            .body(UserDto.from(user));
    }

    /**
     * 更新使用者
     * PUT /api/v1/users/123
     *
     * 請求體:
     * {
     *   "username": "john_updated",
     *   "email": "john_updated@example.com"
     * }
     */
    @PutMapping("/{id}")
    public ResponseEntity<UserDto> updateUser(
            @PathVariable Long id,
            @RequestBody @Valid UpdateUserRequest request) {

        User user = userService.update(id, request);
        return ResponseEntity.ok(UserDto.from(user));
    }

    /**
     * 部分更新使用者
     * PATCH /api/v1/users/123
     *
     * 請求體:
     * {
     *   "email": "newemail@example.com"
     * }
     */
    @PatchMapping("/{id}")
    public ResponseEntity<UserDto> patchUser(
            @PathVariable Long id,
            @RequestBody Map<String, Object> updates) {

        User user = userService.patch(id, updates);
        return ResponseEntity.ok(UserDto.from(user));
    }
}
```

**DTO 設計範例**:

```java
// 對應範例: chapter2-spring-mvc-api/.../dto/CreateUserRequest.java

/**
 * 建立使用者請求 DTO
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateUserRequest {

    @NotBlank(message = "使用者名稱不能為空")
    @Size(min = 3, max = 20, message = "使用者名稱長度必須在 3-20 之間")
    private String username;

    @NotBlank(message = "信箱不能為空")
    @Email(message = "信箱格式不正確")
    private String email;

    @NotBlank(message = "密碼不能為空")
    @Size(min = 6, message = "密碼長度至少 6 位")
    private String password;

    @Pattern(regexp = "^09\\d{8}$", message = "手機號碼格式不正確")
    private String phone;
}
```

**使用場景**:
- 📝 **建立資源**: POST 請求攜帶完整物件
- ✏️ **更新資源**: PUT/PATCH 請求攜帶更新資料
- 🔄 **複雜操作**: 需要傳遞結構化資料時

> 💡 **重點**: `@RequestBody` 會自動調用 Jackson 將 JSON 轉換為 Java 物件，並支援 `@Valid` 進行資料驗證。

---

## 🔐 @RequestHeader - 請求標頭

### 基本用法

`@RequestHeader` 用於獲取 HTTP 請求標頭中的資訊，常用於認證、追蹤等場景。

```java
// 對應範例: chapter2-spring-mvc-api/.../api/AuthController.java

@RestController
@RequestMapping("/api/v1")
public class AuthController {

    /**
     * 獲取當前使用者資訊
     * GET /api/v1/me
     * Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
     */
    @GetMapping("/me")
    public ResponseEntity<UserDto> getCurrentUser(
            @RequestHeader("Authorization") String authorization) {

        // 提取 JWT Token
        String token = authorization.replace("Bearer ", "");
        Long userId = jwtService.getUserIdFromToken(token);

        User user = userService.findById(userId);
        return ResponseEntity.ok(UserDto.from(user));
    }

    /**
     * 獲取多個標頭資訊
     * 用於追蹤和日誌記錄
     */
    @PostMapping("/api/v1/logs")
    public ResponseEntity<Void> logRequest(
            @RequestHeader("User-Agent") String userAgent,
            @RequestHeader(value = "X-Request-ID", required = false) String requestId,
            @RequestHeader(value = "X-Forwarded-For", required = false) String clientIp,
            @RequestBody LogRequest request) {

        logService.log(
            LogEntry.builder()
                .requestId(requestId)
                .userAgent(userAgent)
                .clientIp(clientIp)
                .request(request)
                .build()
        );

        return ResponseEntity.ok().build();
    }

    /**
     * 使用 Map 接收所有標頭
     */
    @GetMapping("/debug/headers")
    public ResponseEntity<Map<String, String>> getAllHeaders(
            @RequestHeader Map<String, String> headers) {

        return ResponseEntity.ok(headers);
    }
}
```

**常用請求標頭**:
- `Authorization`: 認證資訊（如 JWT Token）
- `Content-Type`: 請求體類型（如 `application/json`）
- `Accept`: 期望的回應類型
- `User-Agent`: 客戶端資訊
- `X-Request-ID`: 請求追蹤 ID

---

## 🎨 統一回應格式設計

### 為什麼需要統一回應格式？

**問題分析**:

```mermaid
graph TB
    Problem[回應格式問題]

    Problem --> P1[格式不一致<br/>不同 API 回應結構不同]
    Problem --> P2[錯誤訊息混亂<br/>錯誤格式不統一]
    Problem --> P3[客戶端處理困難<br/>需要針對每個 API 特殊處理]

    Solution[統一回應格式]

    Solution --> S1[標準化結構<br/>所有 API 使用相同格式]
    Solution --> S2[統一錯誤處理<br/>錯誤訊息結構一致]
    Solution --> S3[易於維護<br/>客戶端統一處理]

    style Problem fill:#ffebee
    style Solution fill:#e8f5e9
```

**傳統做法的問題**:

```java
// ❌ 不同 API 返回格式不一致

// API 1
@GetMapping("/users")
public List<User> getUsers() {
    return userService.findAll();  // 直接返回 List
}

// API 2
@GetMapping("/products")
public Map<String, Object> getProducts() {
    Map<String, Object> result = new HashMap<>();
    result.put("data", productService.findAll());
    result.put("count", productService.count());
    return result;  // 返回 Map
}

// API 3 - 錯誤時
@ExceptionHandler(Exception.class)
public String handleError(Exception ex) {
    return ex.getMessage();  // 直接返回字串
}
```

### 統一回應結構設計

```java
// 對應範例: chapter2-spring-mvc-api/.../dto/ApiResponse.java

/**
 * 統一 API 回應格式
 *
 * @param <T> 資料類型
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {

    /**
     * HTTP 狀態碼
     */
    private int code;

    /**
     * 回應訊息
     */
    private String message;

    /**
     * 業務資料
     */
    private T data;

    /**
     * 錯誤詳情（驗證錯誤時使用）
     */
    private Map<String, String> errors;

    /**
     * 時間戳記
     */
    @Builder.Default
    private long timestamp = System.currentTimeMillis();

    /**
     * 成功回應（有資料）
     */
    public static <T> ApiResponse<T> success(T data) {
        return ApiResponse.<T>builder()
            .code(HttpStatus.OK.value())
            .message("操作成功")
            .data(data)
            .build();
    }

    /**
     * 成功回應（自訂訊息）
     */
    public static <T> ApiResponse<T> success(String message, T data) {
        return ApiResponse.<T>builder()
            .code(HttpStatus.OK.value())
            .message(message)
            .data(data)
            .build();
    }

    /**
     * 失敗回應
     */
    public static <T> ApiResponse<T> error(int code, String message) {
        return ApiResponse.<T>builder()
            .code(code)
            .message(message)
            .build();
    }

    /**
     * 驗證失敗回應
     */
    public static <T> ApiResponse<T> validationError(
            String message,
            Map<String, String> errors) {

        return ApiResponse.<T>builder()
            .code(HttpStatus.UNPROCESSABLE_ENTITY.value())
            .message(message)
            .errors(errors)
            .build();
    }
}
```

### 使用統一回應

```java
// 對應範例: chapter2-spring-mvc-api/.../api/UserRestController.java:50

@RestController
@RequestMapping("/api/v1/users")
public class UserRestController {

    /**
     * 查詢使用者列表
     */
    @GetMapping
    public ApiResponse<List<UserDto>> getUsers() {
        List<User> users = userService.findAll();
        List<UserDto> dtos = users.stream()
            .map(UserDto::from)
            .collect(Collectors.toList());

        return ApiResponse.success("查詢成功，共 " + dtos.size() + " 筆", dtos);
    }

    /**
     * 查詢單一使用者
     */
    @GetMapping("/{id}")
    public ApiResponse<UserDto> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ApiResponse.success(UserDto.from(user));
    }

    /**
     * 建立使用者
     */
    @PostMapping
    public ApiResponse<UserDto> createUser(
            @RequestBody @Valid CreateUserRequest request) {

        User user = userService.create(request);
        return ApiResponse.success("建立成功", UserDto.from(user));
    }
}
```

**回應範例**:

**成功回應**:
```json
{
  "code": 200,
  "message": "查詢成功",
  "data": {
    "id": 1,
    "username": "john",
    "email": "john@example.com"
  },
  "errors": null,
  "timestamp": 1698123456789
}
```

**失敗回應**:
```json
{
  "code": 404,
  "message": "使用者不存在",
  "data": null,
  "errors": {
    "userId": "找不到 ID 為 123 的使用者"
  },
  "timestamp": 1698123456789
}
```

**驗證失敗回應**:
```json
{
  "code": 422,
  "message": "資料驗證失敗",
  "data": null,
  "errors": {
    "username": "使用者名稱不能為空",
    "email": "信箱格式不正確"
  },
  "timestamp": 1698123456789
}
```

---

## 🛡️ 全域異常處理

### 為什麼需要統一的錯誤處理？

```mermaid
graph TB
    NoHandler[沒有統一錯誤處理]
    WithHandler[統一錯誤處理]

    NoHandler --> N1[每個 Controller<br/>重複處理異常]
    NoHandler --> N2[錯誤格式<br/>不一致]
    NoHandler --> N3[缺少錯誤日誌]
    NoHandler --> N4[客戶端難以<br/>統一處理]

    WithHandler --> W1[集中式<br/>異常處理]
    WithHandler --> W2[一致的<br/>錯誤格式]
    WithHandler --> W3[自動記錄<br/>錯誤日誌]
    WithHandler --> W4[易於維護<br/>和擴展]

    style NoHandler fill:#ffebee
    style WithHandler fill:#e8f5e9
```

### 全域異常處理器實現

```java
// 對應範例: chapter2-spring-mvc-api/.../exception/GlobalExceptionHandler.java

/**
 * 全域異常處理器
 *
 * 統一處理所有 Controller 拋出的異常
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    /**
     * 處理資源不存在異常
     * 404 Not Found
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ApiResponse<Void> handleResourceNotFound(
            ResourceNotFoundException ex) {

        log.error("資源不存在: {}", ex.getMessage());

        return ApiResponse.error(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage()
        );
    }

    /**
     * 處理資源重複異常
     * 409 Conflict
     */
    @ExceptionHandler(DuplicateResourceException.class)
    @ResponseStatus(HttpStatus.CONFLICT)
    public ApiResponse<Void> handleDuplicateResource(
            DuplicateResourceException ex) {

        log.error("資源衝突: {}", ex.getMessage());

        return ApiResponse.error(
            HttpStatus.CONFLICT.value(),
            ex.getMessage()
        );
    }

    /**
     * 處理資料驗證異常
     * 422 Unprocessable Entity
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.UNPROCESSABLE_ENTITY)
    public ApiResponse<Void> handleValidationErrors(
            MethodArgumentNotValidException ex) {

        Map<String, String> errors = new HashMap<>();

        ex.getBindingResult().getFieldErrors().forEach(error ->
            errors.put(error.getField(), error.getDefaultMessage())
        );

        log.error("資料驗證失敗: {}", errors);

        return ApiResponse.validationError("資料驗證失敗", errors);
    }

    /**
     * 處理請求參數型別錯誤
     * 400 Bad Request
     */
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ApiResponse<Void> handleTypeMismatch(
            MethodArgumentTypeMismatchException ex) {

        String message = String.format(
            "參數 '%s' 的值 '%s' 型別錯誤，期望型別為 %s",
            ex.getName(),
            ex.getValue(),
            ex.getRequiredType().getSimpleName()
        );

        log.error("參數型別錯誤: {}", message);

        return ApiResponse.error(
            HttpStatus.BAD_REQUEST.value(),
            message
        );
    }

    /**
     * 處理缺少請求參數異常
     * 400 Bad Request
     */
    @ExceptionHandler(MissingServletRequestParameterException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ApiResponse<Void> handleMissingParams(
            MissingServletRequestParameterException ex) {

        String message = String.format(
            "缺少必需參數: %s (類型: %s)",
            ex.getParameterName(),
            ex.getParameterType()
        );

        log.error("缺少請求參數: {}", message);

        return ApiResponse.error(
            HttpStatus.BAD_REQUEST.value(),
            message
        );
    }

    /**
     * 處理 JSON 解析異常
     * 400 Bad Request
     */
    @ExceptionHandler(HttpMessageNotReadableException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ApiResponse<Void> handleJsonParseError(
            HttpMessageNotReadableException ex) {

        log.error("JSON 解析失敗", ex);

        return ApiResponse.error(
            HttpStatus.BAD_REQUEST.value(),
            "請求資料格式錯誤，無法解析 JSON"
        );
    }

    /**
     * 處理業務邏輯異常
     * 400 Bad Request
     */
    @ExceptionHandler(BusinessException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ApiResponse<Void> handleBusinessException(
            BusinessException ex) {

        log.error("業務異常: {}", ex.getMessage());

        return ApiResponse.error(
            ex.getCode(),
            ex.getMessage()
        );
    }

    /**
     * 處理通用異常
     * 500 Internal Server Error
     *
     * 注意：不要洩漏系統內部資訊
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ApiResponse<Void> handleGenericException(Exception ex) {
        log.error("系統異常", ex);

        // 生產環境不要返回具體錯誤訊息
        String message = "系統錯誤，請稍後再試";

        // 開發環境可以返回詳細訊息
        if (isDevelopmentMode()) {
            message = ex.getMessage();
        }

        return ApiResponse.error(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            message
        );
    }

    private boolean isDevelopmentMode() {
        // 判斷是否為開發環境
        return false;  // 實際應從配置中讀取
    }
}
```

### 自訂異常類別

```java
// 對應範例: chapter2-spring-mvc-api/.../exception/ResourceNotFoundException.java

/**
 * 資源不存在異常
 */
public class ResourceNotFoundException extends RuntimeException {

    private final String resourceName;
    private final String fieldName;
    private final Object fieldValue;

    public ResourceNotFoundException(
            String resourceName,
            String fieldName,
            Object fieldValue) {

        super(String.format(
            "%s 不存在，%s: %s",
            resourceName,
            fieldName,
            fieldValue
        ));

        this.resourceName = resourceName;
        this.fieldName = fieldName;
        this.fieldValue = fieldValue;
    }

    public ResourceNotFoundException(String message) {
        super(message);
        this.resourceName = null;
        this.fieldName = null;
        this.fieldValue = null;
    }
}
```

```java
// 對應範例: chapter2-spring-mvc-api/.../exception/BusinessException.java

/**
 * 業務邏輯異常
 */
@Getter
public class BusinessException extends RuntimeException {

    private final int code;

    public BusinessException(String message) {
        super(message);
        this.code = HttpStatus.BAD_REQUEST.value();
    }

    public BusinessException(int code, String message) {
        super(message);
        this.code = code;
    }

    public BusinessException(HttpStatus status, String message) {
        super(message);
        this.code = status.value();
    }
}
```

---

## 📊 HTTP 狀態碼最佳實踐

### 正確使用範例

```java
// 對應範例: chapter2-spring-mvc-api/.../api/ProductRestController.java

@RestController
@RequestMapping("/api/v1/products")
public class ProductRestController {

    // 200 OK - 查詢成功
    @GetMapping("/{id}")
    public ResponseEntity<ProductDto> getProduct(@PathVariable Long id) {
        return ResponseEntity.ok(productService.findById(id));
    }

    // 201 Created - 建立成功，返回 Location 標頭
    @PostMapping
    public ResponseEntity<ProductDto> createProduct(
            @RequestBody @Valid CreateProductRequest request) {

        Product product = productService.create(request);

        URI location = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .path("/{id}")
            .buildAndExpand(product.getId())
            .toUri();

        return ResponseEntity
            .status(HttpStatus.CREATED)
            .location(location)
            .body(ProductDto.from(product));
    }

    // 204 No Content - 刪除成功，無回應體
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        productService.delete(id);
        return ResponseEntity.noContent().build();
    }

    // 400 Bad Request - 透過 @Valid 自動處理
    // 404 Not Found - 透過 GlobalExceptionHandler 處理
    // 500 Internal Server Error - 透過 GlobalExceptionHandler 處理
}
```

### 狀態碼選擇流程

```mermaid
graph TD
    Start[開始]

    Start --> Success{操作成功?}

    Success -->|是| GetOrUpdate{GET/PUT/PATCH?}
    Success -->|否| Error{錯誤類型?}

    GetOrUpdate -->|是| Return200[200 OK]
    GetOrUpdate -->|否| Post{POST?}

    Post -->|是| Return201[201 Created<br/>+ Location]
    Post -->|否| Delete{DELETE?}

    Delete -->|是| Return204[204 No Content]
    Delete -->|否| Return200

    Error --> ClientError{客戶端錯誤?}

    ClientError -->|參數錯誤| Return400[400 Bad Request]
    ClientError -->|驗證失敗| Return422[422 Unprocessable Entity]
    ClientError -->|未認證| Return401[401 Unauthorized]
    ClientError -->|無權限| Return403[403 Forbidden]
    ClientError -->|資源不存在| Return404[404 Not Found]
    ClientError -->|資源衝突| Return409[409 Conflict]
    ClientError -->|系統錯誤| Return500[500 Internal Server Error]

    style Return200 fill:#66bb6a,color:#fff
    style Return201 fill:#66bb6a,color:#fff
    style Return204 fill:#66bb6a,color:#fff
    style Return400 fill:#ff9800,color:#fff
    style Return401 fill:#ff9800,color:#fff
    style Return403 fill:#ff9800,color:#fff
    style Return404 fill:#ff9800,color:#fff
    style Return409 fill:#ff9800,color:#fff
    style Return422 fill:#ff9800,color:#fff
    style Return500 fill:#f44336,color:#fff
```

---

## 📝 本節重點回顧

### 核心知識點

1. **參數註解** - 掌握 @PathVariable、@RequestParam、@RequestBody、@RequestHeader 的使用
2. **統一回應** - 設計標準化的 ApiResponse 結構
3. **異常處理** - 使用 @RestControllerAdvice 統一處理異常
4. **狀態碼** - 正確使用 HTTP 狀態碼表達不同情境
5. **最佳實踐** - 建立一致、可維護的 API 設計規範

### 技術要點

- ✅ @PathVariable 用於 RESTful 資源識別
- ✅ @RequestParam 支援 required 和 defaultValue 配置
- ✅ @RequestBody 自動調用 Jackson 反序列化 JSON
- ✅ 統一回應格式便於客戶端處理
- ✅ 全域異常處理集中管理錯誤
- ✅ 自訂異常類別提高程式碼可讀性
- ✅ 正確使用 HTTP 狀態碼表達操作結果

---

## 🚀 下一步

👉 [第3章：企業級功能](../chapter3/3.1-validation-error-handling.md) - 深入學習資料驗證和進階錯誤處理

---

## 📚 參考資源

**官方文件**:
- [Spring MVC Request Mapping](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping)
- [Spring Exception Handling](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-exceptionhandler)

**範例程式碼**:
- [完整專案程式碼](../../code-examples/chapter2-spring-mvc-api)
- [UserRestController.java](../../code-examples/chapter2-spring-mvc-api/src/main/java/com/example/api/UserRestController.java)
- [ApiResponse.java](../../code-examples/chapter2-spring-mvc-api/src/main/java/com/example/dto/ApiResponse.java)
- [GlobalExceptionHandler.java](../../code-examples/chapter2-spring-mvc-api/src/main/java/com/example/exception/GlobalExceptionHandler.java)

---

**相關章節**:
- ← 上一章: [2.2 RESTful API 設計原則](./2.2-restful-api-design.md)
- → 下一章: [第3章：企業級功能](../chapter3/3.1-validation-error-handling.md)

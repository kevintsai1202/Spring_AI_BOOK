# 2.3 API 請求與回應處理

> **學習重點**：掌握請求參數處理、統一回應格式設計和錯誤處理機制

---

## 2.3.1 請求參數處理

### Spring MVC 參數註解概覽

| 註解 | 用途 | 資料來源 | 適用場景 |
|------|------|----------|----------|
| **@PathVariable** | 路徑參數 | URL 路徑 | RESTful 資源識別 |
| **@RequestParam** | 查詢參數 | URL 查詢字串 | 搜尋條件、分頁參數 |
| **@RequestBody** | 請求體參數 | HTTP 請求體 | JSON 物件、複雜資料 |
| **@RequestHeader** | 請求標頭 | HTTP 標頭 | 認證資訊、客戶端資訊 |

### @PathVariable - 路徑參數

```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    // 單一路徑參數
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }

    // 多個路徑參數
    @GetMapping("/{userId}/orders/{orderId}")
    public ResponseEntity<Order> getUserOrder(
            @PathVariable Long userId,
            @PathVariable Long orderId) {
        Order order = orderService.findByUserIdAndOrderId(userId, orderId);
        return ResponseEntity.ok(order);
    }
}
```

**使用場景**：
- 🔍 識別特定資源：`/users/123`
- 🔗 表達資源關聯：`/users/123/orders/456`
- 📦 RESTful 路由設計

### @RequestParam - 查詢參數

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {

    // 搜尋與分頁
    @GetMapping
    public ResponseEntity<Page<Product>> searchProducts(
            @RequestParam(required = false) String keyword,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "id") String sort) {

        Pageable pageable = PageRequest.of(page, size, Sort.by(sort));
        Page<Product> products = productService.search(keyword, pageable);
        return ResponseEntity.ok(products);
    }

    // 複雜查詢條件
    @GetMapping("/filter")
    public ResponseEntity<List<Product>> filterProducts(
            @RequestParam String category,
            @RequestParam(required = false) Integer minPrice,
            @RequestParam(required = false) Integer maxPrice) {

        List<Product> products = productService.filter(category, minPrice, maxPrice);
        return ResponseEntity.ok(products);
    }
}
```

**使用場景**：
- 🔎 搜尋過濾：`?keyword=手機&category=電子`
- 📄 分頁排序：`?page=1&size=10&sort=price`
- 🎯 可選參數：使用 `required = false` 和 `defaultValue`

### @RequestBody - 請求體參數

```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    // 建立使用者
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody CreateUserRequest request) {
        User user = userService.create(request);
        return ResponseEntity
                .created(URI.create("/api/users/" + user.getId()))
                .body(user);
    }

    // 更新使用者
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(
            @PathVariable Long id,
            @RequestBody UpdateUserRequest request) {
        User user = userService.update(id, request);
        return ResponseEntity.ok(user);
    }
}
```

**使用場景**：
- 📝 建立資源：POST 請求攜帶完整物件
- ✏️ 更新資源：PUT/PATCH 請求攜帶更新資料
- 🔄 複雜操作：需要傳遞結構化資料時

> 💡 **重點**：@RequestBody 會自動將 JSON 轉換為 Java 物件

> 📁 **完整範例**：參考 [code-examples/chapter2-spring-mvc-api/src/main/java/com/example/springmvc/controller/](../../code-examples/chapter2-spring-mvc-api/src/main/java/com/example/springmvc/controller/)

---

## 2.3.2 統一回應格式設計

### 為什麼需要統一回應格式？

**問題**：
- 不同 API 回應格式不一致
- 錯誤訊息結構混亂
- 客戶端難以統一處理

**解決方案**：設計統一的 API 回應包裝類

### 統一回應結構

```java
/**
 * 統一 API 回應格式
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ApiResponse<T> {

    // HTTP 狀態碼
    private int code;

    // 回應訊息
    private String message;

    // 業務資料
    private T data;

    // 錯誤詳情（可選）
    private Map<String, String> errors;

    // 時間戳記
    private long timestamp;

    // 靜態工廠方法 - 成功回應
    public static <T> ApiResponse<T> success(String message, T data) {
        return ApiResponse.<T>builder()
                .code(HttpStatus.OK.value())
                .message(message)
                .data(data)
                .timestamp(System.currentTimeMillis())
                .build();
    }

    // 靜態工廠方法 - 錯誤回應
    public static <T> ApiResponse<T> error(int code, String message) {
        return ApiResponse.<T>builder()
                .code(code)
                .message(message)
                .timestamp(System.currentTimeMillis())
                .build();
    }
}
```

### 使用統一回應

```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    // 成功回應
    @GetMapping("/{id}")
    public ApiResponse<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ApiResponse.success("查詢成功", user);
    }

    // 列表回應
    @GetMapping
    public ApiResponse<List<User>> getUsers() {
        List<User> users = userService.findAll();
        return ApiResponse.success("查詢成功，共 " + users.size() + " 筆", users);
    }

    // 建立回應
    @PostMapping
    public ApiResponse<User> createUser(@RequestBody CreateUserRequest request) {
        User user = userService.create(request);
        return ApiResponse.success("建立成功", user);
    }
}
```

**回應範例**：

成功回應：
```json
{
  "code": 200,
  "message": "查詢成功",
  "data": {
    "id": 1,
    "username": "john",
    "email": "john@example.com"
  },
  "timestamp": 1698123456789
}
```

錯誤回應：
```json
{
  "code": 404,
  "message": "使用者不存在",
  "data": null,
  "errors": {
    "userId": "找不到 ID 為 123 的使用者"
  },
  "timestamp": 1698123456789
}
```

> 📁 **完整實作**：參考 [code-examples/chapter2-spring-mvc-api/src/main/java/com/example/springmvc/dto/](../../code-examples/chapter2-spring-mvc-api/src/main/java/com/example/springmvc/dto/)

---

## 2.3.3 錯誤處理概述

### 為什麼需要統一的錯誤處理？

在 API 開發中，錯誤處理和正常回應同樣重要：

**沒有統一錯誤處理的問題**：
- ❌ 每個控制器都要重複處理異常
- ❌ 錯誤回應格式不一致
- ❌ 缺少錯誤日誌記錄
- ❌ 客戶端難以統一處理錯誤

**統一錯誤處理的優勢**：
- ✅ 集中式異常處理邏輯
- ✅ 一致的錯誤回應格式
- ✅ 自動記錄錯誤日誌
- ✅ 易於維護和擴展

### @RestControllerAdvice 核心概念

Spring 提供 `@RestControllerAdvice` 註解來實現全域異常處理：

```java
/**
 * 全域異常處理器（概念示範）
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    // 處理資源不存在異常
    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ApiResponse<Void> handleResourceNotFound(ResourceNotFoundException ex) {
        log.error("資源不存在: {}", ex.getMessage());
        return ApiResponse.error(404, ex.getMessage());
    }

    // 處理通用異常
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ApiResponse<Void> handleGenericException(Exception ex) {
        log.error("系統異常", ex);
        return ApiResponse.error(500, "系統錯誤，請稍後再試");
    }
}
```

**核心機制**：
1. `@RestControllerAdvice` - 標記全域異常處理器
2. `@ExceptionHandler` - 指定要處理的異常類型
3. `@ResponseStatus` - 設定 HTTP 狀態碼

### 錯誤回應範例

使用統一的 ApiResponse 格式回傳錯誤：

```json
{
  "code": 404,
  "message": "使用者不存在",
  "data": null,
  "errors": {
    "userId": "找不到 ID 為 123 的使用者"
  },
  "timestamp": 1698123456789
}
```

> 💡 **進階學習**：本節只介紹錯誤處理的基本概念。完整的企業級錯誤處理實作（包含資料驗證、自訂異常、詳細錯誤處理等）請參考 [第3章：3.1 資料驗證與錯誤處理](../chapter3/3.1-validation-error-handling.md)

> 📁 **程式碼參考**：基本實作請參考 [code-examples/chapter2-spring-mvc-api/src/main/java/com/example/springmvc/exception/](../../code-examples/chapter2-spring-mvc-api/src/main/java/com/example/springmvc/exception/)

---

## 2.3.4 HTTP 狀態碼最佳實踐

### 常用狀態碼對照

| 狀態碼 | 說明 | 使用時機 |
|--------|------|----------|
| **200 OK** | 成功 | GET、PUT、PATCH 成功 |
| **201 Created** | 已建立 | POST 成功建立資源 |
| **204 No Content** | 無內容 | DELETE 成功、PUT 成功無回應 |
| **400 Bad Request** | 錯誤請求 | 請求參數錯誤、驗證失敗 |
| **401 Unauthorized** | 未授權 | 需要身份驗證 |
| **403 Forbidden** | 禁止訪問 | 已驗證但權限不足 |
| **404 Not Found** | 找不到 | 資源不存在 |
| **409 Conflict** | 衝突 | 資源狀態衝突 |
| **500 Internal Server Error** | 伺服器錯誤 | 系統異常 |

### 正確使用範例

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {

    // 200 OK - 查詢成功
    @GetMapping("/{id}")
    public ResponseEntity<Product> getProduct(@PathVariable Long id) {
        return ResponseEntity.ok(productService.findById(id));
    }

    // 201 Created - 建立成功
    @PostMapping
    public ResponseEntity<Product> createProduct(@RequestBody Product product) {
        Product created = productService.create(product);
        return ResponseEntity
                .status(HttpStatus.CREATED)
                .location(URI.create("/api/products/" + created.getId()))
                .body(created);
    }

    // 204 No Content - 刪除成功
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        productService.delete(id);
        return ResponseEntity.noContent().build();
    }

    // 400 Bad Request - 參數錯誤自動處理
    // 404 Not Found - 透過 GlobalExceptionHandler 處理
    // 500 Internal Server Error - 透過 GlobalExceptionHandler 處理
}
```

---

## 📝 本節重點

1. ✅ **參數註解**：掌握 @PathVariable、@RequestParam、@RequestBody 的使用
2. ✅ **統一回應**：設計標準化的 ApiResponse 結構
3. ✅ **異常處理**：使用 @RestControllerAdvice 統一處理異常
4. ✅ **狀態碼**：正確使用 HTTP 狀態碼表達不同情境
5. ✅ **最佳實踐**：建立一致、可維護的 API 設計規範

---

## 🔗 相關資源

- **完整程式碼**：[code-examples/chapter2-spring-mvc-api/](../../code-examples/chapter2-spring-mvc-api/)
- **異常處理器**：[GlobalExceptionHandler.java](../../code-examples/chapter2-spring-mvc-api/src/main/java/com/example/springmvc/exception/GlobalExceptionHandler.java)
- **統一回應類**：[ApiResponse.java](../../code-examples/chapter2-spring-mvc-api/src/main/java/com/example/springmvc/dto/ApiResponse.java)

---

**上一節**：[2.2 RESTful API 設計原則](./2.2-restful-api-design.md)
**回到目錄**：[第2章 README](./README.md)

# 5.10 結構化資料轉換器

> **對應章節**: Day14
> **對應範例**: `chapter5-spring-ai-advanced`
> **難度**: ⭐⭐⭐☆☆

---

## 📚 本章概要

結構化資料轉換器是將 AI 的文字回應轉換為程式可直接使用的資料結構（如 Java 物件、Map、List等）的核心機制。Spring AI 提供了多種轉換方式，從現代化的 `entity()` 方法到傳統的 `Converter` 類別，讓開發者可以根據需求選擇最適合的方案。

**學習目標**：
- 理解結構化輸出的重要性和應用場景
- 掌握 ChatClient 的 entity() 方法（現代化方式）
- 了解傳統轉換器（BeanOutputConverter、MapOutputConverter、ListOutputConverter）
- 學會設計適合 AI 輸出的資料模型
- 實現企業級的結構化資料處理系統

---

## 5.10.1 結構化輸出的重要性

### Spring 很注重一致性

![Spring 一致性](https://ithelp.ithome.com.tw/upload/images/20240814/20161290CYmKc1rZYz.png)

先說個題外話，Spring AI 1.1 在結構化輸出方面有了重大改進！不僅保留了原有的 `StructuredOutputConverter`，還在 ChatClient 中新增了更簡潔的 `entity()` 方法，讓開發者有更多選擇。

### Converter 就是將 JSON 轉為 Java 的結構

對程式而言，要看懂 ChatGPT 回應的文字並不容易，所以 OpenAI 也提供了許多方式將回應轉為不同型態，JSON、XML 或是 Markdown 的語法，最近 OpenAI 還更新了新的功能，透過強制約束，讓 OpenAI 的輸出可以與定義的 JSON 格式完全一致，有了這功能後進行外部系統整合才能讓失誤率降到最低。

### 結構化輸出的核心價值

**1. 系統整合的必要性**
- 🔗 **API 整合**：與其他系統進行資料交換時需要標準格式
- 📊 **資料處理**：程式需要結構化資料才能進行邏輯處理
- 🎯 **類型安全**：強型別語言需要明確的資料結構
- 🔄 **自動化流程**：結構化資料可以觸發後續的自動化處理

**2. 傳統文字 vs 結構化資料**

| 比較項目 | 傳統文字回應 | 結構化資料 |
|----------|-------------|------------|
| **可讀性** | 人類友善 | 程式友善 |
| **處理難度** | 需要解析 | 直接使用 |
| **準確性** | 容易出錯 | 格式保證 |
| **整合性** | 困難 | 容易 |
| **維護性** | 複雜 | 簡單 |
| **擴展性** | 受限 | 靈活 |

**3. Spring AI 1.1 的改進**

Spring AI 1.1 在這方面有了顯著的改進，現在提供了兩種主要方式來處理結構化輸出：

1. **傳統的 StructuredOutputConverter** - 需要手動處理格式描述
2. **新的 ChatClient entity() 方法** - 自動處理類型轉換

### 結構化輸出架構

```mermaid
graph TD
    A[AI 文字回應] --> B{轉換方式選擇}
    B -->|現代化方式| C[ChatClient.entity]
    B -->|傳統方式| D[StructuredOutputConverter]

    C --> E[自動 JSON 解析]
    E --> F[Java Object]

    D --> G[BeanOutputConverter]
    D --> H[MapOutputConverter]
    D --> I[ListOutputConverter]

    G --> J[Java Bean]
    H --> K[Map<String, Object>]
    I --> L[List<String>]

    style C fill:#e1f5ff
    style D fill:#fff4e6
    style F fill:#e8f5e9
    style J fill:#e8f5e9
    style K fill:#fff9c4
    style L fill:#f3e5f5
```

---

## 5.10.2 三種轉換器的用途

### 轉換器類型概覽

Spring AI 目前提供的轉換器有三個 `BeanOutputConverter`、`MapOutputConverter` 和 `ListOutputConverter`（抽象類別就不看了）

### 轉換器架構圖

```mermaid
classDiagram
    class StructuredOutputConverter {
        <<interface>>
        +getFormat() String
        +convert(String text) T
    }

    class BeanOutputConverter {
        +BeanOutputConverter(Class~T~ type)
        +getFormat() String
        +convert(String text) T
    }

    class MapOutputConverter {
        +getFormat() String
        +convert(String text) Map
    }

    class ListOutputConverter {
        +getFormat() String
        +convert(String text) List~String~
    }

    StructuredOutputConverter <|-- BeanOutputConverter
    StructuredOutputConverter <|-- MapOutputConverter
    StructuredOutputConverter <|-- ListOutputConverter

    note for BeanOutputConverter "將 JSON 轉為 Java Bean\n適合複雜結構"
    note for MapOutputConverter "將 JSON 轉為 Map\n適合動態結構"
    note for ListOutputConverter "將文字轉為 List\n適合簡單列表"
```

### 各轉換器詳細說明

**1. BeanOutputConverter**
- 🎯 **用途**：AI 產生的格式化資料主要以 JSON 為主，這個轉換器就是將 JSON 轉為 Java 程式需要的 Bean
- 🔧 **技術實現**：背後用到的就是 Spring MVC 最常用到的 ObjectMapper
- 📋 **適用場景**：複雜的資料結構、企業級應用、需要強型別的場合
- ✅ **優勢**：類型安全、IDE 支援、易於維護

**2. MapOutputConverter**
- 🎯 **用途**：這個轉換器是將資料使用 Map 的方式轉出，對未知的格式最常使用的處理方式
- 🔧 **技術實現**：將 JSON 轉換為 Map<String, Object> 結構
- 📋 **適用場景**：動態資料結構、探索性開發、快速原型
- ✅ **優勢**：靈活性高、無需預定義結構、快速開發

**3. ListOutputConverter**
- 🎯 **用途**：這個轉換器顧名思義就是將結果轉為 List，不過這裡主要以字串的 List 為主
- 🔧 **技術實現**：解析 AI 回應中的列表項目
- 📋 **適用場景**：簡單列表資料、選項清單、標籤集合
- ✅ **優勢**：簡單直接、處理效率高、記憶體佔用少

**使用建議**：
- 例如請 AI 提供最受歡迎的五種冰淇淋口味，若是結構化的複數資料則還是使用 `BeanOutputConverter` 進行轉換，只是將 Bean 的類別改為 `ParameterizedTypeReference`

---

## 5.10.3 現代化 API 實現

### 方法一：使用 ChatClient entity() 方法（推薦）

Spring AI 1.1 新增的 `entity()` 方法是最簡潔的方式，它會自動處理類型轉換：

```java
// 對應範例: chapter5-spring-ai-advanced/.../StructuredOutputController.java:108

@RestController
@RequestMapping("/api/structured")
@RequiredArgsConstructor
@Slf4j
public class StructuredOutputController {
    
    private final ChatClient chatClient;
    
    /**
     * 單一演員的電影作品
     * @param actor 演員名稱
     * @return 演員電影作品
     */
    @GetMapping("/actor-films")
    public ActorsFilms getActorFilms(@RequestParam String actor) {
        try {
            log.info("查詢演員電影作品：{}", actor);
            
            ActorsFilms result = chatClient.prompt()
                    .user("Generate the filmography of 5 movies for {actor}. " +
                          "Please provide the response in JSON format with 'actor' and 'movies' fields.", 
                          Map.of("actor", actor))
                    .call()
                    .entity(ActorsFilms.class);
            
            log.info("成功取得 {} 的電影作品，共 {} 部電影", 
                    result.actor(), result.movies().size());
            
            return result;
            
        } catch (Exception e) {
            log.error("查詢演員電影作品失敗：{}", actor, e);
            return new ActorsFilms(actor, List.of("查詢失敗：" + e.getMessage()));
        }
    }
    
    /**
     * 多位演員的電影作品
     * @return 多位演員的電影作品列表
     */
    @GetMapping("/multiple-actors")
    public List<ActorsFilms> getMultipleActors() {
        try {
            log.info("查詢多位演員電影作品");
            
            List<ActorsFilms> results = chatClient.prompt()
                    .user("Generate the filmography of 5 movies each for Tom Hanks and Bill Murray. " +
                          "Please provide the response as a JSON array with each object containing 'actor' and 'movies' fields.")
                    .call()
                    .entity(new ParameterizedTypeReference<List<ActorsFilms>>() {});
            
            log.info("成功取得 {} 位演員的電影作品", results.size());
            
            return results;
            
        } catch (Exception e) {
            log.error("查詢多位演員電影作品失敗", e);
            return List.of(
                new ActorsFilms("Tom Hanks", List.of("查詢失敗：" + e.getMessage())),
                new ActorsFilms("Bill Murray", List.of("查詢失敗：" + e.getMessage()))
            );
        }
    }
    
    /**
     * 電影資訊查詢
     * @param movieTitle 電影標題
     * @return 電影詳細資訊
     */
    @GetMapping("/movie-info")
    public MovieInfo getMovieInfo(@RequestParam String movieTitle) {
        try {
            log.info("查詢電影資訊：{}", movieTitle);
            
            MovieInfo result = chatClient.prompt()
                    .user("Provide detailed information about the movie '{movieTitle}'. " +
                          "Include title, director, year, genre, rating, and a brief plot summary. " +
                          "Format the response as JSON.", 
                          Map.of("movieTitle", movieTitle))
                    .call()
                    .entity(MovieInfo.class);
            
            log.info("成功取得電影資訊：{} ({})", result.title(), result.year());
            
            return result;
            
        } catch (Exception e) {
            log.error("查詢電影資訊失敗：{}", movieTitle, e);
            return new MovieInfo(
                    movieTitle,
                    "未知",
                    0,
                    "未知",
                    0.0,
                    "查詢失敗：" + e.getMessage()
            );
        }
    }
    
    /**
     * 產品推薦列表
     * @param category 產品類別
     * @param count 推薦數量
     * @return 產品推薦列表
     */
    @GetMapping("/product-recommendations")
    public ProductRecommendations getProductRecommendations(
            @RequestParam String category,
            @RequestParam(defaultValue = "5") int count) {
        
        try {
            log.info("查詢產品推薦：類別={}，數量={}", category, count);
            
            ProductRecommendations result = chatClient.prompt()
                    .user("Recommend {count} popular {category} products. " +
                          "For each product, provide name, brand, price, rating, and description. " +
                          "Format as JSON with 'category', 'count', and 'products' array.",
                          Map.of("count", count, "category", category))
                    .call()
                    .entity(ProductRecommendations.class);
            
            log.info("成功取得 {} 類別的 {} 個產品推薦", 
                    result.category(), result.products().size());
            
            return result;
            
        } catch (Exception e) {
            log.error("查詢產品推薦失敗：類別={}", category, e);
            return new ProductRecommendations(
                    category,
                    0,
                    List.of(),
                    "查詢失敗：" + e.getMessage()
            );
        }
    }
}
```

**使用說明**：
1. **自動轉換**：只需指定目標類型，Spring AI 會自動處理 JSON 解析
2. **類型安全**：編譯時期就能發現型別錯誤
3. **簡潔明瞭**：不需要手動建立轉換器
4. **異常處理**：自動處理轉換失敗的情況

### 資料模型定義

```java
// 對應範例: chapter5-spring-ai-advanced/.../model/ActorsFilms.java

/**
 * 演員電影作品
 */
public record ActorsFilms(
        @JsonProperty("actor") String actor,
        @JsonProperty("movies") List<String> movies
) {}

/**
 * 電影資訊
 */
public record MovieInfo(
        @JsonProperty("title") String title,
        @JsonProperty("director") String director,
        @JsonProperty("year") int year,
        @JsonProperty("genre") String genre,
        @JsonProperty("rating") double rating,
        @JsonProperty("plot") String plot
) {}

/**
 * 產品資訊
 */
public record Product(
        @JsonProperty("name") String name,
        @JsonProperty("brand") String brand,
        @JsonProperty("price") double price,
        @JsonProperty("rating") double rating,
        @JsonProperty("description") String description
) {}

/**
 * 產品推薦列表
 */
public record ProductRecommendations(
        @JsonProperty("category") String category,
        @JsonProperty("count") int count,
        @JsonProperty("products") List<Product> products,
        @JsonProperty("error") String error
) {
    public ProductRecommendations(String category, int count, List<Product> products) {
        this(category, count, products, null);
    }
}

/**
 * 企業資料分析結果
 */
public record BusinessAnalysis(
        @JsonProperty("summary") String summary,
        @JsonProperty("key_metrics") List<KeyMetric> keyMetrics,
        @JsonProperty("recommendations") List<String> recommendations,
        @JsonProperty("risk_factors") List<String> riskFactors,
        @JsonProperty("confidence_score") double confidenceScore
) {}

public record KeyMetric(
        @JsonProperty("name") String name,
        @JsonProperty("value") String value,
        @JsonProperty("trend") String trend,
        @JsonProperty("importance") String importance
) {}
```

---

**資料模型設計原則**：
1. **使用 Record**：Java 16+ 的 record 提供簡潔的資料類別定義
2. **JSON 註解**：使用 `@JsonProperty` 明確指定 JSON 欄位名稱
3. **不可變性**：record 天生不可變，適合資料傳輸
4. **清晰命名**：使用有意義的欄位名稱

---

## 5.10.4 傳統轉換器實現

### 轉換流程比較

在了解傳統方式之前，先看看兩種方式的流程差異：

```mermaid
sequenceDiagram
    participant C as Controller
    participant CC as ChatClient
    participant AI as AI Model
    participant Conv as Converter

    rect rgb(225, 245, 254)
    Note over C,AI: 現代化方式 (entity)
    C->>CC: .entity(Class)
    CC->>AI: 發送請求
    AI-->>CC: JSON 回應
    CC->>CC: 自動轉換
    CC-->>C: Java Object
    end

    rect rgb(255, 244, 230)
    Note over C,Conv: 傳統方式 (Converter)
    C->>Conv: new Converter(Class)
    C->>Conv: getFormat()
    Conv-->>C: JSON Schema
    C->>CC: 包含 format
    CC->>AI: 發送請求
    AI-->>CC: JSON 回應
    CC-->>C: String
    C->>Conv: convert(String)
    Conv-->>C: Java Object
    end
```

**流程說明**：
- **現代化方式**：只需一次 API 調用，自動處理轉換
- **傳統方式**：需要手動管理格式描述和轉換步驟
- **選擇建議**：優先使用現代化方式，除非需要特殊控制

### 方法二：使用傳統的 StructuredOutputConverter

如果你需要更多控制權或使用舊版 Spring AI，仍可以使用傳統的轉換器：

```java
// 對應範例: chapter5-spring-ai-advanced/.../ConverterController.java:323

@RestController
@RequestMapping("/api/converter")
@RequiredArgsConstructor
@Slf4j
public class ConverterController {
    
    private final ChatClient chatClient;
    
    /**
     * Bean Output Converter 範例
     * @param actor 演員名稱
     * @return 演員電影作品
     */
    @GetMapping("/actor-films-converter")
    public ActorsFilms getActorFilmsWithConverter(@RequestParam String actor) {
        try {
            log.info("使用 BeanOutputConverter 查詢演員電影作品：{}", actor);
            
            BeanOutputConverter<ActorsFilms> beanOutputConverter = 
                    new BeanOutputConverter<>(ActorsFilms.class);
            String format = beanOutputConverter.getFormat();
            
            log.debug("轉換器格式：{}", format);
            
            String response = chatClient.prompt()
                    .user("Generate the filmography of 5 movies for {actor}. {format}", 
                          Map.of("actor", actor, "format", format))
                    .call()
                    .content();
            
            log.debug("AI 回應：{}", response);
            
            ActorsFilms result = beanOutputConverter.convert(response);
            
            log.info("成功轉換演員電影作品：{}", result.actor());
            
            return result;
            
        } catch (Exception e) {
            log.error("BeanOutputConverter 查詢失敗：{}", actor, e);
            return new ActorsFilms(actor, List.of("查詢失敗：" + e.getMessage()));
        }
    }
    
    /**
     * Map Output Converter 範例
     * @return 數字資料的 Map 格式
     */
    @GetMapping("/numbers-map")
    public Map<String, Object> getNumbersAsMap() {
        try {
            log.info("使用 MapOutputConverter 查詢數字資料");
            
            MapOutputConverter mapOutputConverter = new MapOutputConverter();
            String format = mapOutputConverter.getFormat();
            
            log.debug("轉換器格式：{}", format);
            
            String response = chatClient.prompt()
                    .user("Provide interesting statistics about the number 42. {format}", 
                          Map.of("format", format))
                    .call()
                    .content();
            
            log.debug("AI 回應：{}", response);
            
            Map<String, Object> result = mapOutputConverter.convert(response);
            
            log.info("成功轉換為 Map，包含 {} 個鍵值對", result.size());
            
            return result;
            
        } catch (Exception e) {
            log.error("MapOutputConverter 查詢失敗", e);
            return Map.of("error", "查詢失敗：" + e.getMessage());
        }
    }
    
    /**
     * List Output Converter 範例
     * @param category 類別
     * @param count 數量
     * @return 項目列表
     */
    @GetMapping("/items-list")
    public List<String> getItemsList(
            @RequestParam String category,
            @RequestParam(defaultValue = "5") int count) {
        
        try {
            log.info("使用 ListOutputConverter 查詢項目列表：類別={}，數量={}", category, count);
            
            ListOutputConverter listOutputConverter = 
                    new ListOutputConverter(new DefaultConversionService());
            String format = listOutputConverter.getFormat();
            
            log.debug("轉換器格式：{}", format);
            
            String response = chatClient.prompt()
                    .user("List {count} popular {category} items. {format}",
                          Map.of("count", count, "category", category, "format", format))
                    .call()
                    .content();
            
            log.debug("AI 回應：{}", response);
            
            List<String> result = listOutputConverter.convert(response);
            
            log.info("成功轉換為列表，包含 {} 個項目", result.size());
            
            return result;
            
        } catch (Exception e) {
            log.error("ListOutputConverter 查詢失敗：類別={}", category, e);
            return List.of("查詢失敗：" + e.getMessage());
        }
    }
    
    /**
     * 複雜業務分析（使用 BeanOutputConverter）
     * @param businessData 業務資料
     * @return 分析結果
     */
    @PostMapping("/business-analysis")
    public BusinessAnalysis analyzeBusinessData(@RequestBody String businessData) {
        try {
            log.info("使用 BeanOutputConverter 進行業務分析");
            
            BeanOutputConverter<BusinessAnalysis> converter = 
                    new BeanOutputConverter<>(BusinessAnalysis.class);
            String format = converter.getFormat();
            
            String response = chatClient.prompt()
                    .user("Analyze the following business data and provide insights: \n{data}\n\n" +
                          "Please provide a comprehensive analysis including summary, key metrics, " +
                          "recommendations, risk factors, and confidence score. {format}",
                          Map.of("data", businessData, "format", format))
                    .call()
                    .content();
            
            BusinessAnalysis result = converter.convert(response);
            
            log.info("業務分析完成，信心分數：{}", result.confidenceScore());
            
            return result;
            
        } catch (Exception e) {
            log.error("業務分析失敗", e);
            return new BusinessAnalysis(
                    "分析失敗：" + e.getMessage(),
                    List.of(),
                    List.of(),
                    List.of("系統錯誤"),
                    0.0
            );
        }
    }
}
```

---

**傳統方式的步驟**：
1. **建立轉換器**：指定目標類型
2. **取得格式描述**：`getFormat()` 返回 JSON Schema 描述
3. **包含格式**：將格式描述加入提示詞
4. **手動轉換**：調用 `convert()` 方法

**何時使用傳統方式**：
- 需要自定義 JSON Schema 格式
- 需要在轉換前後添加額外邏輯
- 使用 Spring AI 舊版本
- 需要更細緻的錯誤處理

---

## 5.10.5 企業級應用場景

### 資料分析平台整合

```java
// 對應範例: chapter5-spring-ai-advanced/.../StructuredAnalysisService.java:489

@Service
@RequiredArgsConstructor
@Slf4j
public class StructuredAnalysisService {
    
    private final ChatClient chatClient;
    
    /**
     * 銷售資料分析
     * @param salesData 銷售資料
     * @return 結構化分析結果
     */
    public SalesAnalysisResult analyzeSalesData(Map<String, Object> salesData) {
        try {
            log.info("開始銷售資料分析");
            
            SalesAnalysisResult result = chatClient.prompt()
                    .system("你是一個專業的銷售資料分析師，請提供準確且結構化的分析結果。")
                    .user("分析以下銷售資料並提供洞察：\n{data}\n\n" +
                          "請提供結構化的分析，包括：\n" +
                          "1. 銷售趨勢分析\n" +
                          "2. 產品表現評估\n" +
                          "3. 市場機會識別\n" +
                          "4. 改進建議\n" +
                          "5. 風險評估",
                          Map.of("data", salesData))
                    .call()
                    .entity(SalesAnalysisResult.class);
            
            log.info("銷售資料分析完成，趨勢：{}", result.trend());
            
            return result;
            
        } catch (Exception e) {
            log.error("銷售資料分析失敗", e);
            throw new RuntimeException("銷售資料分析失敗：" + e.getMessage());
        }
    }
    
    /**
     * 客戶行為分析
     * @param customerData 客戶資料
     * @return 客戶洞察
     */
    public CustomerInsights analyzeCustomerBehavior(List<Map<String, Object>> customerData) {
        try {
            log.info("開始客戶行為分析，資料筆數：{}", customerData.size());
            
            CustomerInsights result = chatClient.prompt()
                    .system("你是一個客戶行為分析專家，請基於資料提供深入的客戶洞察。")
                    .user("分析以下客戶行為資料：\n{data}\n\n" +
                          "請提供結構化的客戶洞察，包括：\n" +
                          "1. 客戶細分\n" +
                          "2. 行為模式\n" +
                          "3. 偏好分析\n" +
                          "4. 流失風險\n" +
                          "5. 個性化建議",
                          Map.of("data", customerData))
                    .call()
                    .entity(CustomerInsights.class);
            
            log.info("客戶行為分析完成，識別出 {} 個客戶群體", 
                    result.segments().size());
            
            return result;
            
        } catch (Exception e) {
            log.error("客戶行為分析失敗", e);
            throw new RuntimeException("客戶行為分析失敗：" + e.getMessage());
        }
    }
    
    /**
     * 市場趨勢預測
     * @param marketData 市場資料
     * @param timeframe 預測時間範圍
     * @return 市場預測結果
     */
    public MarketForecast predictMarketTrends(Map<String, Object> marketData, String timeframe) {
        try {
            log.info("開始市場趨勢預測，時間範圍：{}", timeframe);
            
            MarketForecast result = chatClient.prompt()
                    .system("你是一個市場分析和預測專家，請基於歷史資料提供準確的市場預測。")
                    .user("基於以下市場資料預測 {timeframe} 的市場趨勢：\n{data}\n\n" +
                          "請提供結構化的預測結果，包括：\n" +
                          "1. 整體市場趨勢\n" +
                          "2. 關鍵指標預測\n" +
                          "3. 機會與威脅\n" +
                          "4. 策略建議\n" +
                          "5. 預測信心度",
                          Map.of("data", marketData, "timeframe", timeframe))
                    .call()
                    .entity(MarketForecast.class);
            
            log.info("市場趨勢預測完成，整體趨勢：{}，信心度：{}", 
                    result.overallTrend(), result.confidenceLevel());
            
            return result;
            
        } catch (Exception e) {
            log.error("市場趨勢預測失敗", e);
            throw new RuntimeException("市場趨勢預測失敗：" + e.getMessage());
        }
    }
}
```

**企業級應用的關鍵要素**：
1. **明確的系統提示詞**：定義 AI 的角色和專業領域
2. **結構化輸出**：確保 AI 回應符合預期格式
3. **錯誤處理**：提供完善的異常處理機制
4. **日誌記錄**：追蹤分析過程和結果

### 企業資料模型

```java
// 對應範例: chapter5-spring-ai-advanced/.../model/

/**
 * 銷售分析結果
 */
public record SalesAnalysisResult(
        @JsonProperty("trend") String trend,
        @JsonProperty("total_revenue") double totalRevenue,
        @JsonProperty("growth_rate") double growthRate,
        @JsonProperty("top_products") List<String> topProducts,
        @JsonProperty("opportunities") List<String> opportunities,
        @JsonProperty("recommendations") List<String> recommendations,
        @JsonProperty("risk_factors") List<String> riskFactors
) {}

/**
 * 客戶洞察
 */
public record CustomerInsights(
        @JsonProperty("segments") List<CustomerSegment> segments,
        @JsonProperty("behavior_patterns") List<String> behaviorPatterns,
        @JsonProperty("preferences") List<String> preferences,
        @JsonProperty("churn_risk") ChurnRisk churnRisk,
        @JsonProperty("personalization_suggestions") List<String> personalizationSuggestions
) {}

public record CustomerSegment(
        @JsonProperty("name") String name,
        @JsonProperty("size") int size,
        @JsonProperty("characteristics") List<String> characteristics,
        @JsonProperty("value") String value
) {}

public record ChurnRisk(
        @JsonProperty("high_risk_count") int highRiskCount,
        @JsonProperty("medium_risk_count") int mediumRiskCount,
        @JsonProperty("low_risk_count") int lowRiskCount,
        @JsonProperty("key_indicators") List<String> keyIndicators
) {}

/**
 * 市場預測
 */
public record MarketForecast(
        @JsonProperty("overall_trend") String overallTrend,
        @JsonProperty("key_metrics") List<MetricForecast> keyMetrics,
        @JsonProperty("opportunities") List<String> opportunities,
        @JsonProperty("threats") List<String> threats,
        @JsonProperty("strategic_recommendations") List<String> strategicRecommendations,
        @JsonProperty("confidence_level") double confidenceLevel,
        @JsonProperty("timeframe") String timeframe
) {}

public record MetricForecast(
        @JsonProperty("metric_name") String metricName,
        @JsonProperty("current_value") double currentValue,
        @JsonProperty("predicted_value") double predictedValue,
        @JsonProperty("change_percentage") double changePercentage,
        @JsonProperty("confidence") double confidence
) {}
```

---

## 5.10.6 最佳實踐和優化

### 轉換器選擇指南

```java
// 對應範例: chapter5-spring-ai-advanced/.../ConverterSelectionGuide.java:665

@Service
@Slf4j
public class ConverterSelectionGuide {
    
    /**
     * 根據使用場景選擇最適合的轉換器
     */
    public String getRecommendedApproach(String useCase) {
        return switch (useCase.toLowerCase()) {
            case "simple_entity" -> 
                "推薦使用 ChatClient.entity() 方法 - 最簡潔且類型安全";
            
            case "complex_validation" -> 
                "推薦使用 BeanOutputConverter - 可以添加自定義驗證邏輯";
            
            case "dynamic_structure" -> 
                "推薦使用 MapOutputConverter - 適合未知或動態的資料結構";
            
            case "simple_list" -> 
                "推薦使用 ListOutputConverter - 處理簡單的列表資料";
            
            case "enterprise_integration" -> 
                "推薦使用 ChatClient.entity() + 自定義 Jackson 配置";
            
            default -> 
                "建議先使用 ChatClient.entity() 方法，如需更多控制再考慮傳統轉換器";
        };
    }
}
```

### 效能優化配置

```java
// 對應範例: chapter5-spring-ai-advanced/.../StructuredOutputConfig.java:754

@Configuration
public class StructuredOutputConfig {

    /**
     * 自定義 ObjectMapper 用於結構化輸出
     */
    @Bean("structuredOutputMapper")
    public ObjectMapper structuredOutputMapper() {
        return new ObjectMapper()
                .setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE)
                .findAndRegisterModules()
                .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }
}
```

**效能優化技巧**：
1. **自定義 ObjectMapper**：配置序列化和反序列化選項
2. **命名策略**：統一使用 snake_case 或 camelCase
3. **寬鬆模式**：允許未知屬性，提高容錯性
4. **模組自動註冊**：支援 Java 8 時間 API 等

---

## 📝 本章重點回顧

1. **結構化輸出理解**：掌握了 AI 結構化資料輸出的重要性和技術實現
2. **現代化 API 使用**：學會了使用 ChatClient 的 entity() 方法進行類型轉換
3. **傳統轉換器掌握**：了解了三種轉換器的特點和適用場景
4. **企業級應用設計**：實現了完整的結構化資料處理系統
5. **最佳實踐應用**：掌握了轉換器選擇和效能優化策略

### 實務技巧

**資料模型設計**：
```java
// ✅ 好的設計：清晰、具體、可維護
public record UserAnalysis(
    @JsonProperty("user_id") String userId,
    @JsonProperty("segment") String segment,
    @JsonProperty("risk_score") double riskScore,
    @JsonProperty("recommendations") List<String> recommendations
) {}

// ❌ 不好的設計：模糊、過於複雜、難以維護
public record Data(
    Object info,
    Map<String, Object> details
) {}
```

**錯誤處理最佳實踐**：
```java
// ✅ 提供降級方案
try {
    return chatClient.prompt()
        .user(prompt)
        .call()
        .entity(Result.class);
} catch (Exception e) {
    log.error("轉換失敗，使用預設值", e);
    return new Result("N/A", 0.0, List.of());  // 返回安全的預設值
}

// ❌ 直接拋出異常
return chatClient.prompt()
    .user(prompt)
    .call()
    .entity(Result.class);  // 可能導致系統崩潰
```

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **ChatClient entity()** | ⭐⭐⭐ | 低 | 現代化應用開發 |
| **BeanOutputConverter** | ⭐⭐⭐ | 中 | 複雜資料結構 |
| **MapOutputConverter** | ⭐⭐ | 低 | 動態資料處理 |
| **ListOutputConverter** | ⭐⭐ | 低 | 簡單列表資料 |
| **資料模型設計** | ⭐⭐ | 中 | 企業級應用 |
| **錯誤處理** | ⭐⭐ | 中 | 生產環境穩定性 |

### 選擇建議

**1. 新專案推薦**
- ✅ **優先選擇**：ChatClient entity() 方法
- 🎯 **理由**：簡潔、類型安全、易於維護
- 📋 **適用**：90% 的結構化輸出需求

**2. 特殊需求場景**
- 🔧 **BeanOutputConverter**：需要自定義格式描述或驗證邏輯
- 🗺️ **MapOutputConverter**：處理未知或動態的資料結構
- 📝 **ListOutputConverter**：簡單的字串列表處理

**3. 企業級應用建議**
- 🏢 **混合使用**：根據具體場景選擇最適合的方法
- 📊 **監控機制**：追蹤轉換成功率和效能指標
- 🛡️ **錯誤處理**：實現完善的異常處理和降級機制
- 🔄 **版本管理**：考慮資料模型的版本相容性

### 企業應用價值

**1. 系統整合效益**
- 🔗 **API 標準化**：提供一致的資料介面格式
- 📊 **資料處理自動化**：減少人工資料處理工作
- 🎯 **類型安全保證**：編譯時期發現資料結構問題
- 🚀 **開發效率提升**：簡化 AI 輸出的處理邏輯

**2. 業務價值創造**
- 💼 **決策支援**：結構化的分析結果支援商業決策
- 📈 **洞察生成**：自動化的資料洞察和趨勢分析
- 🎨 **個性化服務**：基於結構化資料的個性化推薦
- 🔍 **智能分析**：深度的業務資料分析和預測

### 下一步學習方向

恭喜您完成了第五章「個性化 ChatBot」的完整學習！接下來我們將進入第六章，學習如何讓 ChatBot 擁有記憶能力，建立真正智能的對話系統。

---

**參考資料：**
- [Spring AI Structured Output Documentation](https://docs.spring.io/spring-ai/reference/api/structured-output-converter.html)
- [ChatClient Entity Method Guide](https://docs.spring.io/spring-ai/reference/api/chatclient.html)
- [Jackson JSON Processing](https://github.com/FasterXML/jackson)
- [OpenAI Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)
- 完整範例程式碼：`code-examples/chapter5-spring-ai-advanced`
# 4.3 如何像 ChatGPT 產生流式輸出

> **本章重點**：學習實現 AI 流式輸出功能，讓使用者體驗如同 ChatGPT 般的即時回應效果，大幅提升應用程式的互動性和使用者滿意度。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解流式輸出原理**：掌握 Server-Sent Events (SSE) 的工作機制
- 🎯 **實現 AI 流式回應**：使用 ChatClient 建立流式 AI 對話功能
- 🎯 **優化使用者體驗**：讓 AI 回應即時顯示，避免長時間等待
- 🎯 **處理流式資料**：掌握 Reactive Streams 和背壓處理
- 🎯 **前端整合技術**：學會使用 EventSource 接收流式資料

---

## 4.3.1 為什麼需要流式輸出？

### 使用者體驗的革命

![流式輸出](https://ithelp.ithome.com.tw/upload/images/20240810/20161290gaE6Faz85x.jpg)

由於 AI 產生內容得靠伺服器運算後產生結果，資料多的話得等不少時間，若能產生資料後馬上分段送出，可大大提升使用者感受。

**傳統同步回應 vs 流式輸出**：

```
傳統方式：
使用者提問 → [等待 10 秒] → 完整回應顯示

流式輸出：
使用者提問 → [0.5秒] 開始顯示 → [持續更新] → 完整回應
```

**流式輸出的優勢**：
- ⚡ **即時反饋**：使用者立即看到 AI 開始回應
- 🎯 **降低焦慮**：避免長時間等待造成的不確定感
- 📱 **更好的互動性**：類似真人對話的體驗
- 🚀 **感知效能提升**：雖然總時間相同，但感覺更快
- 💡 **早期中斷**：使用者可以提前判斷回應品質

### Server-Sent Events (SSE) 技術

要達到這種效果主要靠的是 **Server-Sent Events (SSE)** 伺服器主動推播協定：

**SSE 特點**：
- 📡 **單向通訊**：伺服器向客戶端推送資料
- 🔄 **自動重連**：連線中斷時自動重新連接
- 🌐 **標準協定**：基於 HTTP，廣泛支援
- 💻 **瀏覽器原生支援**：使用 EventSource API

---

## 4.3.2 ChatClient 流式輸出實作

### 基本流式輸出

Spring AI 1.0 GA 的 ChatClient 提供了優雅的流式輸出 API。以下是 `StreamingAiController` 中實現基本流式對話和帶系統提示詞流式對話的範例：

```java
// 來自 code-examples/chapter4-spring-ai-intro/src/main/java/com/example/springai/controller/StreamingAiController.java
// ... (package and imports omitted for brevity)

@RestController
@RequestMapping("/api/ai")
@RequiredArgsConstructor
@Slf4j
public class StreamingAiController {
    
    private final ChatClient chatClient;

    /**
     * 基本流式 AI 對話
     * @param prompt 使用者輸入的提示詞
     * @return 流式字串回應
     */
    @GetMapping(value = "/chat/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> chatStream(@RequestParam String prompt) {
        log.info("開始流式對話：{}", prompt);
        
        return chatClient.prompt()
                .user(prompt)
                .stream()
                .content();
    }
}
```

### 程式碼重點說明

**核心 API**：
- **`stream()`**: 替代 `call()` 來啟用流式輸出
- **`content()`**: 返回 `Flux<String>` 流式字串內容
- **`produces = MediaType.TEXT_EVENT_STREAM_VALUE`**: 指定回應格式為 SSE

**Reactive 操作符**：
- **`doOnSubscribe()`**: 訂閱時執行的動作
- **`doOnComplete()`**: 完成時執行的動作
- **`doOnNext()`**: 每個元素發出時執行的動作

---

## 4.3.3 進階流式輸出控制

### 自定義流式輸出處理

您可以透過 `map`、`filter`、`doOnNext` 等 Reactive 操作符來自定義流式輸出的處理邏輯：

```java
// 來自 code-examples/chapter4-spring-ai-intro/src/main/java/com/example/springai/controller/StreamingAiController.java
// ... (package and imports omitted for brevity)

@RestController
@RequestMapping("/api/ai")
@RequiredArgsConstructor
@Slf4j
public class StreamingAiController {

    private final ChatClient chatClient;

    // ... 其他方法 ...

    /**
     * 自定義流式輸出處理
     * @param prompt 使用者輸入
     * @return 處理後的流式回應
     */
    @GetMapping(value = "/chat/stream/custom", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> chatStreamCustom(@RequestParam String prompt) {
        return chatClient.prompt()
                .user(prompt)
                .stream()
                .content()
                .map(content -> {
                    // 自定義處理每個流式片段
                    return "🤖 AI: " + content;
                })
                .filter(content -> {
                    // 過濾空內容
                    return content != null && !content.trim().isEmpty();
                })
                .doOnNext(content -> {
                    // 記錄每個片段
                    log.debug("流式內容：{}", content);
                })
                .onErrorResume(error -> {
                    log.error("流式輸出錯誤", error);
                    return Flux.just("❌ 抱歉，發生錯誤：" + error.getMessage());
                });
    }
}
```

---

## 4.3.4 使用 ChatModel 的流式輸出

如果直接使用 `ChatModel`，也可以實現流式輸出。`ChatModelService` 示範了如何使用底層的 `StreamingChatModel` API：

```java
// 來自 code-examples/chapter4-spring-ai-intro/src/main/java/com/example/springai/service/ChatModelService.java
// ... (package and imports omitted for brevity)

@Service
@RequiredArgsConstructor
@Slf4j
public class ChatModelService {

    // private final ChatModel chatModel; // 移除不相關的成員變數
    private final StreamingChatModel streamingChatModel;

    /**
     * 流式呼叫
     */
    public Flux<String> streamCall(String message) {
        return streamingChatModel.stream(message);
    }
}
```

---

## 4.3.5 應用程式配置

### 必要依賴

要使用 Spring AI 的流式輸出功能，必須包含 WebFlux 依賴，即使是命令式應用程式也需要：

```xml
<!-- 來自 code-examples/chapter4-spring-ai-intro/pom.xml -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>

<!-- Spring AI OpenAI Starter -->
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
</dependency>
```

### Spring Boot 配置

確保在 `application.yml` 中正確設定字元編碼和流式選項：

```yaml
# 來自 code-examples/chapter4-spring-ai-intro/src/main/resources/application.yml
server:
  port: 8080
  servlet:
    encoding:
      charset: UTF-8
      enabled: true
      force: true

spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      base-url: https://api.openai.com
      chat:
        options:
          model: gpt-4o-mini
          temperature: 0.7
          max-tokens: 1000
          stream: true  # 啟用流式輸出

# 日誌配置
logging:
  level:
    org.springframework.ai: DEBUG
    reactor.netty: INFO
    com.example.springai: DEBUG
```

### 跨域配置 (CORS)

如果前端和後端在不同的網域，需要配置 CORS。以下是 `CorsConfig.java` 的範例：

```java
// 來自 code-examples/chapter4-spring-ai-intro/src/main/java/com/example/springai/config/CorsConfig.java
// ... (package and imports omitted for brevity)

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOriginPatterns("*")  // 允許所有來源（開發環境使用，生產環境應限制為具體域名）
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);  // 預檢請求快取時間（秒）
    }
}
```

---

## 📝 本章重點回顧

1. **流式輸出原理**：理解了 SSE 技術和流式輸出的優勢
2. **ChatClient 流式 API**：掌握了使用 `stream()` 方法實現流式輸出
3. **Reactive Streams**：學會了使用 Flux 處理流式資料
4. **前端整合**：了解如何使用 EventSource 接收流式資料
5. **效能優化**：掌握了背壓處理、錯誤處理等最佳實踐

### 新舊版本對比

| 功能 | 舊版本 (pre-1.0) | 新版本 (1.0 GA) |
|------|------------------|----------------|
| **API 風格** | `chatModel.stream(prompt)` | `chatClient.prompt().user(prompt).stream().content()` |
| **可讀性** | 較低 | 高（Fluent API） |
| **功能豐富度** | 基礎 | 豐富（系統提示詞、選項配置等） |
| **錯誤處理** | 需手動實作 | 內建支援 |
| **效能優化** | 有限 | 完整的 Reactive 支援 |

### 下一步學習方向

在下一章中，我們將深入探討 ChatModel 的內部機制，了解不同 AI 模型的特性和選擇策略，為企業級應用做好準備。

---

**參考資料：**
- [Server-Sent Events Specification](https://html.spec.whatwg.org/multipage/server-sent-events.html)
- [Spring WebFlux Reactive Streams](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html)
- [Project Reactor Documentation](https://projectreactor.io/docs/core/release/reference/)
- [Spring AI Streaming Documentation](https://docs.spring.io/spring-ai/reference/api/chatclient.html#streaming)

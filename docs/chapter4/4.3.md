# 4.3 如何像 ChatGPT 產生流式輸出

> **對應章節**: Day13
> **對應範例**: `chapter4-spring-ai-intro`
> **難度**: ⭐⭐⭐⭐☆

---

## 📚 本章概要

流式輸出是現代 AI 應用的標配功能。本章將教您如何實現 ChatGPT 般的即時回應效果，透過 Server-Sent Events (SSE) 技術讓 AI 回應逐字顯示。

**學習目標**:
- 理解流式輸出的原理和優勢
- 掌握 Server-Sent Events (SSE) 技術
- 使用 ChatClient 實現流式 AI 對話
- 處理 Reactive Streams 和錯誤情況
- 配置 CORS 支援前端整合

---

## 4.3.1 為什麼需要流式輸出？

### 使用者體驗的革命

![流式輸出](https://ithelp.ithome.com.tw/upload/images/20240810/20161290gaE6Faz85x.jpg)

由於 AI 產生內容得靠伺服器運算後產生結果，資料多的話得等不少時間，若能產生資料後馬上分段送出，可大大提升使用者感受。

### 問題場景: 沒有流式輸出會怎樣？

```
❌ 傳統同步回應:
使用者: "請寫一篇500字的文章"
      ↓
   [等待15秒...]  ← 使用者焦慮，不知道是否還在處理
      ↓
   完整文章一次顯示

問題:
- 長時間等待造成焦慮
- 無法提前判斷回應品質
- 感覺系統沒反應
- 無法中途中斷

✅ 流式輸出:
使用者: "請寫一篇500字的文章"
      ↓
   [0.5秒] "春天是..." ← 立即看到開始回應
      ↓
   [持續更新] "春天是萬物復甦的季節..."
      ↓
   [可隨時停止] 完整回應

優勢:
- 即時反饋，降低焦慮
- 可提前判斷品質
- 類似真人對話體驗
- 可中途中斷節省成本
```

**流式輸出的優勢**：
- ⚡ **即時反饋**：使用者立即看到 AI 開始回應
- 🎯 **降低焦慮**：避免長時間等待造成的不確定感
- 📱 **更好的互動性**：類似真人對話的體驗
- 🚀 **感知效能提升**：雖然總時間相同，但感覺更快
- 💡 **早期中斷**：使用者可以提前判斷回應品質

### Server-Sent Events (SSE) 技術

要達到這種效果主要靠的是 **Server-Sent Events (SSE)** 伺服器主動推播協定：

**SSE 特點**：
- 📡 **單向通訊**：伺服器向客戶端推送資料
- 🔄 **自動重連**：連線中斷時自動重新連接
- 🌐 **標準協定**：基於 HTTP，廣泛支援
- 💻 **瀏覽器原生支援**：使用 EventSource API

---

## 4.3.2 ChatClient 流式輸出實作

### 基本流式輸出

Spring AI 1.0 GA 的 ChatClient 提供了優雅的流式輸出 API。以下是 `StreamingAiController` 中實現基本流式對話和帶系統提示詞流式對話的範例：

```java
// 來自 code-examples/chapter4-spring-ai-intro/src/main/java/com/example/springai/controller/StreamingAiController.java
// ... (package and imports omitted for brevity)

@RestController
@RequestMapping("/api/ai")
@RequiredArgsConstructor
@Slf4j
public class StreamingAiController {
    
    private final ChatClient chatClient;

    /**
     * 基本流式 AI 對話
     * @param prompt 使用者輸入的提示詞
     * @return 流式字串回應
     */
    @GetMapping(value = "/chat/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> chatStream(@RequestParam String prompt) {
        log.info("開始流式對話：{}", prompt);
        
        return chatClient.prompt()
                .user(prompt)
                .stream()
                .content();
    }
}
```

### 程式碼重點說明

**核心 API**：
- **`stream()`**: 替代 `call()` 來啟用流式輸出
- **`content()`**: 返回 `Flux<String>` 流式字串內容
- **`produces = MediaType.TEXT_EVENT_STREAM_VALUE`**: 指定回應格式為 SSE

**Reactive 操作符**：
- **`doOnSubscribe()`**: 訂閱時執行的動作
- **`doOnComplete()`**: 完成時執行的動作
- **`doOnNext()`**: 每個元素發出時執行的動作

---

## 4.3.3 進階流式輸出控制

### 自定義流式輸出處理

您可以透過 `map`、`filter`、`doOnNext` 等 Reactive 操作符來自定義流式輸出的處理邏輯：

```java
// 來自 code-examples/chapter4-spring-ai-intro/src/main/java/com/example/springai/controller/StreamingAiController.java
// ... (package and imports omitted for brevity)

@RestController
@RequestMapping("/api/ai")
@RequiredArgsConstructor
@Slf4j
public class StreamingAiController {

    private final ChatClient chatClient;

    // ... 其他方法 ...

    /**
     * 自定義流式輸出處理
     * @param prompt 使用者輸入
     * @return 處理後的流式回應
     */
    @GetMapping(value = "/chat/stream/custom", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> chatStreamCustom(@RequestParam String prompt) {
        return chatClient.prompt()
                .user(prompt)
                .stream()
                .content()
                .map(content -> {
                    // 自定義處理每個流式片段
                    return "🤖 AI: " + content;
                })
                .filter(content -> {
                    // 過濾空內容
                    return content != null && !content.trim().isEmpty();
                })
                .doOnNext(content -> {
                    // 記錄每個片段
                    log.debug("流式內容：{}", content);
                })
                .onErrorResume(error -> {
                    log.error("流式輸出錯誤", error);
                    return Flux.just("❌ 抱歉，發生錯誤：" + error.getMessage());
                });
    }
}
```

---

## 4.3.4 使用 ChatModel 的流式輸出

如果直接使用 `ChatModel`，也可以實現流式輸出。`ChatModelService` 示範了如何使用底層的 `StreamingChatModel` API：

```java
// 來自 code-examples/chapter4-spring-ai-intro/src/main/java/com/example/springai/service/ChatModelService.java
// ... (package and imports omitted for brevity)

@Service
@RequiredArgsConstructor
@Slf4j
public class ChatModelService {

    // private final ChatModel chatModel; // 移除不相關的成員變數
    private final StreamingChatModel streamingChatModel;

    /**
     * 流式呼叫
     */
    public Flux<String> streamCall(String message) {
        return streamingChatModel.stream(message);
    }
}
```

---

## 4.3.5 應用程式配置

### 必要依賴

要使用 Spring AI 的流式輸出功能，必須包含 WebFlux 依賴，即使是命令式應用程式也需要：

```xml
<!-- 來自 code-examples/chapter4-spring-ai-intro/pom.xml -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>

<!-- Spring AI OpenAI Starter -->
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
</dependency>
```

### Spring Boot 配置

確保在 `application.yml` 中正確設定字元編碼和流式選項：

```yaml
# 來自 code-examples/chapter4-spring-ai-intro/src/main/resources/application.yml
server:
  port: 8080
  servlet:
    encoding:
      charset: UTF-8
      enabled: true
      force: true

spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      base-url: https://api.openai.com
      chat:
        options:
          model: gpt-4o-mini
          temperature: 0.7
          max-tokens: 1000
          stream: true  # 啟用流式輸出

# 日誌配置
logging:
  level:
    org.springframework.ai: DEBUG
    reactor.netty: INFO
    com.example.springai: DEBUG
```

### 跨域配置 (CORS)

如果前端和後端在不同的網域，需要配置 CORS。以下是 `CorsConfig.java` 的範例：

```java
// 來自 code-examples/chapter4-spring-ai-intro/src/main/java/com/example/springai/config/CorsConfig.java
// ... (package and imports omitted for brevity)

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOriginPatterns("*")  // 允許所有來源（開發環境使用，生產環境應限制為具體域名）
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);  // 預檢請求快取時間（秒）
    }
}
```

---

## 📝 本章重點回顧

### 流式輸出核心概念
✅ SSE (Server-Sent Events) - HTML5 標準的單向推送協定
✅ Reactive Streams - 使用 Flux 處理非同步資料流
✅ 背壓處理 - 控制資料流速避免記憶體溢出
✅ 錯誤恢復 - onErrorResume 處理流式錯誤

### ChatClient 流式 API
```java
// 核心模式: stream() 替代 call()
chatClient.prompt()
    .user("使用者訊息")
    .stream()                  // 啟用流式輸出
    .content();                // 返回 Flux<String>
```

### 配置要點
- **Content-Type**: `text/event-stream`
- **依賴**: spring-boot-starter-webflux
- **CORS**: 允許前端跨域存取
- **編碼**: 設定 UTF-8 避免中文亂碼

### SSE vs WebSocket vs 輪詢

| 特性 | SSE | WebSocket | 輪詢 |
|------|-----|-----------|------|
| **複雜度** | 低 | 中 | 低 |
| **即時性** | 高 | 高 | 低 |
| **資源消耗** | 低 | 中 | 高 |
| **自動重連** | 是 | 否 | 否 |
| **適用場景** | AI 流式輸出 | 雙向通訊 | 簡單查詢 |

### Reactive 操作符
- `doOnSubscribe()`: 訂閱時執行
- `doOnNext()`: 每個元素發出時執行
- `doOnComplete()`: 完成時執行
- `onErrorResume()`: 錯誤處理和恢復

---

## 🚀 下一步

👉 [4.4 深入了解 ChatModel](./4.4.md) - 探討 ChatModel 內部機制

---

**相關章節**:
- ← 上一章: [4.2 Hello AI World](./4.2.md)
- → 下一章: [4.4 深入了解 ChatModel](./4.4.md)

**參考資料：**
- [Server-Sent Events Specification](https://html.spec.whatwg.org/multipage/server-sent-events.html)
- [Spring WebFlux Reactive Streams](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html)
- [Project Reactor Documentation](https://projectreactor.io/docs/core/release/reference/)
- [Spring AI Streaming Documentation](https://docs.spring.io/spring-ai/reference/api/chatclient.html#streaming)

# 4.5 前端該如何處理流式輸出

> **對應章節**: Day15
> **對應範例**: `chapter4-spring-ai-intro/frontend-demo`
> **難度**: ⭐⭐⭐⭐☆

---

## 📚 本章概要

前端是使用者體驗的關鍵。本章將教您如何使用 EventSource API 接收後端的流式資料，建立如同 ChatGPT 般流暢的聊天介面。

**學習目標**:
- 掌握 EventSource API 和 SSE 客戶端技術
- 實現即時更新的聊天 UI
- 處理連線管理、錯誤和重連
- 優化使用者體驗（打字效果、載入狀態）
- 整合現代前端框架（React、Vue）

---

## 4.5.1 EventSource API 基礎

### 什麼是 Server-Sent Events (SSE)？

Server-Sent Events 是 HTML5 標準的一部分，允許伺服器向瀏覽器推送資料。與 WebSocket 不同，SSE 是單向的（僅伺服器到客戶端），但對於 AI 流式輸出來說已經足夠。

**SSE vs WebSocket vs 輪詢**：

| 特性 | SSE | WebSocket | 輪詢 |
|------|-----|-----------|------|
| **複雜度** | 低 | 中 | 低 |
| **即時性** | 高 | 高 | 低 |
| **資源消耗** | 低 | 中 | 高 |
| **瀏覽器支援** | 廣泛 | 廣泛 | 全部 |
| **自動重連** | 是 | 否 | 否 |
| **適用場景** | 單向推送 | 雙向通訊 | 簡單查詢 |

### EventSource 基本用法

以下是 `frontend-demo/index.html` 中 EventSource 的基本使用範例，展示如何建立連線、監聽訊息和處理錯誤：

```javascript
// 來自 code-examples/chapter4-spring-ai-intro/frontend-demo/index.html
// EventSource 實例
let eventSource = null;

/**
 * 開始流式輸出
 */
function startStreaming() {
    const apiUrl = document.getElementById('apiUrl').value.trim();
    const prompt = document.getElementById('prompt').value.trim();

    if (!prompt) {
        alert('請輸入提示詞');
        return;
    }

    // 清空之前的回應
    document.getElementById('response').textContent = '';

    // 建構完整的 URL（包含查詢參數）
    const fullUrl = `${apiUrl}?prompt=${encodeURIComponent(prompt)}`;
    console.log('連線到:', fullUrl);

    try {
        // 建立 EventSource 連線
        eventSource = new EventSource(fullUrl);

        // 監聽連線開啟事件
        eventSource.onopen = function(event) {
            console.log('✅ EventSource 連線已建立', event);
            // updateStatus('connected');
        };

        // 監聽訊息事件（接收資料）
        eventSource.onmessage = function(event) {
            console.log('📨 收到資料:', event.data);

            // 將接收到的資料附加到回應區域
            const responseDiv = document.getElementById('response');
            responseDiv.textContent += event.data;

            // 自動捲動到底部
            responseDiv.scrollTop = responseDiv.scrollHeight;
        };

        // 監聽錯誤事件
        eventSource.onerror = function(event) {
            console.error('❌ EventSource 錯誤:', event);

            if (eventSource.readyState === EventSource.CLOSED) {
                console.log('🔒 連線已關閉');
                // updateStatus('closed');
                // stopStreaming();
            } else {
                // updateStatus('error');
                alert('連線發生錯誤，請檢查後端服務是否正常運作');
                // stopStreaming();
            }
        };

    } catch (error) {
        console.error('建立 EventSource 失敗:', error);
        alert('建立連線失敗: ' + error.message);
        // stopStreaming();
    }
}

/**
 * 停止流式輸出
 */
function stopStreaming() {
    if (eventSource) {
        eventSource.close();
        eventSource = null;
        console.log('🛑 EventSource 連線已關閉');
    }
}
```

---

## 4.5.2 建立流式聊天介面

### HTML 結構設計

以下是 `frontend-demo/streaming-demo.html` 的核心 HTML 結構，用於建立一個類似 ChatGPT 的聊天介面：

```html
<!-- 來自 code-examples/chapter4-spring-ai-intro/frontend-demo/streaming-demo.html (精簡版) -->
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 流式聊天介面 - Spring AI</title>
    <style>
        /* ... CSS 樣式 ... */
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div>
                <h1>🤖 AI 智能助手</h1>
                <div class="header-info">Spring AI 流式對話展示</div>
            </div>
            <div class="status-indicator">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">未連線</span>
            </div>
        </div>

        <div class="chat-container">
            <div class="messages" id="messages">
                <!-- 歡迎訊息 -->
                <div class="message ai">
                    <div class="message-avatar">AI</div>
                    <div class="message-content">
                        <strong>👋 您好！我是 Spring AI 智能助手</strong><br><br>
                        <!-- ... 歡迎訊息內容 ... -->
                    </div>
                </div>
            </div>

            <div class="input-area">
                <div class="example-prompts">
                    <button class="example-prompt" onclick="setPrompt('什麼是 Spring AI？')">什麼是 Spring AI？</button>
                    <!-- ... 其他範例提示詞 ... -->
                </div>

                <div class="controls">
                    <button class="control-btn" onclick="clearChat()">🗑️ 清除對話</button>
                    <button class="control-btn" id="autoScrollBtn" class="active" onclick="toggleAutoScroll()">📜 自動捲動</button>
                    <button class="control-btn" onclick="exportChat()">💾 匯出對話</button>
                </div>

                <div class="input-wrapper">
                    <textarea
                        id="messageInput"
                        placeholder="輸入您的問題... (Ctrl+Enter 發送)"
                        rows="1"
                    ></textarea>
                    <button class="send-btn" id="sendBtn" onclick="sendMessage()">
                        ➤
                    </button>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <span id="messageCount">訊息數：0</span>
            <span id="apiEndpoint">API: http://localhost:8080</span>
        </div>
    </div>

    <script>
        // ... JavaScript 邏輯 ...
    </script>
</body>
</html>
```

### CSS 樣式設計

`frontend-demo/streaming-demo.html` 內嵌了完整的 CSS 樣式，用於美化聊天介面，實現類似 ChatGPT 的視覺效果。

---

## 4.5.3 JavaScript 流式聊天實現

### 流式輸出流程示意圖

以下是前端處理 AI 流式輸出的整體流程示意圖：

```mermaid
graph TD
    A[使用者發送請求] --> B(前端應用)
    B --> C{建立 EventSource 連線}
    C --> D[後端服務]
    D -- 流式回應 SSE --> E[前端 EventSource 監聽器]
    E -- 接收資料塊 --> F[更新 UI]
    F --> G[顯示 AI 回應]
    G -- 自動捲動 --> H[優化使用者體驗]
    E -- 連線關閉/錯誤 --> I[處理連線狀態]
    I --> J[顯示錯誤或完成訊息]
```

---

以下是 `frontend-demo/streaming-demo.html` 中實現流式聊天功能的 JavaScript 核心邏輯，包括訊息發送、EventSource 連線管理、UI 更新等：

```javascript
// 來自 code-examples/chapter4-spring-ai-intro/frontend-demo/streaming-demo.html
// ... (全域變數和輔助函數省略)

/**
 * 發送訊息
 */
function sendMessage() {
    const input = document.getElementById('messageInput');
    const message = input.value.trim();

    if (!message) {
        return;
    }

    // 顯示使用者訊息
    addUserMessage(message);

    // 清空輸入框
    input.value = '';
    input.style.height = 'auto';

    // 開始 AI 回應
    startAiResponse(message);
}

/**
 * 開始 AI 回應（流式輸出）
 */
function startAiResponse(prompt) {
    const messagesDiv = document.getElementById('messages');

    // 建立 AI 訊息容器
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message ai';
    messageDiv.innerHTML = `
        <div class="message-avatar">AI</div>
        <div class="message-content"></div>
    `;

    messagesDiv.appendChild(messageDiv);
    currentAiMessage = messageDiv.querySelector('.message-content');

    // 顯示輸入中指示器
    showTypingIndicator();

    // 建立 EventSource 連線
    const url = `${API_BASE_URL}?prompt=${encodeURIComponent(prompt)}`;
    console.log('開始連線:', url);

    try {
        eventSource = new EventSource(url);

        // 連線開啟
        eventSource.onopen = function(event) {
            console.log('✅ 連線已建立');
            updateConnectionStatus(true);
            hideTypingIndicator();
        };

        // 接收訊息
        eventSource.onmessage = function(event) {
            const data = event.data;
            console.log('📨 收到資料:', data);

            if (currentAiMessage) {
                currentAiMessage.textContent += data;
                if (autoScroll) {
                    scrollToBottom();
                }
            }
        };

        // 連線錯誤
        eventSource.onerror = function(event) {
            console.error('❌ 連線錯誤:', event);
            hideTypingIndicator();
            updateConnectionStatus(false);
            closeConnection();

            if (currentAiMessage && !currentAiMessage.textContent) {
                currentAiMessage.innerHTML = '<span style="color: red;">⚠️ 連線失敗，請確認後端服務是否正常運作</span>';
            }

            messageCount++;
            updateMessageCount();
            currentAiMessage = null;
        };

        // 自動關閉連線（收到完整回應後）
        setTimeout(() => {
            if (eventSource && eventSource.readyState === EventSource.OPEN) {
                closeConnection();
                messageCount++;
                updateMessageCount();
                currentAiMessage = null;
            }
        }, 30000); // 30秒超時

    } catch (error) {
        console.error('建立連線失敗:', error);
        alert('建立連線失敗: ' + error.message);
        hideTypingIndicator();
    }
}

// ... (其他輔助函數和事件監聽省略)
```



## 📝 本章重點回顧

### EventSource API 核心
✅ EventSource - 瀏覽器原生的 SSE 客戶端
✅ onmessage - 接收伺服器推送的訊息
✅ onerror - 處理連線錯誤和中斷
✅ readyState - 監控連線狀態
✅ close() - 主動關閉連線

### 流式聊天介面要素
```javascript
// 核心流程
const eventSource = new EventSource(url);
eventSource.onmessage = (event) => {
    appendContent(event.data);  // 逐步顯示內容
};
eventSource.onerror = () => {
    handleError();              // 錯誤處理
    eventSource.close();        // 關閉連線
};
```

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **EventSource API** | ⭐⭐⭐ | 低 | 所有流式應用 |
| **連線管理** | ⭐⭐⭐ | 中 | 生產環境必需 |
| **錯誤處理** | ⭐⭐⭐ | 中 | 穩定性保證 |
| **UI 即時更新** | ⭐⭐ | 低 | 使用者體驗 |
| **記憶體優化** | ⭐⭐ | 中 | 長時間使用 |
| **自動重連** | ⭐⭐ | 高 | 網路不穩定環境 |

### React Hook 整合
```javascript
// 使用 useRef 管理 EventSource 實例
const eventSourceRef = useRef(null);

// 清理副作用
useEffect(() => {
    return () => {
        if (eventSourceRef.current) {
            eventSourceRef.current.close();
        }
    };
}, []);
```

### 最佳實踐
1. ✅ 始終處理錯誤和異常狀況
2. ✅ 限制訊息數量避免記憶體洩漏
3. ✅ 提供停止按鈕讓使用者控制
4. ✅ 使用 createTextNode 防止 XSS
5. ✅ 重連機制加入隨機抖動
6. ✅ 組件卸載時清理資源

### 完整功能清單
- 📱 即時流式顯示
- ⏸️ 停止流式接收
- 🔄 自動錯誤重連
- 💾 對話歷史管理
- 📊 字元計數和限制
- 🎨 打字動畫效果
- 📱 響應式設計

---

## 🚀 下一步

👉 第五章：Spring AI 進階功能 - 提示詞範本、多模態處理、Function Calling

---

**相關章節**:
- ← 上一章: [4.4 深入了解 ChatModel](./4.4.md)
- → 下一章: 第五章 Spring AI 進階功能

**參考資料：**
- [Server-Sent Events - MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)
- [EventSource API - MDN](https://developer.mozilla.org/en-US/docs/Web/API/EventSource)
- [React Hooks Documentation](https://reactjs.org/docs/hooks-intro.html)
- [Web Performance Best Practices](https://web.dev/performance/)
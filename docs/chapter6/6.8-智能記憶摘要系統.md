# 6.8 æ™ºèƒ½è¨˜æ†¶æ‘˜è¦ç³»çµ±

> **å°æ‡‰ç« ç¯€**: Day18
> **å°æ‡‰ç¯„ä¾‹**: `chapter6-memory-advanced`
> **é›£åº¦**: â­â­â­â­â­

---

## ğŸ“š æœ¬ç« æ¦‚è¦

ç•¶å°è©±è®Šå¾—å¾ˆé•·æ™‚,å³ä½¿æœ‰è¨˜æ†¶ç®¡ç†,ä»æœƒé¢è‡¨ Token æˆæœ¬å’Œæ•ˆèƒ½å•é¡Œã€‚æ™ºèƒ½è¨˜æ†¶æ‘˜è¦ç³»çµ±é€éè‡ªå‹•æ‘˜è¦ã€æ··åˆç­–ç•¥å’Œå°è©±åˆ†æä¾†å„ªåŒ–è¨˜æ†¶ç®¡ç†ã€‚

**å­¸ç¿’ç›®æ¨™**:
- ç†è§£æ™ºèƒ½æ‘˜è¦çš„å¿…è¦æ€§
- æŒæ¡ SmartMemoryAdvisor è¨­è¨ˆ
- å­¸æœƒå¯¦ç¾æ··åˆè¨˜æ†¶ç­–ç•¥
- äº†è§£å°è©±åˆ†æèˆ‡å„ªåŒ–æŠ€è¡“

---

## ğŸ¯ ç‚ºä»€éº¼éœ€è¦æ™ºèƒ½æ‘˜è¦?

### é•·å°è©±çš„å•é¡Œ

```
ç¬¬1è¼ª: "ä½ å¥½"
ç¬¬2è¼ª: "ä»‹ç´¹Spring AI"
...
ç¬¬50è¼ª: ç´¯ç© 5000 tokens
ç¬¬100è¼ª: ç´¯ç© 10000 tokens â† è¶…éæ¨¡å‹é™åˆ¶!
```

**å•é¡Œ**:
- ğŸ’° **æˆæœ¬çˆ†ç‚¸**: Token è²»ç”¨ç·šæ€§å¢é•·
- ğŸŒ **å›æ‡‰è®Šæ…¢**: è™•ç†æ™‚é–“å¢åŠ 
- âŒ **è¶…å‡ºé™åˆ¶**: è¶…éæ¨¡å‹ä¸Šä¸‹æ–‡è¦–çª—

### æ™ºèƒ½æ‘˜è¦è§£æ±ºæ–¹æ¡ˆ

```mermaid
graph TD
    A[é•·å°è©±] --> B{è¶…éé–¾å€¼?}
    B -->|æ˜¯| C[è‡ªå‹•æ‘˜è¦]
    B -->|å¦| D[ä¿ç•™åŸå§‹]

    C --> E[æ‘˜è¦ + æœ€è¿‘å°è©±]
    E --> F[AI å›æ‡‰]

    D --> F

    style A fill:#e1f5ff
    style C fill:#fff4e6
    style F fill:#e8f5e9
```

---

## ğŸ’» SmartMemoryAdvisor è¨­è¨ˆ

### æ ¸å¿ƒæ¦‚å¿µ

```java
// å°æ‡‰ç¯„ä¾‹: chapter6-memory-advanced/.../advisor/SmartMemoryAdvisor.java

@Component
public class SmartMemoryAdvisor implements CallAdvisor {

    private final ChatMemory chatMemory;
    private final ChatClient summarizerClient;

    private static final int SUMMARY_THRESHOLD = 50;  // è§¸ç™¼æ‘˜è¦çš„é–¾å€¼
    private static final int KEEP_RECENT = 20;        // ä¿ç•™æœ€è¿‘Næ¢

    @Override
    public ChatClientResponse adviseCall(
            ChatClientRequest request,
            CallAdvisorChain chain) {

        String conversationId = getConversationId(request);
        List<Message> history = chatMemory.get(conversationId);

        // æª¢æŸ¥æ˜¯å¦éœ€è¦æ‘˜è¦
        if (history.size() > SUMMARY_THRESHOLD) {
            optimizeMemory(conversationId, history);
        }

        return chain.nextCall(request);
    }

    /**
     * å„ªåŒ–è¨˜æ†¶: æ‘˜è¦èˆŠå°è©±,ä¿ç•™æœ€è¿‘å°è©±
     */
    private void optimizeMemory(String conversationId, List<Message> history) {
        // 1. åˆ†å‰²: èˆŠå°è©± vs æœ€è¿‘å°è©±
        int splitPoint = history.size() - KEEP_RECENT;
        List<Message> oldMessages = history.subList(0, splitPoint);
        List<Message> recentMessages = history.subList(splitPoint, history.size());

        // 2. æ‘˜è¦èˆŠå°è©±
        String summary = summarizeConversation(oldMessages);

        // 3. é‡å»ºè¨˜æ†¶
        chatMemory.clear(conversationId);

        // æ·»åŠ æ‘˜è¦ä½œç‚ºç³»çµ±è¨Šæ¯
        chatMemory.add(conversationId,
            new SystemMessage("å°è©±æ‘˜è¦: " + summary));

        // æ·»åŠ æœ€è¿‘å°è©±
        chatMemory.addAll(conversationId, recentMessages);

        log.info("Memory optimized for conversation: {}. " +
                 "Old: {} â†’ Summary, Recent: {}",
            conversationId, oldMessages.size(), recentMessages.size());
    }

    /**
     * ä½¿ç”¨ AI ç”Ÿæˆå°è©±æ‘˜è¦
     */
    private String summarizeConversation(List<Message> messages) {
        String conversation = messages.stream()
            .map(msg -> {
                String role = msg instanceof UserMessage ? "ç”¨æˆ¶" : "åŠ©æ‰‹";
                return role + ": " + msg.getContent();
            })
            .collect(Collectors.joining("\n"));

        return summarizerClient.prompt()
            .user("""
                è«‹ç°¡æ½”æ‘˜è¦ä»¥ä¸‹å°è©±çš„é‡é»:

                %s

                æ‘˜è¦æ‡‰åŒ…å«:
                1. ä¸»è¦è¨è«–è©±é¡Œ
                2. é‡è¦æ±ºå®šæˆ–çµè«–
                3. å¾…è¾¦äº‹é …æˆ–å¾ŒçºŒè¡Œå‹•

                è«‹ç”¨3-5å¥è©±ç¸½çµã€‚
                """.formatted(conversation))
            .call()
            .content();
    }

    @Override
    public String getName() {
        return "SmartMemoryAdvisor";
    }

    @Override
    public int getOrder() {
        return 1;
    }
}
```

---

## ğŸ”€ æ··åˆè¨˜æ†¶ç­–ç•¥

### HybridMemoryService

```java
// å°æ‡‰ç¯„ä¾‹: chapter6-memory-advanced/.../service/HybridMemoryService.java

@Service
public class HybridMemoryService {

    @Autowired
    private ChatMemory shortTermMemory;

    @Autowired
    private VectorStore longTermMemory;

    @Autowired
    private ChatClient chatClient;

    /**
     * å‹•æ…‹é¸æ“‡è¨˜æ†¶ç­–ç•¥
     */
    public String chat(String conversationId, String message) {
        MemoryStrategy strategy = selectStrategy(conversationId);

        return switch (strategy) {
            case SHORT_TERM_ONLY -> useShortTermMemory(conversationId, message);
            case LONG_TERM_ONLY -> useLongTermMemory(conversationId, message);
            case HYBRID -> useHybridMemory(conversationId, message);
            case SMART_SUMMARY -> useSmartSummary(conversationId, message);
        };
    }

    /**
     * é¸æ“‡ç­–ç•¥: æ ¹æ“šå°è©±é•·åº¦å’Œé¡å‹
     */
    private MemoryStrategy selectStrategy(String conversationId) {
        long messageCount = shortTermMemory.count(conversationId);

        if (messageCount < 10) {
            return MemoryStrategy.SHORT_TERM_ONLY;  // çŸ­å°è©±
        } else if (messageCount < 50) {
            return MemoryStrategy.HYBRID;            // ä¸­ç­‰å°è©±
        } else {
            return MemoryStrategy.SMART_SUMMARY;     // é•·å°è©±
        }
    }

    /**
     * æ··åˆè¨˜æ†¶: çµåˆçŸ­æœŸå’Œé•·æœŸ
     */
    private String useHybridMemory(String conversationId, String message) {
        // 1. ç²å–çŸ­æœŸè¨˜æ†¶ (æœ€è¿‘å°è©±)
        List<Message> recentMessages = shortTermMemory
            .getRecent(conversationId, 20);

        // 2. èªç¾©æœå°‹é•·æœŸè¨˜æ†¶
        List<Document> relevantHistory = longTermMemory.similaritySearch(
            SearchRequest.query(message)
                .withTopK(5)
                .withSimilarityThreshold(0.75)
                .withFilterExpression(String.format(
                    "conversationId == '%s'", conversationId
                ))
        );

        // 3. çµ„åˆä¸Šä¸‹æ–‡
        String context = buildHybridContext(recentMessages, relevantHistory);

        // 4. èª¿ç”¨ AI
        return chatClient.prompt()
            .system(context)
            .user(message)
            .call()
            .content();
    }

    private String buildHybridContext(
            List<Message> recent,
            List<Document> relevant) {

        StringBuilder context = new StringBuilder();

        // ç›¸é—œæ­·å²
        if (!relevant.isEmpty()) {
            context.append("ã€ç›¸é—œæ­·å²è¨˜éŒ„ã€‘\n");
            relevant.forEach(doc ->
                context.append("- ").append(doc.getContent()).append("\n")
            );
            context.append("\n");
        }

        // æœ€è¿‘å°è©±
        context.append("ã€æœ€è¿‘å°è©±ã€‘\n");
        recent.forEach(msg -> {
            String role = msg instanceof UserMessage ? "ç”¨æˆ¶" : "åŠ©æ‰‹";
            context.append(role).append(": ")
                   .append(msg.getContent()).append("\n");
        });

        return context.toString();
    }
}

enum MemoryStrategy {
    SHORT_TERM_ONLY,   // åƒ…çŸ­æœŸè¨˜æ†¶
    LONG_TERM_ONLY,    // åƒ…é•·æœŸè¨˜æ†¶
    HYBRID,            // æ··åˆç­–ç•¥
    SMART_SUMMARY      // æ™ºèƒ½æ‘˜è¦
}
```

---

## ğŸ“Š å°è©±åˆ†æåŠŸèƒ½

### ConversationSummaryService

```java
@Service
public class ConversationSummaryService {

    @Autowired
    private ChatClient chatClient;

    @Autowired
    private ChatMemory chatMemory;

    /**
     * ç”Ÿæˆå°è©±æ‘˜è¦
     */
    public ConversationSummary summarize(String conversationId) {
        List<Message> messages = chatMemory.get(conversationId);

        // 1. åŸºæœ¬çµ±è¨ˆ
        ConversationStats stats = calculateStats(messages);

        // 2. AI ç”Ÿæˆæ‘˜è¦
        String summary = generateSummary(messages);

        // 3. æå–ä¸»é¡Œ
        List<String> topics = extractTopics(messages);

        // 4. è­˜åˆ¥å¾…è¾¦äº‹é …
        List<String> todos = extractTodos(messages);

        return ConversationSummary.builder()
            .conversationId(conversationId)
            .summary(summary)
            .topics(topics)
            .todos(todos)
            .stats(stats)
            .build();
    }

    /**
     * è¨ˆç®—å°è©±çµ±è¨ˆ
     */
    private ConversationStats calculateStats(List<Message> messages) {
        long userMessages = messages.stream()
            .filter(m -> m instanceof UserMessage)
            .count();

        long aiMessages = messages.stream()
            .filter(m -> m instanceof AssistantMessage)
            .count();

        int totalTokens = messages.stream()
            .mapToInt(m -> estimateTokens(m.getContent()))
            .sum();

        return ConversationStats.builder()
            .totalMessages(messages.size())
            .userMessages(userMessages)
            .aiMessages(aiMessages)
            .estimatedTokens(totalTokens)
            .build();
    }

    /**
     * æå–å°è©±ä¸»é¡Œ
     */
    private List<String> extractTopics(List<Message> messages) {
        String conversation = formatConversation(messages);

        String prompt = """
            è«‹åˆ†æä»¥ä¸‹å°è©±,æå–3-5å€‹ä¸»è¦è©±é¡Œ:

            %s

            ä»¥åˆ—è¡¨å½¢å¼è¿”å›è©±é¡Œ,æ¯å€‹è©±é¡Œä¸€è¡Œã€‚
            """.formatted(conversation);

        String response = chatClient.prompt()
            .user(prompt)
            .call()
            .content();

        return Arrays.stream(response.split("\n"))
            .filter(line -> !line.trim().isEmpty())
            .map(String::trim)
            .collect(Collectors.toList());
    }

    /**
     * è­˜åˆ¥å¾…è¾¦äº‹é …
     */
    private List<String> extractTodos(List<Message> messages) {
        String conversation = formatConversation(messages);

        String prompt = """
            è«‹å¾ä»¥ä¸‹å°è©±ä¸­è­˜åˆ¥æ‰€æœ‰å¾…è¾¦äº‹é …æˆ–å¾ŒçºŒè¡Œå‹•:

            %s

            ä»¥æ¸…å–®å½¢å¼è¿”å›,æ¯å€‹äº‹é …ä¸€è¡Œã€‚å¦‚æœæ²’æœ‰,è¿”å›"ç„¡"ã€‚
            """.formatted(conversation);

        String response = chatClient.prompt()
            .user(prompt)
            .call()
            .content();

        if (response.contains("ç„¡")) {
            return Collections.emptyList();
        }

        return Arrays.stream(response.split("\n"))
            .filter(line -> !line.trim().isEmpty())
            .map(String::trim)
            .collect(Collectors.toList());
    }

    private int estimateTokens(String text) {
        // ç°¡åŒ–ä¼°ç®—: 1 token â‰ˆ 4 å­—ç¬¦
        return text.length() / 4;
    }
}

@Builder
@Data
class ConversationSummary {
    private String conversationId;
    private String summary;
    private List<String> topics;
    private List<String> todos;
    private ConversationStats stats;
}

@Builder
@Data
class ConversationStats {
    private long totalMessages;
    private long userMessages;
    private long aiMessages;
    private int estimatedTokens;
}
```

---

## ğŸ¯ è¨˜æ†¶å„ªåŒ–æŠ€è¡“

### 1. MessageWindowChatMemory

```java
// å°æ‡‰ç¯„ä¾‹: chapter6-memory-core/.../memory/MessageWindowChatMemory.java

public class MessageWindowChatMemory implements ChatMemory {

    private final ChatMemory delegate;
    private final int maxMessages;

    @Override
    public List<Message> get(String conversationId) {
        List<Message> all = delegate.get(conversationId);

        // åªè¿”å›æœ€è¿‘çš„è¨Šæ¯
        if (all.size() <= maxMessages) {
            return all;
        }

        return new ArrayList<>(
            all.subList(all.size() - maxMessages, all.size())
        );
    }
}
```

### 2. è‡ªå‹•æ¸…ç†ç­–ç•¥

```java
@Component
public class MemoryCleanupService {

    @Autowired
    private ChatMemory chatMemory;

    @Scheduled(cron = "0 0 2 * * ?")  // æ¯å¤©å‡Œæ™¨2é»
    public void cleanupOldConversations() {
        Set<String> conversationIds = getAllConversationIds();

        for (String id : conversationIds) {
            if (shouldCleanup(id)) {
                chatMemory.clear(id);
                log.info("Cleaned up conversation: {}", id);
            }
        }
    }

    private boolean shouldCleanup(String conversationId) {
        // è¶…é30å¤©æœªæ´»å‹•çš„å°è©±
        LocalDateTime lastActivity = getLastActivity(conversationId);
        return lastActivity.isBefore(
            LocalDateTime.now().minusDays(30)
        );
    }
}
```

### 3. è¨˜æ†¶å£“ç¸®

```java
public class MemoryCompressor {

    /**
     * å£“ç¸®å°è©±: ç§»é™¤å†—é¤˜è³‡è¨Š
     */
    public List<Message> compress(List<Message> messages) {
        return messages.stream()
            .map(this::compressMessage)
            .collect(Collectors.toList());
    }

    private Message compressMessage(Message message) {
        String content = message.getContent();

        // ç§»é™¤å¤šé¤˜ç©ºç™½
        content = content.replaceAll("\\s+", " ").trim();

        // å¦‚æœæ˜¯ UserMessage,ä¿æŒåŸæ¨£
        if (message instanceof UserMessage) {
            return new UserMessage(content);
        }

        // å¦‚æœæ˜¯ AssistantMessage,å¯ä»¥é€²ä¸€æ­¥å£“ç¸®
        return new AssistantMessage(content);
    }
}
```

---

## ğŸ“ é‡é»å›é¡§

### æ™ºèƒ½æ‘˜è¦æ ¸å¿ƒ
âœ… è‡ªå‹•åµæ¸¬é•·å°è©±
âœ… AI ç”Ÿæˆæ‘˜è¦
âœ… ä¿ç•™æœ€è¿‘å°è©±

### æ··åˆç­–ç•¥
- æ ¹æ“šå°è©±é•·åº¦å‹•æ…‹é¸æ“‡
- çµåˆçŸ­æœŸã€é•·æœŸã€æ‘˜è¦
- å„ªåŒ– Token ä½¿ç”¨

### å°è©±åˆ†æ
- ç”Ÿæˆå°è©±æ‘˜è¦
- æå–ä¸»è¦è©±é¡Œ
- è­˜åˆ¥å¾…è¾¦äº‹é …
- çµ±è¨ˆè³‡è¨Š

---

## ğŸš€ ä¸‹ä¸€æ­¥

æ­å–œ!ä½ å·²ç¶“å®Œæˆç¬¬6ç« æ‰€æœ‰å…§å®¹ã€‚æ¥ä¸‹ä¾†å¯ä»¥:

ğŸ‘‰ [ç¬¬7ç«  RAG åŸºç¤](../../chapter7/README.md) - æ·±å…¥ RAG ç³»çµ±
ğŸ‘‰ å›åˆ° [ç¬¬6ç« å°è¦½](./README.md) - è¤‡ç¿’æœ¬ç« å…§å®¹

---

**ç›¸é—œç« ç¯€**:
- â† ä¸Šä¸€ç« : [6.7 VectorStoreChatMemoryAdvisor](./6.7-VectorStoreChatMemoryAdvisor.md)
- â†’ ä¸‹ä¸€ç« : [ç¬¬7ç«  RAG åŸºç¤](../../chapter7/README.md)

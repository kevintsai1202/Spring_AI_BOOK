# 9.4 é–‹ç™¼ MCP Server å·¥å…·

> **æœ¬ç« é‡é»**ï¼šæ·±å…¥å­¸ç¿’å¦‚ä½•é–‹ç™¼ä¼æ¥­ç´šçš„ MCP Serverï¼ŒæŒæ¡å·¥å…·è¨»å†Šã€è³‡æºç®¡ç†ã€æç¤ºç³»çµ±çš„å®Œæ•´é–‹ç™¼æµç¨‹ï¼Œå»ºç«‹å¯æ“´å±•ã€é«˜å¯ç”¨çš„ MCP æœå‹™æä¾›è€…ï¼Œç‚ºä¼æ¥­ AI ç”Ÿæ…‹ç³»çµ±æä¾›æ¨™æº–åŒ–çš„æœå‹™èƒ½åŠ›ã€‚

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬ç« å­¸ç¿’å¾Œï¼Œæ‚¨å°‡èƒ½å¤ ï¼š

- ğŸ¯ **é–‹ç™¼ MCP å·¥å…·**ï¼šæŒæ¡è‡ªå®šç¾© MCP å·¥å…·çš„é–‹ç™¼å’Œè¨»å†Šæ–¹æ³•
- ğŸ¯ **ç®¡ç† MCP è³‡æº**ï¼šå¯¦ç¾ MCP è³‡æºçš„æä¾›å’Œç®¡ç†æ©Ÿåˆ¶
- ğŸ¯ **å»ºç«‹æç¤ºç³»çµ±**ï¼šé–‹ç™¼æ™ºèƒ½åŒ–çš„ MCP æç¤ºæœå‹™
- ğŸ¯ **éƒ¨ç½² MCP Server**ï¼šå»ºç«‹ä¼æ¥­ç´šçš„ MCP Server éƒ¨ç½²æ–¹æ¡ˆ
- ğŸ¯ **ç›£æ§èˆ‡ç¶­è­·**ï¼šå¯¦ç¾ MCP Server çš„ç›£æ§ã€æ—¥èªŒå’Œç¶­è­·æ©Ÿåˆ¶

---

## 9.4.1 MCP Server åŸºç¤æ¶æ§‹

### MCP Server é…ç½®

#### åŸºç¤é…ç½®é¡

```java
/**
 * ä¼æ¥­ç´š MCP Server é…ç½®
 */
@Configuration
@Slf4j
public class EnterpriseMcpServerConfiguration {
    
    /**
     * æ–‡æª”æœå°‹æœå‹™å·¥å…·
     */
    @Bean
    public ToolCallbackProvider documentSearchTools(DocumentSearchService documentService) {
        return MethodToolCallbackProvider.builder()
            .toolObjects(documentService)
            .build();
    }
    
    /**
     * æ•¸æ“šåˆ†ææœå‹™å·¥å…·
     */
    @Bean
    public ToolCallbackProvider dataAnalysisTools(DataAnalysisService analysisService) {
        return MethodToolCallbackProvider.builder()
            .toolObjects(analysisService)
            .build();
    }
    
    /**
     * å·¥ä½œæµç¨‹æœå‹™å·¥å…·
     */
    @Bean
    public ToolCallbackProvider workflowTools(WorkflowService workflowService) {
        return MethodToolCallbackProvider.builder()
            .toolObjects(workflowService)
            .build();
    }
    
    /**
     * é…ç½®å®‰å…¨è¨­ç½®
     */
    private void configureSecurity(McpServer.Builder builder, 
                                 McpSecurityProperties securityProps) {
        
        builder.security(security -> {
            // èªè­‰é…ç½®
            security.authentication(auth -> {
                auth.type(securityProps.getAuthenticationType());
                auth.tokenValidator(new JwtTokenValidator());
                auth.roleExtractor(new CustomRoleExtractor());
            });
            
            // æˆæ¬Šé…ç½®
            security.authorization(authz -> {
                authz.requireRole("MCP_USER");
                authz.toolAccess("admin_tools", "ADMIN");
                authz.resourceAccess("sensitive_data", "DATA_ACCESS");
            });
            
            // é€Ÿç‡é™åˆ¶
            security.rateLimit(rate -> {
                rate.requestsPerMinute(securityProps.getRateLimit());
                rate.burstCapacity(securityProps.getBurstCapacity());
            });
        });
    }
    
    /**
     * é…ç½®ç›£æ§
     */
    private void configureMonitoring(McpServer.Builder builder) {
        builder.monitoring(monitor -> {
            monitor.metrics(true);
            monitor.healthCheck(true);
            monitor.requestLogging(true);
            monitor.performanceTracking(true);
        });
    }
    
    /**
     * é…ç½®éŒ¯èª¤è™•ç†
     */
    private void configureErrorHandling(McpServer.Builder builder) {
        builder.errorHandler((request, error) -> {
            log.error("MCP è«‹æ±‚è™•ç†éŒ¯èª¤: {} - {}", 
                request.getId(), error.getMessage(), error);
            
            // æ ¹æ“šéŒ¯èª¤é¡å‹è¿”å›é©ç•¶çš„å›æ‡‰
            return switch (error) {
                case ValidationException ve -> 
                    McpErrorResponse.invalidParams(ve.getMessage());
                case AuthenticationException ae -> 
                    McpErrorResponse.unauthorized("èªè­‰å¤±æ•—");
                case AuthorizationException aze -> 
                    McpErrorResponse.forbidden("æ¬Šé™ä¸è¶³");
                case RateLimitException rle -> 
                    McpErrorResponse.tooManyRequests("è«‹æ±‚éæ–¼é »ç¹");
                case ResourceNotFoundException rnfe -> 
                    McpErrorResponse.notFound("è³‡æºæœªæ‰¾åˆ°");
                default -> 
                    McpErrorResponse.internalError("å…§éƒ¨ä¼ºæœå™¨éŒ¯èª¤");
            };
        });
    }
}

/**
 * MCP å®‰å…¨é…ç½®å±¬æ€§
 */
@ConfigurationProperties(prefix = "mcp.security")
@Data
public class McpSecurityProperties {
    private boolean enabled = true;
    private String authenticationType = "bearer";
    private int rateLimit = 100;
    private int burstCapacity = 20;
    private List<String> allowedOrigins = List.of("*");
    private List<String> trustedClients = new ArrayList<>();
}
```

---

## 9.4.2 MCP å·¥å…·é–‹ç™¼

### å·¥å…·è¨»å†Šèˆ‡é…ç½®

```java
/**
 * MCP å·¥å…·é…ç½®é¡
 */
@Configuration
@Slf4j
public class McpToolsConfiguration {
    
    /**
     * è¨»å†Šä¼æ¥­ç´š MCP å·¥å…·
     */
    @Bean
    public List<McpServerFeatures.SyncToolSpecification> enterpriseTools(
            DocumentSearchService documentService,
            DataAnalysisService analysisService,
            WorkflowService workflowService) {
        
        List<McpServerFeatures.SyncToolSpecification> tools = new ArrayList<>();
        
        // 1. æ–‡æª”æœå°‹å·¥å…·
        tools.add(createDocumentSearchTool(documentService));
        
        // 2. æ•¸æ“šåˆ†æå·¥å…·
        tools.add(createDataAnalysisTool(analysisService));
        
        // 3. å·¥ä½œæµç¨‹å·¥å…·
        tools.add(createWorkflowTool(workflowService));
        
        // 4. æ–‡ä»¶è™•ç†å·¥å…·
        tools.add(createFileProcessingTool());
        
        // 5. ç³»çµ±ç®¡ç†å·¥å…·
        tools.add(createSystemManagementTool());
        
        log.info("è¨»å†Šäº† {} å€‹ä¼æ¥­ç´š MCP å·¥å…·", tools.size());
        return tools;
    }
    
    /**
     * å‰µå»ºæ–‡æª”æœå°‹å·¥å…·
     */
    private McpServerFeatures.SyncToolSpecification createDocumentSearchTool(
            DocumentSearchService documentService) {
        
        // å®šç¾©å·¥å…· Schema
        var toolSchema = new McpSchema.Tool(
            "search_documents",
            "æœå°‹ä¼æ¥­æ–‡æª”åº«ä¸­çš„ç›¸é—œæ–‡æª”",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "query", Map.of(
                        "type", "string",
                        "description", "æœå°‹é—œéµå­—æˆ–å•é¡Œ"
                    ),
                    "domain", Map.of(
                        "type", "string",
                        "description", "å°ˆæ¥­é ˜åŸŸéæ¿¾ï¼ˆå¯é¸ï¼‰",
                        "enum", List.of("æŠ€è¡“", "è²¡å‹™", "äººäº‹", "æ³•å‹™", "ç‡Ÿé‹")
                    ),
                    "max_results", Map.of(
                        "type", "integer",
                        "description", "æœ€å¤§çµæœæ•¸é‡",
                        "default", 5,
                        "minimum", 1,
                        "maximum", 20
                    ),
                    "similarity_threshold", Map.of(
                        "type", "number",
                        "description", "ç›¸ä¼¼åº¦é–¾å€¼",
                        "default", 0.7,
                        "minimum", 0.0,
                        "maximum", 1.0
                    )
                ),
                "required", List.of("query")
            )
        );
        
        // å®šç¾©å·¥å…·åŸ·è¡Œé‚è¼¯
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    // æå–åƒæ•¸
                    String query = (String) request.arguments().get("query");
                    String domain = (String) request.arguments().get("domain");
                    Integer maxResults = (Integer) request.arguments().getOrDefault("max_results", 5);
                    Double threshold = (Double) request.arguments().getOrDefault("similarity_threshold", 0.7);
                    
                    log.info("åŸ·è¡Œæ–‡æª”æœå°‹: query={}, domain={}, maxResults={}, threshold={}", 
                        query, domain, maxResults, threshold);
                    
                    // åŸ·è¡Œæœå°‹
                    DocumentSearchRequest searchRequest = DocumentSearchRequest.builder()
                        .query(query)
                        .domain(domain)
                        .maxResults(maxResults)
                        .similarityThreshold(threshold)
                        .build();
                    
                    DocumentSearchResult result = documentService.search(searchRequest);
                    
                    // æ ¼å¼åŒ–çµæœ
                    String formattedResult = formatSearchResult(result);
                    
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(formattedResult))
                    );
                    
                } catch (Exception e) {
                    log.error("æ–‡æª”æœå°‹å·¥å…·åŸ·è¡Œå¤±æ•—", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "æœå°‹å¤±æ•—: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    /**
     * å‰µå»ºæ•¸æ“šåˆ†æå·¥å…·
     */
    private McpServerFeatures.SyncToolSpecification createDataAnalysisTool(
            DataAnalysisService analysisService) {
        
        var toolSchema = new McpSchema.Tool(
            "analyze_data",
            "å°ä¼æ¥­æ•¸æ“šé€²è¡Œçµ±è¨ˆåˆ†æå’Œå¯è¦–åŒ–",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "data_source", Map.of(
                        "type", "string",
                        "description", "æ•¸æ“šä¾†æºï¼ˆSQLæŸ¥è©¢ã€CSVæ–‡ä»¶è·¯å¾‘ç­‰ï¼‰"
                    ),
                    "analysis_type", Map.of(
                        "type", "string",
                        "description", "åˆ†æé¡å‹",
                        "enum", List.of("descriptive", "correlation", "trend", "forecast")
                    ),
                    "output_format", Map.of(
                        "type", "string",
                        "description", "è¼¸å‡ºæ ¼å¼",
                        "enum", List.of("text", "chart", "table", "json"),
                        "default", "text"
                    )
                ),
                "required", List.of("data_source", "analysis_type")
            )
        );
        
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    String dataSource = (String) request.arguments().get("data_source");
                    String analysisType = (String) request.arguments().get("analysis_type");
                    String outputFormat = (String) request.arguments().getOrDefault("output_format", "text");
                    
                    log.info("åŸ·è¡Œæ•¸æ“šåˆ†æ: source={}, type={}, format={}", 
                        dataSource, analysisType, outputFormat);
                    
                    DataAnalysisRequest analysisRequest = DataAnalysisRequest.builder()
                        .dataSource(dataSource)
                        .analysisType(AnalysisType.valueOf(analysisType.toUpperCase()))
                        .outputFormat(OutputFormat.valueOf(outputFormat.toUpperCase()))
                        .build();
                    
                    DataAnalysisResult result = analysisService.analyze(analysisRequest);
                    
                    // æ ¹æ“šè¼¸å‡ºæ ¼å¼è¿”å›çµæœ
                    return switch (outputFormat) {
                        case "chart" -> new McpSchema.CallToolResult(
                            List.of(new McpSchema.ImageContent(
                                result.getChartData(), "image/png"))
                        );
                        case "json" -> new McpSchema.CallToolResult(
                            List.of(new McpSchema.TextContent(
                                result.getJsonData()))
                        );
                        default -> new McpSchema.CallToolResult(
                            List.of(new McpSchema.TextContent(
                                result.getTextSummary()))
                        );
                    };
                    
                } catch (Exception e) {
                    log.error("æ•¸æ“šåˆ†æå·¥å…·åŸ·è¡Œå¤±æ•—", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "åˆ†æå¤±æ•—: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    /**
     * å‰µå»ºå·¥ä½œæµç¨‹å·¥å…·
     */
    private McpServerFeatures.SyncToolSpecification createWorkflowTool(
            WorkflowService workflowService) {
        
        var toolSchema = new McpSchema.Tool(
            "execute_workflow",
            "åŸ·è¡Œé å®šç¾©çš„æ¥­å‹™å·¥ä½œæµç¨‹",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "workflow_name", Map.of(
                        "type", "string",
                        "description", "å·¥ä½œæµç¨‹åç¨±"
                    ),
                    "parameters", Map.of(
                        "type", "object",
                        "description", "å·¥ä½œæµç¨‹åƒæ•¸"
                    ),
                    "async", Map.of(
                        "type", "boolean",
                        "description", "æ˜¯å¦ç•°æ­¥åŸ·è¡Œ",
                        "default", false
                    )
                ),
                "required", List.of("workflow_name")
            )
        );
        
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    String workflowName = (String) request.arguments().get("workflow_name");
                    @SuppressWarnings("unchecked")
                    Map<String, Object> parameters = (Map<String, Object>) 
                        request.arguments().getOrDefault("parameters", Map.of());
                    Boolean async = (Boolean) request.arguments().getOrDefault("async", false);
                    
                    log.info("åŸ·è¡Œå·¥ä½œæµç¨‹: name={}, async={}", workflowName, async);
                    
                    WorkflowExecutionRequest workflowRequest = WorkflowExecutionRequest.builder()
                        .workflowName(workflowName)
                        .parameters(parameters)
                        .async(async)
                        .build();
                    
                    WorkflowExecutionResult result = workflowService.execute(workflowRequest);
                    
                    String responseText = async ? 
                        "å·¥ä½œæµç¨‹å·²å•Ÿå‹•ï¼ŒåŸ·è¡ŒID: " + result.getExecutionId() :
                        "å·¥ä½œæµç¨‹åŸ·è¡Œå®Œæˆ: " + result.getResult();
                    
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(responseText))
                    );
                    
                } catch (Exception e) {
                    log.error("å·¥ä½œæµç¨‹å·¥å…·åŸ·è¡Œå¤±æ•—", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "å·¥ä½œæµç¨‹åŸ·è¡Œå¤±æ•—: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    /**
     * å‰µå»ºæ–‡ä»¶è™•ç†å·¥å…·
     */
    private McpServerFeatures.SyncToolSpecification createFileProcessingTool() {
        
        var toolSchema = new McpSchema.Tool(
            "process_file",
            "è™•ç†å’Œè½‰æ›å„ç¨®æ ¼å¼çš„æ–‡ä»¶",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "file_path", Map.of(
                        "type", "string",
                        "description", "æ–‡ä»¶è·¯å¾‘"
                    ),
                    "operation", Map.of(
                        "type", "string",
                        "description", "è™•ç†æ“ä½œ",
                        "enum", List.of("extract_text", "convert_format", "compress", "encrypt")
                    ),
                    "target_format", Map.of(
                        "type", "string",
                        "description", "ç›®æ¨™æ ¼å¼ï¼ˆè½‰æ›æ™‚ä½¿ç”¨ï¼‰"
                    )
                ),
                "required", List.of("file_path", "operation")
            )
        );
        
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    String filePath = (String) request.arguments().get("file_path");
                    String operation = (String) request.arguments().get("operation");
                    String targetFormat = (String) request.arguments().get("target_format");
                    
                    log.info("è™•ç†æ–‡ä»¶: path={}, operation={}, target={}", 
                        filePath, operation, targetFormat);
                    
                    // åŸ·è¡Œæ–‡ä»¶è™•ç†é‚è¼¯
                    String result = processFile(filePath, operation, targetFormat);
                    
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(result))
                    );
                    
                } catch (Exception e) {
                    log.error("æ–‡ä»¶è™•ç†å·¥å…·åŸ·è¡Œå¤±æ•—", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "æ–‡ä»¶è™•ç†å¤±æ•—: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    /**
     * å‰µå»ºç³»çµ±ç®¡ç†å·¥å…·
     */
    private McpServerFeatures.SyncToolSpecification createSystemManagementTool() {
        
        var toolSchema = new McpSchema.Tool(
            "system_info",
            "ç²å–ç³»çµ±ç‹€æ…‹å’Œè³‡æºä½¿ç”¨æƒ…æ³",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "info_type", Map.of(
                        "type", "string",
                        "description", "ä¿¡æ¯é¡å‹",
                        "enum", List.of("health", "metrics", "logs", "config")
                    )
                ),
                "required", List.of("info_type")
            )
        );
        
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    String infoType = (String) request.arguments().get("info_type");
                    
                    log.debug("ç²å–ç³»çµ±ä¿¡æ¯: type={}", infoType);
                    
                    String result = switch (infoType) {
                        case "health" -> getSystemHealth();
                        case "metrics" -> getSystemMetrics();
                        case "logs" -> getRecentLogs();
                        case "config" -> getSystemConfig();
                        default -> "æœªçŸ¥çš„ä¿¡æ¯é¡å‹: " + infoType;
                    };
                    
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(result))
                    );
                    
                } catch (Exception e) {
                    log.error("ç³»çµ±ç®¡ç†å·¥å…·åŸ·è¡Œå¤±æ•—", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "ç²å–ç³»çµ±ä¿¡æ¯å¤±æ•—: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    // è¼”åŠ©æ–¹æ³•
    private String formatSearchResult(DocumentSearchResult result) {
        StringBuilder sb = new StringBuilder();
        sb.append("æ‰¾åˆ° ").append(result.getDocuments().size()).append(" å€‹ç›¸é—œæ–‡æª”:\n\n");
        
        for (int i = 0; i < result.getDocuments().size(); i++) {
            Document doc = result.getDocuments().get(i);
            sb.append(i + 1).append(". ").append(doc.getTitle()).append("\n");
            sb.append("   ç›¸ä¼¼åº¦: ").append(String.format("%.2f", doc.getScore())).append("\n");
            sb.append("   æ‘˜è¦: ").append(doc.getSummary()).append("\n\n");
        }
        
        return sb.toString();
    }
    
    private String processFile(String filePath, String operation, String targetFormat) {
        // ç°¡åŒ–çš„æ–‡ä»¶è™•ç†é‚è¼¯
        return switch (operation) {
            case "extract_text" -> "å·²æå–æ–‡ä»¶æ–‡æœ¬å…§å®¹: " + filePath;
            case "convert_format" -> "å·²è½‰æ›æ–‡ä»¶æ ¼å¼: " + filePath + " -> " + targetFormat;
            case "compress" -> "å·²å£“ç¸®æ–‡ä»¶: " + filePath;
            case "encrypt" -> "å·²åŠ å¯†æ–‡ä»¶: " + filePath;
            default -> "æœªçŸ¥æ“ä½œ: " + operation;
        };
    }
    
    private String getSystemHealth() {
        return "ç³»çµ±ç‹€æ…‹: æ­£å¸¸\nCPU ä½¿ç”¨ç‡: 45%\nè¨˜æ†¶é«”ä½¿ç”¨ç‡: 62%\nç£ç¢Ÿä½¿ç”¨ç‡: 78%";
    }
    
    private String getSystemMetrics() {
        return "è«‹æ±‚ç¸½æ•¸: 12,345\næˆåŠŸç‡: 99.2%\nå¹³å‡å›æ‡‰æ™‚é–“: 150ms\næ´»èºé€£æ¥: 23";
    }
    
    private String getRecentLogs() {
        return "æœ€è¿‘æ—¥èªŒ:\n[INFO] MCP Server å•Ÿå‹•æˆåŠŸ\n[DEBUG] è™•ç†å·¥å…·èª¿ç”¨è«‹æ±‚\n[INFO] å®¢æˆ¶ç«¯é€£æ¥å»ºç«‹";
    }
    
    private String getSystemConfig() {
        return "ä¼ºæœå™¨é…ç½®:\nç‰ˆæœ¬: 1.0.0\nç«¯å£: 8080\næœ€å¤§é€£æ¥æ•¸: 100\nå·¥å…·æ•¸é‡: 5";
    }
}
```

---

## 9.4.3 MCP è³‡æºç®¡ç†

### è³‡æºæä¾›è€…é…ç½®

```java
/**
 * MCP è³‡æºé…ç½®é¡
 */
@Configuration
@Slf4j
public class McpResourcesConfiguration {
    
    /**
     * ç³»çµ±è³‡æºæä¾›è€…
     */
    @Bean
    public List<McpServerFeatures.SyncResourceSpecification> systemResources() {
        List<McpServerFeatures.SyncResourceSpecification> resources = new ArrayList<>();
        
        // 1. ç³»çµ±ä¿¡æ¯è³‡æº
        var systemInfoResource = new McpSchema.Resource(
            URI.create("system://info"),
            "ç³»çµ±ä¿¡æ¯",
            Optional.of("ç•¶å‰ç³»çµ±çš„åŸºæœ¬ä¿¡æ¯å’Œç‹€æ…‹"),
            Optional.of("application/json")
        );
        
        resources.add(new McpServerFeatures.SyncResourceSpecification(
            systemInfoResource,
            this::getSystemInfo
        ));
        
        // 2. æ‡‰ç”¨é…ç½®è³‡æº
        var configResource = new McpSchema.Resource(
            URI.create("config://application"),
            "æ‡‰ç”¨é…ç½®",
            Optional.of("ç•¶å‰æ‡‰ç”¨çš„é…ç½®ä¿¡æ¯"),
            Optional.of("application/yaml")
        );
        
        resources.add(new McpServerFeatures.SyncResourceSpecification(
            configResource,
            this::getApplicationConfig
        ));
        
        log.info("è¨»å†Šäº† {} å€‹ç³»çµ±è³‡æº", resources.size());
        return resources;
    }
    
    /**
     * ç²å–ç³»çµ±ä¿¡æ¯
     */
    private McpSchema.ReadResourceResult getSystemInfo(
            McpSyncServerExchange exchange,
            McpSchema.ReadResourceRequest request
    ) {
        try {
            Map<String, Object> systemInfo = Map.of(
                "serverName", "enterprise-mcp-server",
                "version", "1.0.0",
                "startTime", Instant.now().toString(),
                "javaVersion", System.getProperty("java.version"),
                "osName", System.getProperty("os.name"),
                "osVersion", System.getProperty("os.version"),
                "availableProcessors", Runtime.getRuntime().availableProcessors(),
                "maxMemory", Runtime.getRuntime().maxMemory(),
                "totalMemory", Runtime.getRuntime().totalMemory(),
                "freeMemory", Runtime.getRuntime().freeMemory()
            );
            
            String jsonContent = new ObjectMapper().writeValueAsString(systemInfo);
            
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    request.uri(),
                    "application/json",
                    jsonContent
                ))
            );
            
        } catch (Exception e) {
            log.error("ç²å–ç³»çµ±ä¿¡æ¯å¤±æ•—", e);
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    request.uri(),
                    "text/plain",
                    "ç²å–ç³»çµ±ä¿¡æ¯å¤±æ•—: " + e.getMessage()
                ))
            );
        }
    }
    
    /**
     * ç²å–æ‡‰ç”¨é…ç½®
     */
    private McpSchema.ReadResourceResult getApplicationConfig(
            McpSyncServerExchange exchange,
            McpSchema.ReadResourceRequest request
    ) {
        try {
            Map<String, Object> config = Map.of(
                "server", Map.of(
                    "name", "enterprise-mcp-server",
                    "port", 8080,
                    "ssl", false
                ),
                "mcp", Map.of(
                    "tools", Map.of(
                        "enabled", true,
                        "maxConcurrent", 20
                    ),
                    "resources", Map.of(
                        "enabled", true,
                        "cacheTtl", "PT5M"
                    ),
                    "security", Map.of(
                        "enabled", true,
                        "rateLimit", 100
                    )
                )
            );
            
            String yamlContent = new Yaml().dump(config);
            
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    request.uri(),
                    "application/yaml",
                    yamlContent
                ))
            );
            
        } catch (Exception e) {
            log.error("ç²å–æ‡‰ç”¨é…ç½®å¤±æ•—", e);
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    request.uri(),
                    "text/plain",
                    "ç²å–æ‡‰ç”¨é…ç½®å¤±æ•—: " + e.getMessage()
                ))
            );
        }
    }
    
    /**
     * æ–‡ä»¶ç³»çµ±è³‡æºæä¾›è€…
     */
    @Bean
    public List<McpServerFeatures.SyncResourceSpecification> fileResources(
            @Value("${mcp.resources.file.base-path:/data}") String basePath) {
        
        List<McpServerFeatures.SyncResourceSpecification> resources = new ArrayList<>();
        
        try {
            Path baseDir = Paths.get(basePath);
            if (!Files.exists(baseDir)) {
                log.warn("æ–‡ä»¶è³‡æºåŸºç¤è·¯å¾‘ä¸å­˜åœ¨: {}", basePath);
                return resources;
            }
            
            List<McpSchema.Resource> fileResources = new ArrayList<>();
            
            // æƒææ–‡ä»¶ç³»çµ±
            Files.walk(baseDir, 3)
                .filter(Files::isRegularFile)
                .filter(path -> isAllowedFileType(path))
                .forEach(path -> {
                    try {
                        URI uri = URI.create("file://" + path.toString());
                        String name = path.getFileName().toString();
                        String description = "æ–‡ä»¶: " + path.toString();
                        String mimeType = Files.probeContentType(path);
                        
                        fileResources.add(new McpSchema.Resource(
                            uri, name, Optional.of(description), Optional.ofNullable(mimeType)
                        ));
                        
                    } catch (Exception e) {
                        log.warn("è™•ç†æ–‡ä»¶è³‡æºå¤±æ•—: {}", path, e);
                    }
                });
            
            // ç‚ºæ¯å€‹æ–‡ä»¶å‰µå»ºè³‡æºè¦ç¯„
            for (McpSchema.Resource resource : fileResources) {
                resources.add(new McpServerFeatures.SyncResourceSpecification(
                    resource,
                    (exchange, request) -> readFileResource(request.uri())
                ));
            }
            
            log.info("è¨»å†Šäº† {} å€‹æ–‡ä»¶è³‡æº", resources.size());
            
        } catch (Exception e) {
            log.error("åˆå§‹åŒ–æ–‡ä»¶è³‡æºå¤±æ•—", e);
        }
        
        return resources;
    }
    
    /**
     * è®€å–æ–‡ä»¶è³‡æº
     */
    private McpSchema.ReadResourceResult readFileResource(URI uri) {
        try {
            String filePath = uri.getPath();
            Path path = Paths.get(filePath);
            
            if (!Files.exists(path)) {
                throw new FileNotFoundException("æ–‡ä»¶ä¸å­˜åœ¨: " + filePath);
            }
            
            String content = Files.readString(path, StandardCharsets.UTF_8);
            String mimeType = Files.probeContentType(path);
            
            McpSchema.ReadResourceResult result = new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    uri,
                    mimeType != null ? mimeType : "text/plain",
                    content
                ))
            );
            
            log.debug("æˆåŠŸè®€å–æ–‡ä»¶è³‡æº: {}", filePath);
            return result;
            
        } catch (Exception e) {
            log.error("è®€å–æ–‡ä»¶è³‡æºå¤±æ•—: {}", uri, e);
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    uri,
                    "text/plain",
                    "è®€å–æ–‡ä»¶å¤±æ•—: " + e.getMessage()
                ))
            );
        }
    }
    
    /**
     * æª¢æŸ¥æ˜¯å¦ç‚ºå…è¨±çš„æ–‡ä»¶é¡å‹
     */
    private boolean isAllowedFileType(Path path) {
        String fileName = path.getFileName().toString().toLowerCase();
        return fileName.endsWith(".txt") ||
               fileName.endsWith(".md") ||
               fileName.endsWith(".json") ||
               fileName.endsWith(".yaml") ||
               fileName.endsWith(".yml") ||
               fileName.endsWith(".xml") ||
               fileName.endsWith(".csv");
    }
}
```

---

## 9.4.4 MCP æç¤ºç³»çµ±

### æ™ºèƒ½æç¤ºé…ç½®

```java
/**
 * MCP æç¤ºé…ç½®é¡
 */
@Configuration
@Slf4j
public class McpPromptsConfiguration {
    
    /**
     * æ¥­å‹™æç¤ºæ¨¡æ¿
     */
    @Bean
    public List<McpServerFeatures.SyncPromptSpecification> businessPrompts() {
        List<McpServerFeatures.SyncPromptSpecification> prompts = new ArrayList<>();
        
        // 1. æ–‡æª”åˆ†ææç¤º
        var documentAnalysisPrompt = new McpSchema.Prompt(
            "document_analysis",
            Optional.of("åˆ†ææ–‡æª”å…§å®¹ä¸¦æä¾›æ·±å…¥è¦‹è§£"),
            List.of(
                new McpSchema.PromptArgument("document", "è¦åˆ†æçš„æ–‡æª”å…§å®¹", Optional.of(true)),
                new McpSchema.PromptArgument("focus", "åˆ†æé‡é»", Optional.of(false))
            )
        );
        
        prompts.add(new McpServerFeatures.SyncPromptSpecification(
            documentAnalysisPrompt,
            this::generateDocumentAnalysisPrompt
        ));
        
        // 2. ç¨‹å¼ç¢¼å¯©æŸ¥æç¤º
        var codeReviewPrompt = new McpSchema.Prompt(
            "code_review",
            Optional.of("å°ç¨‹å¼ç¢¼é€²è¡Œå°ˆæ¥­å¯©æŸ¥å’Œå»ºè­°"),
            List.of(
                new McpSchema.PromptArgument("code", "ç¨‹å¼ç¢¼å…§å®¹", Optional.of(true)),
                new McpSchema.PromptArgument("language", "ç¨‹å¼èªè¨€", Optional.of(false)),
                new McpSchema.PromptArgument("style", "å¯©æŸ¥é¢¨æ ¼", Optional.of(false))
            )
        );
        
        prompts.add(new McpServerFeatures.SyncPromptSpecification(
            codeReviewPrompt,
            this::generateCodeReviewPrompt
        ));
        
        log.info("è¨»å†Šäº† {} å€‹æ¥­å‹™æç¤º", prompts.size());
        return prompts;
    }
    
    /**
     * ç”Ÿæˆæ–‡æª”åˆ†ææç¤º
     */
    private McpSchema.GetPromptResult generateDocumentAnalysisPrompt(
            McpSyncServerExchange exchange,
            McpSchema.GetPromptRequest request
    ) {
        try {
            String document = (String) request.arguments().get("document");
            String focus = (String) request.arguments().getOrDefault("focus", "å…¨é¢åˆ†æ");
            
            String systemPrompt = """
                ä½ æ˜¯ä¸€ä½å°ˆæ¥­çš„æ–‡æª”åˆ†æå°ˆå®¶ï¼Œå…·å‚™ä»¥ä¸‹èƒ½åŠ›ï¼š
                1. æ·±å…¥ç†è§£æ–‡æª”å…§å®¹å’Œçµæ§‹
                2. è­˜åˆ¥é—œéµä¿¡æ¯å’Œé‡è¦è§€é»
                3. æä¾›å®¢è§€ã€æº–ç¢ºçš„åˆ†æçµæœ
                4. æ ¹æ“šåˆ†æé‡é»èª¿æ•´åˆ†ææ·±åº¦
                
                è«‹å°æä¾›çš„æ–‡æª”é€²è¡Œå°ˆæ¥­åˆ†æã€‚
                """;
            
            String userPrompt = String.format("""
                è«‹åˆ†æä»¥ä¸‹æ–‡æª”ï¼Œé‡é»é—œæ³¨ï¼š%s
                
                æ–‡æª”å…§å®¹ï¼š
                %s
                
                è«‹æä¾›ï¼š
                1. æ–‡æª”æ‘˜è¦
                2. é—œéµè§€é»
                3. é‡è¦æ•¸æ“šæˆ–äº‹å¯¦
                4. çµè«–å’Œå»ºè­°
                """, focus, document);
            
            List<McpSchema.PromptMessage> messages = List.of(
                new McpSchema.PromptMessage(
                    McpSchema.Role.SYSTEM,
                    new McpSchema.TextContent(systemPrompt)
                ),
                new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent(userPrompt)
                )
            );
            
            return new McpSchema.GetPromptResult(
                Optional.of("æ–‡æª”åˆ†ææç¤ºå·²ç”Ÿæˆ"),
                messages
            );
            
        } catch (Exception e) {
            log.error("ç”Ÿæˆæ–‡æª”åˆ†ææç¤ºå¤±æ•—", e);
            throw new RuntimeException("æç¤ºç”Ÿæˆå¤±æ•—", e);
        }
    }
    
    /**
     * ç”Ÿæˆç¨‹å¼ç¢¼å¯©æŸ¥æç¤º
     */
    private McpSchema.GetPromptResult generateCodeReviewPrompt(
            McpSyncServerExchange exchange,
            McpSchema.GetPromptRequest request
    ) {
        try {
            String code = (String) request.arguments().get("code");
            String language = (String) request.arguments().getOrDefault("language", "Java");
            String style = (String) request.arguments().getOrDefault("style", "æ¨™æº–");
            
            String systemPrompt = String.format("""
                ä½ æ˜¯ä¸€ä½è³‡æ·±çš„ %s ç¨‹å¼é–‹ç™¼å°ˆå®¶ï¼Œå…·å‚™ä»¥ä¸‹èƒ½åŠ›ï¼š
                1. æ·±å…¥ç†è§£ %s èªè¨€ç‰¹æ€§å’Œæœ€ä½³å¯¦è¸
                2. è­˜åˆ¥ç¨‹å¼ç¢¼ä¸­çš„æ½›åœ¨å•é¡Œå’Œæ”¹é€²æ©Ÿæœƒ
                3. æä¾›å…·é«”ã€å¯è¡Œçš„æ”¹é€²å»ºè­°
                4. éµå¾ª %s å¯©æŸ¥é¢¨æ ¼
                
                è«‹å°æä¾›çš„ç¨‹å¼ç¢¼é€²è¡Œå°ˆæ¥­å¯©æŸ¥ã€‚
                """, language, language, style);
            
            String userPrompt = String.format("""
                è«‹å¯©æŸ¥ä»¥ä¸‹ %s ç¨‹å¼ç¢¼ï¼š
                
                ```%s
                %s
                ```
                
                è«‹æä¾›ï¼š
                1. ç¨‹å¼ç¢¼å“è³ªè©•ä¼°
                2. æ½›åœ¨å•é¡Œè­˜åˆ¥
                3. æ€§èƒ½å„ªåŒ–å»ºè­°
                4. å®‰å…¨æ€§æª¢æŸ¥
                5. å¯è®€æ€§å’Œç¶­è­·æ€§æ”¹é€²
                """, language, language.toLowerCase(), code);
            
            List<McpSchema.PromptMessage> messages = List.of(
                new McpSchema.PromptMessage(
                    McpSchema.Role.SYSTEM,
                    new McpSchema.TextContent(systemPrompt)
                ),
                new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent(userPrompt)
                )
            );
            
            return new McpSchema.GetPromptResult(
                Optional.of("ç¨‹å¼ç¢¼å¯©æŸ¥æç¤ºå·²ç”Ÿæˆ"),
                messages
            );
            
        } catch (Exception e) {
            log.error("ç”Ÿæˆç¨‹å¼ç¢¼å¯©æŸ¥æç¤ºå¤±æ•—", e);
            throw new RuntimeException("æç¤ºç”Ÿæˆå¤±æ•—", e);
        }
    }
    
    /**
     * å‹•æ…‹æç¤ºæä¾›è€…
     */
    @Bean
    public List<McpServerFeatures.SyncPromptSpecification> dynamicPrompts(
            PromptTemplateRepository promptRepository) {
        
        return loadPromptsFromDatabase(promptRepository);
    }
    
    /**
     * å¾è³‡æ–™åº«è¼‰å…¥æç¤ºæ¨¡æ¿
     */
    private List<McpServerFeatures.SyncPromptSpecification> loadPromptsFromDatabase(
            PromptTemplateRepository repository) {
        
        List<McpServerFeatures.SyncPromptSpecification> prompts = new ArrayList<>();
        
        try {
            List<PromptTemplate> templates = repository.findAllActive();
            
            for (PromptTemplate template : templates) {
                String name = template.getName();
                String description = template.getDescription();
                String argumentsJson = template.getArguments();
                
                List<McpSchema.PromptArgument> arguments = parseArguments(argumentsJson);
                
                var prompt = new McpSchema.Prompt(name, Optional.of(description), arguments);
                
                prompts.add(new McpServerFeatures.SyncPromptSpecification(
                    prompt,
                    (exchange, request) -> generateDynamicPrompt(template, request)
                ));
            }
            
            log.info("å¾è³‡æ–™åº«è¼‰å…¥äº† {} å€‹å‹•æ…‹æç¤º", prompts.size());
            
        } catch (Exception e) {
            log.error("è¼‰å…¥å‹•æ…‹æç¤ºå¤±æ•—", e);
        }
        
        return prompts;
    }
    
    /**
     * è§£ææç¤ºåƒæ•¸
     */
    private List<McpSchema.PromptArgument> parseArguments(String argumentsJson) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            JsonNode argsNode = mapper.readTree(argumentsJson);
            
            List<McpSchema.PromptArgument> arguments = new ArrayList<>();
            
            if (argsNode.isArray()) {
                for (JsonNode argNode : argsNode) {
                    String name = argNode.get("name").asText();
                    String description = argNode.get("description").asText();
                    boolean required = argNode.get("required").asBoolean(false);
                    
                    arguments.add(new McpSchema.PromptArgument(name, description, Optional.of(required)));
                }
            }
            
            return arguments;
            
        } catch (Exception e) {
            log.warn("è§£ææç¤ºåƒæ•¸å¤±æ•—: {}", argumentsJson, e);
            return List.of();
        }
    }
    
    /**
     * ç”Ÿæˆå‹•æ…‹æç¤º
     */
    private McpSchema.GetPromptResult generateDynamicPrompt(
            PromptTemplate template, McpSchema.GetPromptRequest request) {
        
        try {
            // ä½¿ç”¨æ¨¡æ¿å¼•æ“è™•ç†æç¤ºå…§å®¹
            String processedContent = processTemplate(template.getContent(), request.arguments());
            
            List<McpSchema.PromptMessage> messages = List.of(
                new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent(processedContent)
                )
            );
            
            return new McpSchema.GetPromptResult(
                Optional.of("å‹•æ…‹æç¤ºå·²ç”Ÿæˆ: " + template.getName()),
                messages
            );
            
        } catch (Exception e) {
            log.error("ç”Ÿæˆå‹•æ…‹æç¤ºå¤±æ•—: {}", template.getName(), e);
            throw new RuntimeException("å‹•æ…‹æç¤ºç”Ÿæˆå¤±æ•—", e);
        }
    }
    
    /**
     * è™•ç†æç¤ºæ¨¡æ¿
     */
    private String processTemplate(String template, Map<String, Object> arguments) {
        String result = template;
        
        // ç°¡å–®çš„æ¨¡æ¿è®Šæ•¸æ›¿æ›
        for (Map.Entry<String, Object> entry : arguments.entrySet()) {
            String placeholder = "{{" + entry.getKey() + "}}";
            String value = entry.getValue().toString();
            result = result.replace(placeholder, value);
        }
        
        return result;
    }
}

/**
 * æç¤ºæ¨¡æ¿å¯¦é«”
 */
@Entity
@Table(name = "prompt_templates")
@Data
public class PromptTemplate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String name;
    
    @Column(nullable = false)
    private String description;
    
    @Column(columnDefinition = "TEXT")
    private String content;
    
    @Column(columnDefinition = "JSON")
    private String arguments;
    
    @Column(nullable = false)
    private Boolean active = true;
    
    @CreationTimestamp
    private Instant createdAt;
    
    @UpdateTimestamp
    private Instant updatedAt;
}

/**
 * æç¤ºæ¨¡æ¿å­˜å„²åº«
 */
@Repository
public interface PromptTemplateRepository extends JpaRepository<PromptTemplate, Long> {
    List<PromptTemplate> findAllActive();
    Optional<PromptTemplate> findByNameAndActive(String name, Boolean active);
}
```

---

## ğŸ“ æœ¬ç« é‡é»å›é¡§

1. **MCP Server æ¶æ§‹**ï¼šå»ºç«‹äº†å®Œæ•´çš„ä¼æ¥­ç´š MCP Server åŸºç¤æ¶æ§‹
2. **å·¥å…·é–‹ç™¼**ï¼šæŒæ¡äº†è‡ªå®šç¾© MCP å·¥å…·çš„é–‹ç™¼å’Œè¨»å†Šæ–¹æ³•
3. **è³‡æºç®¡ç†**ï¼šå¯¦ç¾äº†éˆæ´»çš„ MCP è³‡æºæä¾›å’Œç®¡ç†æ©Ÿåˆ¶
4. **æç¤ºç³»çµ±**ï¼šå»ºç«‹äº†æ™ºèƒ½åŒ–çš„ MCP æç¤ºæœå‹™
5. **ä¼æ¥­æ‡‰ç”¨**ï¼šæä¾›äº†å®Œæ•´çš„ä¼æ¥­ç´š MCP Server è§£æ±ºæ–¹æ¡ˆ

### æ ¸å¿ƒçµ„ä»¶ç¸½çµ

| çµ„ä»¶ | åŠŸèƒ½ | é‡è¦æ€§ | å¯¦ç¾é›£åº¦ |
|------|------|--------|----------|
| **å·¥å…·ç³»çµ±** | æä¾›å¯åŸ·è¡Œçš„åŠŸèƒ½æœå‹™ | â­â­â­â­â­ | ä¸­ |
| **è³‡æºç®¡ç†** | æä¾›å¯è®€å–çš„æ•¸æ“šè³‡æº | â­â­â­â­ | ä¸­ |
| **æç¤ºæœå‹™** | æä¾›æ™ºèƒ½åŒ–çš„æç¤ºæ¨¡æ¿ | â­â­â­ | ä¸­ |
| **å®‰å…¨æ§åˆ¶** | ç¢ºä¿æœå‹™çš„å®‰å…¨æ€§ | â­â­â­â­ | é«˜ |
| **ç›£æ§ç³»çµ±** | æä¾›æœå‹™ç›£æ§å’Œç®¡ç† | â­â­â­ | ä¸­ |

### æœ€ä½³å¯¦è¸å»ºè­°

1. **æ¨¡çµ„åŒ–è¨­è¨ˆ**ï¼šå°‡ä¸åŒé¡å‹çš„æœå‹™åˆ†é›¢åˆ°ä¸åŒçš„é…ç½®é¡ä¸­
2. **å®‰å…¨å„ªå…ˆ**ï¼šå¯¦ç¾å®Œæ•´çš„èªè­‰ã€æˆæ¬Šå’Œé€Ÿç‡é™åˆ¶æ©Ÿåˆ¶
3. **éŒ¯èª¤è™•ç†**ï¼šå»ºç«‹å¥å…¨çš„éŒ¯èª¤è™•ç†å’Œæ—¥èªŒè¨˜éŒ„æ©Ÿåˆ¶
4. **æ€§èƒ½å„ªåŒ–**ï¼šä½¿ç”¨å¿«å–å’Œç•°æ­¥è™•ç†æå‡æœå‹™æ€§èƒ½
5. **ç›£æ§å®Œå–„**ï¼šå»ºç«‹å®Œæ•´çš„æœå‹™ç›£æ§å’Œå‘Šè­¦é«”ç³»

### MCP Server éƒ¨ç½²æ¶æ§‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 ä¼æ¥­ç´š MCP Server æ¶æ§‹                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è² è¼‰å‡è¡¡å™¨ (Nginx/HAProxy)                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  MCP Server å¯¦ä¾‹ 1    MCP Server å¯¦ä¾‹ 2    ...         â”‚ â”‚
â”‚  â”‚  â€¢ å·¥å…·æœå‹™           â€¢ å·¥å…·æœå‹™                       â”‚ â”‚
â”‚  â”‚  â€¢ è³‡æºç®¡ç†           â€¢ è³‡æºç®¡ç†                       â”‚ â”‚
â”‚  â”‚  â€¢ æç¤ºç³»çµ±           â€¢ æç¤ºç³»çµ±                       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                            â†“                                â”‚
â”‚  å…±äº«æœå‹™å±¤                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â€¢ è³‡æ–™åº« (PostgreSQL)                                 â”‚ â”‚
â”‚  â”‚  â€¢ å¿«å– (Redis)                                        â”‚ â”‚
â”‚  â”‚  â€¢ æª”æ¡ˆå­˜å„² (MinIO/S3)                                 â”‚ â”‚
â”‚  â”‚  â€¢ ç›£æ§ (Prometheus + Grafana)                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä¸‹ä¸€æ­¥ç™¼å±•æ–¹å‘

å®Œæˆç¬¬ä¹ç« çš„å­¸ç¿’å¾Œï¼Œæ‚¨å·²ç¶“æŒæ¡äº†å®Œæ•´çš„ MCP æŠ€è¡“é«”ç³»ï¼š
- å¾ MCP åŸºç¤æ¦‚å¿µåˆ°å¯¦éš›æ‡‰ç”¨
- å¾ Client ä½¿ç”¨åˆ° Server é–‹ç™¼
- å¾å–®ä¸€å·¥å…·åˆ°ä¼æ¥­ç´šæœå‹™

æœªä¾†å¯ä»¥è€ƒæ…®çš„ç™¼å±•æ–¹å‘ï¼š
- **å¤šæ¨¡æ…‹ MCP æœå‹™**ï¼šæ”¯æ´åœ–åƒã€éŸ³é »ç­‰å¤šåª’é«”è™•ç†
- **åˆ†æ•£å¼ MCP æ¶æ§‹**ï¼šå»ºç«‹è·¨å€åŸŸçš„ MCP æœå‹™ç¶²è·¯
- **AI é©…å‹•çš„ MCP**ï¼šä½¿ç”¨ AI æŠ€è¡“è‡ªå‹•ç”Ÿæˆå’Œå„ªåŒ– MCP æœå‹™
- **æ¨™æº–åŒ–æ¨å»£**ï¼šåƒèˆ‡ MCP å”è­°çš„æ¨™æº–åŒ–å’Œç”Ÿæ…‹å»ºè¨­

---

**åƒè€ƒè³‡æ–™ï¼š**
- [MCP Server Specification](https://spec.modelcontextprotocol.io/specification/server/)
- [Spring AI MCP Server Documentation](https://docs.spring.io/spring-ai/reference/api/mcp-server.html)
- [Enterprise MCP Best Practices](https://github.com/modelcontextprotocol/servers)
- [MCP Security Guidelines](https://spec.modelcontextprotocol.io/specification/security/)
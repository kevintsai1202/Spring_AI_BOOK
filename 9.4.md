# 9.4 開發 MCP Server 工具

> **本章重點**：深入學習如何開發企業級的 MCP Server，掌握工具註冊、資源管理、提示系統的完整開發流程，建立可擴展、高可用的 MCP 服務提供者，為企業 AI 生態系統提供標準化的服務能力。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **開發 MCP 工具**：掌握自定義 MCP 工具的開發和註冊方法
- 🎯 **管理 MCP 資源**：實現 MCP 資源的提供和管理機制
- 🎯 **建立提示系統**：開發智能化的 MCP 提示服務
- 🎯 **部署 MCP Server**：建立企業級的 MCP Server 部署方案
- 🎯 **監控與維護**：實現 MCP Server 的監控、日誌和維護機制

---

## 9.4.1 MCP Server 基礎架構

### MCP Server 配置

#### 基礎配置類

```java
/**
 * 企業級 MCP Server 配置
 */
@Configuration
@Slf4j
public class EnterpriseMcpServerConfiguration {
    
    /**
     * 文檔搜尋服務工具
     */
    @Bean
    public ToolCallbackProvider documentSearchTools(DocumentSearchService documentService) {
        return MethodToolCallbackProvider.builder()
            .toolObjects(documentService)
            .build();
    }
    
    /**
     * 數據分析服務工具
     */
    @Bean
    public ToolCallbackProvider dataAnalysisTools(DataAnalysisService analysisService) {
        return MethodToolCallbackProvider.builder()
            .toolObjects(analysisService)
            .build();
    }
    
    /**
     * 工作流程服務工具
     */
    @Bean
    public ToolCallbackProvider workflowTools(WorkflowService workflowService) {
        return MethodToolCallbackProvider.builder()
            .toolObjects(workflowService)
            .build();
    }
    
    /**
     * 配置安全設置
     */
    private void configureSecurity(McpServer.Builder builder, 
                                 McpSecurityProperties securityProps) {
        
        builder.security(security -> {
            // 認證配置
            security.authentication(auth -> {
                auth.type(securityProps.getAuthenticationType());
                auth.tokenValidator(new JwtTokenValidator());
                auth.roleExtractor(new CustomRoleExtractor());
            });
            
            // 授權配置
            security.authorization(authz -> {
                authz.requireRole("MCP_USER");
                authz.toolAccess("admin_tools", "ADMIN");
                authz.resourceAccess("sensitive_data", "DATA_ACCESS");
            });
            
            // 速率限制
            security.rateLimit(rate -> {
                rate.requestsPerMinute(securityProps.getRateLimit());
                rate.burstCapacity(securityProps.getBurstCapacity());
            });
        });
    }
    
    /**
     * 配置監控
     */
    private void configureMonitoring(McpServer.Builder builder) {
        builder.monitoring(monitor -> {
            monitor.metrics(true);
            monitor.healthCheck(true);
            monitor.requestLogging(true);
            monitor.performanceTracking(true);
        });
    }
    
    /**
     * 配置錯誤處理
     */
    private void configureErrorHandling(McpServer.Builder builder) {
        builder.errorHandler((request, error) -> {
            log.error("MCP 請求處理錯誤: {} - {}", 
                request.getId(), error.getMessage(), error);
            
            // 根據錯誤類型返回適當的回應
            return switch (error) {
                case ValidationException ve -> 
                    McpErrorResponse.invalidParams(ve.getMessage());
                case AuthenticationException ae -> 
                    McpErrorResponse.unauthorized("認證失敗");
                case AuthorizationException aze -> 
                    McpErrorResponse.forbidden("權限不足");
                case RateLimitException rle -> 
                    McpErrorResponse.tooManyRequests("請求過於頻繁");
                case ResourceNotFoundException rnfe -> 
                    McpErrorResponse.notFound("資源未找到");
                default -> 
                    McpErrorResponse.internalError("內部伺服器錯誤");
            };
        });
    }
}

/**
 * MCP 安全配置屬性
 */
@ConfigurationProperties(prefix = "mcp.security")
@Data
public class McpSecurityProperties {
    private boolean enabled = true;
    private String authenticationType = "bearer";
    private int rateLimit = 100;
    private int burstCapacity = 20;
    private List<String> allowedOrigins = List.of("*");
    private List<String> trustedClients = new ArrayList<>();
}
```

---

## 9.4.2 MCP 工具開發

### 工具註冊與配置

```java
/**
 * MCP 工具配置類
 */
@Configuration
@Slf4j
public class McpToolsConfiguration {
    
    /**
     * 註冊企業級 MCP 工具
     */
    @Bean
    public List<McpServerFeatures.SyncToolSpecification> enterpriseTools(
            DocumentSearchService documentService,
            DataAnalysisService analysisService,
            WorkflowService workflowService) {
        
        List<McpServerFeatures.SyncToolSpecification> tools = new ArrayList<>();
        
        // 1. 文檔搜尋工具
        tools.add(createDocumentSearchTool(documentService));
        
        // 2. 數據分析工具
        tools.add(createDataAnalysisTool(analysisService));
        
        // 3. 工作流程工具
        tools.add(createWorkflowTool(workflowService));
        
        // 4. 文件處理工具
        tools.add(createFileProcessingTool());
        
        // 5. 系統管理工具
        tools.add(createSystemManagementTool());
        
        log.info("註冊了 {} 個企業級 MCP 工具", tools.size());
        return tools;
    }
    
    /**
     * 創建文檔搜尋工具
     */
    private McpServerFeatures.SyncToolSpecification createDocumentSearchTool(
            DocumentSearchService documentService) {
        
        // 定義工具 Schema
        var toolSchema = new McpSchema.Tool(
            "search_documents",
            "搜尋企業文檔庫中的相關文檔",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "query", Map.of(
                        "type", "string",
                        "description", "搜尋關鍵字或問題"
                    ),
                    "domain", Map.of(
                        "type", "string",
                        "description", "專業領域過濾（可選）",
                        "enum", List.of("技術", "財務", "人事", "法務", "營運")
                    ),
                    "max_results", Map.of(
                        "type", "integer",
                        "description", "最大結果數量",
                        "default", 5,
                        "minimum", 1,
                        "maximum", 20
                    ),
                    "similarity_threshold", Map.of(
                        "type", "number",
                        "description", "相似度閾值",
                        "default", 0.7,
                        "minimum", 0.0,
                        "maximum", 1.0
                    )
                ),
                "required", List.of("query")
            )
        );
        
        // 定義工具執行邏輯
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    // 提取參數
                    String query = (String) request.arguments().get("query");
                    String domain = (String) request.arguments().get("domain");
                    Integer maxResults = (Integer) request.arguments().getOrDefault("max_results", 5);
                    Double threshold = (Double) request.arguments().getOrDefault("similarity_threshold", 0.7);
                    
                    log.info("執行文檔搜尋: query={}, domain={}, maxResults={}, threshold={}", 
                        query, domain, maxResults, threshold);
                    
                    // 執行搜尋
                    DocumentSearchRequest searchRequest = DocumentSearchRequest.builder()
                        .query(query)
                        .domain(domain)
                        .maxResults(maxResults)
                        .similarityThreshold(threshold)
                        .build();
                    
                    DocumentSearchResult result = documentService.search(searchRequest);
                    
                    // 格式化結果
                    String formattedResult = formatSearchResult(result);
                    
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(formattedResult))
                    );
                    
                } catch (Exception e) {
                    log.error("文檔搜尋工具執行失敗", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "搜尋失敗: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    /**
     * 創建數據分析工具
     */
    private McpServerFeatures.SyncToolSpecification createDataAnalysisTool(
            DataAnalysisService analysisService) {
        
        var toolSchema = new McpSchema.Tool(
            "analyze_data",
            "對企業數據進行統計分析和可視化",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "data_source", Map.of(
                        "type", "string",
                        "description", "數據來源（SQL查詢、CSV文件路徑等）"
                    ),
                    "analysis_type", Map.of(
                        "type", "string",
                        "description", "分析類型",
                        "enum", List.of("descriptive", "correlation", "trend", "forecast")
                    ),
                    "output_format", Map.of(
                        "type", "string",
                        "description", "輸出格式",
                        "enum", List.of("text", "chart", "table", "json"),
                        "default", "text"
                    )
                ),
                "required", List.of("data_source", "analysis_type")
            )
        );
        
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    String dataSource = (String) request.arguments().get("data_source");
                    String analysisType = (String) request.arguments().get("analysis_type");
                    String outputFormat = (String) request.arguments().getOrDefault("output_format", "text");
                    
                    log.info("執行數據分析: source={}, type={}, format={}", 
                        dataSource, analysisType, outputFormat);
                    
                    DataAnalysisRequest analysisRequest = DataAnalysisRequest.builder()
                        .dataSource(dataSource)
                        .analysisType(AnalysisType.valueOf(analysisType.toUpperCase()))
                        .outputFormat(OutputFormat.valueOf(outputFormat.toUpperCase()))
                        .build();
                    
                    DataAnalysisResult result = analysisService.analyze(analysisRequest);
                    
                    // 根據輸出格式返回結果
                    return switch (outputFormat) {
                        case "chart" -> new McpSchema.CallToolResult(
                            List.of(new McpSchema.ImageContent(
                                result.getChartData(), "image/png"))
                        );
                        case "json" -> new McpSchema.CallToolResult(
                            List.of(new McpSchema.TextContent(
                                result.getJsonData()))
                        );
                        default -> new McpSchema.CallToolResult(
                            List.of(new McpSchema.TextContent(
                                result.getTextSummary()))
                        );
                    };
                    
                } catch (Exception e) {
                    log.error("數據分析工具執行失敗", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "分析失敗: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    /**
     * 創建工作流程工具
     */
    private McpServerFeatures.SyncToolSpecification createWorkflowTool(
            WorkflowService workflowService) {
        
        var toolSchema = new McpSchema.Tool(
            "execute_workflow",
            "執行預定義的業務工作流程",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "workflow_name", Map.of(
                        "type", "string",
                        "description", "工作流程名稱"
                    ),
                    "parameters", Map.of(
                        "type", "object",
                        "description", "工作流程參數"
                    ),
                    "async", Map.of(
                        "type", "boolean",
                        "description", "是否異步執行",
                        "default", false
                    )
                ),
                "required", List.of("workflow_name")
            )
        );
        
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    String workflowName = (String) request.arguments().get("workflow_name");
                    @SuppressWarnings("unchecked")
                    Map<String, Object> parameters = (Map<String, Object>) 
                        request.arguments().getOrDefault("parameters", Map.of());
                    Boolean async = (Boolean) request.arguments().getOrDefault("async", false);
                    
                    log.info("執行工作流程: name={}, async={}", workflowName, async);
                    
                    WorkflowExecutionRequest workflowRequest = WorkflowExecutionRequest.builder()
                        .workflowName(workflowName)
                        .parameters(parameters)
                        .async(async)
                        .build();
                    
                    WorkflowExecutionResult result = workflowService.execute(workflowRequest);
                    
                    String responseText = async ? 
                        "工作流程已啟動，執行ID: " + result.getExecutionId() :
                        "工作流程執行完成: " + result.getResult();
                    
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(responseText))
                    );
                    
                } catch (Exception e) {
                    log.error("工作流程工具執行失敗", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "工作流程執行失敗: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    /**
     * 創建文件處理工具
     */
    private McpServerFeatures.SyncToolSpecification createFileProcessingTool() {
        
        var toolSchema = new McpSchema.Tool(
            "process_file",
            "處理和轉換各種格式的文件",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "file_path", Map.of(
                        "type", "string",
                        "description", "文件路徑"
                    ),
                    "operation", Map.of(
                        "type", "string",
                        "description", "處理操作",
                        "enum", List.of("extract_text", "convert_format", "compress", "encrypt")
                    ),
                    "target_format", Map.of(
                        "type", "string",
                        "description", "目標格式（轉換時使用）"
                    )
                ),
                "required", List.of("file_path", "operation")
            )
        );
        
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    String filePath = (String) request.arguments().get("file_path");
                    String operation = (String) request.arguments().get("operation");
                    String targetFormat = (String) request.arguments().get("target_format");
                    
                    log.info("處理文件: path={}, operation={}, target={}", 
                        filePath, operation, targetFormat);
                    
                    // 執行文件處理邏輯
                    String result = processFile(filePath, operation, targetFormat);
                    
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(result))
                    );
                    
                } catch (Exception e) {
                    log.error("文件處理工具執行失敗", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "文件處理失敗: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    /**
     * 創建系統管理工具
     */
    private McpServerFeatures.SyncToolSpecification createSystemManagementTool() {
        
        var toolSchema = new McpSchema.Tool(
            "system_info",
            "獲取系統狀態和資源使用情況",
            Map.of(
                "type", "object",
                "properties", Map.of(
                    "info_type", Map.of(
                        "type", "string",
                        "description", "信息類型",
                        "enum", List.of("health", "metrics", "logs", "config")
                    )
                ),
                "required", List.of("info_type")
            )
        );
        
        return new McpServerFeatures.SyncToolSpecification(
            toolSchema,
            (exchange, request) -> {
                try {
                    String infoType = (String) request.arguments().get("info_type");
                    
                    log.debug("獲取系統信息: type={}", infoType);
                    
                    String result = switch (infoType) {
                        case "health" -> getSystemHealth();
                        case "metrics" -> getSystemMetrics();
                        case "logs" -> getRecentLogs();
                        case "config" -> getSystemConfig();
                        default -> "未知的信息類型: " + infoType;
                    };
                    
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(result))
                    );
                    
                } catch (Exception e) {
                    log.error("系統管理工具執行失敗", e);
                    return new McpSchema.CallToolResult(
                        List.of(new McpSchema.TextContent(
                            "獲取系統信息失敗: " + e.getMessage()))
                    );
                }
            }
        );
    }
    
    // 輔助方法
    private String formatSearchResult(DocumentSearchResult result) {
        StringBuilder sb = new StringBuilder();
        sb.append("找到 ").append(result.getDocuments().size()).append(" 個相關文檔:\n\n");
        
        for (int i = 0; i < result.getDocuments().size(); i++) {
            Document doc = result.getDocuments().get(i);
            sb.append(i + 1).append(". ").append(doc.getTitle()).append("\n");
            sb.append("   相似度: ").append(String.format("%.2f", doc.getScore())).append("\n");
            sb.append("   摘要: ").append(doc.getSummary()).append("\n\n");
        }
        
        return sb.toString();
    }
    
    private String processFile(String filePath, String operation, String targetFormat) {
        // 簡化的文件處理邏輯
        return switch (operation) {
            case "extract_text" -> "已提取文件文本內容: " + filePath;
            case "convert_format" -> "已轉換文件格式: " + filePath + " -> " + targetFormat;
            case "compress" -> "已壓縮文件: " + filePath;
            case "encrypt" -> "已加密文件: " + filePath;
            default -> "未知操作: " + operation;
        };
    }
    
    private String getSystemHealth() {
        return "系統狀態: 正常\nCPU 使用率: 45%\n記憶體使用率: 62%\n磁碟使用率: 78%";
    }
    
    private String getSystemMetrics() {
        return "請求總數: 12,345\n成功率: 99.2%\n平均回應時間: 150ms\n活躍連接: 23";
    }
    
    private String getRecentLogs() {
        return "最近日誌:\n[INFO] MCP Server 啟動成功\n[DEBUG] 處理工具調用請求\n[INFO] 客戶端連接建立";
    }
    
    private String getSystemConfig() {
        return "伺服器配置:\n版本: 1.0.0\n端口: 8080\n最大連接數: 100\n工具數量: 5";
    }
}
```

---

## 9.4.3 MCP 資源管理

### 資源提供者配置

```java
/**
 * MCP 資源配置類
 */
@Configuration
@Slf4j
public class McpResourcesConfiguration {
    
    /**
     * 系統資源提供者
     */
    @Bean
    public List<McpServerFeatures.SyncResourceSpecification> systemResources() {
        List<McpServerFeatures.SyncResourceSpecification> resources = new ArrayList<>();
        
        // 1. 系統信息資源
        var systemInfoResource = new McpSchema.Resource(
            URI.create("system://info"),
            "系統信息",
            Optional.of("當前系統的基本信息和狀態"),
            Optional.of("application/json")
        );
        
        resources.add(new McpServerFeatures.SyncResourceSpecification(
            systemInfoResource,
            this::getSystemInfo
        ));
        
        // 2. 應用配置資源
        var configResource = new McpSchema.Resource(
            URI.create("config://application"),
            "應用配置",
            Optional.of("當前應用的配置信息"),
            Optional.of("application/yaml")
        );
        
        resources.add(new McpServerFeatures.SyncResourceSpecification(
            configResource,
            this::getApplicationConfig
        ));
        
        log.info("註冊了 {} 個系統資源", resources.size());
        return resources;
    }
    
    /**
     * 獲取系統信息
     */
    private McpSchema.ReadResourceResult getSystemInfo(
            McpSyncServerExchange exchange,
            McpSchema.ReadResourceRequest request
    ) {
        try {
            Map<String, Object> systemInfo = Map.of(
                "serverName", "enterprise-mcp-server",
                "version", "1.0.0",
                "startTime", Instant.now().toString(),
                "javaVersion", System.getProperty("java.version"),
                "osName", System.getProperty("os.name"),
                "osVersion", System.getProperty("os.version"),
                "availableProcessors", Runtime.getRuntime().availableProcessors(),
                "maxMemory", Runtime.getRuntime().maxMemory(),
                "totalMemory", Runtime.getRuntime().totalMemory(),
                "freeMemory", Runtime.getRuntime().freeMemory()
            );
            
            String jsonContent = new ObjectMapper().writeValueAsString(systemInfo);
            
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    request.uri(),
                    "application/json",
                    jsonContent
                ))
            );
            
        } catch (Exception e) {
            log.error("獲取系統信息失敗", e);
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    request.uri(),
                    "text/plain",
                    "獲取系統信息失敗: " + e.getMessage()
                ))
            );
        }
    }
    
    /**
     * 獲取應用配置
     */
    private McpSchema.ReadResourceResult getApplicationConfig(
            McpSyncServerExchange exchange,
            McpSchema.ReadResourceRequest request
    ) {
        try {
            Map<String, Object> config = Map.of(
                "server", Map.of(
                    "name", "enterprise-mcp-server",
                    "port", 8080,
                    "ssl", false
                ),
                "mcp", Map.of(
                    "tools", Map.of(
                        "enabled", true,
                        "maxConcurrent", 20
                    ),
                    "resources", Map.of(
                        "enabled", true,
                        "cacheTtl", "PT5M"
                    ),
                    "security", Map.of(
                        "enabled", true,
                        "rateLimit", 100
                    )
                )
            );
            
            String yamlContent = new Yaml().dump(config);
            
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    request.uri(),
                    "application/yaml",
                    yamlContent
                ))
            );
            
        } catch (Exception e) {
            log.error("獲取應用配置失敗", e);
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    request.uri(),
                    "text/plain",
                    "獲取應用配置失敗: " + e.getMessage()
                ))
            );
        }
    }
    
    /**
     * 文件系統資源提供者
     */
    @Bean
    public List<McpServerFeatures.SyncResourceSpecification> fileResources(
            @Value("${mcp.resources.file.base-path:/data}") String basePath) {
        
        List<McpServerFeatures.SyncResourceSpecification> resources = new ArrayList<>();
        
        try {
            Path baseDir = Paths.get(basePath);
            if (!Files.exists(baseDir)) {
                log.warn("文件資源基礎路徑不存在: {}", basePath);
                return resources;
            }
            
            List<McpSchema.Resource> fileResources = new ArrayList<>();
            
            // 掃描文件系統
            Files.walk(baseDir, 3)
                .filter(Files::isRegularFile)
                .filter(path -> isAllowedFileType(path))
                .forEach(path -> {
                    try {
                        URI uri = URI.create("file://" + path.toString());
                        String name = path.getFileName().toString();
                        String description = "文件: " + path.toString();
                        String mimeType = Files.probeContentType(path);
                        
                        fileResources.add(new McpSchema.Resource(
                            uri, name, Optional.of(description), Optional.ofNullable(mimeType)
                        ));
                        
                    } catch (Exception e) {
                        log.warn("處理文件資源失敗: {}", path, e);
                    }
                });
            
            // 為每個文件創建資源規範
            for (McpSchema.Resource resource : fileResources) {
                resources.add(new McpServerFeatures.SyncResourceSpecification(
                    resource,
                    (exchange, request) -> readFileResource(request.uri())
                ));
            }
            
            log.info("註冊了 {} 個文件資源", resources.size());
            
        } catch (Exception e) {
            log.error("初始化文件資源失敗", e);
        }
        
        return resources;
    }
    
    /**
     * 讀取文件資源
     */
    private McpSchema.ReadResourceResult readFileResource(URI uri) {
        try {
            String filePath = uri.getPath();
            Path path = Paths.get(filePath);
            
            if (!Files.exists(path)) {
                throw new FileNotFoundException("文件不存在: " + filePath);
            }
            
            String content = Files.readString(path, StandardCharsets.UTF_8);
            String mimeType = Files.probeContentType(path);
            
            McpSchema.ReadResourceResult result = new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    uri,
                    mimeType != null ? mimeType : "text/plain",
                    content
                ))
            );
            
            log.debug("成功讀取文件資源: {}", filePath);
            return result;
            
        } catch (Exception e) {
            log.error("讀取文件資源失敗: {}", uri, e);
            return new McpSchema.ReadResourceResult(
                List.of(new McpSchema.TextResourceContents(
                    uri,
                    "text/plain",
                    "讀取文件失敗: " + e.getMessage()
                ))
            );
        }
    }
    
    /**
     * 檢查是否為允許的文件類型
     */
    private boolean isAllowedFileType(Path path) {
        String fileName = path.getFileName().toString().toLowerCase();
        return fileName.endsWith(".txt") ||
               fileName.endsWith(".md") ||
               fileName.endsWith(".json") ||
               fileName.endsWith(".yaml") ||
               fileName.endsWith(".yml") ||
               fileName.endsWith(".xml") ||
               fileName.endsWith(".csv");
    }
}
```

---

## 9.4.4 MCP 提示系統

### 智能提示配置

```java
/**
 * MCP 提示配置類
 */
@Configuration
@Slf4j
public class McpPromptsConfiguration {
    
    /**
     * 業務提示模板
     */
    @Bean
    public List<McpServerFeatures.SyncPromptSpecification> businessPrompts() {
        List<McpServerFeatures.SyncPromptSpecification> prompts = new ArrayList<>();
        
        // 1. 文檔分析提示
        var documentAnalysisPrompt = new McpSchema.Prompt(
            "document_analysis",
            Optional.of("分析文檔內容並提供深入見解"),
            List.of(
                new McpSchema.PromptArgument("document", "要分析的文檔內容", Optional.of(true)),
                new McpSchema.PromptArgument("focus", "分析重點", Optional.of(false))
            )
        );
        
        prompts.add(new McpServerFeatures.SyncPromptSpecification(
            documentAnalysisPrompt,
            this::generateDocumentAnalysisPrompt
        ));
        
        // 2. 程式碼審查提示
        var codeReviewPrompt = new McpSchema.Prompt(
            "code_review",
            Optional.of("對程式碼進行專業審查和建議"),
            List.of(
                new McpSchema.PromptArgument("code", "程式碼內容", Optional.of(true)),
                new McpSchema.PromptArgument("language", "程式語言", Optional.of(false)),
                new McpSchema.PromptArgument("style", "審查風格", Optional.of(false))
            )
        );
        
        prompts.add(new McpServerFeatures.SyncPromptSpecification(
            codeReviewPrompt,
            this::generateCodeReviewPrompt
        ));
        
        log.info("註冊了 {} 個業務提示", prompts.size());
        return prompts;
    }
    
    /**
     * 生成文檔分析提示
     */
    private McpSchema.GetPromptResult generateDocumentAnalysisPrompt(
            McpSyncServerExchange exchange,
            McpSchema.GetPromptRequest request
    ) {
        try {
            String document = (String) request.arguments().get("document");
            String focus = (String) request.arguments().getOrDefault("focus", "全面分析");
            
            String systemPrompt = """
                你是一位專業的文檔分析專家，具備以下能力：
                1. 深入理解文檔內容和結構
                2. 識別關鍵信息和重要觀點
                3. 提供客觀、準確的分析結果
                4. 根據分析重點調整分析深度
                
                請對提供的文檔進行專業分析。
                """;
            
            String userPrompt = String.format("""
                請分析以下文檔，重點關注：%s
                
                文檔內容：
                %s
                
                請提供：
                1. 文檔摘要
                2. 關鍵觀點
                3. 重要數據或事實
                4. 結論和建議
                """, focus, document);
            
            List<McpSchema.PromptMessage> messages = List.of(
                new McpSchema.PromptMessage(
                    McpSchema.Role.SYSTEM,
                    new McpSchema.TextContent(systemPrompt)
                ),
                new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent(userPrompt)
                )
            );
            
            return new McpSchema.GetPromptResult(
                Optional.of("文檔分析提示已生成"),
                messages
            );
            
        } catch (Exception e) {
            log.error("生成文檔分析提示失敗", e);
            throw new RuntimeException("提示生成失敗", e);
        }
    }
    
    /**
     * 生成程式碼審查提示
     */
    private McpSchema.GetPromptResult generateCodeReviewPrompt(
            McpSyncServerExchange exchange,
            McpSchema.GetPromptRequest request
    ) {
        try {
            String code = (String) request.arguments().get("code");
            String language = (String) request.arguments().getOrDefault("language", "Java");
            String style = (String) request.arguments().getOrDefault("style", "標準");
            
            String systemPrompt = String.format("""
                你是一位資深的 %s 程式開發專家，具備以下能力：
                1. 深入理解 %s 語言特性和最佳實踐
                2. 識別程式碼中的潛在問題和改進機會
                3. 提供具體、可行的改進建議
                4. 遵循 %s 審查風格
                
                請對提供的程式碼進行專業審查。
                """, language, language, style);
            
            String userPrompt = String.format("""
                請審查以下 %s 程式碼：
                
                ```%s
                %s
                ```
                
                請提供：
                1. 程式碼品質評估
                2. 潛在問題識別
                3. 性能優化建議
                4. 安全性檢查
                5. 可讀性和維護性改進
                """, language, language.toLowerCase(), code);
            
            List<McpSchema.PromptMessage> messages = List.of(
                new McpSchema.PromptMessage(
                    McpSchema.Role.SYSTEM,
                    new McpSchema.TextContent(systemPrompt)
                ),
                new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent(userPrompt)
                )
            );
            
            return new McpSchema.GetPromptResult(
                Optional.of("程式碼審查提示已生成"),
                messages
            );
            
        } catch (Exception e) {
            log.error("生成程式碼審查提示失敗", e);
            throw new RuntimeException("提示生成失敗", e);
        }
    }
    
    /**
     * 動態提示提供者
     */
    @Bean
    public List<McpServerFeatures.SyncPromptSpecification> dynamicPrompts(
            PromptTemplateRepository promptRepository) {
        
        return loadPromptsFromDatabase(promptRepository);
    }
    
    /**
     * 從資料庫載入提示模板
     */
    private List<McpServerFeatures.SyncPromptSpecification> loadPromptsFromDatabase(
            PromptTemplateRepository repository) {
        
        List<McpServerFeatures.SyncPromptSpecification> prompts = new ArrayList<>();
        
        try {
            List<PromptTemplate> templates = repository.findAllActive();
            
            for (PromptTemplate template : templates) {
                String name = template.getName();
                String description = template.getDescription();
                String argumentsJson = template.getArguments();
                
                List<McpSchema.PromptArgument> arguments = parseArguments(argumentsJson);
                
                var prompt = new McpSchema.Prompt(name, Optional.of(description), arguments);
                
                prompts.add(new McpServerFeatures.SyncPromptSpecification(
                    prompt,
                    (exchange, request) -> generateDynamicPrompt(template, request)
                ));
            }
            
            log.info("從資料庫載入了 {} 個動態提示", prompts.size());
            
        } catch (Exception e) {
            log.error("載入動態提示失敗", e);
        }
        
        return prompts;
    }
    
    /**
     * 解析提示參數
     */
    private List<McpSchema.PromptArgument> parseArguments(String argumentsJson) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            JsonNode argsNode = mapper.readTree(argumentsJson);
            
            List<McpSchema.PromptArgument> arguments = new ArrayList<>();
            
            if (argsNode.isArray()) {
                for (JsonNode argNode : argsNode) {
                    String name = argNode.get("name").asText();
                    String description = argNode.get("description").asText();
                    boolean required = argNode.get("required").asBoolean(false);
                    
                    arguments.add(new McpSchema.PromptArgument(name, description, Optional.of(required)));
                }
            }
            
            return arguments;
            
        } catch (Exception e) {
            log.warn("解析提示參數失敗: {}", argumentsJson, e);
            return List.of();
        }
    }
    
    /**
     * 生成動態提示
     */
    private McpSchema.GetPromptResult generateDynamicPrompt(
            PromptTemplate template, McpSchema.GetPromptRequest request) {
        
        try {
            // 使用模板引擎處理提示內容
            String processedContent = processTemplate(template.getContent(), request.arguments());
            
            List<McpSchema.PromptMessage> messages = List.of(
                new McpSchema.PromptMessage(
                    McpSchema.Role.USER,
                    new McpSchema.TextContent(processedContent)
                )
            );
            
            return new McpSchema.GetPromptResult(
                Optional.of("動態提示已生成: " + template.getName()),
                messages
            );
            
        } catch (Exception e) {
            log.error("生成動態提示失敗: {}", template.getName(), e);
            throw new RuntimeException("動態提示生成失敗", e);
        }
    }
    
    /**
     * 處理提示模板
     */
    private String processTemplate(String template, Map<String, Object> arguments) {
        String result = template;
        
        // 簡單的模板變數替換
        for (Map.Entry<String, Object> entry : arguments.entrySet()) {
            String placeholder = "{{" + entry.getKey() + "}}";
            String value = entry.getValue().toString();
            result = result.replace(placeholder, value);
        }
        
        return result;
    }
}

/**
 * 提示模板實體
 */
@Entity
@Table(name = "prompt_templates")
@Data
public class PromptTemplate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String name;
    
    @Column(nullable = false)
    private String description;
    
    @Column(columnDefinition = "TEXT")
    private String content;
    
    @Column(columnDefinition = "JSON")
    private String arguments;
    
    @Column(nullable = false)
    private Boolean active = true;
    
    @CreationTimestamp
    private Instant createdAt;
    
    @UpdateTimestamp
    private Instant updatedAt;
}

/**
 * 提示模板存儲庫
 */
@Repository
public interface PromptTemplateRepository extends JpaRepository<PromptTemplate, Long> {
    List<PromptTemplate> findAllActive();
    Optional<PromptTemplate> findByNameAndActive(String name, Boolean active);
}
```

---

## 📝 本章重點回顧

1. **MCP Server 架構**：建立了完整的企業級 MCP Server 基礎架構
2. **工具開發**：掌握了自定義 MCP 工具的開發和註冊方法
3. **資源管理**：實現了靈活的 MCP 資源提供和管理機制
4. **提示系統**：建立了智能化的 MCP 提示服務
5. **企業應用**：提供了完整的企業級 MCP Server 解決方案

### 核心組件總結

| 組件 | 功能 | 重要性 | 實現難度 |
|------|------|--------|----------|
| **工具系統** | 提供可執行的功能服務 | ⭐⭐⭐⭐⭐ | 中 |
| **資源管理** | 提供可讀取的數據資源 | ⭐⭐⭐⭐ | 中 |
| **提示服務** | 提供智能化的提示模板 | ⭐⭐⭐ | 中 |
| **安全控制** | 確保服務的安全性 | ⭐⭐⭐⭐ | 高 |
| **監控系統** | 提供服務監控和管理 | ⭐⭐⭐ | 中 |

### 最佳實踐建議

1. **模組化設計**：將不同類型的服務分離到不同的配置類中
2. **安全優先**：實現完整的認證、授權和速率限制機制
3. **錯誤處理**：建立健全的錯誤處理和日誌記錄機制
4. **性能優化**：使用快取和異步處理提升服務性能
5. **監控完善**：建立完整的服務監控和告警體系

### MCP Server 部署架構

```
┌─────────────────────────────────────────────────────────────┐
│                 企業級 MCP Server 架構                      │
├─────────────────────────────────────────────────────────────┤
│  負載均衡器 (Nginx/HAProxy)                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  MCP Server 實例 1    MCP Server 實例 2    ...         │ │
│  │  • 工具服務           • 工具服務                       │ │
│  │  • 資源管理           • 資源管理                       │ │
│  │  • 提示系統           • 提示系統                       │ │
│  └─────────────────────────────────────────────────────────┘ │
│                            ↓                                │
│  共享服務層                                                 │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  • 資料庫 (PostgreSQL)                                 │ │
│  │  • 快取 (Redis)                                        │ │
│  │  • 檔案存儲 (MinIO/S3)                                 │ │
│  │  • 監控 (Prometheus + Grafana)                        │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 下一步發展方向

完成第九章的學習後，您已經掌握了完整的 MCP 技術體系：
- 從 MCP 基礎概念到實際應用
- 從 Client 使用到 Server 開發
- 從單一工具到企業級服務

未來可以考慮的發展方向：
- **多模態 MCP 服務**：支援圖像、音頻等多媒體處理
- **分散式 MCP 架構**：建立跨區域的 MCP 服務網路
- **AI 驅動的 MCP**：使用 AI 技術自動生成和優化 MCP 服務
- **標準化推廣**：參與 MCP 協議的標準化和生態建設

---

**參考資料：**
- [MCP Server Specification](https://spec.modelcontextprotocol.io/specification/server/)
- [Spring AI MCP Server Documentation](https://docs.spring.io/spring-ai/reference/api/mcp-server.html)
- [Enterprise MCP Best Practices](https://github.com/modelcontextprotocol/servers)
- [MCP Security Guidelines](https://spec.modelcontextprotocol.io/specification/security/)
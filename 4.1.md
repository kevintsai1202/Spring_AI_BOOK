# 4.1 取得 AI 入門鑰匙 API key

> **第四章導讀**：歡迎進入 Spring AI 的世界！本章將帶您從零開始學習 Spring AI 的核心概念和基礎應用，為後續的企業級 RAG 知識庫開發奠定堅實基礎。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **取得 AI 服務 API Key**：學會申請和配置各種 AI 服務的 API 金鑰
- 🎯 **理解 AI 服務成本**：掌握不同 AI 模型的定價策略和成本控制
- 🎯 **配置開發環境**：為 Spring AI 開發準備必要的認證資訊
- 🎯 **選擇合適的 AI 服務**：了解各種 AI 服務提供商的特點和適用場景
- 🎯 **建立安全的配置管理**：學會安全地管理 API 金鑰和敏感資訊

---

## 4.1.1 為什麼需要 API Key？

### 開啟 AI 的鑰匙

![AI API Key](https://ithelp.ithome.com.tw/upload/images/20240810/20161290sQLWvAdoDT.jpg)

平常使用 ChatGPT 或其他類似的對話 AI 都可直接使用，大不了額度沒了會降為效果比較差的模型，不過要進行程式開發就需要先申請 API key，除非使用本地的 LLM。

**API Key 的重要性**：
- 🔐 **身份認證**：證明您有權限使用 AI 服務
- 💰 **計費管理**：追蹤和控制 API 使用成本
- 🚦 **流量控制**：管理 API 呼叫頻率和配額
- 📊 **使用統計**：監控 API 使用情況和效能
- 🛡️ **安全保護**：防止未授權的 API 存取

### AI 服務成本革命

原本凱文大叔測試 AI 都以本地 LLM 或是一些免費的服務為主，不過 2025 年 8 月 [OpenAI 正式發布 GPT-5](https://openai.com/index/introducing-gpt-5/) 系列模型後就完全改觀了：

**GPT-5 革命性優勢**：
- 🚀 **統一系統**：結合推理和快速回應的統一 AI 模型
- 💡 **超強性能**：數學能力 94.6%，編程能力 74.9%，減少 45% 錯誤率
- 💰 **彈性定價**：GPT-5 Nano 只需 $0.05/百萬 Token，超低成本入門
- ⚡ **多層選擇**：從 Nano 到完整版 GPT-5，滿足不同需求
- 🎯 **降低門檻**：讓原本猶豫不決的開發人員一起加入 AI 的賽道

---

## 4.1.2 主要 AI 服務提供商

### OpenAI - 業界標竿

**申請步驟**：
1. **註冊帳號**：前往 [OpenAI Platform](https://platform.openai.com/)
2. **驗證身份**：提供手機號碼進行驗證
3. **建立 API Key**：
   - 點擊右上角個人頭像
   - 選擇「View API keys」
   - 點擊「Create new secret key」
   - 為 Key 命名（如：spring-ai-demo）
   - 複製並安全保存 API Key

**重要提醒**：
```
⚠️ API Key 只會顯示一次，請務必立即複製並安全保存！
```

**OpenAI 模型選擇**：

| 模型 | 適用場景 | 成本 | 特點 | 定價 (每百萬 Token) |
|------|----------|------|------|-------------------|
| **GPT-5** | 最複雜任務、專業級應用 | 極高 | 🚀 2025最新旗艦，統一推理系統 | 輸入$1.25 / 輸出$10 |
| **GPT-5 Mini** | 平衡型選擇、商業應用 | 中高 | ⚡ 中等性能，支援推理功能 | 輸入$0.25 / 輸出$2 |
| **GPT-5 Nano** | 開發測試、輕量應用 | 低 | 💡 輕量高效，入門推薦 | 輸入$0.05 / 輸出$0.40 |
| **o1** | 複雜推理、數學、編程 | 極高 | 🧠 深度思考推理專家 | - |
| **GPT-4o mini** | 舊版輕量選擇 | 低 | 📊 經典性價比選擇 | - |

### Groq - 高速推理

**特色**：
- ⚡ **超高速度**：推理速度極快
- 🆓 **免費使用**：目前提供免費服務
- 🎯 **開發友好**：適合開發和測試階段

**申請步驟**：
1. 前往 [Groq Console](https://console.groq.com/)
2. 使用 Google 或 GitHub 帳號登入
3. 在 API Keys 頁面建立新的 API Key
4. 複製並保存 API Key

### Anthropic Claude - 最新智能選擇

**2025 年最強寫程式 AI**：
- 🧠 **Claude 4 系列**：業界最新的智能模型
- 🎯 **多模態能力**：支援文字、圖片、PDF 處理
- 💡 **思考功能**：Claude Opus 4.1 具備透明推理過程
- 🔧 **工具整合**：完整支援函數調用和工具使用
- 💰 **彈性定價**：從便宜的 Haiku 到強大的 Opus

**申請步驟**：
1. **註冊帳號**：前往 [Anthropic Console](https://console.anthropic.com/)
2. **建立 API Key**：
   - 登入後進入 [API Keys](https://console.anthropic.com/settings/keys)
   - 點擊「Create Key」
   - 為 Key 命名並設定權限
   - 複製並安全保存 API Key

**Claude 模型選擇**：

| 模型 | 適用場景 | 成本 | 特點 |
|------|----------|------|------|
| **Claude Opus 4.1** | 最複雜的推理任務 | 極高 | 最強智能，編碼專家 |
| **Claude Sonnet 4** | 平衡型選擇 | 高 | 高效能，100萬 Token 語境 |

---

## 4.1.3 API Key 配置與管理

### Spring Boot 配置方式

**1. application.yml 配置**
```yaml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      base-url: https://api.openai.com
      chat:
        options:
          model: gpt-5-nano
    
    # Anthropic Claude 配置
    anthropic:
      api-key: ${ANTHROPIC_API_KEY}
      chat:
        options:
          model: claude-sonnet-4-0
    
    # Groq 配置範例
    groq:
      api-key: ${GROQ_API_KEY}
      chat:
        options:
          model: llama-3.1-70b-versatile
```

**2. 環境變數設定**
```bash
# Windows PowerShell
$env:OPENAI_API_KEY="your-openai-api-key-here"
$env:ANTHROPIC_API_KEY="your-anthropic-api-key-here"
$env:GROQ_API_KEY="your-groq-api-key-here"

# Linux/macOS
export OPENAI_API_KEY="your-openai-api-key-here"
export ANTHROPIC_API_KEY="your-anthropic-api-key-here"
export GROQ_API_KEY="your-groq-api-key-here"
```

**3. IDE 環境變數配置**

在 STS4 中配置環境變數：
1. 右鍵點擊專案 → Run As → Run Configurations
2. 選擇 Spring Boot App
3. 切換到 Environment 標籤
4. 新增環境變數：
   - Name: `OPENAI_API_KEY`
   - Value: `your-api-key-here`

### 安全最佳實踐

**1. 絕不將 API Key 寫入程式碼**
```java
// ❌ 錯誤做法 - 硬編碼 API Key
public class BadExample {
    private static final String API_KEY = "sk-1234567890abcdef"; // 危險！
}

// ✅ 正確做法 - 使用環境變數或注入 OpenAiApi
@Value("${spring.ai.openai.api-key}")
private String apiKey;

// 或者使用官方推薦的方式
@Autowired
private OpenAiApi openAiApi;
```

**2. 使用 .env 檔案（開發環境）**
```properties
# .env 檔案
OPENAI_API_KEY=your-openai-api-key-here
GROQ_API_KEY=your-groq-api-key-here
```

**重要提醒**：
```
⚠️ 務必將 .env 檔案加入 .gitignore，避免意外提交到版本控制系統！
```

---

## 4.1.4 成本控制與監控

### OpenAI 成本管理

**1. 設定使用限制**
- 在 OpenAI Platform 設定月度預算上限
- 配置使用量警告通知
- 監控 API 呼叫統計

**2. 模型選擇策略**
```java
@Service
public class AIModelSelector {
    
    // 開發環境使用便宜的模型
    @Profile("dev")
    @Bean
    public OpenAiChatModel devChatModel(OpenAiApi openAiApi) {
        return OpenAiChatModel.builder()
            .openAiApi(openAiApi)
            .options(OpenAiChatOptions.builder()
                .model("gpt-5-nano") // 最便宜的選項
                .build())
            .build();
    }
    
    // 生產環境使用高性能模型
    @Profile("prod")
    @Bean
    public OpenAiChatModel prodChatModel(OpenAiApi openAiApi) {
        return OpenAiChatModel.builder()
            .openAiApi(openAiApi)
            .options(OpenAiChatOptions.builder()
                .model("gpt-5") // 最強統一系統
                .build())
            .build();
    }
}
```

### 使用量監控

**1. 建立使用統計**
```java
@Component
public class AIUsageTracker {
    
    private final MeterRegistry meterRegistry;
    private final Counter apiCallCounter;
    private final Timer responseTimer;
    
    public AIUsageTracker(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.apiCallCounter = Counter.builder("ai.api.calls")
            .description("AI API calls count")
            .register(meterRegistry);
        this.responseTimer = Timer.builder("ai.api.response.time")
            .description("AI API response time")
            .register(meterRegistry);
    }
    
    public void recordApiCall(String model, Duration responseTime) {
        apiCallCounter.increment(Tags.of("model", model));
        responseTimer.record(responseTime);
    }
}
```

**2. 成本預估工具**
```java
@Service
public class CostEstimator {
    
    // GPT-5 nano 定價（每 1M tokens）- 2025年8月最新
    private static final double INPUT_COST_PER_MILLION = 0.05;  // $0.05
    private static final double OUTPUT_COST_PER_MILLION = 0.40; // $0.40
    
    public double estimateCost(int inputTokens, int outputTokens) {
        double inputCost = (inputTokens / 1_000_000.0) * INPUT_COST_PER_MILLION;
        double outputCost = (outputTokens / 1_000_000.0) * OUTPUT_COST_PER_MILLION;
        return inputCost + outputCost;
    }
}
```

---

## 4.1.5 多服務提供商配置

### 彈性切換策略

```java
@Configuration
public class MultiAIProviderConfig {
    
    @Value("${app.ai.provider:openai}")
    private String aiProvider;
    
    @Bean
    @Primary
    public ChatModel primaryChatModel(
            @Qualifier("openaiChatModel") ChatModel openaiModel,
            @Qualifier("anthropicChatModel") ChatModel anthropicModel,
            @Qualifier("groqChatModel") ChatModel groqModel) {
        
        return switch (aiProvider.toLowerCase()) {
            case "anthropic", "claude" -> anthropicModel;
            case "groq" -> groqModel;
            case "openai" -> openaiModel;
            default -> openaiModel;
        };
    }
    
    @Bean("openaiChatModel")
    public OpenAiChatModel openaiChatModel(OpenAiApi openAiApi) {
        return OpenAiChatModel.builder()
            .openAiApi(openAiApi)
            .options(OpenAiChatOptions.builder()
                .model("gpt-5-nano")
                .build())
            .build();
    }
    
    @Bean("anthropicChatModel")
    public AnthropicChatModel anthropicChatModel() {
        var anthropicApi = new AnthropicApi(anthropicApiKey);
        return AnthropicChatModel.builder()
            .anthropicApi(anthropicApi)
            .defaultOptions(AnthropicChatOptions.builder()
                .model("claude-sonnet-4-0")
                .temperature(0.7)
                .maxTokens(1000)
                .build())
            .build();
    }
    
    @Bean("groqChatModel")
    public OpenAiChatModel groqChatModel() {
        // Groq 使用 OpenAI 相容 API
        var groqApi = OpenAiApi.builder()
            .apiKey(groqApiKey)
            .baseUrl("https://api.groq.com/openai/v1")
            .build();
        
        return OpenAiChatModel.builder()
            .openAiApi(groqApi)
            .options(OpenAiChatOptions.builder()
                .model("llama-3.1-70b-versatile")
                .build())
            .build();
    }
}
```

### 容錯機制

```java
@Service
public class ResilientAIService {
    
    private final List<ChatModel> chatModels;
    
    public ResilientAIService(
            @Qualifier("openaiChatModel") ChatModel openaiModel,
            @Qualifier("anthropicChatModel") ChatModel anthropicModel,
            @Qualifier("groqChatModel") ChatModel groqModel) {
        this.chatModels = List.of(openaiModel, anthropicModel, groqModel);
    }
    
    public String chat(String message) {
        for (ChatModel model : chatModels) {
            try {
                return model.call(message);
            } catch (Exception e) {
                log.warn("AI service failed, trying next provider: {}", e.getMessage());
            }
        }
        throw new RuntimeException("All AI services are unavailable");
    }
}
```

---

## 📝 本章重點回顧

1. **API Key 重要性**：理解了 API Key 在 AI 服務中的關鍵作用
2. **服務提供商選擇**：掌握了 OpenAI、Groq、Azure 等主要服務商的特點
3. **安全配置管理**：學會了安全地管理和配置 API 金鑰
4. **成本控制策略**：了解了如何監控和控制 AI 服務使用成本
5. **多服務商整合**：建立了彈性的多服務商切換機制

### 下一步學習方向

在下一章中，我們將使用取得的 API Key 建立第一個 Spring AI 應用程式，體驗「Hello AI World」的魅力。

---

**參考資料：**
- [OpenAI Platform Documentation](https://platform.openai.com/docs)
- [Groq API Documentation](https://console.groq.com/docs)
- [Azure OpenAI Service](https://azure.microsoft.com/en-us/products/ai-services/openai-service)
- [Spring AI Reference Guide](https://docs.spring.io/spring-ai/reference/)
# 4.5 å‰ç«¯è©²å¦‚ä½•è™•ç†æµå¼è¼¸å‡º

> **æœ¬ç« é‡é»**ï¼šæ·±å…¥æ¢è¨å‰ç«¯å¦‚ä½•å„ªé›…åœ°è™•ç† AI æµå¼è¼¸å‡ºï¼Œå»ºç«‹å®Œæ•´çš„å‰å¾Œç«¯æ•´åˆæ–¹æ¡ˆï¼Œç‚ºä½¿ç”¨è€…æä¾›å¦‚åŒ ChatGPT èˆ¬çš„æµæš¢äº’å‹•é«”é©—ã€‚

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬ç« å­¸ç¿’å¾Œï¼Œæ‚¨å°‡èƒ½å¤ ï¼š

- ğŸ¯ **æŒæ¡ EventSource API**ï¼šç†Ÿç·´ä½¿ç”¨ç€è¦½å™¨åŸç”Ÿçš„ SSE æ¥æ”¶æŠ€è¡“
- ğŸ¯ **å¯¦ç¾æµå¼ UI æ›´æ–°**ï¼šå»ºç«‹å³æ™‚æ›´æ–°çš„èŠå¤©ä»‹é¢
- ğŸ¯ **è™•ç†é€£ç·šç®¡ç†**ï¼šæŒæ¡é€£ç·šå»ºç«‹ã€ç¶­è­·å’ŒéŒ¯èª¤è™•ç†
- ğŸ¯ **å„ªåŒ–ä½¿ç”¨è€…é«”é©—**ï¼šå¯¦ç¾æ‰“å­—æ•ˆæœã€è¼‰å…¥ç‹€æ…‹ç­‰äº’å‹•ç´°ç¯€
- ğŸ¯ **æ•´åˆç¾ä»£å‰ç«¯æ¡†æ¶**ï¼šåœ¨ Reactã€Vue ç­‰æ¡†æ¶ä¸­å¯¦ç¾æµå¼åŠŸèƒ½

---

## 4.5.1 EventSource API åŸºç¤

### ä»€éº¼æ˜¯ Server-Sent Events (SSE)ï¼Ÿ

Server-Sent Events æ˜¯ HTML5 æ¨™æº–çš„ä¸€éƒ¨åˆ†ï¼Œå…è¨±ä¼ºæœå™¨å‘ç€è¦½å™¨æ¨é€è³‡æ–™ã€‚èˆ‡ WebSocket ä¸åŒï¼ŒSSE æ˜¯å–®å‘çš„ï¼ˆåƒ…ä¼ºæœå™¨åˆ°å®¢æˆ¶ç«¯ï¼‰ï¼Œä½†å°æ–¼ AI æµå¼è¼¸å‡ºä¾†èªªå·²ç¶“è¶³å¤ ã€‚

**SSE vs WebSocket vs è¼ªè©¢**ï¼š

| ç‰¹æ€§ | SSE | WebSocket | è¼ªè©¢ |
|------|-----|-----------|------|
| **è¤‡é›œåº¦** | ä½ | ä¸­ | ä½ |
| **å³æ™‚æ€§** | é«˜ | é«˜ | ä½ |
| **è³‡æºæ¶ˆè€—** | ä½ | ä¸­ | é«˜ |
| **ç€è¦½å™¨æ”¯æ´** | å»£æ³› | å»£æ³› | å…¨éƒ¨ |
| **è‡ªå‹•é‡é€£** | æ˜¯ | å¦ | å¦ |
| **é©ç”¨å ´æ™¯** | å–®å‘æ¨é€ | é›™å‘é€šè¨Š | ç°¡å–®æŸ¥è©¢ |

### EventSource åŸºæœ¬ç”¨æ³•

```javascript
/**
 * åŸºæœ¬çš„ EventSource ä½¿ç”¨ç¯„ä¾‹
 */
function basicEventSourceExample() {
    // å»ºç«‹ EventSource é€£ç·š
    const eventSource = new EventSource('/api/ai/chat/stream?prompt=Hello');
    
    // ç›£è½è¨Šæ¯äº‹ä»¶
    eventSource.onmessage = function(event) {
        console.log('æ”¶åˆ°è³‡æ–™:', event.data);
    };
    
    // ç›£è½é–‹å•Ÿäº‹ä»¶
    eventSource.onopen = function(event) {
        console.log('é€£ç·šå·²å»ºç«‹');
    };
    
    // ç›£è½éŒ¯èª¤äº‹ä»¶
    eventSource.onerror = function(event) {
        console.error('é€£ç·šéŒ¯èª¤:', event);
        
        // æ ¹æ“šéŒ¯èª¤ç‹€æ…‹æ±ºå®šæ˜¯å¦é‡é€£
        if (event.target.readyState === EventSource.CLOSED) {
            console.log('é€£ç·šå·²é—œé–‰');
        }
    };
    
    // æ‰‹å‹•é—œé–‰é€£ç·š
    setTimeout(() => {
        eventSource.close();
        console.log('é€£ç·šå·²æ‰‹å‹•é—œé–‰');
    }, 30000); // 30ç§’å¾Œé—œé–‰
}
```

### EventSource ç‹€æ…‹ç®¡ç†

```javascript
/**
 * EventSource ç‹€æ…‹å¸¸æ•¸
 */
const SSE_STATE = {
    CONNECTING: 0,  // æ­£åœ¨é€£ç·š
    OPEN: 1,        // é€£ç·šå·²é–‹å•Ÿ
    CLOSED: 2       // é€£ç·šå·²é—œé–‰
};

/**
 * ç›£æ§ EventSource ç‹€æ…‹
 */
function monitorEventSourceState(eventSource) {
    const checkState = () => {
        switch (eventSource.readyState) {
            case SSE_STATE.CONNECTING:
                console.log('ç‹€æ…‹ï¼šæ­£åœ¨é€£ç·š...');
                break;
            case SSE_STATE.OPEN:
                console.log('ç‹€æ…‹ï¼šé€£ç·šå·²é–‹å•Ÿ');
                break;
            case SSE_STATE.CLOSED:
                console.log('ç‹€æ…‹ï¼šé€£ç·šå·²é—œé–‰');
                break;
        }
    };
    
    // å®šæœŸæª¢æŸ¥ç‹€æ…‹
    const stateChecker = setInterval(checkState, 1000);
    
    // é€£ç·šé—œé–‰æ™‚åœæ­¢æª¢æŸ¥
    eventSource.addEventListener('close', () => {
        clearInterval(stateChecker);
    });
}
```

---

## 4.5.2 å»ºç«‹æµå¼èŠå¤©ä»‹é¢

### HTML çµæ§‹è¨­è¨ˆ

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI æµå¼èŠå¤©</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="chat-container">
        <!-- èŠå¤©æ¨™é¡Œ -->
        <div class="chat-header">
            <h1>ğŸ¤– AI åŠ©æ‰‹</h1>
            <div class="connection-status" id="connectionStatus">
                <span class="status-indicator"></span>
                <span class="status-text">å°±ç·’</span>
            </div>
        </div>
        
        <!-- èŠå¤©è¨Šæ¯å€åŸŸ -->
        <div class="chat-messages" id="chatMessages">
            <div class="message system">
                <div class="message-content">
                    ğŸ‘‹ æ‚¨å¥½ï¼æˆ‘æ˜¯ AI åŠ©æ‰‹ï¼Œæœ‰ä»€éº¼å¯ä»¥å¹«åŠ©æ‚¨çš„å—ï¼Ÿ
                </div>
                <div class="message-time">å‰›å‰›</div>
            </div>
        </div>
        
        <!-- è¼¸å…¥å€åŸŸ -->
        <div class="chat-input">
            <div class="input-container">
                <textarea 
                    id="messageInput" 
                    placeholder="è¼¸å…¥æ‚¨çš„å•é¡Œ..." 
                    rows="1"
                    maxlength="2000"></textarea>
                <button id="sendButton" class="send-button">
                    <span class="send-icon">ğŸ“¤</span>
                    <span class="send-text">ç™¼é€</span>
                </button>
                <button id="stopButton" class="stop-button" style="display: none;">
                    <span class="stop-icon">â¹ï¸</span>
                    <span class="stop-text">åœæ­¢</span>
                </button>
            </div>
            <div class="input-info">
                <span id="charCount">0/2000</span>
                <span class="tips">æŒ‰ Ctrl+Enter å¿«é€Ÿç™¼é€</span>
            </div>
        </div>
    </div>
    
    <script src="chat.js"></script>
</body>
</html>
```

### CSS æ¨£å¼è¨­è¨ˆ

```css
/* styles.css */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

.chat-container {
    width: 90%;
    max-width: 800px;
    height: 90vh;
    background: white;
    border-radius: 20px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* èŠå¤©æ¨™é¡Œ */
.chat-header {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.chat-header h1 {
    font-size: 1.5rem;
    font-weight: 600;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
}

.status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #4ade80;
    animation: pulse 2s infinite;
}

.status-indicator.connecting {
    background: #fbbf24;
}

.status-indicator.error {
    background: #ef4444;
    animation: none;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

/* èŠå¤©è¨Šæ¯å€åŸŸ */
.chat-messages {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    scroll-behavior: smooth;
}

.message {
    margin-bottom: 20px;
    display: flex;
    flex-direction: column;
}

.message.user {
    align-items: flex-end;
}

.message.ai {
    align-items: flex-start;
}

.message.system {
    align-items: center;
}

.message-content {
    max-width: 80%;
    padding: 12px 16px;
    border-radius: 18px;
    line-height: 1.5;
    word-wrap: break-word;
    position: relative;
}

.message.user .message-content {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
    border-bottom-right-radius: 4px;
}

.message.ai .message-content {
    background: #f1f5f9;
    color: #334155;
    border-bottom-left-radius: 4px;
    border: 1px solid #e2e8f0;
}

.message.system .message-content {
    background: #fef3c7;
    color: #92400e;
    border: 1px solid #fcd34d;
    font-size: 0.9rem;
}

.message-time {
    font-size: 0.75rem;
    color: #64748b;
    margin-top: 4px;
    padding: 0 8px;
}

/* æ‰“å­—æ•ˆæœ */
.typing-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #64748b;
    animation: typing 1.4s infinite ease-in-out;
    margin-left: 2px;
}

.typing-indicator:nth-child(1) { animation-delay: -0.32s; }
.typing-indicator:nth-child(2) { animation-delay: -0.16s; }

@keyframes typing {
    0%, 80%, 100% {
        transform: scale(0);
        opacity: 0.5;
    }
    40% {
        transform: scale(1);
        opacity: 1;
    }
}

/* è¼¸å…¥å€åŸŸ */
.chat-input {
    padding: 20px;
    background: #f8fafc;
    border-top: 1px solid #e2e8f0;
}

.input-container {
    display: flex;
    gap: 12px;
    align-items: flex-end;
}

#messageInput {
    flex: 1;
    padding: 12px 16px;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    font-size: 1rem;
    line-height: 1.5;
    resize: none;
    outline: none;
    transition: all 0.2s ease;
    max-height: 120px;
}

#messageInput:focus {
    border-color: #4facfe;
    box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
}

.send-button, .stop-button {
    padding: 12px 20px;
    border: none;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 100px;
    justify-content: center;
}

.send-button {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
}

.send-button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(79, 172, 254, 0.3);
}

.send-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
}

.stop-button {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    color: white;
}

.stop-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(239, 68, 68, 0.3);
}

.input-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
    font-size: 0.8rem;
    color: #64748b;
}

.tips {
    font-style: italic;
}

/* éŸ¿æ‡‰å¼è¨­è¨ˆ */
@media (max-width: 768px) {
    .chat-container {
        width: 100%;
        height: 100vh;
        border-radius: 0;
    }
    
    .message-content {
        max-width: 90%;
    }
    
    .input-container {
        flex-direction: column;
    }
    
    .send-button, .stop-button {
        width: 100%;
    }
}
```

---

## 4.5.3 JavaScript æµå¼èŠå¤©å¯¦ç¾

### æ ¸å¿ƒèŠå¤©é¡åˆ¥

```javascript
// chat.js

/**
 * æµå¼èŠå¤©ç®¡ç†é¡åˆ¥
 */
class StreamingChat {
    constructor() {
        this.eventSource = null;
        this.isStreaming = false;
        this.currentMessageElement = null;
        
        // DOM å…ƒç´ 
        this.messagesContainer = document.getElementById('chatMessages');
        this.messageInput = document.getElementById('messageInput');
        this.sendButton = document.getElementById('sendButton');
        this.stopButton = document.getElementById('stopButton');
        this.connectionStatus = document.getElementById('connectionStatus');
        this.charCount = document.getElementById('charCount');
        
        this.initializeEventListeners();
        this.updateConnectionStatus('ready', 'å°±ç·’');
    }
    
    /**
     * åˆå§‹åŒ–äº‹ä»¶ç›£è½å™¨
     */
    initializeEventListeners() {
        // ç™¼é€æŒ‰éˆ•é»æ“Š
        this.sendButton.addEventListener('click', () => {
            this.sendMessage();
        });
        
        // åœæ­¢æŒ‰éˆ•é»æ“Š
        this.stopButton.addEventListener('click', () => {
            this.stopStreaming();
        });
        
        // è¼¸å…¥æ¡†äº‹ä»¶
        this.messageInput.addEventListener('input', (e) => {
            this.updateCharCount();
            this.autoResize(e.target);
        });
        
        // å¿«æ·éµæ”¯æ´
        this.messageInput.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                this.sendMessage();
            }
        });
        
        // é˜²æ­¢é é¢é—œé–‰æ™‚é€£ç·šæœªé—œé–‰ï¼ˆé¿å…è³‡æºæ´©æ¼ï¼‰
        window.addEventListener('beforeunload', () => {
            this.cleanup();
        });
    }
    
    /**
     * ç™¼é€è¨Šæ¯
     */
    async sendMessage() {
        const message = this.messageInput.value.trim();
        if (!message || this.isStreaming) return;
        
        try {
            // é¡¯ç¤ºä½¿ç”¨è€…è¨Šæ¯
            this.addMessage('user', message);
            
            // æ¸…ç©ºè¼¸å…¥æ¡†
            this.messageInput.value = '';
            this.updateCharCount();
            this.autoResize(this.messageInput);
            
            // é–‹å§‹æµå¼æ¥æ”¶
            await this.startStreaming(message);
            
        } catch (error) {
            console.error('ç™¼é€è¨Šæ¯å¤±æ•—:', error);
            this.addMessage('system', 'âŒ ç™¼é€å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦');
        }
    }
    
    /**
     * é–‹å§‹æµå¼æ¥æ”¶
     */
    async startStreaming(message) {
        this.isStreaming = true;
        this.updateUI(true);
        this.updateConnectionStatus('connecting', 'é€£ç·šä¸­...');
        
        // å»ºç«‹ AI è¨Šæ¯å®¹å™¨
        this.currentMessageElement = this.addMessage('ai', '', true);
        
        // å»ºç«‹ EventSource é€£ç·š
        const encodedMessage = encodeURIComponent(message);
        const url = `/api/ai/chat/stream?prompt=${encodedMessage}`;
        
        this.eventSource = new EventSource(url);
        
        // è¨­å®šäº‹ä»¶ç›£è½å™¨
        this.setupEventSourceListeners();
    }
    
    /**
     * è¨­å®š EventSource äº‹ä»¶ç›£è½å™¨
     */
    setupEventSourceListeners() {
        // æ¥æ”¶è¨Šæ¯
        this.eventSource.onmessage = (event) => {
            const content = event.data;
            if (content && content.trim() !== '') {
                this.appendToCurrentMessage(content);
            }
        };
        
        // é€£ç·šé–‹å•Ÿ
        this.eventSource.onopen = () => {
            console.log('EventSource é€£ç·šå·²å»ºç«‹');
            this.updateConnectionStatus('connected', 'å·²é€£ç·š');
        };
        
        // é€£ç·šéŒ¯èª¤
        this.eventSource.onerror = (event) => {
            console.error('EventSource éŒ¯èª¤:', event);
            
            if (event.target.readyState === EventSource.CLOSED) {
                console.log('EventSource é€£ç·šå·²é—œé–‰');
                this.handleStreamComplete();
            } else {
                this.updateConnectionStatus('error', 'é€£ç·šéŒ¯èª¤');
                this.addMessage('system', 'âŒ é€£ç·šç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹é‡æ–°å˜—è©¦');
                this.stopStreaming();
            }
        };
        
        // è‡ªå®šç¾©äº‹ä»¶ï¼šæµå¼å®Œæˆ
        this.eventSource.addEventListener('complete', () => {
            console.log('æµå¼è¼¸å‡ºå®Œæˆ');
            this.handleStreamComplete();
        });
    }
    
    /**
     * åœæ­¢æµå¼æ¥æ”¶
     */
    stopStreaming() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
        
        this.handleStreamComplete();
    }
    
    /**
     * è™•ç†æµå¼å®Œæˆ
     */
    handleStreamComplete() {
        this.isStreaming = false;
        this.updateUI(false);
        this.updateConnectionStatus('ready', 'å°±ç·’');
        
        // ç§»é™¤æ‰“å­—æŒ‡ç¤ºå™¨
        if (this.currentMessageElement) {
            const typingIndicator = this.currentMessageElement.querySelector('.typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }
        
        this.currentMessageElement = null;
    }
    
    /**
     * æ·»åŠ è¨Šæ¯åˆ°èŠå¤©å€åŸŸ
     */
    addMessage(type, content, isStreaming = false) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        
        if (isStreaming) {
            // æ·»åŠ æ‰“å­—æŒ‡ç¤ºå™¨
            contentDiv.innerHTML = `
                <span class="typing-indicator"></span>
                <span class="typing-indicator"></span>
                <span class="typing-indicator"></span>
            `;
        } else {
            contentDiv.textContent = content;
        }
        
        const timeDiv = document.createElement('div');
        timeDiv.className = 'message-time';
        timeDiv.textContent = this.formatTime(new Date());
        
        messageDiv.appendChild(contentDiv);
        messageDiv.appendChild(timeDiv);
        
        this.messagesContainer.appendChild(messageDiv);
        this.scrollToBottom();
        
        return contentDiv;
    }
    
    /**
     * è¿½åŠ å…§å®¹åˆ°ç•¶å‰è¨Šæ¯
     */
    appendToCurrentMessage(content) {
        if (!this.currentMessageElement) return;
        
        // ç§»é™¤æ‰“å­—æŒ‡ç¤ºå™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        const typingIndicators = this.currentMessageElement.querySelectorAll('.typing-indicator');
        typingIndicators.forEach(indicator => indicator.remove());
        
        // ä½¿ç”¨ createTextNode ä»¥é¿å… XSS æ”»æ“Šä¸¦æå‡æ•ˆèƒ½
        const textNode = document.createTextNode(content);
        this.currentMessageElement.appendChild(textNode);
        
        // æ»¾å‹•åˆ°åº•éƒ¨
        this.scrollToBottom();
    }
    
    /**
     * æ›´æ–° UI ç‹€æ…‹
     */
    updateUI(isStreaming) {
        this.sendButton.style.display = isStreaming ? 'none' : 'flex';
        this.stopButton.style.display = isStreaming ? 'flex' : 'none';
        this.messageInput.disabled = isStreaming;
        
        if (isStreaming) {
            this.messageInput.placeholder = 'AI æ­£åœ¨å›æ‡‰ä¸­...';
        } else {
            this.messageInput.placeholder = 'è¼¸å…¥æ‚¨çš„å•é¡Œ...';
        }
    }
    
    /**
     * æ›´æ–°é€£ç·šç‹€æ…‹
     */
    updateConnectionStatus(status, text) {
        const indicator = this.connectionStatus.querySelector('.status-indicator');
        const statusText = this.connectionStatus.querySelector('.status-text');
        
        // ç§»é™¤æ‰€æœ‰ç‹€æ…‹é¡åˆ¥
        indicator.className = 'status-indicator';
        
        // æ·»åŠ å°æ‡‰ç‹€æ…‹é¡åˆ¥
        if (status !== 'ready') {
            indicator.classList.add(status);
        }
        
        statusText.textContent = text;
    }
    
    /**
     * æ›´æ–°å­—å…ƒè¨ˆæ•¸
     */
    updateCharCount() {
        const count = this.messageInput.value.length;
        const maxLength = this.messageInput.maxLength;
        this.charCount.textContent = `${count}/${maxLength}`;
        
        // æ¥è¿‘ä¸Šé™æ™‚è®Šè‰²è­¦å‘Š
        if (count > maxLength * 0.9) {
            this.charCount.style.color = '#ef4444';
        } else {
            this.charCount.style.color = '#64748b';
        }
    }
    
    /**
     * è‡ªå‹•èª¿æ•´è¼¸å…¥æ¡†é«˜åº¦
     */
    autoResize(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }
    
    /**
     * æ»¾å‹•åˆ°åº•éƒ¨
     */
    scrollToBottom() {
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }
    
    /**
     * æ ¼å¼åŒ–æ™‚é–“
     */
    formatTime(date) {
        const now = new Date();
        const diff = now - date;
        
        if (diff < 60000) { // 1åˆ†é˜å…§
            return 'å‰›å‰›';
        } else if (diff < 3600000) { // 1å°æ™‚å…§
            return `${Math.floor(diff / 60000)} åˆ†é˜å‰`;
        } else if (date.toDateString() === now.toDateString()) { // ä»Šå¤©
            return date.toLocaleTimeString('zh-TW', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
        } else { // å…¶ä»–æ—¥æœŸ
            return date.toLocaleDateString('zh-TW', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }
    }
    
    /**
     * æ¸…ç†è³‡æº
     */
    cleanup() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
    }
}

// åˆå§‹åŒ–èŠå¤©æ‡‰ç”¨
document.addEventListener('DOMContentLoaded', () => {
    const chat = new StreamingChat();
    
    // å…¨åŸŸéŒ¯èª¤è™•ç†
    window.addEventListener('error', (event) => {
        console.error('å…¨åŸŸéŒ¯èª¤:', event.error);
    });
    
    // å…¨åŸŸæœªè™•ç†çš„ Promise æ‹’çµ•
    window.addEventListener('unhandledrejection', (event) => {
        console.error('æœªè™•ç†çš„ Promise æ‹’çµ•:', event.reason);
    });
});
```

---

## 4.5.4 é€²éšåŠŸèƒ½å¯¦ç¾

### è¨Šæ¯æ­·å²ç®¡ç†

```javascript
/**
 * è¨Šæ¯æ­·å²ç®¡ç†å™¨
 */
class MessageHistory {
    constructor(maxSize = 100) {
        this.messages = [];
        this.maxSize = maxSize;
        this.currentIndex = -1;
        
        this.loadFromStorage();
    }
    
    /**
     * æ·»åŠ è¨Šæ¯åˆ°æ­·å²
     */
    add(message) {
        // é¿å…é‡è¤‡æ·»åŠ ç›¸åŒè¨Šæ¯
        if (this.messages[this.messages.length - 1] !== message) {
            this.messages.push(message);
            
            // é™åˆ¶æ­·å²å¤§å°
            if (this.messages.length > this.maxSize) {
                this.messages.shift();
            }
            
            this.currentIndex = this.messages.length;
            this.saveToStorage();
        }
    }
    
    /**
     * ç²å–ä¸Šä¸€æ¢è¨Šæ¯
     */
    getPrevious() {
        if (this.currentIndex > 0) {
            this.currentIndex--;
            return this.messages[this.currentIndex];
        }
        return null;
    }
    
    /**
     * ç²å–ä¸‹ä¸€æ¢è¨Šæ¯
     */
    getNext() {
        if (this.currentIndex < this.messages.length - 1) {
            this.currentIndex++;
            return this.messages[this.currentIndex];
        } else if (this.currentIndex === this.messages.length - 1) {
            this.currentIndex = this.messages.length;
            return '';
        }
        return null;
    }
    
    /**
     * é‡ç½®ç´¢å¼•
     */
    resetIndex() {
        this.currentIndex = this.messages.length;
    }
    
    /**
     * å„²å­˜åˆ°æœ¬åœ°å­˜å„²
     */
    saveToStorage() {
        try {
            localStorage.setItem('chatHistory', JSON.stringify(this.messages));
        } catch (error) {
            console.warn('ç„¡æ³•å„²å­˜èŠå¤©æ­·å²:', error);
        }
    }
    
    /**
     * å¾æœ¬åœ°å­˜å„²è¼‰å…¥
     */
    loadFromStorage() {
        try {
            const stored = localStorage.getItem('chatHistory');
            if (stored) {
                this.messages = JSON.parse(stored);
                this.currentIndex = this.messages.length;
            }
        } catch (error) {
            console.warn('ç„¡æ³•è¼‰å…¥èŠå¤©æ­·å²:', error);
            this.messages = [];
        }
    }
    
    /**
     * æ¸…é™¤æ­·å²
     */
    clear() {
        this.messages = [];
        this.currentIndex = -1;
        localStorage.removeItem('chatHistory');
    }
}
```

### æ‰“å­—æ•ˆæœå¢å¼·

```javascript
/**
 * æ‰“å­—æ•ˆæœç®¡ç†å™¨
 */
class TypingEffect {
    constructor(element, speed = 50) {
        this.element = element;
        this.speed = speed;
        this.isTyping = false;
        this.queue = [];
    }
    
    /**
     * æ·»åŠ æ–‡å­—åˆ°æ‰“å­—ä½‡åˆ—
     */
    addText(text) {
        this.queue.push(text);
        if (!this.isTyping) {
            this.processQueue();
        }
    }
    
    /**
     * è™•ç†æ‰“å­—ä½‡åˆ—
     */
    async processQueue() {
        this.isTyping = true;
        
        while (this.queue.length > 0) {
            const text = this.queue.shift();
            await this.typeText(text);
        }
        
        this.isTyping = false;
    }
    
    /**
     * æ‰“å­—æ•ˆæœ
     */
    async typeText(text) {
        for (let i = 0; i < text.length; i++) {
            this.element.textContent += text[i];
            
            // æ»¾å‹•åˆ°åº•éƒ¨
            this.element.scrollIntoView({ behavior: 'smooth', block: 'end' });
            
            // ç­‰å¾…
            await this.delay(this.speed);
        }
    }
    
    /**
     * å»¶é²å‡½æ•¸
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    /**
     * åœæ­¢æ‰“å­—æ•ˆæœ
     */
    stop() {
        this.queue = [];
        this.isTyping = false;
    }
}
```

### é‡é€£æ©Ÿåˆ¶

```javascript
/**
 * è‡ªå‹•é‡é€£ç®¡ç†å™¨
 */
class ReconnectionManager {
    constructor(maxRetries = 3, baseDelay = 1000) {
        this.maxRetries = maxRetries;
        this.baseDelay = baseDelay;
        this.retryCount = 0;
        this.isReconnecting = false;
    }
    
    /**
     * å˜—è©¦é‡é€£
     */
    async attemptReconnection(reconnectFunction) {
        if (this.isReconnecting || this.retryCount >= this.maxRetries) {
            return false;
        }
        
        this.isReconnecting = true;
        
        try {
            // æŒ‡æ•¸é€€é¿å»¶é² + éš¨æ©ŸæŠ–å‹•ï¼ˆé¿å…é›·æ“Šæ•ˆæ‡‰ï¼‰
            const jitter = Math.random() * 0.1 + 0.95; // 0.95-1.05
            const delay = this.baseDelay * Math.pow(2, this.retryCount) * jitter;
            console.log(`å˜—è©¦é‡é€£ (${this.retryCount + 1}/${this.maxRetries})ï¼Œå»¶é² ${Math.round(delay)}ms`);
            
            await this.delay(delay);
            
            // åŸ·è¡Œé‡é€£å‡½æ•¸
            await reconnectFunction();
            
            // é‡é€£æˆåŠŸï¼Œé‡ç½®è¨ˆæ•¸å™¨
            this.retryCount = 0;
            this.isReconnecting = false;
            
            console.log('é‡é€£æˆåŠŸ');
            return true;
            
        } catch (error) {
            this.retryCount++;
            this.isReconnecting = false;
            
            console.error(`é‡é€£å¤±æ•— (${this.retryCount}/${this.maxRetries}):`, error);
            
            if (this.retryCount >= this.maxRetries) {
                console.error('å·²é”åˆ°æœ€å¤§é‡é€£æ¬¡æ•¸ï¼Œåœæ­¢é‡é€£');
                return false;
            }
            
            // éè¿´é‡è©¦
            return this.attemptReconnection(reconnectFunction);
        }
    }
    
    /**
     * é‡ç½®é‡é€£è¨ˆæ•¸å™¨
     */
    reset() {
        this.retryCount = 0;
        this.isReconnecting = false;
    }
    
    /**
     * å»¶é²å‡½æ•¸
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
```

---

## 4.5.5 React æ•´åˆç¯„ä¾‹

### React Hook å¯¦ç¾

```jsx
import React, { useState, useEffect, useRef, useCallback } from 'react';

/**
 * æµå¼èŠå¤© Hook
 */
function useStreamingChat() {
    const [messages, setMessages] = useState([]);
    const [isStreaming, setIsStreaming] = useState(false);
    const [connectionStatus, setConnectionStatus] = useState('ready');
    const eventSourceRef = useRef(null);
    const currentMessageRef = useRef('');
    
    /**
     * ç™¼é€è¨Šæ¯
     */
    const sendMessage = useCallback(async (message, systemPrompt = null) => {
        if (!message.trim() || isStreaming) return;
        
        // æ·»åŠ ä½¿ç”¨è€…è¨Šæ¯
        const userMessage = {
            id: Date.now(),
            type: 'user',
            content: message,
            timestamp: new Date()
        };
        
        setMessages(prev => [...prev, userMessage]);
        setIsStreaming(true);
        setConnectionStatus('connecting');
        
        // æº–å‚™ AI è¨Šæ¯
        const aiMessage = {
            id: Date.now() + 1,
            type: 'ai',
            content: '',
            timestamp: new Date(),
            isStreaming: true
        };
        
        setMessages(prev => [...prev, aiMessage]);
        currentMessageRef.current = '';
        
        try {
            // å»ºç«‹ EventSource
            let url = `/api/ai/chat/stream?prompt=${encodeURIComponent(message)}`;
            if (systemPrompt) {
                url += `&system=${encodeURIComponent(systemPrompt)}`;
            }
            
            eventSourceRef.current = new EventSource(url);
            
            // è¨­å®šäº‹ä»¶ç›£è½å™¨
            eventSourceRef.current.onmessage = (event) => {
                const content = event.data;
                if (content) {
                    currentMessageRef.current += content;
                    
                    setMessages(prev => 
                        prev.map(msg => 
                            msg.id === aiMessage.id 
                                ? { ...msg, content: currentMessageRef.current }
                                : msg
                        )
                    );
                }
            };
            
            eventSourceRef.current.onopen = () => {
                setConnectionStatus('connected');
            };
            
            eventSourceRef.current.onerror = (error) => {
                console.error('EventSource éŒ¯èª¤:', error);
                handleStreamComplete();
                
                if (eventSourceRef.current?.readyState === EventSource.CLOSED) {
                    setConnectionStatus('ready');
                } else {
                    setConnectionStatus('error');
                }
            };
            
        } catch (error) {
            console.error('ç™¼é€è¨Šæ¯å¤±æ•—:', error);
            handleStreamComplete();
            setConnectionStatus('error');
        }
    }, [isStreaming]);
    
    /**
     * åœæ­¢æµå¼æ¥æ”¶
     */
    const stopStreaming = useCallback(() => {
        if (eventSourceRef.current) {
            eventSourceRef.current.close();
            eventSourceRef.current = null;
        }
        handleStreamComplete();
    }, []);
    
    /**
     * è™•ç†æµå¼å®Œæˆ
     */
    const handleStreamComplete = useCallback(() => {
        setIsStreaming(false);
        setConnectionStatus('ready');
        
        // æ›´æ–°æœ€å¾Œä¸€æ¢ AI è¨Šæ¯ç‹€æ…‹
        setMessages(prev => 
            prev.map(msg => 
                msg.isStreaming 
                    ? { ...msg, isStreaming: false }
                    : msg
            )
        );
    }, []);
    
    /**
     * æ¸…é™¤èŠå¤©è¨˜éŒ„
     */
    const clearMessages = useCallback(() => {
        setMessages([]);
        stopStreaming();
    }, [stopStreaming]);
    
    // æ¸…ç†æ•ˆæœ
    useEffect(() => {
        return () => {
            if (eventSourceRef.current) {
                eventSourceRef.current.close();
                eventSourceRef.current = null;
            }
        };
    }, []);
    
    return {
        messages,
        isStreaming,
        connectionStatus,
        sendMessage,
        stopStreaming,
        clearMessages
    };
}

/**
 * æµå¼èŠå¤©çµ„ä»¶
 */
function StreamingChatComponent() {
    const {
        messages,
        isStreaming,
        connectionStatus,
        sendMessage,
        stopStreaming,
        clearMessages
    } = useStreamingChat();
    
    const [inputMessage, setInputMessage] = useState('');
    const messagesEndRef = useRef(null);
    
    // è‡ªå‹•æ»¾å‹•åˆ°åº•éƒ¨
    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);
    
    const handleSend = () => {
        if (inputMessage.trim()) {
            sendMessage(inputMessage);
            setInputMessage('');
        }
    };
    
    const handleKeyPress = (e) => {
        if (e.key === 'Enter' && e.ctrlKey) {
            handleSend();
        }
    };
    
    return (
        <div className="streaming-chat">
            {/* èŠå¤©æ¨™é¡Œ */}
            <div className="chat-header">
                <h1>ğŸ¤– AI åŠ©æ‰‹</h1>
                <div className="connection-status">
                    <span className={`status-indicator ${connectionStatus}`}></span>
                    <span>{getStatusText(connectionStatus)}</span>
                </div>
            </div>
            
            {/* è¨Šæ¯åˆ—è¡¨ */}
            <div className="messages-container">
                {messages.map((message) => (
                    <MessageComponent key={message.id} message={message} />
                ))}
                <div ref={messagesEndRef} />
            </div>
            
            {/* è¼¸å…¥å€åŸŸ */}
            <div className="input-container">
                <textarea
                    value={inputMessage}
                    onChange={(e) => setInputMessage(e.target.value)}
                    onKeyPress={handleKeyPress}
                    placeholder={isStreaming ? 'AI æ­£åœ¨å›æ‡‰ä¸­...' : 'è¼¸å…¥æ‚¨çš„å•é¡Œ...'}
                    disabled={isStreaming}
                    rows={1}
                />
                
                {isStreaming ? (
                    <button onClick={stopStreaming} className="stop-button">
                        â¹ï¸ åœæ­¢
                    </button>
                ) : (
                    <button 
                        onClick={handleSend} 
                        disabled={!inputMessage.trim()}
                        className="send-button"
                    >
                        ğŸ“¤ ç™¼é€
                    </button>
                )}
                
                <button onClick={clearMessages} className="clear-button">
                    ğŸ—‘ï¸ æ¸…é™¤
                </button>
            </div>
        </div>
    );
}

/**
 * è¨Šæ¯çµ„ä»¶
 */
function MessageComponent({ message }) {
    return (
        <div className={`message ${message.type}`}>
            <div className="message-content">
                {message.isStreaming && !message.content ? (
                    <TypingIndicator />
                ) : (
                    <MessageContent content={message.content} />
                )}
            </div>
            <div className="message-time">
                {formatTime(message.timestamp)}
            </div>
        </div>
    );
}

/**
 * æ‰“å­—æŒ‡ç¤ºå™¨çµ„ä»¶
 */
function TypingIndicator() {
    return (
        <div className="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
        </div>
    );
}

/**
 * è¨Šæ¯å…§å®¹çµ„ä»¶ï¼ˆæ”¯æ´ Markdownï¼‰
 */
function MessageContent({ content }) {
    // é€™è£¡å¯ä»¥æ•´åˆ Markdown æ¸²æŸ“å™¨
    return <div className="content">{content}</div>;
}

/**
 * ç²å–ç‹€æ…‹æ–‡å­—
 */
function getStatusText(status) {
    switch (status) {
        case 'connecting': return 'é€£ç·šä¸­...';
        case 'connected': return 'å·²é€£ç·š';
        case 'error': return 'é€£ç·šéŒ¯èª¤';
        default: return 'å°±ç·’';
    }
}

/**
 * æ ¼å¼åŒ–æ™‚é–“
 */
function formatTime(date) {
    return date.toLocaleTimeString('zh-TW', {
        hour: '2-digit',
        minute: '2-digit'
    });
}

export default StreamingChatComponent;
```

---

## 4.5.6 æ•ˆèƒ½å„ªåŒ–èˆ‡æœ€ä½³å¯¦è¸

### è¨˜æ†¶é«”ç®¡ç†

```javascript
/**
 * è¨˜æ†¶é«”å„ªåŒ–çš„èŠå¤©ç®¡ç†å™¨
 */
class OptimizedChatManager {
    constructor(maxMessages = 50) {
        this.maxMessages = maxMessages;
        this.messages = [];
        this.observers = new Set();
    }
    
    /**
     * æ·»åŠ è¨Šæ¯ï¼ˆè‡ªå‹•æ¸…ç†èˆŠè¨Šæ¯ï¼‰
     */
    addMessage(message) {
        this.messages.push(message);
        
        // é™åˆ¶è¨Šæ¯æ•¸é‡ï¼Œé¿å…è¨˜æ†¶é«”æ´©æ¼
        if (this.messages.length > this.maxMessages) {
            const removed = this.messages.splice(0, this.messages.length - this.maxMessages);
            
            // æ¸…ç† DOM å…ƒç´ 
            removed.forEach(msg => {
                if (msg.element && msg.element.parentNode) {
                    msg.element.parentNode.removeChild(msg.element);
                }
            });
        }
        
        this.notifyObservers('messageAdded', message);
    }
    
    /**
     * è¨‚é–±è®Šæ›´é€šçŸ¥
     */
    subscribe(callback) {
        this.observers.add(callback);
        
        // è¿”å›å–æ¶ˆè¨‚é–±å‡½æ•¸
        return () => {
            this.observers.delete(callback);
        };
    }
    
    /**
     * é€šçŸ¥è§€å¯Ÿè€…
     */
    notifyObservers(event, data) {
        this.observers.forEach(callback => {
            try {
                callback(event, data);
            } catch (error) {
                console.error('è§€å¯Ÿè€…å›èª¿éŒ¯èª¤:', error);
            }
        });
    }
    
    /**
     * æ¸…ç†è³‡æº
     */
    cleanup() {
        this.messages = [];
        this.observers.clear();
    }
}
```

### ç¯€æµèˆ‡é˜²æŠ–

```javascript
/**
 * å·¥å…·å‡½æ•¸ï¼šç¯€æµ
 */
function throttle(func, limit) {
    let inThrottle;
    return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

/**
 * å·¥å…·å‡½æ•¸ï¼šé˜²æŠ–
 */
function debounce(func, wait, immediate) {
    let timeout;
    return function() {
        const context = this;
        const args = arguments;
        const later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
}

// ä½¿ç”¨ç¯„ä¾‹
const throttledScrollHandler = throttle(() => {
    // è™•ç†æ»¾å‹•äº‹ä»¶
}, 100);

const debouncedInputHandler = debounce((value) => {
    // è™•ç†è¼¸å…¥è®Šæ›´
}, 300);
```

### éŒ¯èª¤é‚Šç•Œè™•ç†

```javascript
/**
 * éŒ¯èª¤é‚Šç•Œç®¡ç†å™¨
 */
class ErrorBoundary {
    constructor() {
        this.errorHandlers = new Map();
        this.setupGlobalErrorHandling();
    }
    
    /**
     * è¨­å®šå…¨åŸŸéŒ¯èª¤è™•ç†
     */
    setupGlobalErrorHandling() {
        // æ•ç² JavaScript éŒ¯èª¤
        window.addEventListener('error', (event) => {
            this.handleError('javascript', event.error, {
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        });
        
        // æ•ç² Promise æ‹’çµ•
        window.addEventListener('unhandledrejection', (event) => {
            this.handleError('promise', event.reason);
        });
        
        // æ•ç² EventSource éŒ¯èª¤
        this.registerErrorHandler('eventsource', (error, context) => {
            console.error('EventSource éŒ¯èª¤:', error);
            
            // å˜—è©¦é‡é€£
            if (context && context.reconnect) {
                setTimeout(() => {
                    context.reconnect();
                }, 5000);
            }
        });
    }
    
    /**
     * è¨»å†ŠéŒ¯èª¤è™•ç†å™¨
     */
    registerErrorHandler(type, handler) {
        this.errorHandlers.set(type, handler);
    }
    
    /**
     * è™•ç†éŒ¯èª¤
     */
    handleError(type, error, context = null) {
        const handler = this.errorHandlers.get(type);
        if (handler) {
            handler(error, context);
        } else {
            console.error(`æœªè™•ç†çš„ ${type} éŒ¯èª¤:`, error);
        }
    }
}

// å…¨åŸŸéŒ¯èª¤é‚Šç•Œå¯¦ä¾‹
const errorBoundary = new ErrorBoundary();
```

---

## ğŸ“ æœ¬ç« é‡é»å›é¡§

1. **EventSource API æŒæ¡**ï¼šå­¸æœƒäº†ä½¿ç”¨ç€è¦½å™¨åŸç”Ÿçš„ SSE æŠ€è¡“æ¥æ”¶æµå¼è³‡æ–™
2. **æµå¼ UI å¯¦ç¾**ï¼šå»ºç«‹äº†å®Œæ•´çš„èŠå¤©ä»‹é¢ï¼ŒåŒ…å«å³æ™‚æ›´æ–°å’Œäº’å‹•æ•ˆæœ
3. **é€£ç·šç®¡ç†**ï¼šæŒæ¡äº†é€£ç·šå»ºç«‹ã€ç¶­è­·ã€éŒ¯èª¤è™•ç†å’Œè‡ªå‹•é‡é€£æ©Ÿåˆ¶
4. **ä½¿ç”¨è€…é«”é©—å„ªåŒ–**ï¼šå¯¦ç¾äº†æ‰“å­—æ•ˆæœã€è¼‰å…¥ç‹€æ…‹ã€æ­·å²ç®¡ç†ç­‰ç´°ç¯€
5. **ç¾ä»£æ¡†æ¶æ•´åˆ**ï¼šå­¸æœƒäº†åœ¨ React ç­‰æ¡†æ¶ä¸­æ•´åˆæµå¼åŠŸèƒ½

### æŠ€è¡“è¦é»ç¸½çµ

| æŠ€è¡“é» | é‡è¦æ€§ | å¯¦ç¾é›£åº¦ | ä½¿ç”¨å ´æ™¯ |
|--------|--------|----------|----------|
| **EventSource API** | â­â­â­ | ä½ | æ‰€æœ‰æµå¼æ‡‰ç”¨ |
| **é€£ç·šç®¡ç†** | â­â­â­ | ä¸­ | ç”Ÿç”¢ç’°å¢ƒå¿…éœ€ |
| **éŒ¯èª¤è™•ç†** | â­â­â­ | ä¸­ | ç©©å®šæ€§ä¿è­‰ |
| **UI å³æ™‚æ›´æ–°** | â­â­ | ä½ | ä½¿ç”¨è€…é«”é©— |
| **è¨˜æ†¶é«”å„ªåŒ–** | â­â­ | ä¸­ | é•·æ™‚é–“ä½¿ç”¨ |
| **è‡ªå‹•é‡é€£** | â­â­ | é«˜ | ç¶²è·¯ä¸ç©©å®šç’°å¢ƒ |

### æœ€ä½³å¯¦è¸å»ºè­°

1. **å§‹çµ‚è™•ç†éŒ¯èª¤**ï¼šEventSource é€£ç·šå¯èƒ½å› å„ç¨®åŸå› ä¸­æ–·
2. **é™åˆ¶è¨Šæ¯æ•¸é‡**ï¼šé¿å…é•·æ™‚é–“ä½¿ç”¨é€ æˆçš„è¨˜æ†¶é«”æ´©æ¼
3. **æä¾›ä½¿ç”¨è€…æ§åˆ¶**ï¼šå…è¨±ä½¿ç”¨è€…åœæ­¢æµå¼æ¥æ”¶
4. **å„ªé›…é™ç´š**ï¼šåœ¨ä¸æ”¯æ´ SSE çš„ç’°å¢ƒä¸­æä¾›æ›¿ä»£æ–¹æ¡ˆ
5. **æ•ˆèƒ½ç›£æ§**ï¼šç›£æ§é€£ç·šç‹€æ…‹å’Œè³‡æºä½¿ç”¨æƒ…æ³
6. **å®‰å…¨æ€§è€ƒé‡**ï¼šä½¿ç”¨ createTextNode é¿å… XSS æ”»æ“Š
7. **é‡é€£å„ªåŒ–**ï¼šåŠ å…¥éš¨æ©ŸæŠ–å‹•é¿å…é›·æ“Šæ•ˆæ‡‰
8. **è³‡æºæ¸…ç†**ï¼šç¢ºä¿çµ„ä»¶å¸è¼‰æ™‚æ­£ç¢ºé—œé–‰é€£ç·š

### ä¸‹ä¸€æ­¥å­¸ç¿’æ–¹å‘

å®Œæˆç¬¬å››ç« çš„å­¸ç¿’å¾Œï¼Œæˆ‘å€‘å·²ç¶“æŒæ¡äº† Spring AI çš„åŸºç¤çŸ¥è­˜å’Œæµå¼è¼¸å‡ºæŠ€è¡“ã€‚åœ¨ç¬¬äº”ç« ä¸­ï¼Œæˆ‘å€‘å°‡é€²å…¥æ›´é€²éšçš„ä¸»é¡Œï¼Œå­¸ç¿’å¦‚ä½•å»ºç«‹å€‹æ€§åŒ–çš„ ChatBotï¼ŒåŒ…æ‹¬æç¤ºè©ç¯„æœ¬ã€å¤šæ¨¡æ…‹è™•ç†ç­‰é«˜ç´šåŠŸèƒ½ã€‚

---

## ğŸ”§ æœ¬ç« ç¨‹å¼ç¢¼å„ªåŒ–æ‘˜è¦

æœ¬ç« å¯¦ç¾çš„ç¨‹å¼ç¢¼å·²æ ¹æ“šæœ€ä½³å¯¦è¸é€²è¡Œäº†ä»¥ä¸‹é—œéµå„ªåŒ–ï¼š

### å®‰å…¨æ€§å¢å¼·
- âœ… ä½¿ç”¨ `createTextNode` æ›¿ä»£ `textContent +=` é˜²æ­¢ XSS æ”»æ“Š
- âœ… é©ç•¶çš„è¼¸å…¥é©—è­‰å’Œæ¸…ç†æ©Ÿåˆ¶

### æ•ˆèƒ½å„ªåŒ–
- âœ… é‡é€£æ©Ÿåˆ¶åŠ å…¥éš¨æ©ŸæŠ–å‹•é¿å…é›·æ“Šæ•ˆæ‡‰
- âœ… React Hook ä¸­æ­£ç¢ºè¨­ç½® ref ç‚º null é˜²æ­¢è¨˜æ†¶é«”æ´©æ¼
- âœ… è¨Šæ¯æ•¸é‡é™åˆ¶å’ŒèˆŠè¨Šæ¯è‡ªå‹•æ¸…ç†

### ç©©å®šæ€§æå‡
- âœ… å®Œå–„çš„éŒ¯èª¤é‚Šç•Œè™•ç†
- âœ… è³‡æºæ¸…ç†å’Œé€£ç·šé—œé–‰æ©Ÿåˆ¶
- âœ… é˜²æŠ–ç¯€æµæ©Ÿåˆ¶é¿å…éåº¦è«‹æ±‚

é€™äº›å„ªåŒ–ç¢ºä¿äº†ä»£ç¢¼åœ¨ç”Ÿç”¢ç’°å¢ƒä¸­çš„ç©©å®šæ€§ã€å®‰å…¨æ€§å’Œæ•ˆèƒ½è¡¨ç¾ã€‚

---

**åƒè€ƒè³‡æ–™ï¼š**
- [Server-Sent Events - MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)
- [EventSource API - MDN](https://developer.mozilla.org/en-US/docs/Web/API/EventSource)
- [React Hooks Documentation](https://reactjs.org/docs/hooks-intro.html)
- [Web Performance Best Practices](https://web.dev/performance/)
# 4.5 前端該如何處理流式輸出

> **本章重點**：深入探討前端如何優雅地處理 AI 流式輸出，建立完整的前後端整合方案，為使用者提供如同 ChatGPT 般的流暢互動體驗。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握 EventSource API**：熟練使用瀏覽器原生的 SSE 接收技術
- 🎯 **實現流式 UI 更新**：建立即時更新的聊天介面
- 🎯 **處理連線管理**：掌握連線建立、維護和錯誤處理
- 🎯 **優化使用者體驗**：實現打字效果、載入狀態等互動細節
- 🎯 **整合現代前端框架**：在 React、Vue 等框架中實現流式功能

---

## 4.5.1 EventSource API 基礎

### 什麼是 Server-Sent Events (SSE)？

Server-Sent Events 是 HTML5 標準的一部分，允許伺服器向瀏覽器推送資料。與 WebSocket 不同，SSE 是單向的（僅伺服器到客戶端），但對於 AI 流式輸出來說已經足夠。

**SSE vs WebSocket vs 輪詢**：

| 特性 | SSE | WebSocket | 輪詢 |
|------|-----|-----------|------|
| **複雜度** | 低 | 中 | 低 |
| **即時性** | 高 | 高 | 低 |
| **資源消耗** | 低 | 中 | 高 |
| **瀏覽器支援** | 廣泛 | 廣泛 | 全部 |
| **自動重連** | 是 | 否 | 否 |
| **適用場景** | 單向推送 | 雙向通訊 | 簡單查詢 |

### EventSource 基本用法

```javascript
/**
 * 基本的 EventSource 使用範例
 */
function basicEventSourceExample() {
    // 建立 EventSource 連線
    const eventSource = new EventSource('/api/ai/chat/stream?prompt=Hello');
    
    // 監聽訊息事件
    eventSource.onmessage = function(event) {
        console.log('收到資料:', event.data);
    };
    
    // 監聽開啟事件
    eventSource.onopen = function(event) {
        console.log('連線已建立');
    };
    
    // 監聽錯誤事件
    eventSource.onerror = function(event) {
        console.error('連線錯誤:', event);
        
        // 根據錯誤狀態決定是否重連
        if (event.target.readyState === EventSource.CLOSED) {
            console.log('連線已關閉');
        }
    };
    
    // 手動關閉連線
    setTimeout(() => {
        eventSource.close();
        console.log('連線已手動關閉');
    }, 30000); // 30秒後關閉
}
```

### EventSource 狀態管理

```javascript
/**
 * EventSource 狀態常數
 */
const SSE_STATE = {
    CONNECTING: 0,  // 正在連線
    OPEN: 1,        // 連線已開啟
    CLOSED: 2       // 連線已關閉
};

/**
 * 監控 EventSource 狀態
 */
function monitorEventSourceState(eventSource) {
    const checkState = () => {
        switch (eventSource.readyState) {
            case SSE_STATE.CONNECTING:
                console.log('狀態：正在連線...');
                break;
            case SSE_STATE.OPEN:
                console.log('狀態：連線已開啟');
                break;
            case SSE_STATE.CLOSED:
                console.log('狀態：連線已關閉');
                break;
        }
    };
    
    // 定期檢查狀態
    const stateChecker = setInterval(checkState, 1000);
    
    // 連線關閉時停止檢查
    eventSource.addEventListener('close', () => {
        clearInterval(stateChecker);
    });
}
```

---

## 4.5.2 建立流式聊天介面

### HTML 結構設計

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 流式聊天</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="chat-container">
        <!-- 聊天標題 -->
        <div class="chat-header">
            <h1>🤖 AI 助手</h1>
            <div class="connection-status" id="connectionStatus">
                <span class="status-indicator"></span>
                <span class="status-text">就緒</span>
            </div>
        </div>
        
        <!-- 聊天訊息區域 -->
        <div class="chat-messages" id="chatMessages">
            <div class="message system">
                <div class="message-content">
                    👋 您好！我是 AI 助手，有什麼可以幫助您的嗎？
                </div>
                <div class="message-time">剛剛</div>
            </div>
        </div>
        
        <!-- 輸入區域 -->
        <div class="chat-input">
            <div class="input-container">
                <textarea 
                    id="messageInput" 
                    placeholder="輸入您的問題..." 
                    rows="1"
                    maxlength="2000"></textarea>
                <button id="sendButton" class="send-button">
                    <span class="send-icon">📤</span>
                    <span class="send-text">發送</span>
                </button>
                <button id="stopButton" class="stop-button" style="display: none;">
                    <span class="stop-icon">⏹️</span>
                    <span class="stop-text">停止</span>
                </button>
            </div>
            <div class="input-info">
                <span id="charCount">0/2000</span>
                <span class="tips">按 Ctrl+Enter 快速發送</span>
            </div>
        </div>
    </div>
    
    <script src="chat.js"></script>
</body>
</html>
```

### CSS 樣式設計

```css
/* styles.css */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

.chat-container {
    width: 90%;
    max-width: 800px;
    height: 90vh;
    background: white;
    border-radius: 20px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* 聊天標題 */
.chat-header {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.chat-header h1 {
    font-size: 1.5rem;
    font-weight: 600;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
}

.status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #4ade80;
    animation: pulse 2s infinite;
}

.status-indicator.connecting {
    background: #fbbf24;
}

.status-indicator.error {
    background: #ef4444;
    animation: none;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

/* 聊天訊息區域 */
.chat-messages {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    scroll-behavior: smooth;
}

.message {
    margin-bottom: 20px;
    display: flex;
    flex-direction: column;
}

.message.user {
    align-items: flex-end;
}

.message.ai {
    align-items: flex-start;
}

.message.system {
    align-items: center;
}

.message-content {
    max-width: 80%;
    padding: 12px 16px;
    border-radius: 18px;
    line-height: 1.5;
    word-wrap: break-word;
    position: relative;
}

.message.user .message-content {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
    border-bottom-right-radius: 4px;
}

.message.ai .message-content {
    background: #f1f5f9;
    color: #334155;
    border-bottom-left-radius: 4px;
    border: 1px solid #e2e8f0;
}

.message.system .message-content {
    background: #fef3c7;
    color: #92400e;
    border: 1px solid #fcd34d;
    font-size: 0.9rem;
}

.message-time {
    font-size: 0.75rem;
    color: #64748b;
    margin-top: 4px;
    padding: 0 8px;
}

/* 打字效果 */
.typing-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #64748b;
    animation: typing 1.4s infinite ease-in-out;
    margin-left: 2px;
}

.typing-indicator:nth-child(1) { animation-delay: -0.32s; }
.typing-indicator:nth-child(2) { animation-delay: -0.16s; }

@keyframes typing {
    0%, 80%, 100% {
        transform: scale(0);
        opacity: 0.5;
    }
    40% {
        transform: scale(1);
        opacity: 1;
    }
}

/* 輸入區域 */
.chat-input {
    padding: 20px;
    background: #f8fafc;
    border-top: 1px solid #e2e8f0;
}

.input-container {
    display: flex;
    gap: 12px;
    align-items: flex-end;
}

#messageInput {
    flex: 1;
    padding: 12px 16px;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    font-size: 1rem;
    line-height: 1.5;
    resize: none;
    outline: none;
    transition: all 0.2s ease;
    max-height: 120px;
}

#messageInput:focus {
    border-color: #4facfe;
    box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
}

.send-button, .stop-button {
    padding: 12px 20px;
    border: none;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 100px;
    justify-content: center;
}

.send-button {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
}

.send-button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(79, 172, 254, 0.3);
}

.send-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
}

.stop-button {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    color: white;
}

.stop-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(239, 68, 68, 0.3);
}

.input-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
    font-size: 0.8rem;
    color: #64748b;
}

.tips {
    font-style: italic;
}

/* 響應式設計 */
@media (max-width: 768px) {
    .chat-container {
        width: 100%;
        height: 100vh;
        border-radius: 0;
    }
    
    .message-content {
        max-width: 90%;
    }
    
    .input-container {
        flex-direction: column;
    }
    
    .send-button, .stop-button {
        width: 100%;
    }
}
```

---

## 4.5.3 JavaScript 流式聊天實現

### 核心聊天類別

```javascript
// chat.js

/**
 * 流式聊天管理類別
 */
class StreamingChat {
    constructor() {
        this.eventSource = null;
        this.isStreaming = false;
        this.currentMessageElement = null;
        
        // DOM 元素
        this.messagesContainer = document.getElementById('chatMessages');
        this.messageInput = document.getElementById('messageInput');
        this.sendButton = document.getElementById('sendButton');
        this.stopButton = document.getElementById('stopButton');
        this.connectionStatus = document.getElementById('connectionStatus');
        this.charCount = document.getElementById('charCount');
        
        this.initializeEventListeners();
        this.updateConnectionStatus('ready', '就緒');
    }
    
    /**
     * 初始化事件監聽器
     */
    initializeEventListeners() {
        // 發送按鈕點擊
        this.sendButton.addEventListener('click', () => {
            this.sendMessage();
        });
        
        // 停止按鈕點擊
        this.stopButton.addEventListener('click', () => {
            this.stopStreaming();
        });
        
        // 輸入框事件
        this.messageInput.addEventListener('input', (e) => {
            this.updateCharCount();
            this.autoResize(e.target);
        });
        
        // 快捷鍵支援
        this.messageInput.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                this.sendMessage();
            }
        });
        
        // 防止頁面關閉時連線未關閉（避免資源洩漏）
        window.addEventListener('beforeunload', () => {
            this.cleanup();
        });
    }
    
    /**
     * 發送訊息
     */
    async sendMessage() {
        const message = this.messageInput.value.trim();
        if (!message || this.isStreaming) return;
        
        try {
            // 顯示使用者訊息
            this.addMessage('user', message);
            
            // 清空輸入框
            this.messageInput.value = '';
            this.updateCharCount();
            this.autoResize(this.messageInput);
            
            // 開始流式接收
            await this.startStreaming(message);
            
        } catch (error) {
            console.error('發送訊息失敗:', error);
            this.addMessage('system', '❌ 發送失敗，請稍後再試');
        }
    }
    
    /**
     * 開始流式接收
     */
    async startStreaming(message) {
        this.isStreaming = true;
        this.updateUI(true);
        this.updateConnectionStatus('connecting', '連線中...');
        
        // 建立 AI 訊息容器
        this.currentMessageElement = this.addMessage('ai', '', true);
        
        // 建立 EventSource 連線
        const encodedMessage = encodeURIComponent(message);
        const url = `/api/ai/chat/stream?prompt=${encodedMessage}`;
        
        this.eventSource = new EventSource(url);
        
        // 設定事件監聽器
        this.setupEventSourceListeners();
    }
    
    /**
     * 設定 EventSource 事件監聽器
     */
    setupEventSourceListeners() {
        // 接收訊息
        this.eventSource.onmessage = (event) => {
            const content = event.data;
            if (content && content.trim() !== '') {
                this.appendToCurrentMessage(content);
            }
        };
        
        // 連線開啟
        this.eventSource.onopen = () => {
            console.log('EventSource 連線已建立');
            this.updateConnectionStatus('connected', '已連線');
        };
        
        // 連線錯誤
        this.eventSource.onerror = (event) => {
            console.error('EventSource 錯誤:', event);
            
            if (event.target.readyState === EventSource.CLOSED) {
                console.log('EventSource 連線已關閉');
                this.handleStreamComplete();
            } else {
                this.updateConnectionStatus('error', '連線錯誤');
                this.addMessage('system', '❌ 連線發生錯誤，請重新嘗試');
                this.stopStreaming();
            }
        };
        
        // 自定義事件：流式完成
        this.eventSource.addEventListener('complete', () => {
            console.log('流式輸出完成');
            this.handleStreamComplete();
        });
    }
    
    /**
     * 停止流式接收
     */
    stopStreaming() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
        
        this.handleStreamComplete();
    }
    
    /**
     * 處理流式完成
     */
    handleStreamComplete() {
        this.isStreaming = false;
        this.updateUI(false);
        this.updateConnectionStatus('ready', '就緒');
        
        // 移除打字指示器
        if (this.currentMessageElement) {
            const typingIndicator = this.currentMessageElement.querySelector('.typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }
        
        this.currentMessageElement = null;
    }
    
    /**
     * 添加訊息到聊天區域
     */
    addMessage(type, content, isStreaming = false) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        
        if (isStreaming) {
            // 添加打字指示器
            contentDiv.innerHTML = `
                <span class="typing-indicator"></span>
                <span class="typing-indicator"></span>
                <span class="typing-indicator"></span>
            `;
        } else {
            contentDiv.textContent = content;
        }
        
        const timeDiv = document.createElement('div');
        timeDiv.className = 'message-time';
        timeDiv.textContent = this.formatTime(new Date());
        
        messageDiv.appendChild(contentDiv);
        messageDiv.appendChild(timeDiv);
        
        this.messagesContainer.appendChild(messageDiv);
        this.scrollToBottom();
        
        return contentDiv;
    }
    
    /**
     * 追加內容到當前訊息
     */
    appendToCurrentMessage(content) {
        if (!this.currentMessageElement) return;
        
        // 移除打字指示器（如果存在）
        const typingIndicators = this.currentMessageElement.querySelectorAll('.typing-indicator');
        typingIndicators.forEach(indicator => indicator.remove());
        
        // 使用 createTextNode 以避免 XSS 攻擊並提升效能
        const textNode = document.createTextNode(content);
        this.currentMessageElement.appendChild(textNode);
        
        // 滾動到底部
        this.scrollToBottom();
    }
    
    /**
     * 更新 UI 狀態
     */
    updateUI(isStreaming) {
        this.sendButton.style.display = isStreaming ? 'none' : 'flex';
        this.stopButton.style.display = isStreaming ? 'flex' : 'none';
        this.messageInput.disabled = isStreaming;
        
        if (isStreaming) {
            this.messageInput.placeholder = 'AI 正在回應中...';
        } else {
            this.messageInput.placeholder = '輸入您的問題...';
        }
    }
    
    /**
     * 更新連線狀態
     */
    updateConnectionStatus(status, text) {
        const indicator = this.connectionStatus.querySelector('.status-indicator');
        const statusText = this.connectionStatus.querySelector('.status-text');
        
        // 移除所有狀態類別
        indicator.className = 'status-indicator';
        
        // 添加對應狀態類別
        if (status !== 'ready') {
            indicator.classList.add(status);
        }
        
        statusText.textContent = text;
    }
    
    /**
     * 更新字元計數
     */
    updateCharCount() {
        const count = this.messageInput.value.length;
        const maxLength = this.messageInput.maxLength;
        this.charCount.textContent = `${count}/${maxLength}`;
        
        // 接近上限時變色警告
        if (count > maxLength * 0.9) {
            this.charCount.style.color = '#ef4444';
        } else {
            this.charCount.style.color = '#64748b';
        }
    }
    
    /**
     * 自動調整輸入框高度
     */
    autoResize(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }
    
    /**
     * 滾動到底部
     */
    scrollToBottom() {
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }
    
    /**
     * 格式化時間
     */
    formatTime(date) {
        const now = new Date();
        const diff = now - date;
        
        if (diff < 60000) { // 1分鐘內
            return '剛剛';
        } else if (diff < 3600000) { // 1小時內
            return `${Math.floor(diff / 60000)} 分鐘前`;
        } else if (date.toDateString() === now.toDateString()) { // 今天
            return date.toLocaleTimeString('zh-TW', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
        } else { // 其他日期
            return date.toLocaleDateString('zh-TW', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }
    }
    
    /**
     * 清理資源
     */
    cleanup() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
    }
}

// 初始化聊天應用
document.addEventListener('DOMContentLoaded', () => {
    const chat = new StreamingChat();
    
    // 全域錯誤處理
    window.addEventListener('error', (event) => {
        console.error('全域錯誤:', event.error);
    });
    
    // 全域未處理的 Promise 拒絕
    window.addEventListener('unhandledrejection', (event) => {
        console.error('未處理的 Promise 拒絕:', event.reason);
    });
});
```

---

## 4.5.4 進階功能實現

### 訊息歷史管理

```javascript
/**
 * 訊息歷史管理器
 */
class MessageHistory {
    constructor(maxSize = 100) {
        this.messages = [];
        this.maxSize = maxSize;
        this.currentIndex = -1;
        
        this.loadFromStorage();
    }
    
    /**
     * 添加訊息到歷史
     */
    add(message) {
        // 避免重複添加相同訊息
        if (this.messages[this.messages.length - 1] !== message) {
            this.messages.push(message);
            
            // 限制歷史大小
            if (this.messages.length > this.maxSize) {
                this.messages.shift();
            }
            
            this.currentIndex = this.messages.length;
            this.saveToStorage();
        }
    }
    
    /**
     * 獲取上一條訊息
     */
    getPrevious() {
        if (this.currentIndex > 0) {
            this.currentIndex--;
            return this.messages[this.currentIndex];
        }
        return null;
    }
    
    /**
     * 獲取下一條訊息
     */
    getNext() {
        if (this.currentIndex < this.messages.length - 1) {
            this.currentIndex++;
            return this.messages[this.currentIndex];
        } else if (this.currentIndex === this.messages.length - 1) {
            this.currentIndex = this.messages.length;
            return '';
        }
        return null;
    }
    
    /**
     * 重置索引
     */
    resetIndex() {
        this.currentIndex = this.messages.length;
    }
    
    /**
     * 儲存到本地存儲
     */
    saveToStorage() {
        try {
            localStorage.setItem('chatHistory', JSON.stringify(this.messages));
        } catch (error) {
            console.warn('無法儲存聊天歷史:', error);
        }
    }
    
    /**
     * 從本地存儲載入
     */
    loadFromStorage() {
        try {
            const stored = localStorage.getItem('chatHistory');
            if (stored) {
                this.messages = JSON.parse(stored);
                this.currentIndex = this.messages.length;
            }
        } catch (error) {
            console.warn('無法載入聊天歷史:', error);
            this.messages = [];
        }
    }
    
    /**
     * 清除歷史
     */
    clear() {
        this.messages = [];
        this.currentIndex = -1;
        localStorage.removeItem('chatHistory');
    }
}
```

### 打字效果增強

```javascript
/**
 * 打字效果管理器
 */
class TypingEffect {
    constructor(element, speed = 50) {
        this.element = element;
        this.speed = speed;
        this.isTyping = false;
        this.queue = [];
    }
    
    /**
     * 添加文字到打字佇列
     */
    addText(text) {
        this.queue.push(text);
        if (!this.isTyping) {
            this.processQueue();
        }
    }
    
    /**
     * 處理打字佇列
     */
    async processQueue() {
        this.isTyping = true;
        
        while (this.queue.length > 0) {
            const text = this.queue.shift();
            await this.typeText(text);
        }
        
        this.isTyping = false;
    }
    
    /**
     * 打字效果
     */
    async typeText(text) {
        for (let i = 0; i < text.length; i++) {
            this.element.textContent += text[i];
            
            // 滾動到底部
            this.element.scrollIntoView({ behavior: 'smooth', block: 'end' });
            
            // 等待
            await this.delay(this.speed);
        }
    }
    
    /**
     * 延遲函數
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    /**
     * 停止打字效果
     */
    stop() {
        this.queue = [];
        this.isTyping = false;
    }
}
```

### 重連機制

```javascript
/**
 * 自動重連管理器
 */
class ReconnectionManager {
    constructor(maxRetries = 3, baseDelay = 1000) {
        this.maxRetries = maxRetries;
        this.baseDelay = baseDelay;
        this.retryCount = 0;
        this.isReconnecting = false;
    }
    
    /**
     * 嘗試重連
     */
    async attemptReconnection(reconnectFunction) {
        if (this.isReconnecting || this.retryCount >= this.maxRetries) {
            return false;
        }
        
        this.isReconnecting = true;
        
        try {
            // 指數退避延遲 + 隨機抖動（避免雷擊效應）
            const jitter = Math.random() * 0.1 + 0.95; // 0.95-1.05
            const delay = this.baseDelay * Math.pow(2, this.retryCount) * jitter;
            console.log(`嘗試重連 (${this.retryCount + 1}/${this.maxRetries})，延遲 ${Math.round(delay)}ms`);
            
            await this.delay(delay);
            
            // 執行重連函數
            await reconnectFunction();
            
            // 重連成功，重置計數器
            this.retryCount = 0;
            this.isReconnecting = false;
            
            console.log('重連成功');
            return true;
            
        } catch (error) {
            this.retryCount++;
            this.isReconnecting = false;
            
            console.error(`重連失敗 (${this.retryCount}/${this.maxRetries}):`, error);
            
            if (this.retryCount >= this.maxRetries) {
                console.error('已達到最大重連次數，停止重連');
                return false;
            }
            
            // 遞迴重試
            return this.attemptReconnection(reconnectFunction);
        }
    }
    
    /**
     * 重置重連計數器
     */
    reset() {
        this.retryCount = 0;
        this.isReconnecting = false;
    }
    
    /**
     * 延遲函數
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
```

---

## 4.5.5 React 整合範例

### React Hook 實現

```jsx
import React, { useState, useEffect, useRef, useCallback } from 'react';

/**
 * 流式聊天 Hook
 */
function useStreamingChat() {
    const [messages, setMessages] = useState([]);
    const [isStreaming, setIsStreaming] = useState(false);
    const [connectionStatus, setConnectionStatus] = useState('ready');
    const eventSourceRef = useRef(null);
    const currentMessageRef = useRef('');
    
    /**
     * 發送訊息
     */
    const sendMessage = useCallback(async (message, systemPrompt = null) => {
        if (!message.trim() || isStreaming) return;
        
        // 添加使用者訊息
        const userMessage = {
            id: Date.now(),
            type: 'user',
            content: message,
            timestamp: new Date()
        };
        
        setMessages(prev => [...prev, userMessage]);
        setIsStreaming(true);
        setConnectionStatus('connecting');
        
        // 準備 AI 訊息
        const aiMessage = {
            id: Date.now() + 1,
            type: 'ai',
            content: '',
            timestamp: new Date(),
            isStreaming: true
        };
        
        setMessages(prev => [...prev, aiMessage]);
        currentMessageRef.current = '';
        
        try {
            // 建立 EventSource
            let url = `/api/ai/chat/stream?prompt=${encodeURIComponent(message)}`;
            if (systemPrompt) {
                url += `&system=${encodeURIComponent(systemPrompt)}`;
            }
            
            eventSourceRef.current = new EventSource(url);
            
            // 設定事件監聽器
            eventSourceRef.current.onmessage = (event) => {
                const content = event.data;
                if (content) {
                    currentMessageRef.current += content;
                    
                    setMessages(prev => 
                        prev.map(msg => 
                            msg.id === aiMessage.id 
                                ? { ...msg, content: currentMessageRef.current }
                                : msg
                        )
                    );
                }
            };
            
            eventSourceRef.current.onopen = () => {
                setConnectionStatus('connected');
            };
            
            eventSourceRef.current.onerror = (error) => {
                console.error('EventSource 錯誤:', error);
                handleStreamComplete();
                
                if (eventSourceRef.current?.readyState === EventSource.CLOSED) {
                    setConnectionStatus('ready');
                } else {
                    setConnectionStatus('error');
                }
            };
            
        } catch (error) {
            console.error('發送訊息失敗:', error);
            handleStreamComplete();
            setConnectionStatus('error');
        }
    }, [isStreaming]);
    
    /**
     * 停止流式接收
     */
    const stopStreaming = useCallback(() => {
        if (eventSourceRef.current) {
            eventSourceRef.current.close();
            eventSourceRef.current = null;
        }
        handleStreamComplete();
    }, []);
    
    /**
     * 處理流式完成
     */
    const handleStreamComplete = useCallback(() => {
        setIsStreaming(false);
        setConnectionStatus('ready');
        
        // 更新最後一條 AI 訊息狀態
        setMessages(prev => 
            prev.map(msg => 
                msg.isStreaming 
                    ? { ...msg, isStreaming: false }
                    : msg
            )
        );
    }, []);
    
    /**
     * 清除聊天記錄
     */
    const clearMessages = useCallback(() => {
        setMessages([]);
        stopStreaming();
    }, [stopStreaming]);
    
    // 清理效果
    useEffect(() => {
        return () => {
            if (eventSourceRef.current) {
                eventSourceRef.current.close();
                eventSourceRef.current = null;
            }
        };
    }, []);
    
    return {
        messages,
        isStreaming,
        connectionStatus,
        sendMessage,
        stopStreaming,
        clearMessages
    };
}

/**
 * 流式聊天組件
 */
function StreamingChatComponent() {
    const {
        messages,
        isStreaming,
        connectionStatus,
        sendMessage,
        stopStreaming,
        clearMessages
    } = useStreamingChat();
    
    const [inputMessage, setInputMessage] = useState('');
    const messagesEndRef = useRef(null);
    
    // 自動滾動到底部
    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);
    
    const handleSend = () => {
        if (inputMessage.trim()) {
            sendMessage(inputMessage);
            setInputMessage('');
        }
    };
    
    const handleKeyPress = (e) => {
        if (e.key === 'Enter' && e.ctrlKey) {
            handleSend();
        }
    };
    
    return (
        <div className="streaming-chat">
            {/* 聊天標題 */}
            <div className="chat-header">
                <h1>🤖 AI 助手</h1>
                <div className="connection-status">
                    <span className={`status-indicator ${connectionStatus}`}></span>
                    <span>{getStatusText(connectionStatus)}</span>
                </div>
            </div>
            
            {/* 訊息列表 */}
            <div className="messages-container">
                {messages.map((message) => (
                    <MessageComponent key={message.id} message={message} />
                ))}
                <div ref={messagesEndRef} />
            </div>
            
            {/* 輸入區域 */}
            <div className="input-container">
                <textarea
                    value={inputMessage}
                    onChange={(e) => setInputMessage(e.target.value)}
                    onKeyPress={handleKeyPress}
                    placeholder={isStreaming ? 'AI 正在回應中...' : '輸入您的問題...'}
                    disabled={isStreaming}
                    rows={1}
                />
                
                {isStreaming ? (
                    <button onClick={stopStreaming} className="stop-button">
                        ⏹️ 停止
                    </button>
                ) : (
                    <button 
                        onClick={handleSend} 
                        disabled={!inputMessage.trim()}
                        className="send-button"
                    >
                        📤 發送
                    </button>
                )}
                
                <button onClick={clearMessages} className="clear-button">
                    🗑️ 清除
                </button>
            </div>
        </div>
    );
}

/**
 * 訊息組件
 */
function MessageComponent({ message }) {
    return (
        <div className={`message ${message.type}`}>
            <div className="message-content">
                {message.isStreaming && !message.content ? (
                    <TypingIndicator />
                ) : (
                    <MessageContent content={message.content} />
                )}
            </div>
            <div className="message-time">
                {formatTime(message.timestamp)}
            </div>
        </div>
    );
}

/**
 * 打字指示器組件
 */
function TypingIndicator() {
    return (
        <div className="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
        </div>
    );
}

/**
 * 訊息內容組件（支援 Markdown）
 */
function MessageContent({ content }) {
    // 這裡可以整合 Markdown 渲染器
    return <div className="content">{content}</div>;
}

/**
 * 獲取狀態文字
 */
function getStatusText(status) {
    switch (status) {
        case 'connecting': return '連線中...';
        case 'connected': return '已連線';
        case 'error': return '連線錯誤';
        default: return '就緒';
    }
}

/**
 * 格式化時間
 */
function formatTime(date) {
    return date.toLocaleTimeString('zh-TW', {
        hour: '2-digit',
        minute: '2-digit'
    });
}

export default StreamingChatComponent;
```

---

## 4.5.6 效能優化與最佳實踐

### 記憶體管理

```javascript
/**
 * 記憶體優化的聊天管理器
 */
class OptimizedChatManager {
    constructor(maxMessages = 50) {
        this.maxMessages = maxMessages;
        this.messages = [];
        this.observers = new Set();
    }
    
    /**
     * 添加訊息（自動清理舊訊息）
     */
    addMessage(message) {
        this.messages.push(message);
        
        // 限制訊息數量，避免記憶體洩漏
        if (this.messages.length > this.maxMessages) {
            const removed = this.messages.splice(0, this.messages.length - this.maxMessages);
            
            // 清理 DOM 元素
            removed.forEach(msg => {
                if (msg.element && msg.element.parentNode) {
                    msg.element.parentNode.removeChild(msg.element);
                }
            });
        }
        
        this.notifyObservers('messageAdded', message);
    }
    
    /**
     * 訂閱變更通知
     */
    subscribe(callback) {
        this.observers.add(callback);
        
        // 返回取消訂閱函數
        return () => {
            this.observers.delete(callback);
        };
    }
    
    /**
     * 通知觀察者
     */
    notifyObservers(event, data) {
        this.observers.forEach(callback => {
            try {
                callback(event, data);
            } catch (error) {
                console.error('觀察者回調錯誤:', error);
            }
        });
    }
    
    /**
     * 清理資源
     */
    cleanup() {
        this.messages = [];
        this.observers.clear();
    }
}
```

### 節流與防抖

```javascript
/**
 * 工具函數：節流
 */
function throttle(func, limit) {
    let inThrottle;
    return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

/**
 * 工具函數：防抖
 */
function debounce(func, wait, immediate) {
    let timeout;
    return function() {
        const context = this;
        const args = arguments;
        const later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
}

// 使用範例
const throttledScrollHandler = throttle(() => {
    // 處理滾動事件
}, 100);

const debouncedInputHandler = debounce((value) => {
    // 處理輸入變更
}, 300);
```

### 錯誤邊界處理

```javascript
/**
 * 錯誤邊界管理器
 */
class ErrorBoundary {
    constructor() {
        this.errorHandlers = new Map();
        this.setupGlobalErrorHandling();
    }
    
    /**
     * 設定全域錯誤處理
     */
    setupGlobalErrorHandling() {
        // 捕獲 JavaScript 錯誤
        window.addEventListener('error', (event) => {
            this.handleError('javascript', event.error, {
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        });
        
        // 捕獲 Promise 拒絕
        window.addEventListener('unhandledrejection', (event) => {
            this.handleError('promise', event.reason);
        });
        
        // 捕獲 EventSource 錯誤
        this.registerErrorHandler('eventsource', (error, context) => {
            console.error('EventSource 錯誤:', error);
            
            // 嘗試重連
            if (context && context.reconnect) {
                setTimeout(() => {
                    context.reconnect();
                }, 5000);
            }
        });
    }
    
    /**
     * 註冊錯誤處理器
     */
    registerErrorHandler(type, handler) {
        this.errorHandlers.set(type, handler);
    }
    
    /**
     * 處理錯誤
     */
    handleError(type, error, context = null) {
        const handler = this.errorHandlers.get(type);
        if (handler) {
            handler(error, context);
        } else {
            console.error(`未處理的 ${type} 錯誤:`, error);
        }
    }
}

// 全域錯誤邊界實例
const errorBoundary = new ErrorBoundary();
```

---

## 📝 本章重點回顧

1. **EventSource API 掌握**：學會了使用瀏覽器原生的 SSE 技術接收流式資料
2. **流式 UI 實現**：建立了完整的聊天介面，包含即時更新和互動效果
3. **連線管理**：掌握了連線建立、維護、錯誤處理和自動重連機制
4. **使用者體驗優化**：實現了打字效果、載入狀態、歷史管理等細節
5. **現代框架整合**：學會了在 React 等框架中整合流式功能

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **EventSource API** | ⭐⭐⭐ | 低 | 所有流式應用 |
| **連線管理** | ⭐⭐⭐ | 中 | 生產環境必需 |
| **錯誤處理** | ⭐⭐⭐ | 中 | 穩定性保證 |
| **UI 即時更新** | ⭐⭐ | 低 | 使用者體驗 |
| **記憶體優化** | ⭐⭐ | 中 | 長時間使用 |
| **自動重連** | ⭐⭐ | 高 | 網路不穩定環境 |

### 最佳實踐建議

1. **始終處理錯誤**：EventSource 連線可能因各種原因中斷
2. **限制訊息數量**：避免長時間使用造成的記憶體洩漏
3. **提供使用者控制**：允許使用者停止流式接收
4. **優雅降級**：在不支援 SSE 的環境中提供替代方案
5. **效能監控**：監控連線狀態和資源使用情況
6. **安全性考量**：使用 createTextNode 避免 XSS 攻擊
7. **重連優化**：加入隨機抖動避免雷擊效應
8. **資源清理**：確保組件卸載時正確關閉連線

### 下一步學習方向

完成第四章的學習後，我們已經掌握了 Spring AI 的基礎知識和流式輸出技術。在第五章中，我們將進入更進階的主題，學習如何建立個性化的 ChatBot，包括提示詞範本、多模態處理等高級功能。

---

## 🔧 本章程式碼優化摘要

本章實現的程式碼已根據最佳實踐進行了以下關鍵優化：

### 安全性增強
- ✅ 使用 `createTextNode` 替代 `textContent +=` 防止 XSS 攻擊
- ✅ 適當的輸入驗證和清理機制

### 效能優化
- ✅ 重連機制加入隨機抖動避免雷擊效應
- ✅ React Hook 中正確設置 ref 為 null 防止記憶體洩漏
- ✅ 訊息數量限制和舊訊息自動清理

### 穩定性提升
- ✅ 完善的錯誤邊界處理
- ✅ 資源清理和連線關閉機制
- ✅ 防抖節流機制避免過度請求

這些優化確保了代碼在生產環境中的穩定性、安全性和效能表現。

---

**參考資料：**
- [Server-Sent Events - MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)
- [EventSource API - MDN](https://developer.mozilla.org/en-US/docs/Web/API/EventSource)
- [React Hooks Documentation](https://reactjs.org/docs/hooks-intro.html)
- [Web Performance Best Practices](https://web.dev/performance/)
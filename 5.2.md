# 5.2 如何跟 ChatGPT 一樣處理多模態資料

> **本章重點**：學習使用 Spring AI 處理多模態資料，讓 AI 不僅能理解文字，還能分析圖片、音訊、影片等多種媒體格式，實現如同 ChatGPT 般的多模態互動體驗。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解多模態概念**：掌握多模態 AI 的核心原理和應用場景
- 🎯 **選擇合適的 AI 模型**：了解各種 AI 模型的多模態能力和限制
- 🎯 **實現圖片分析功能**：建立圖片上傳和分析的完整功能
- 🎯 **處理多種媒體格式**：支援圖片、音訊、影片等多種媒體類型
- 🎯 **優化多模態應用**：掌握效能優化和錯誤處理的最佳實踐

---

## 5.2.1 什麼是多模態 AI？

### 多模態就是同時提供兩種以上資料源

![多模態 AI](https://ithelp.ithome.com.tw/upload/images/20240810/201612905TZ6mYSAy1.jpg)

**多模態（Multimodality）** 是指 AI 系統能夠同時處理和理解多種不同類型的資料輸入，如文字、圖片、音訊、影片等。這種能力讓 AI 更接近人類的感知方式，能夠綜合多種感官資訊來理解和回應。

### Spring AI 中的多模態架構

還記得 Message 這張 UML 圖片嗎？在 UserMessage 中其實是可以包含多媒體檔案的：

![Spring AI Message 架構](https://ithelp.ithome.com.tw/upload/images/20240806/2016129049tSDbXBcM.jpg)

**重要說明**：雖然 UserMessage 類別支援直接傳入 Media 物件，但在實際開發中，**建議使用 ChatClient 的 fluent API**，因為它提供了更好的開發體驗和錯誤處理。

```java
// Spring AI 的多模態實現方式 - 使用 ChatClient fluent API
String response = chatClient.prompt()
    .user(u -> u.text("請分析這張圖片的內容")  // 文字部分
        .media(MimeTypeUtils.IMAGE_JPEG, imageResource))   // 圖片
    .call()
    .content();

// 也可以添加多個媒體檔案
String response = chatClient.prompt()
    .user(u -> u.text("請分析這些檔案")
        .media(MimeTypeUtils.IMAGE_JPEG, imageResource)
        .media(MimeTypeUtils.parseMediaType("audio/mp3"), audioResource))
    .call()
    .content();

// 💡 最佳實踐：建議將 Resource 和 MimeType 分開宣告，便於錯誤處理
Resource imageResource = new ClassPathResource("image.jpg");
MimeType mimeType = MimeTypeUtils.IMAGE_JPEG;

String response = chatClient.prompt()
    .user(u -> u.text("分析這張圖片")
        .media(mimeType, imageResource))
    .call()
    .content();
```

### 多模態的核心價值

**1. 更豐富的互動體驗**
- 📸 **視覺理解**：分析圖片內容、識別物體、理解場景
- 🎵 **聽覺處理**：語音轉文字、音樂分析、聲音識別
- 🎬 **影片分析**：動作識別、場景理解、內容摘要
- 📄 **文件處理**：OCR 文字識別、表格分析、版面理解

**2. 更準確的理解能力**
- 🔍 **上下文增強**：結合多種資訊源提供更準確的分析
- 🧠 **語義理解**：透過視覺和文字的結合提升理解深度
- 🎯 **精確回應**：基於多模態資訊提供更精確的答案

**3. 更廣泛的應用場景**
- 🏥 **醫療診斷**：結合影像和病歷資料進行輔助診斷
- 🛒 **電商應用**：商品圖片分析和推薦
- 📚 **教育培訓**：多媒體教材的智能分析和問答
- 🏭 **工業檢測**：設備圖片分析和故障診斷

---

## 5.2.2 支援多模態的 AI 模型

### 主流模型能力對比

目前有支援多模態的模型如下，其他模型送出多媒體檔案時可是會出現錯誤的：

| 模型提供商 | 模型名稱 | 圖像 | 音頻 | 視頻 | 文件 | 成本效益 | 推薦場景 |
|-----------|---------|------|------|------|------|----------|----------|
| **OpenAI** | GPT-4o | ✅ | ✅ | ✅ | ✅ | 高 | 全方位多模態應用 |
| **OpenAI** | GPT-4o mini | ✅ | ❌ | ❌ | ✅ | 極高 | 圖片分析、文件處理 |
| **OpenAI** | GPT-4 Vision | ✅ | ❌ | ❌ | ✅ | 中 | 圖片分析專用 |
| **Anthropic** | Claude 3.5 Sonnet | ✅ | ❌ | ❌ | ✅ | 高 | 圖片+文字分析 |
| **Anthropic** | Claude 3 Opus | ✅ | ❌ | ❌ | ✅ | 中 | 複雜圖片理解 |
| **Google** | Gemini 1.5 Pro | ✅ | ✅ | ✅ | ✅ | 中 | 多媒體內容分析 |
| **Google** | Gemini Pro Vision | ✅ | ❌ | ❌ | ✅ | 高 | 圖片識別 |
| **Ollama** | LlaVa | ✅ | ❌ | ❌ | ❌ | 極高(本地) | 本地圖片分析 |
| **Ollama** | Bakllava | ✅ | ❌ | ❌ | ❌ | 極高(本地) | 本地多模態 |

### 輸入輸出格式支援表

| Input | Output | Examples | 適用場景 |
|-------|--------|----------|----------|
| **Language/Code/Images** | Language/Code | GPT-4o, Gemini 1.5 Pro | 多模態問答、程式碼分析 |
| **Language/Code** | Language/Code | GPT-3.5, Claude 3 Haiku | 純文字對話 |
| **Language** | Image | DALL-E 3, Midjourney | 文字生成圖片 |
| **Language/Image** | Image | Stable Diffusion | 圖片編輯、風格轉換 |
| **Language** | Audio | OpenAI TTS, ElevenLabs | 文字轉語音 |
| **Audio** | Language | OpenAI Whisper | 語音轉文字 |
| **Text** | Numbers | Embedding Models | 向量化、相似度計算 |

### 模型選擇建議

```java
@Configuration
public class MultimodalModelConfig {
    
    @Value("${spring.ai.openai.api-key}")
    private String openaiApiKey;
    
    /**
     * 根據使用場景選擇合適的模型
     */
    @Bean
    @Primary
    public ChatModel primaryMultimodalModel() {
        // GPT-4o mini：性價比最高的圖片分析模型
        return OpenAiChatModel.builder()
            .apiKey(openaiApiKey)
            .modelName("gpt-4o-mini")
            .temperature(0.3)  // 較低溫度確保分析準確性
            .maxTokens(1500)
            .build();
    }
    
    /**
     * 高精度圖片分析模型
     */
    @Bean("highAccuracyModel")
    public ChatModel highAccuracyModel() {
        // GPT-4o：最強多模態能力
        return OpenAiChatModel.builder()
            .apiKey(openaiApiKey)
            .modelName("gpt-4o")
            .temperature(0.2)
            .maxTokens(2000)
            .build();
    }
    
    /**
     * 本地多模態模型（節省成本）
     */
    @Bean("localModel")
    @ConditionalOnProperty(name = "app.ai.local.enabled", havingValue = "true")
    public ChatModel localMultimodalModel() {
        // Ollama LlaVa：本地免費方案
        return OllamaChatModel.builder()
            .baseUrl("http://localhost:11434")
            .model("llava")
            .build();
    }
}
```

---

## 5.2.3 圖片分析功能實現

### 基礎圖片上傳和分析

```java
package com.example.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.core.io.Resource;
import org.springframework.http.MediaType;
import org.springframework.util.MimeType;
import org.springframework.util.MimeTypeUtils;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

@RestController
@RequestMapping("/api/multimodal")
@RequiredArgsConstructor
@Slf4j
public class MultimodalController {
    
    private final ChatClient chatClient;
    
    /**
     * 基礎圖片分析
     * @param file 上傳的圖片檔案
     * @param message 分析要求
     * @return AI 分析結果
     */
    @PostMapping(value = "/image-analysis", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public String analyzeImage(
            @RequestParam("file") MultipartFile file,
            @RequestParam("message") String message) {
        
        try {
            // 驗證檔案類型
            if (!isValidImageFile(file)) {
                return "❌ 不支援的圖片格式，請上傳 JPG、PNG、GIF 或 WebP 格式的圖片";
            }
            
            // 驗證檔案大小（限制 10MB）
            if (file.getSize() > 10 * 1024 * 1024) {
                return "❌ 圖片檔案過大，請上傳小於 10MB 的圖片";
            }
            
            log.info("開始分析圖片：{}，大小：{} bytes", file.getOriginalFilename(), file.getSize());
            
            // 創建 Spring Resource
            Resource imageResource = file.getResource();
            MimeType mimeType = MimeTypeUtils.parseMimeType(file.getContentType());
            
            // 使用 ChatClient 進行圖片分析
            String response = chatClient.prompt()
                    .user(u -> u.text(message)
                            .media(mimeType, imageResource))
                    .call()
                    .content();
            
            log.info("圖片分析完成");
            return response;
            
        } catch (IOException e) {
            log.error("圖片處理失敗", e);
            return "❌ 圖片處理失敗：" + e.getMessage();
        } catch (Exception e) {
            log.error("AI 分析失敗", e);
            return "❌ AI 分析失敗，請稍後再試：" + e.getMessage();
        }
    }
    
    /**
     * 驗證圖片檔案格式
     */
    private boolean isValidImageFile(MultipartFile file) {
        String contentType = file.getContentType();
        return contentType != null && (
            contentType.equals("image/jpeg") ||
            contentType.equals("image/png") ||
            contentType.equals("image/gif") ||
            contentType.equals("image/webp")
        );
    }
}
```

### 進階圖片分析功能

```java
@RestController
@RequestMapping("/api/advanced-multimodal")
@RequiredArgsConstructor
public class AdvancedMultimodalController {
    
    private final ChatClient chatClient;
    
    /**
     * 結構化圖片分析
     * @param file 圖片檔案
     * @param analysisType 分析類型
     * @return 結構化分析結果
     */
    @PostMapping("/structured-analysis")
    public ImageAnalysisResult structuredImageAnalysis(
            @RequestParam("file") MultipartFile file,
            @RequestParam("type") AnalysisType analysisType) {
        
        try {
            String prompt = buildAnalysisPrompt(analysisType);
            
            Resource fileResource = file.getResource();
            MimeType mimeType = MimeTypeUtils.parseMimeType(file.getContentType());
            
            String response = chatClient.prompt()
                    .user(u -> u.text(prompt)
                            .media(mimeType, fileResource))
                    .call()
                    .content();
            
            return parseAnalysisResult(response, analysisType);
            
        } catch (Exception e) {
            log.error("結構化分析失敗", e);
            return ImageAnalysisResult.error("分析失敗：" + e.getMessage());
        }
    }
    
    /**
     * 批次圖片分析
     * @param files 多個圖片檔案
     * @param message 分析要求
     * @return 批次分析結果
     */
    @PostMapping("/batch-analysis")
    public List<BatchAnalysisResult> batchImageAnalysis(
            @RequestParam("files") MultipartFile[] files,
            @RequestParam("message") String message) {
        
        return Arrays.stream(files)
                .parallel()
                .map(file -> processSingleImage(file, message))
                .collect(Collectors.toList());
    }
    
    /**
     * 圖片比較分析
     * @param file1 第一張圖片
     * @param file2 第二張圖片
     * @param comparisonType 比較類型
     * @return 比較結果
     */
    @PostMapping("/compare-images")
    public String compareImages(
            @RequestParam("file1") MultipartFile file1,
            @RequestParam("file2") MultipartFile file2,
            @RequestParam("type") ComparisonType comparisonType) {
        
        try {
            String prompt = buildComparisonPrompt(comparisonType);
            
            Resource resource1 = file1.getResource();
            Resource resource2 = file2.getResource();
            MimeType mimeType1 = MimeTypeUtils.parseMimeType(file1.getContentType());
            MimeType mimeType2 = MimeTypeUtils.parseMimeType(file2.getContentType());
            
            return chatClient.prompt()
                    .user(u -> u.text(prompt)
                            .media(mimeType1, resource1)
                            .media(mimeType2, resource2))
                    .call()
                    .content();
            
        } catch (Exception e) {
            log.error("圖片比較失敗", e);
            return "❌ 圖片比較失敗：" + e.getMessage();
        }
    }
    
    private String buildAnalysisPrompt(AnalysisType type) {
        return switch (type) {
            case OBJECT_DETECTION -> """
                請分析這張圖片中的所有物體，並按照以下格式回答：
                
                ## 🔍 物體識別
                - 物體名稱：[位置描述]
                
                ## 📊 統計資訊
                - 總物體數量：
                - 主要類別：
                
                ## 💡 場景描述
                [整體場景的描述]
                """;
                
            case TEXT_EXTRACTION -> """
                請提取這張圖片中的所有文字內容，並按照以下格式整理：
                
                ## 📝 文字內容
                [按照在圖片中的位置順序列出所有文字]
                
                ## 🏷️ 文字分類
                - 標題：
                - 正文：
                - 其他：
                
                ## 📋 結構化資訊
                [如果有表格、清單等結構化內容，請整理出來]
                """;
                
            case SCENE_ANALYSIS -> """
                請詳細分析這張圖片的場景，包含：
                
                ## 🌍 場景類型
                [室內/室外，具體場所]
                
                ## 🎨 視覺元素
                - 色彩：
                - 光線：
                - 構圖：
                
                ## 👥 人物活動
                [如果有人物，描述他們在做什麼]
                
                ## 🎯 整體氛圍
                [場景給人的感受和氛圍]
                """;
                
            case QUALITY_ASSESSMENT -> """
                請評估這張圖片的品質，包含：
                
                ## 📸 技術品質
                - 清晰度：[1-10分]
                - 曝光：[過曝/正常/欠曝]
                - 色彩：[1-10分]
                
                ## 🎨 藝術品質
                - 構圖：[1-10分]
                - 美感：[1-10分]
                
                ## 💡 改進建議
                [如何提升圖片品質的具體建議]
                """;
        };
    }
    
    private String buildComparisonPrompt(ComparisonType type) {
        return switch (type) {
            case SIMILARITY -> """
                請比較這兩張圖片的相似性：
                
                ## 🔍 相似點
                [列出兩張圖片的相似之處]
                
                ## 🆚 差異點
                [列出兩張圖片的不同之處]
                
                ## 📊 相似度評分
                整體相似度：[0-100%]
                
                ## 💡 總結
                [簡要總結比較結果]
                """;
                
            case QUALITY -> """
                請比較這兩張圖片的品質：
                
                ## 📸 技術品質比較
                - 清晰度：圖片1 vs 圖片2
                - 色彩：圖片1 vs 圖片2
                - 曝光：圖片1 vs 圖片2
                
                ## 🏆 推薦結果
                推薦圖片：[1/2]
                推薦理由：[具體說明]
                """;
                
            case CONTENT -> """
                請比較這兩張圖片的內容：
                
                ## 📋 內容對比
                - 主題：
                - 物體：
                - 場景：
                
                ## 🎯 用途建議
                - 圖片1適合：
                - 圖片2適合：
                """;
        };
    }
    
    public enum AnalysisType {
        OBJECT_DETECTION, TEXT_EXTRACTION, SCENE_ANALYSIS, QUALITY_ASSESSMENT
    }
    
    public enum ComparisonType {
        SIMILARITY, QUALITY, CONTENT
    }
}
```

---

## 5.2.4 多媒體檔案處理

### 音訊檔案分析

```java
@RestController
@RequestMapping("/api/audio")
@RequiredArgsConstructor
public class AudioAnalysisController {
    
    private final ChatClient chatClient;
    
    /**
     * 音訊內容分析（需要支援音訊的模型如 GPT-4o）
     * @param file 音訊檔案
     * @param analysisType 分析類型
     * @return 分析結果
     */
    @PostMapping("/analyze")
    public String analyzeAudio(
            @RequestParam("file") MultipartFile file,
            @RequestParam("type") AudioAnalysisType analysisType) {
        
        try {
            // 驗證音訊檔案格式
            if (!isValidAudioFile(file)) {
                return "❌ 不支援的音訊格式，請上傳 MP3、WAV、M4A 或 OGG 格式";
            }
            
            // 檔案大小限制（25MB）
            if (file.getSize() > 25 * 1024 * 1024) {
                return "❌ 音訊檔案過大，請上傳小於 25MB 的檔案";
            }
            
            String prompt = buildAudioAnalysisPrompt(analysisType);
            
            Resource audioResource = file.getResource();
            MimeType mimeType = MimeTypeUtils.parseMimeType(file.getContentType());
            
            return chatClient.prompt()
                    .user(u -> u.text(prompt)
                            .media(mimeType, audioResource))
                    .call()
                    .content();
            
        } catch (Exception e) {
            log.error("音訊分析失敗", e);
            return "❌ 音訊分析失敗：" + e.getMessage();
        }
    }
    
    private boolean isValidAudioFile(MultipartFile file) {
        String contentType = file.getContentType();
        return contentType != null && (
            contentType.equals("audio/mpeg") ||     // MP3
            contentType.equals("audio/wav") ||      // WAV
            contentType.equals("audio/mp4") ||      // M4A
            contentType.equals("audio/ogg")        // OGG
        );
    }
    
    private String buildAudioAnalysisPrompt(AudioAnalysisType type) {
        return switch (type) {
            case TRANSCRIPTION -> """
                請將這個音訊檔案轉換為文字，並按照以下格式輸出：
                
                ## 📝 轉錄內容
                [完整的語音轉文字內容]
                
                ## 🎤 音訊資訊
                - 語言：
                - 說話者數量：
                - 音訊品質：
                
                ## ⏱️ 時間資訊
                - 總時長：
                - 語速：
                """;
                
            case SENTIMENT -> """
                請分析這個音訊的情感和語調：
                
                ## 😊 情感分析
                - 整體情感：[正面/中性/負面]
                - 情感強度：[1-10]
                
                ## 🎵 語調特徵
                - 語速：[快/中/慢]
                - 音調：[高/中/低]
                - 語氣：[描述具體語氣]
                
                ## 💡 內容摘要
                [音訊內容的簡要摘要]
                """;
                
            case MUSIC_ANALYSIS -> """
                請分析這個音樂檔案：
                
                ## 🎵 音樂特徵
                - 風格/類型：
                - 節拍：
                - 調性：
                
                ## 🎼 樂器識別
                [識別出的樂器]
                
                ## 🎭 情緒氛圍
                [音樂給人的感受]
                
                ## 🎯 適用場景
                [這首音樂適合的使用場景]
                """;
        };
    }
    
    public enum AudioAnalysisType {
        TRANSCRIPTION, SENTIMENT, MUSIC_ANALYSIS
    }
}
```

### 影片檔案分析

```java
@RestController
@RequestMapping("/api/video")
@RequiredArgsConstructor
public class VideoAnalysisController {
    
    private final ChatClient chatClient;
    
    /**
     * 影片內容分析（需要支援影片的模型如 GPT-4o、Gemini 1.5 Pro）
     * @param file 影片檔案
     * @param analysisType 分析類型
     * @return 分析結果
     */
    @PostMapping("/analyze")
    public String analyzeVideo(
            @RequestParam("file") MultipartFile file,
            @RequestParam("type") VideoAnalysisType analysisType) {
        
        try {
            // 驗證影片檔案格式
            if (!isValidVideoFile(file)) {
                return "❌ 不支援的影片格式，請上傳 MP4、AVI、MOV 或 WebM 格式";
            }
            
            // 檔案大小限制（100MB）
            if (file.getSize() > 100 * 1024 * 1024) {
                return "❌ 影片檔案過大，請上傳小於 100MB 的檔案";
            }
            
            String prompt = buildVideoAnalysisPrompt(analysisType);
            
            Resource videoResource = file.getResource();
            MimeType mimeType = MimeTypeUtils.parseMimeType(file.getContentType());
            
            return chatClient.prompt()
                    .user(u -> u.text(prompt)
                            .media(mimeType, videoResource))
                    .call()
                    .content();
            
        } catch (Exception e) {
            log.error("影片分析失敗", e);
            return "❌ 影片分析失敗：" + e.getMessage();
        }
    }
    
    private boolean isValidVideoFile(MultipartFile file) {
        String contentType = file.getContentType();
        return contentType != null && (
            contentType.equals("video/mp4") ||      // MP4
            contentType.equals("video/avi") ||      // AVI
            contentType.equals("video/quicktime") || // MOV
            contentType.equals("video/webm")       // WebM
        );
    }
    
    private String buildVideoAnalysisPrompt(VideoAnalysisType type) {
        return switch (type) {
            case CONTENT_SUMMARY -> """
                請分析這個影片的內容並提供摘要：
                
                ## 📹 影片概述
                - 主題：
                - 類型：[教學/娛樂/新聞/其他]
                - 時長：
                
                ## 🎬 內容摘要
                [影片的主要內容摘要]
                
                ## 👥 人物活動
                [影片中的人物和他們的活動]
                
                ## 🎯 關鍵時刻
                [重要的場景或時間點]
                """;
                
            case SCENE_DETECTION -> """
                請分析這個影片的場景變化：
                
                ## 🎬 場景分析
                [按時間順序描述主要場景]
                
                ## 🔄 場景轉換
                [場景之間的轉換方式]
                
                ## 📍 拍攝地點
                [識別出的拍攝地點或環境]
                
                ## 🎨 視覺風格
                [影片的視覺風格和特色]
                """;
                
            case ACTION_RECOGNITION -> """
                請識別影片中的動作和活動：
                
                ## 🏃 動作識別
                [識別出的具體動作]
                
                ## 👥 互動分析
                [人物之間的互動]
                
                ## ⚽ 運動/活動
                [如果是運動影片，分析運動類型和技巧]
                
                ## 📊 活動統計
                [動作的頻率和持續時間]
                """;
        };
    }
    
    public enum VideoAnalysisType {
        CONTENT_SUMMARY, SCENE_DETECTION, ACTION_RECOGNITION
    }
}
```

---

## 5.2.5 企業級多模態應用

### 文件智能分析系統

```java
@Service
@RequiredArgsConstructor
public class DocumentAnalysisService {
    
    private final ChatClient chatClient;
    
    /**
     * 智能文件分析
     * @param file 文件檔案（PDF、圖片等）
     * @param analysisRequest 分析需求
     * @return 分析結果
     */
    public DocumentAnalysisResult analyzeDocument(
            MultipartFile file, 
            DocumentAnalysisRequest analysisRequest) {
        
        try {
            String prompt = buildDocumentAnalysisPrompt(analysisRequest);
            
            Resource fileResource = file.getResource();
            MimeType mimeType = MimeTypeUtils.parseMimeType(file.getContentType());
            
            String response = chatClient.prompt()
                    .user(u -> u.text(prompt)
                            .media(mimeType, fileResource))
                    .call()
                    .content();
            
            return DocumentAnalysisResult.builder()
                    .fileName(file.getOriginalFilename())
                    .fileSize(file.getSize())
                    .analysisType(analysisRequest.getType())
                    .result(response)
                    .timestamp(LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("文件分析失敗：{}", file.getOriginalFilename(), e);
            return DocumentAnalysisResult.error(e.getMessage());
        }
    }
    
    /**
     * 批次文件處理
     * @param files 多個文件
     * @param analysisRequest 分析需求
     * @return 批次處理結果
     */
    public List<DocumentAnalysisResult> batchAnalyzeDocuments(
            List<MultipartFile> files,
            DocumentAnalysisRequest analysisRequest) {
        
        return files.parallelStream()
                .map(file -> analyzeDocument(file, analysisRequest))
                .collect(Collectors.toList());
    }
    
    private String buildDocumentAnalysisPrompt(DocumentAnalysisRequest request) {
        String basePrompt = switch (request.getType()) {
            case OCR_EXTRACTION -> """
                請提取這個文件中的所有文字內容，並按照原始格式整理：
                
                ## 📄 文字內容
                [保持原始格式的文字內容]
                
                ## 📊 文件結構
                - 標題：
                - 段落數：
                - 表格：[如果有]
                - 清單：[如果有]
                
                ## 🔍 關鍵資訊
                [提取出的重要資訊，如日期、金額、姓名等]
                """;
                
            case FORM_ANALYSIS -> """
                請分析這個表單文件，提取所有欄位和值：
                
                ## 📋 表單資訊
                - 表單類型：
                - 表單標題：
                
                ## 📝 欄位內容
                [以「欄位名稱：值」的格式列出所有欄位]
                
                ## ✅ 完整性檢查
                - 已填寫欄位：
                - 空白欄位：
                - 必填欄位狀態：
                """;
                
            case CONTRACT_REVIEW -> """
                請分析這份合約文件的關鍵內容：
                
                ## 📜 合約基本資訊
                - 合約類型：
                - 當事人：
                - 簽署日期：
                - 有效期限：
                
                ## 💰 財務條款
                - 金額：
                - 付款方式：
                - 付款期限：
                
                ## ⚖️ 重要條款
                [列出重要的權利義務條款]
                
                ## ⚠️ 風險提醒
                [識別出的潛在風險點]
                """;
                
            case INVOICE_PROCESSING -> """
                請處理這張發票，提取所有相關資訊：
                
                ## 🧾 發票基本資訊
                - 發票號碼：
                - 開立日期：
                - 賣方：
                - 買方：
                
                ## 💵 金額明細
                - 小計：
                - 稅額：
                - 總計：
                
                ## 📦 商品/服務明細
                [列出所有商品或服務項目]
                
                ## ✅ 驗證狀態
                [檢查發票資訊的完整性和合理性]
                """;
        };
        
        // 加入客製化要求
        if (request.getCustomRequirements() != null && !request.getCustomRequirements().isEmpty()) {
            basePrompt += "\n\n## 🎯 特殊要求\n" + request.getCustomRequirements();
        }
        
        return basePrompt;
    }
}

@Data
@Builder
public class DocumentAnalysisRequest {
    private DocumentType type;
    private String customRequirements;
    private boolean extractTables;
    private boolean detectSignatures;
    private String targetLanguage;
    
    public enum DocumentType {
        OCR_EXTRACTION, FORM_ANALYSIS, CONTRACT_REVIEW, INVOICE_PROCESSING
    }
}

@Data
@Builder
public class DocumentAnalysisResult {
    private String fileName;
    private Long fileSize;
    private DocumentAnalysisRequest.DocumentType analysisType;
    private String result;
    private LocalDateTime timestamp;
    private boolean success;
    private String errorMessage;
    
    public static DocumentAnalysisResult error(String errorMessage) {
        return DocumentAnalysisResult.builder()
                .success(false)
                .errorMessage(errorMessage)
                .timestamp(LocalDateTime.now())
                .build();
    }
}
```

---

## 5.2.6 效能優化與最佳實踐

### 檔案處理優化

```java
@Service
@RequiredArgsConstructor
public class OptimizedMultimodalService {
    
    private final ChatClient chatClient;
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 帶快取的圖片分析
     */
    @Cacheable(value = "imageAnalysis", key = "#file.originalFilename + '_' + #message.hashCode()")
    public String analyzeImageWithCache(MultipartFile file, String message) {
        // 生成檔案雜湊值作為快取鍵
        String fileHash = generateFileHash(file);
        String cacheKey = "image_analysis:" + fileHash + ":" + message.hashCode();
        
        // 檢查快取
        String cachedResult = (String) redisTemplate.opsForValue().get(cacheKey);
        if (cachedResult != null) {
            log.info("從快取返回分析結果：{}", file.getOriginalFilename());
            return cachedResult;
        }
        
        // 執行分析
        String result = performImageAnalysis(file, message);
        
        // 儲存到快取（24小時）
        redisTemplate.opsForValue().set(cacheKey, result, Duration.ofHours(24));
        
        return result;
    }
    
    /**
     * 非同步批次處理
     */
    @Async
    public CompletableFuture<List<String>> batchAnalyzeAsync(
            List<MultipartFile> files, 
            String message) {
        
        List<CompletableFuture<String>> futures = files.stream()
                .map(file -> CompletableFuture.supplyAsync(() -> 
                    analyzeImageWithCache(file, message)))
                .collect(Collectors.toList());
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApply(v -> futures.stream()
                        .map(CompletableFuture::join)
                        .collect(Collectors.toList()));
    }
    
    /**
     * 圖片壓縮和優化
     */
    public MultipartFile optimizeImage(MultipartFile originalFile) {
        try {
            BufferedImage originalImage = ImageIO.read(originalFile.getInputStream());
            
            // 如果圖片太大，進行壓縮
            if (originalFile.getSize() > 5 * 1024 * 1024) { // 5MB
                BufferedImage resizedImage = resizeImage(originalImage, 1920, 1080);
                return convertToMultipartFile(resizedImage, originalFile.getOriginalFilename());
            }
            
            return originalFile;
            
        } catch (IOException e) {
            log.warn("圖片優化失敗，使用原始檔案：{}", e.getMessage());
            return originalFile;
        }
    }
    
    private BufferedImage resizeImage(BufferedImage original, int maxWidth, int maxHeight) {
        int originalWidth = original.getWidth();
        int originalHeight = original.getHeight();
        
        // 計算縮放比例
        double scaleX = (double) maxWidth / originalWidth;
        double scaleY = (double) maxHeight / originalHeight;
        double scale = Math.min(scaleX, scaleY);
        
        if (scale >= 1.0) {
            return original; // 不需要縮放
        }
        
        int newWidth = (int) (originalWidth * scale);
        int newHeight = (int) (originalHeight * scale);
        
        BufferedImage resized = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_RGB);
        Graphics2D g2d = resized.createGraphics();
        g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        g2d.drawImage(original, 0, 0, newWidth, newHeight, null);
        g2d.dispose();
        
        return resized;
    }
    
    private String generateFileHash(MultipartFile file) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] hash = md.digest(file.getBytes());
            return DatatypeConverter.printHexBinary(hash).toLowerCase();
        } catch (Exception e) {
            return String.valueOf(file.getOriginalFilename().hashCode());
        }
    }
}
```

### 錯誤處理和監控

```java
@Component
@Slf4j
public class MultimodalErrorHandler {
    
    private final MeterRegistry meterRegistry;
    private final Counter successCounter;
    private final Counter errorCounter;
    private final Timer processingTimer;
    
    public MultimodalErrorHandler(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.successCounter = Counter.builder("multimodal.analysis.success")
                .description("Successful multimodal analysis count")
                .register(meterRegistry);
        this.errorCounter = Counter.builder("multimodal.analysis.error")
                .description("Failed multimodal analysis count")
                .register(meterRegistry);
        this.processingTimer = Timer.builder("multimodal.analysis.duration")
                .description("Multimodal analysis processing time")
                .register(meterRegistry);
    }
    
    public <T> T executeWithMonitoring(
            String operation, 
            Supplier<T> supplier, 
            Function<Exception, T> errorHandler) {
        
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            T result = supplier.get();
            successCounter.increment(Tags.of("operation", operation));
            return result;
            
        } catch (Exception e) {
            errorCounter.increment(Tags.of(
                "operation", operation,
                "error_type", e.getClass().getSimpleName()
            ));
            
            log.error("多模態操作失敗：{}", operation, e);
            return errorHandler.apply(e);
            
        } finally {
            sample.stop(processingTimer.tag("operation", operation));
        }
    }
}
```

---

## 📝 本章重點回顧

1. **多模態概念理解**：掌握了多模態 AI 的核心價值和應用場景
2. **模型選擇策略**：了解了各種 AI 模型的多模態能力和適用場景
3. **圖片分析實現**：建立了完整的圖片上傳、分析和批次處理功能
4. **多媒體處理**：實現了音訊、影片等多種媒體格式的分析功能
5. **企業級應用**：設計了文件智能分析等實際業務場景的解決方案

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **圖片分析** | ⭐⭐⭐ | 中 | 所有視覺 AI 應用 |
| **文件 OCR** | ⭐⭐⭐ | 中 | 企業文件處理 |
| **音訊處理** | ⭐⭐ | 高 | 語音應用、內容分析 |
| **影片分析** | ⭐⭐ | 高 | 影片內容理解 |
| **批次處理** | ⭐⭐ | 中 | 大量檔案處理 |
| **效能優化** | ⭐⭐ | 高 | 生產環境部署 |

### 最佳實踐建議

1. **檔案驗證**：始終驗證檔案格式、大小和內容
2. **錯誤處理**：提供友善的錯誤訊息和降級方案
3. **效能優化**：使用快取、壓縮和非同步處理
4. **成本控制**：監控 API 使用量，特別是多模態請求成本較高
5. **安全考量**：注意檔案上傳的安全性和隱私保護

### 下一步學習方向

在下一章中，我們將學習如何使用 Spring AI 生成圖片，探索 AI 的創作能力，建立完整的圖片生成和編輯功能。

---

**參考資料：**
- [Spring AI Multimodality Documentation](https://docs.spring.io/spring-ai/reference/api/multimodality.html)
- [OpenAI Vision API](https://platform.openai.com/docs/guides/vision)
- [Anthropic Claude Vision](https://docs.anthropic.com/claude/docs/vision)
- [Google Gemini Multimodal](https://ai.google.dev/docs/multimodal_concepts)
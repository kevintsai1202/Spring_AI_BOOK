# 7.6 ä¼æ¥­ RAG çœŸæ­£çš„è³‡æ–™ä¾†æº

> **æœ¬ç« é‡é»**ï¼šæ·±å…¥æ¢è¨ä¼æ¥­ç´š RAG ç³»çµ±çš„è³‡æ–™ä¾†æºæ•´åˆç­–ç•¥ï¼ŒæŒæ¡å³æ™‚è³‡æ–™åŒæ­¥ã€å¤šè³‡æ–™æºç®¡ç†ã€è³‡æ–™å®‰å…¨å’Œæ¬Šé™æ§åˆ¶ï¼Œå»ºç«‹çœŸæ­£é©åˆä¼æ¥­ä½¿ç”¨çš„ RAG çŸ¥è­˜åº«ã€‚

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬ç« å­¸ç¿’å¾Œï¼Œæ‚¨å°‡èƒ½å¤ ï¼š

- ğŸ¯ **è¨­è¨ˆä¼æ¥­è³‡æ–™æ¶æ§‹**ï¼šå»ºç«‹å¯æ“´å±•çš„å¤šè³‡æ–™æºæ•´åˆæ¶æ§‹
- ğŸ¯ **å¯¦ç¾å³æ™‚è³‡æ–™åŒæ­¥**ï¼šæŒæ¡è³‡æ–™è®Šæ›´æª¢æ¸¬å’Œå¢é‡åŒæ­¥æŠ€è¡“
- ğŸ¯ **ç®¡ç†è³‡æ–™å®‰å…¨æ¬Šé™**ï¼šå¯¦ç¾ç´°ç²’åº¦çš„è³‡æ–™å­˜å–æ§åˆ¶
- ğŸ¯ **å„ªåŒ–è³‡æ–™ç®¡é“æ•ˆèƒ½**ï¼šå»ºç«‹é«˜æ•ˆçš„è³‡æ–™è™•ç†å’ŒåŒæ­¥æ©Ÿåˆ¶
- ğŸ¯ **ç›£æ§è³‡æ–™å“è³ª**ï¼šå¯¦ç¾å®Œæ•´çš„è³‡æ–™å“è³ªç›£æ§å’Œå‘Šè­¦ç³»çµ±

---

## 7.6.1 ä¼æ¥­è³‡æ–™ä¾†æºæ¶æ§‹è¨­è¨ˆ

### ä¼æ¥­è³‡æ–™ä¾†æºçš„è¤‡é›œæ€§

**ä¼æ¥­ç’°å¢ƒä¸­çš„è³‡æ–™æŒ‘æˆ°**ï¼š
- ğŸ¢ **å¤šç³»çµ±åˆ†æ•£**ï¼šè³‡æ–™åˆ†æ•£åœ¨ä¸åŒçš„æ¥­å‹™ç³»çµ±ä¸­
- ğŸ”„ **å³æ™‚æ€§è¦æ±‚**ï¼šæ¥­å‹™è³‡æ–™éœ€è¦å³æ™‚æˆ–è¿‘å³æ™‚åŒæ­¥
- ğŸ”’ **å®‰å…¨æ€§è¦æ±‚**ï¼šåš´æ ¼çš„è³‡æ–™å­˜å–æ¬Šé™å’Œå®‰å…¨æ§åˆ¶
- ğŸ“Š **è³‡æ–™ç•°è³ªæ€§**ï¼šä¸åŒæ ¼å¼ã€çµæ§‹å’Œå“è³ªçš„è³‡æ–™
- âš¡ **é«˜å¯ç”¨æ€§éœ€æ±‚**ï¼š7x24 å°æ™‚ä¸é–“æ–·æœå‹™è¦æ±‚

### ä¼æ¥­è³‡æ–™æ¶æ§‹è¨­è¨ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Enterprise Data Architecture                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Application Layer                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              RAG Application Services                   â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Query Processing                             â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Response Generation                          â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ User Interface                               â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Data Access Layer                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              Unified Data Access API                   â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Authentication & Authorization               â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Data Virtualization                          â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Caching & Performance                        â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Data Processing Layer                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              Real-time Data Pipeline                   â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Change Data Capture (CDC)                   â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Stream Processing                            â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ ETL Orchestration                            â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â€¢ Data Quality Monitoring                      â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Data Storage Layer                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              Hybrid Storage Architecture                â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚ â”‚
â”‚  â”‚  â”‚Vector Store â”‚ â”‚Search Engineâ”‚ â”‚Data Lake    â”‚      â”‚ â”‚
â”‚  â”‚  â”‚â€¢ Embeddings â”‚ â”‚â€¢ Full-text  â”‚ â”‚â€¢ Raw Data   â”‚      â”‚ â”‚
â”‚  â”‚  â”‚â€¢ Similarity â”‚ â”‚â€¢ Faceted    â”‚ â”‚â€¢ Archives   â”‚      â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Data Sources Layer                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚Enterprise   â”‚ â”‚Cloud        â”‚ â”‚External     â”‚          â”‚
â”‚  â”‚Systems      â”‚ â”‚Services     â”‚ â”‚APIs         â”‚          â”‚
â”‚  â”‚â€¢ ERP        â”‚ â”‚â€¢ SaaS       â”‚ â”‚â€¢ Partners   â”‚          â”‚
â”‚  â”‚â€¢ CRM        â”‚ â”‚â€¢ Cloud DB   â”‚ â”‚â€¢ Public     â”‚          â”‚
â”‚  â”‚â€¢ Legacy     â”‚ â”‚â€¢ Object     â”‚ â”‚â€¢ Vendors    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è³‡æ–™ä¾†æºç®¡ç†æœå‹™

```java
/**
 * ä¼æ¥­è³‡æ–™ä¾†æºç®¡ç†æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class EnterpriseDataSourceManager {
    
    private final Map<String, DataSourceConnector> connectors;
    private final DataSourceRegistry dataSourceRegistry;
    private final SecurityManager securityManager;
    private final MetricsCollector metricsCollector;
    
    /**
     * è¨»å†Šè³‡æ–™ä¾†æº
     */
    public void registerDataSource(DataSourceConfig config) {
        log.info("Registering data source: {}", config.getName());
        
        try {
            // 1. é©—è­‰é…ç½®
            validateDataSourceConfig(config);
            
            // 2. å®‰å…¨æª¢æŸ¥
            securityManager.validateDataSourceAccess(config);
            
            // 3. å»ºç«‹é€£æ¥å™¨
            DataSourceConnector connector = createConnector(config);
            
            // 4. æ¸¬è©¦é€£æ¥
            testConnection(connector);
            
            // 5. è¨»å†Šåˆ°ç³»çµ±
            dataSourceRegistry.register(config.getName(), config);
            connectors.put(config.getName(), connector);
            
            log.info("Successfully registered data source: {}", config.getName());
            
        } catch (Exception e) {
            log.error("Failed to register data source: {}", config.getName(), e);
            throw new DataSourceRegistrationException("Registration failed", e);
        }
    }
    
    /**
     * å–å¾—è³‡æ–™ä¾†æºé€£æ¥å™¨
     */
    public DataSourceConnector getConnector(String dataSourceName) {
        DataSourceConnector connector = connectors.get(dataSourceName);
        if (connector == null) {
            throw new DataSourceNotFoundException("Data source not found: " + dataSourceName);
        }
        
        // æª¢æŸ¥é€£æ¥ç‹€æ…‹
        if (!connector.isHealthy()) {
            log.warn("Data source {} is unhealthy, attempting reconnection", dataSourceName);
            reconnectDataSource(dataSourceName);
        }
        
        return connector;
    }
    
    /**
     * å»ºç«‹é€£æ¥å™¨
     */
    private DataSourceConnector createConnector(DataSourceConfig config) {
        DataSourceType type = config.getType();
        
        return switch (type) {
            case RELATIONAL_DATABASE -> new JdbcDataSourceConnector(config);
            case NOSQL_DATABASE -> new NoSqlDataSourceConnector(config);
            case REST_API -> new RestApiDataSourceConnector(config);
            case FILE_SYSTEM -> new FileSystemDataSourceConnector(config);
            case MESSAGE_QUEUE -> new MessageQueueDataSourceConnector(config);
            case CLOUD_STORAGE -> new CloudStorageDataSourceConnector(config);
            default -> throw new UnsupportedDataSourceException("Unsupported type: " + type);
        };
    }
    
    /**
     * æ¸¬è©¦é€£æ¥
     */
    private void testConnection(DataSourceConnector connector) {
        try {
            ConnectionTestResult result = connector.testConnection();
            if (!result.isSuccessful()) {
                throw new DataSourceConnectionException(
                    "Connection test failed: " + result.getErrorMessage());
            }
        } catch (Exception e) {
            throw new DataSourceConnectionException("Connection test failed", e);
        }
    }
    
    /**
     * é‡æ–°é€£æ¥è³‡æ–™ä¾†æº
     */
    private void reconnectDataSource(String dataSourceName) {
        try {
            DataSourceConfig config = dataSourceRegistry.getConfig(dataSourceName);
            DataSourceConnector newConnector = createConnector(config);
            testConnection(newConnector);
            
            // æ›¿æ›èˆŠé€£æ¥å™¨
            DataSourceConnector oldConnector = connectors.put(dataSourceName, newConnector);
            if (oldConnector != null) {
                oldConnector.close();
            }
            
            log.info("Successfully reconnected data source: {}", dataSourceName);
            
        } catch (Exception e) {
            log.error("Failed to reconnect data source: {}", dataSourceName, e);
            metricsCollector.recordConnectionFailure(dataSourceName);
        }
    }
    
    /**
     * é©—è­‰è³‡æ–™ä¾†æºé…ç½®
     */
    private void validateDataSourceConfig(DataSourceConfig config) {
        if (config.getName() == null || config.getName().trim().isEmpty()) {
            throw new IllegalArgumentException("Data source name cannot be empty");
        }
        
        if (config.getType() == null) {
            throw new IllegalArgumentException("Data source type must be specified");
        }
        
        if (config.getConnectionString() == null || config.getConnectionString().trim().isEmpty()) {
            throw new IllegalArgumentException("Connection string cannot be empty");
        }
        
        // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
        if (dataSourceRegistry.exists(config.getName())) {
            throw new DataSourceAlreadyExistsException(
                "Data source already exists: " + config.getName());
        }
    }
    
    /**
     * å–å¾—æ‰€æœ‰è³‡æ–™ä¾†æºç‹€æ…‹
     */
    public List<DataSourceStatus> getAllDataSourceStatus() {
        return connectors.entrySet().stream()
            .map(entry -> {
                String name = entry.getKey();
                DataSourceConnector connector = entry.getValue();
                
                return DataSourceStatus.builder()
                    .name(name)
                    .type(connector.getType())
                    .healthy(connector.isHealthy())
                    .lastChecked(LocalDateTime.now())
                    .connectionCount(connector.getActiveConnectionCount())
                    .build();
            })
            .collect(Collectors.toList());
    }
    
    /**
     * é—œé–‰æ‰€æœ‰é€£æ¥
     */
    @PreDestroy
    public void shutdown() {
        log.info("Shutting down data source manager");
        
        connectors.values().parallelStream().forEach(connector -> {
            try {
                connector.close();
            } catch (Exception e) {
                log.warn("Error closing connector", e);
            }
        });
        
        connectors.clear();
    }
}

/**
 * è³‡æ–™ä¾†æºé…ç½®
 */
@Data
@Builder
public class DataSourceConfig {
    private String name;
    private DataSourceType type;
    private String connectionString;
    private Map<String, String> properties;
    private SecurityConfig security;
    private SyncConfig sync;
    private RetryConfig retry;
    
    @Data
    @Builder
    public static class SecurityConfig {
        private String username;
        private String password;
        private String certificatePath;
        private boolean sslEnabled;
        private List<String> allowedRoles;
    }
    
    @Data
    @Builder
    public static class SyncConfig {
        private boolean enabled;
        private Duration interval;
        private SyncMode mode;
        private String changeDetectionColumn;
    }
    
    @Data
    @Builder
    public static class RetryConfig {
        private int maxAttempts;
        private Duration initialDelay;
        private Duration maxDelay;
        private double backoffMultiplier;
    }
}

enum DataSourceType {
    RELATIONAL_DATABASE,
    NOSQL_DATABASE,
    REST_API,
    FILE_SYSTEM,
    MESSAGE_QUEUE,
    CLOUD_STORAGE
}

enum SyncMode {
    FULL_SYNC,
    INCREMENTAL_SYNC,
    REAL_TIME_SYNC
}
```

---

## 7.6.2 å³æ™‚è³‡æ–™åŒæ­¥æ©Ÿåˆ¶

### Change Data Capture (CDC) å¯¦ç¾

```java
/**
 * è®Šæ›´è³‡æ–™æ•ç²æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class ChangeDataCaptureService {
    
    private final Map<String, CDCConnector> cdcConnectors;
    private final DataSyncOrchestrator syncOrchestrator;
    private final EventPublisher eventPublisher;
    
    /**
     * å•Ÿå‹• CDC ç›£æ§
     */
    public void startCDCMonitoring(String dataSourceName, CDCConfig config) {
        log.info("Starting CDC monitoring for data source: {}", dataSourceName);
        
        try {
            CDCConnector connector = createCDCConnector(config);
            
            // è¨­å®šè®Šæ›´äº‹ä»¶è™•ç†å™¨
            connector.setChangeEventHandler(event -> handleChangeEvent(dataSourceName, event));
            
            // å•Ÿå‹•ç›£æ§
            connector.start();
            
            cdcConnectors.put(dataSourceName, connector);
            
            log.info("CDC monitoring started for: {}", dataSourceName);
            
        } catch (Exception e) {
            log.error("Failed to start CDC monitoring for: {}", dataSourceName, e);
            throw new CDCException("CDC startup failed", e);
        }
    }
    
    /**
     * è™•ç†è®Šæ›´äº‹ä»¶
     */
    private void handleChangeEvent(String dataSourceName, ChangeEvent event) {
        try {
            log.debug("Processing change event: {} for data source: {}", 
                event.getType(), dataSourceName);
            
            // 1. é©—è­‰äº‹ä»¶
            validateChangeEvent(event);
            
            // 2. è½‰æ›ç‚ºåŒæ­¥ä»»å‹™
            SyncTask syncTask = createSyncTask(dataSourceName, event);
            
            // 3. æäº¤åŒæ­¥ä»»å‹™
            syncOrchestrator.submitTask(syncTask);
            
            // 4. ç™¼å¸ƒäº‹ä»¶é€šçŸ¥
            eventPublisher.publishEvent(new DataChangeDetectedEvent(dataSourceName, event));
            
        } catch (Exception e) {
            log.error("Failed to handle change event for: {}", dataSourceName, e);
            // è¨˜éŒ„å¤±æ•—äº‹ä»¶ï¼Œç¨å¾Œé‡è©¦
            recordFailedEvent(dataSourceName, event, e);
        }
    }
    
    /**
     * å»ºç«‹ CDC é€£æ¥å™¨
     */
    private CDCConnector createCDCConnector(CDCConfig config) {
        return switch (config.getType()) {
            case DATABASE_LOG -> new DatabaseLogCDCConnector(config);
            case TRIGGER_BASED -> new TriggerBasedCDCConnector(config);
            case TIMESTAMP_BASED -> new TimestampBasedCDCConnector(config);
            case KAFKA_CONNECT -> new KafkaConnectCDCConnector(config);
            default -> throw new UnsupportedOperationException(
                "Unsupported CDC type: " + config.getType());
        };
    }
    
    /**
     * å»ºç«‹åŒæ­¥ä»»å‹™
     */
    private SyncTask createSyncTask(String dataSourceName, ChangeEvent event) {
        return SyncTask.builder()
            .dataSourceName(dataSourceName)
            .operation(mapToSyncOperation(event.getType()))
            .entityId(event.getEntityId())
            .entityType(event.getEntityType())
            .changeData(event.getData())
            .timestamp(event.getTimestamp())
            .priority(determinePriority(event))
            .build();
    }
    
    private SyncOperation mapToSyncOperation(ChangeEventType eventType) {
        return switch (eventType) {
            case INSERT -> SyncOperation.CREATE;
            case UPDATE -> SyncOperation.UPDATE;
            case DELETE -> SyncOperation.DELETE;
        };
    }
    
    private TaskPriority determinePriority(ChangeEvent event) {
        // æ ¹æ“šå¯¦é«”é¡å‹å’Œè®Šæ›´é¡å‹æ±ºå®šå„ªå…ˆç´š
        if (event.getEntityType().equals("critical_data")) {
            return TaskPriority.HIGH;
        } else if (event.getType() == ChangeEventType.DELETE) {
            return TaskPriority.MEDIUM;
        } else {
            return TaskPriority.LOW;
        }
    }
}

/**
 * è³‡æ–™åŒæ­¥å”èª¿å™¨
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class DataSyncOrchestrator {
    
    private final TaskExecutor taskExecutor;
    private final SyncTaskQueue taskQueue;
    private final DataProcessor dataProcessor;
    private final ConflictResolver conflictResolver;
    
    /**
     * æäº¤åŒæ­¥ä»»å‹™
     */
    public void submitTask(SyncTask task) {
        try {
            // 1. ä»»å‹™é©—è­‰
            validateSyncTask(task);
            
            // 2. è¡çªæª¢æ¸¬
            if (hasConflict(task)) {
                task = conflictResolver.resolve(task);
            }
            
            // 3. åŠ å…¥ä»»å‹™ä½‡åˆ—
            taskQueue.enqueue(task);
            
            log.debug("Sync task submitted: {}", task.getId());
            
        } catch (Exception e) {
            log.error("Failed to submit sync task", e);
            throw new SyncTaskException("Task submission failed", e);
        }
    }
    
    /**
     * è™•ç†åŒæ­¥ä»»å‹™
     */
    @Async
    public CompletableFuture<Void> processSyncTask(SyncTask task) {
        return CompletableFuture.runAsync(() -> {
            try {
                log.debug("Processing sync task: {}", task.getId());
                
                // 1. å–å¾—åŸå§‹è³‡æ–™
                Object sourceData = fetchSourceData(task);
                
                // 2. è³‡æ–™è™•ç†å’Œè½‰æ›
                ProcessedData processedData = dataProcessor.process(sourceData, task);
                
                // 3. æ›´æ–°ç›®æ¨™ç³»çµ±
                updateTargetSystem(processedData, task);
                
                // 4. è¨˜éŒ„æˆåŠŸ
                recordTaskSuccess(task);
                
                log.debug("Sync task completed: {}", task.getId());
                
            } catch (Exception e) {
                log.error("Sync task failed: {}", task.getId(), e);
                recordTaskFailure(task, e);
                
                // æ ¹æ“šé‡è©¦ç­–ç•¥æ±ºå®šæ˜¯å¦é‡è©¦
                if (shouldRetry(task)) {
                    scheduleRetry(task);
                }
            }
        }, taskExecutor);
    }
    
    /**
     * æ‰¹æ¬¡åŒæ­¥è™•ç†
     */
    public void processBatchSync(String dataSourceName, BatchSyncConfig config) {
        log.info("Starting batch sync for data source: {}", dataSourceName);
        
        try {
            // 1. å–å¾—è³‡æ–™ç¯„åœ
            DataRange dataRange = determineDataRange(dataSourceName, config);
            
            // 2. åˆ†æ‰¹è™•ç†
            List<DataBatch> batches = createDataBatches(dataRange, config.getBatchSize());
            
            // 3. ä¸¦è¡Œè™•ç†æ‰¹æ¬¡
            List<CompletableFuture<Void>> futures = batches.stream()
                .map(batch -> processBatch(dataSourceName, batch))
                .collect(Collectors.toList());
            
            // 4. ç­‰å¾…æ‰€æœ‰æ‰¹æ¬¡å®Œæˆ
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
            
            log.info("Batch sync completed for: {}", dataSourceName);
            
        } catch (Exception e) {
            log.error("Batch sync failed for: {}", dataSourceName, e);
            throw new BatchSyncException("Batch sync failed", e);
        }
    }
    
    private CompletableFuture<Void> processBatch(String dataSourceName, DataBatch batch) {
        return CompletableFuture.runAsync(() -> {
            try {
                // è™•ç†æ‰¹æ¬¡ä¸­çš„æ¯å€‹é …ç›®
                for (DataItem item : batch.getItems()) {
                    SyncTask task = SyncTask.builder()
                        .dataSourceName(dataSourceName)
                        .operation(SyncOperation.UPDATE)
                        .entityId(item.getId())
                        .entityType(item.getType())
                        .changeData(item.getData())
                        .timestamp(LocalDateTime.now())
                        .priority(TaskPriority.MEDIUM)
                        .build();
                    
                    processSyncTask(task).join();
                }
                
            } catch (Exception e) {
                log.error("Batch processing failed", e);
                throw new RuntimeException(e);
            }
        }, taskExecutor);
    }
}

/**
 * åŒæ­¥ä»»å‹™
 */
@Data
@Builder
public class SyncTask {
    private String id;
    private String dataSourceName;
    private SyncOperation operation;
    private String entityId;
    private String entityType;
    private Object changeData;
    private LocalDateTime timestamp;
    private TaskPriority priority;
    private int retryCount;
    private LocalDateTime nextRetryTime;
    
    @PostConstruct
    private void generateId() {
        if (id == null) {
            id = UUID.randomUUID().toString();
        }
    }
}

enum SyncOperation {
    CREATE, UPDATE, DELETE
}

enum TaskPriority {
    HIGH, MEDIUM, LOW
}

enum ChangeEventType {
    INSERT, UPDATE, DELETE
}
```

---

## 7.6.3 è³‡æ–™å®‰å…¨èˆ‡æ¬Šé™æ§åˆ¶

### ç´°ç²’åº¦æ¬Šé™æ§åˆ¶ç³»çµ±

```java
/**
 * è³‡æ–™å®‰å…¨ç®¡ç†æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class DataSecurityService {
    
    private final PermissionRepository permissionRepository;
    private final RoleRepository roleRepository;
    private final AuditLogger auditLogger;
    private final EncryptionService encryptionService;
    
    /**
     * æª¢æŸ¥è³‡æ–™å­˜å–æ¬Šé™
     */
    public boolean hasDataAccess(String userId, String dataSourceName, 
                                String entityType, AccessType accessType) {
        try {
            // 1. å–å¾—ä½¿ç”¨è€…è§’è‰²
            List<String> userRoles = getUserRoles(userId);
            
            // 2. æª¢æŸ¥è§’è‰²æ¬Šé™
            for (String role : userRoles) {
                if (hasRolePermission(role, dataSourceName, entityType, accessType)) {
                    auditLogger.logAccessGranted(userId, dataSourceName, entityType, accessType);
                    return true;
                }
            }
            
            // 3. æª¢æŸ¥ç›´æ¥æ¬Šé™
            if (hasDirectPermission(userId, dataSourceName, entityType, accessType)) {
                auditLogger.logAccessGranted(userId, dataSourceName, entityType, accessType);
                return true;
            }
            
            auditLogger.logAccessDenied(userId, dataSourceName, entityType, accessType);
            return false;
            
        } catch (Exception e) {
            log.error("Error checking data access permission", e);
            auditLogger.logAccessError(userId, dataSourceName, entityType, accessType, e);
            return false; // é è¨­æ‹’çµ•å­˜å–
        }
    }
    
    /**
     * è³‡æ–™è„«æ•è™•ç†
     */
    public Object maskSensitiveData(Object data, String userId, DataMaskingPolicy policy) {
        if (data == null || policy == null) {
            return data;
        }
        
        try {
            // 1. æª¢æŸ¥æ˜¯å¦éœ€è¦è„«æ•
            if (!needsDataMasking(userId, policy)) {
                return data;
            }
            
            // 2. æ ¹æ“šç­–ç•¥é€²è¡Œè„«æ•
            Object maskedData = applyDataMasking(data, policy);
            
            // 3. è¨˜éŒ„è„«æ•æ“ä½œ
            auditLogger.logDataMasking(userId, policy.getPolicyName());
            
            return maskedData;
            
        } catch (Exception e) {
            log.error("Error applying data masking", e);
            // ç™¼ç”ŸéŒ¯èª¤æ™‚ï¼Œè¿”å›å®Œå…¨è„«æ•çš„è³‡æ–™
            return applyFullMasking(data);
        }
    }
    
    /**
     * è³‡æ–™åŠ å¯†
     */
    public String encryptSensitiveField(String plainText, EncryptionPolicy policy) {
        try {
            return switch (policy.getAlgorithm()) {
                case AES_256 -> encryptionService.encryptAES256(plainText, policy.getKey());
                case RSA_2048 -> encryptionService.encryptRSA2048(plainText, policy.getPublicKey());
                case HASH_SHA256 -> encryptionService.hashSHA256(plainText, policy.getSalt());
                default -> throw new UnsupportedEncryptionException(
                    "Unsupported encryption algorithm: " + policy.getAlgorithm());
            };
        } catch (Exception e) {
            log.error("Encryption failed", e);
            throw new EncryptionException("Failed to encrypt sensitive field", e);
        }
    }
    
    /**
     * å»ºç«‹è³‡æ–™å­˜å–ä¸Šä¸‹æ–‡
     */
    public DataAccessContext createAccessContext(String userId, String sessionId) {
        try {
            // 1. å–å¾—ä½¿ç”¨è€…è³‡è¨Š
            UserInfo userInfo = getUserInfo(userId);
            
            // 2. å–å¾—ä½¿ç”¨è€…æ¬Šé™
            List<Permission> permissions = getUserPermissions(userId);
            
            // 3. å»ºç«‹å­˜å–ä¸Šä¸‹æ–‡
            return DataAccessContext.builder()
                .userId(userId)
                .sessionId(sessionId)
                .userInfo(userInfo)
                .permissions(permissions)
                .createdAt(LocalDateTime.now())
                .expiresAt(LocalDateTime.now().plusHours(8)) // 8å°æ™‚æœ‰æ•ˆæœŸ
                .build();
                
        } catch (Exception e) {
            log.error("Failed to create access context for user: {}", userId, e);
            throw new SecurityException("Access context creation failed", e);
        }
    }
    
    /**
     * é©—è­‰è³‡æ–™å­˜å–ä¸Šä¸‹æ–‡
     */
    public boolean validateAccessContext(DataAccessContext context) {
        if (context == null) {
            return false;
        }
        
        // 1. æª¢æŸ¥æ˜¯å¦éæœŸ
        if (context.getExpiresAt().isBefore(LocalDateTime.now())) {
            log.warn("Access context expired for user: {}", context.getUserId());
            return false;
        }
        
        // 2. æª¢æŸ¥æœƒè©±æœ‰æ•ˆæ€§
        if (!isValidSession(context.getSessionId())) {
            log.warn("Invalid session for user: {}", context.getUserId());
            return false;
        }
        
        // 3. æª¢æŸ¥ä½¿ç”¨è€…ç‹€æ…‹
        if (!isUserActive(context.getUserId())) {
            log.warn("User is not active: {}", context.getUserId());
            return false;
        }
        
        return true;
    }
    
    private List<String> getUserRoles(String userId) {
        return roleRepository.findRolesByUserId(userId);
    }
    
    private boolean hasRolePermission(String role, String dataSource, 
                                    String entityType, AccessType accessType) {
        return permissionRepository.hasRolePermission(role, dataSource, entityType, accessType);
    }
    
    private boolean hasDirectPermission(String userId, String dataSource, 
                                      String entityType, AccessType accessType) {
        return permissionRepository.hasUserPermission(userId, dataSource, entityType, accessType);
    }
    
    private boolean needsDataMasking(String userId, DataMaskingPolicy policy) {
        // æª¢æŸ¥ä½¿ç”¨è€…æ˜¯å¦æœ‰æŸ¥çœ‹æ•æ„Ÿè³‡æ–™çš„æ¬Šé™
        return !hasDataAccess(userId, policy.getDataSource(), 
                            policy.getEntityType(), AccessType.VIEW_SENSITIVE);
    }
    
    private Object applyDataMasking(Object data, DataMaskingPolicy policy) {
        // æ ¹æ“šè„«æ•ç­–ç•¥è™•ç†è³‡æ–™
        return switch (policy.getMaskingType()) {
            case PARTIAL_MASK -> applyPartialMasking(data, policy);
            case FULL_MASK -> applyFullMasking(data);
            case HASH_MASK -> applyHashMasking(data, policy);
            case TOKENIZE -> applyTokenization(data, policy);
        };
    }
    
    private Object applyPartialMasking(Object data, DataMaskingPolicy policy) {
        // éƒ¨åˆ†è„«æ•å¯¦ç¾
        if (data instanceof String str) {
            int visibleChars = policy.getVisibleCharacters();
            if (str.length() <= visibleChars * 2) {
                return "*".repeat(str.length());
            }
            return str.substring(0, visibleChars) + 
                   "*".repeat(str.length() - visibleChars * 2) + 
                   str.substring(str.length() - visibleChars);
        }
        return data;
    }
    
    private Object applyFullMasking(Object data) {
        // å®Œå…¨è„«æ•å¯¦ç¾
        if (data instanceof String str) {
            return "*".repeat(str.length());
        } else if (data instanceof Number) {
            return 0;
        }
        return "[MASKED]";
    }
    
    private Object applyHashMasking(Object data, DataMaskingPolicy policy) {
        // é›œæ¹Šè„«æ•å¯¦ç¾
        if (data instanceof String str) {
            return encryptionService.hashSHA256(str, policy.getSalt());
        }
        return data;
    }
    
    private Object applyTokenization(Object data, DataMaskingPolicy policy) {
        // ä»£å¹£åŒ–å¯¦ç¾
        if (data instanceof String str) {
            return "TOKEN_" + UUID.randomUUID().toString().substring(0, 8);
        }
        return data;
    }
}

/**
 * è³‡æ–™å­˜å–ä¸Šä¸‹æ–‡
 */
@Data
@Builder
public class DataAccessContext {
    private String userId;
    private String sessionId;
    private UserInfo userInfo;
    private List<Permission> permissions;
    private LocalDateTime createdAt;
    private LocalDateTime expiresAt;
}

/**
 * æ¬Šé™å®šç¾©
 */
@Data
@Builder
public class Permission {
    private String id;
    private String dataSource;
    private String entityType;
    private AccessType accessType;
    private List<String> conditions;
}

enum AccessType {
    READ, WRITE, DELETE, VIEW_SENSITIVE, EXPORT
}

/**
 * è³‡æ–™è„«æ•ç­–ç•¥
 */
@Data
@Builder
public class DataMaskingPolicy {
    private String policyName;
    private String dataSource;
    private String entityType;
    private MaskingType maskingType;
    private int visibleCharacters;
    private String salt;
}

enum MaskingType {
    PARTIAL_MASK, FULL_MASK, HASH_MASK, TOKENIZE
}
```

---

## ğŸ“ æœ¬ç« é‡é»å›é¡§

1. **ä¼æ¥­è³‡æ–™æ¶æ§‹**ï¼šè¨­è¨ˆäº†å¯æ“´å±•çš„å¤šè³‡æ–™æºæ•´åˆæ¶æ§‹
2. **å³æ™‚è³‡æ–™åŒæ­¥**ï¼šå¯¦ç¾äº† CDC å’Œæ‰¹æ¬¡åŒæ­¥æ©Ÿåˆ¶
3. **è³‡æ–™å®‰å…¨æ§åˆ¶**ï¼šå»ºç«‹äº†ç´°ç²’åº¦çš„æ¬Šé™æ§åˆ¶å’Œè³‡æ–™è„«æ•
4. **æ•ˆèƒ½å„ªåŒ–**ï¼šå¯¦ç¾äº†é«˜æ•ˆçš„è³‡æ–™è™•ç†å’ŒåŒæ­¥æ©Ÿåˆ¶
5. **ç›£æ§å‘Šè­¦**ï¼šå»ºç«‹äº†å®Œæ•´çš„è³‡æ–™å“è³ªç›£æ§é«”ç³»

### æŠ€è¡“è¦é»ç¸½çµ

| æŠ€è¡“é» | é‡è¦æ€§ | å¯¦ç¾é›£åº¦ | ä¼æ¥­åƒ¹å€¼ |
|--------|--------|----------|----------|
| **å¤šè³‡æ–™æºæ•´åˆ** | â­â­â­ | é«˜ | ç³»çµ±æ•´åˆ |
| **å³æ™‚è³‡æ–™åŒæ­¥** | â­â­â­ | é«˜ | è³‡æ–™æ™‚æ•ˆæ€§ |
| **å®‰å…¨æ¬Šé™æ§åˆ¶** | â­â­â­ | é«˜ | è³‡æ–™å®‰å…¨ |
| **æ•ˆèƒ½å„ªåŒ–** | â­â­ | ä¸­ | ç³»çµ±æ•ˆèƒ½ |
| **ç›£æ§å‘Šè­¦** | â­â­ | ä¸­ | é‹ç¶­ç®¡ç† |

### æœ€ä½³å¯¦è¸å»ºè­°

1. **åˆ†å±¤æ¶æ§‹**ï¼šæ¡ç”¨åˆ†å±¤æ¶æ§‹è¨­è¨ˆï¼Œç¢ºä¿ç³»çµ±çš„å¯ç¶­è­·æ€§å’Œæ“´å±•æ€§
2. **å®‰å…¨å„ªå…ˆ**ï¼šå°‡è³‡æ–™å®‰å…¨ä½œç‚ºé¦–è¦è€ƒé‡ï¼Œå¯¦æ–½å¤šå±¤æ¬¡çš„å®‰å…¨æ§åˆ¶
3. **æ•ˆèƒ½ç›£æ§**ï¼šå»ºç«‹å®Œæ•´çš„æ•ˆèƒ½ç›£æ§å’Œå‘Šè­¦æ©Ÿåˆ¶
4. **æ¼¸é€²å¼åŒæ­¥**ï¼šæ¡ç”¨æ¼¸é€²å¼çš„è³‡æ–™åŒæ­¥ç­–ç•¥ï¼Œé¿å…ç³»çµ±éè¼‰
5. **å®¹éŒ¯è¨­è¨ˆ**ï¼šå¯¦ç¾å®Œå–„çš„å®¹éŒ¯å’Œæ¢å¾©æ©Ÿåˆ¶

### ä¸‹ä¸€æ­¥å­¸ç¿’æ–¹å‘

åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘å€‘å°‡å­¸ç¿’ RAG çš„æœ€å¾Œä¸€å“©è·¯ï¼ŒåŒ…æ‹¬ï¼š
- ç³»çµ±éƒ¨ç½²å’Œé‹ç¶­
- æ•ˆèƒ½èª¿æ ¡å’Œå„ªåŒ–
- ç›£æ§å’Œå‘Šè­¦ç³»çµ±
- æ•…éšœæ’é™¤å’Œæ¢å¾©

---

### ğŸ’¡ èˆ‡ Spring AI çš„æ•´åˆ

æœ¬ç« è¨è«–çš„ä¼æ¥­ç´šè³‡æ–™ç®¡ç†åŠŸèƒ½å¯ä»¥èˆ‡ Spring AI å®Œç¾é…åˆï¼š

```java
/**
 * æ•´åˆ Spring AI çš„ä¼æ¥­ RAG æœå‹™
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class EnterpriseRagService {
    
    private final VectorStore vectorStore;
    private final EnterpriseDataSourceManager dataSourceManager;
    private final DataSyncOrchestrator syncOrchestrator;
    private final DataSecurityService securityService;
    
    /**
     * å®‰å…¨çš„æ–‡æª”æŸ¥è©¢æœå‹™
     */
    public List<Document> secureSearch(String userId, String query, int topK) {
        // 1. é©—è­‰ä½¿ç”¨è€…æ¬Šé™
        DataAccessContext accessContext = securityService.createAccessContext(userId, null);
        if (!securityService.validateAccessContext(accessContext)) {
            throw new SecurityException("Access denied");
        }
        
        // 2. åŸ·è¡Œå‘é‡æœå°‹
        SearchRequest searchRequest = SearchRequest.builder()
            .query(query)
            .topK(topK)
            .build();
        List<Document> results = vectorStore.similaritySearch(searchRequest);
        
        // 3. æ‡‰ç”¨è³‡æ–™è„«æ•
        return results.stream()
            .map(doc -> securityService.maskSensitiveData(doc, userId, getDataMaskingPolicy(doc)))
            .map(Document.class::cast)
            .collect(Collectors.toList());
    }
    
    /**
     * å³æ™‚æ›´æ–°å‘é‡è³‡æ–™åº«
     */
    @EventListener
    public void handleDataChangeEvent(DataChangeDetectedEvent event) {
        try {
            // 1. ç²å–æ›´æ–°çš„è³‡æ–™
            Object updatedData = dataSourceManager.getConnector(event.getDataSourceName())
                .fetchData(event.getEntityId());
            
            // 2. è½‰æ›ç‚º Document
            Document document = convertToDocument(updatedData, event);
            
            // 3. æ›´æ–°å‘é‡è³‡æ–™åº«
            if (event.getChangeEvent().getType() == ChangeEventType.DELETE) {
                vectorStore.delete(List.of(document.getId()));
            } else {
                vectorStore.add(List.of(document));
            }
            
            log.info("Vector store updated for entity: {}", event.getEntityId());
            
        } catch (Exception e) {
            log.error("Failed to update vector store", e);
        }
    }
    
    private Document convertToDocument(Object data, DataChangeDetectedEvent event) {
        // å°‡ä¼æ¥­è³‡æ–™è½‰æ›ç‚º Spring AI Document
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("data_source", event.getDataSourceName());
        metadata.put("entity_type", event.getChangeEvent().getEntityType());
        metadata.put("last_updated", LocalDateTime.now().toString());
        
        return new Document(data.toString(), metadata);
    }
    
    private DataMaskingPolicy getDataMaskingPolicy(Document document) {
        // æ ¹æ“šæ–‡æª”é¡å‹è¿”å›ç›¸æ‡‰çš„è„«æ•ç­–ç•¥
        String entityType = (String) document.getMetadata().get("entity_type");
        return DataMaskingPolicy.builder()
            .policyName("default_policy")
            .entityType(entityType)
            .maskingType(MaskingType.PARTIAL_MASK)
            .visibleCharacters(3)
            .build();
    }
}
```

**åƒè€ƒè³‡æ–™ï¼š**
- [Spring AI Documentation](https://docs.spring.io/spring-ai/reference/)
- [Spring AI Vector Databases](https://docs.spring.io/spring-ai/reference/api/vectordbs.html)
- [Apache Kafka Connect](https://kafka.apache.org/documentation/#connect)
- [Debezium CDC](https://debezium.io/)
- [Spring Security](https://spring.io/projects/spring-security)
- [Enterprise Integration Patterns](https://www.enterpriseintegrationpatterns.com/)
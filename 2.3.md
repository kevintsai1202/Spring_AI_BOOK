# 2.3 API 請求與回應處理

> **本章重點**：掌握 Spring MVC 中請求參數處理和回應格式設計的核心技術，建立完整的 API 資料交換體系，為 Spring AI 整合做好準備。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **掌握參數註解體系**：理解 @PathVariable、@RequestParam、@RequestBody 等核心註解的使用場景
- 🎯 **設計統一回應格式**：建立標準化的 API 回應結構，提升介面一致性
- 🎯 **熟練運用 HTTP 狀態碼**：正確使用各種狀態碼表達不同的業務情境
- 🎯 **實現完善錯誤處理**：建構統一的錯誤回應機制和異常處理策略
- 🎯 **為 AI 服務做準備**：設計適合 AI 應用的請求回應模式

---

## 2.3.1 請求參數處理

### 為什麼需要理解請求參數處理？

在現代 Web 應用開發中，API 是前後端交互的橋樑。一個設計良好的 API 需要能夠靈活地處理各種類型的請求參數，特別是在 AI 應用中，我們需要處理複雜的輸入資料。

### Spring MVC 參數註解概覽

| 註解 | 用途 | 資料來源 | 適用場景 |
|------|------|----------|----------|
| **@PathVariable** | 路徑參數 | URL 路徑 | RESTful 資源識別 |
| **@RequestParam** | 查詢參數 | URL 查詢字串 | 搜尋條件、分頁參數 |
| **@RequestBody** | 請求體參數 | HTTP 請求體 | JSON 物件、複雜資料 |
| **@RequestHeader** | 請求標頭 | HTTP 標頭 | 認證資訊、客戶端資訊 |

### @PathVariable - 路徑參數處理

路徑參數是 RESTful API 設計的核心，用於標識特定的資源：

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    /**
     * 獲取單一使用者資訊
     * URL: GET /api/users/123
     */
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
    
    /**
     * 獲取使用者的特定訂單
     * URL: GET /api/users/123/orders/456
     */
    @GetMapping("/{userId}/orders/{orderId}")
    public ResponseEntity<Order> getUserOrder(
            @PathVariable Long userId,
            @PathVariable Long orderId) {
        Order order = orderService.findByUserIdAndOrderId(userId, orderId);
        return ResponseEntity.ok(order);
    }
}
```

### @RequestParam - 查詢參數處理

查詢參數適用於搜尋條件、分頁和排序等場景：

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    /**
     * 商品搜尋與分頁
     * URL: GET /api/products?keyword=手機&page=1&size=10&sort=price
     */
    @GetMapping
    public ResponseEntity<Page<Product>> searchProducts(
            @RequestParam(required = false) String keyword,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "id") String sort) {
        
        Pageable pageable = PageRequest.of(page, size, Sort.by(sort));
        Page<Product> products = productService.search(keyword, pageable);
        return ResponseEntity.ok(products);
    }
    
    /**
     * 複雜查詢條件
     * URL: GET /api/products?category=electronics&minPrice=100&maxPrice=1000
     */
    @GetMapping("/filter")
    public ResponseEntity<List<Product>> filterProducts(
            @RequestParam String category,
            @RequestParam(required = false) BigDecimal minPrice,
            @RequestParam(required = false) BigDecimal maxPrice) {
        
        List<Product> products = productService.filter(category, minPrice, maxPrice);
        return ResponseEntity.ok(products);
    }
}
```

### @RequestBody - 請求體參數處理

請求體參數適用於複雜的資料結構，特別是 JSON 物件：

```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    /**
     * 建立訂單
     * 接收複雜的 JSON 物件
     */
    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody CreateOrderRequest request) {
        Order order = orderService.createOrder(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(order);
    }
    
    /**
     * 批量更新商品
     * 處理陣列資料
     */
    @PutMapping("/batch")
    public ResponseEntity<List<Product>> batchUpdateProducts(
            @RequestBody List<UpdateProductRequest> requests) {
        List<Product> updatedProducts = productService.batchUpdate(requests);
        return ResponseEntity.ok(updatedProducts);
    }
}
```

---

## 2.3.2 統一回應格式設計

### 為什麼需要標準化的 API 回應格式？

統一的回應格式能夠：
- 提升前端處理的一致性
- 簡化錯誤處理邏輯
- 改善 API 的可維護性
- 為 AI 服務提供標準化的資料介面

### 基礎回應結構設計

```java
/**
 * 統一 API 回應格式
 * 適用於所有 API 端點，包括未來的 AI 服務
 */
public class ApiResponse<T> {
    
    /** 回應狀態碼 */
    private int code;
    
    /** 回應訊息 */
    private String message;
    
    /** 回應資料 */
    private T data;
    
    /** 時間戳記 */
    private long timestamp;
    
    /** 請求追蹤 ID */
    private String traceId;
    
    // 建構子
    private ApiResponse(int code, String message, T data) {
        this.code = code;
        this.message = message;
        this.data = data;
        this.timestamp = System.currentTimeMillis();
        this.traceId = UUID.randomUUID().toString();
    }
    
    /**
     * 建立成功回應
     */
    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(200, "操作成功", data);
    }
    
    public static <T> ApiResponse<T> success(String message, T data) {
        return new ApiResponse<>(200, message, data);
    }
    
    /**
     * 建立錯誤回應
     */
    public static <T> ApiResponse<T> error(int code, String message) {
        return new ApiResponse<>(code, message, null);
    }
    
    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>(500, message, null);
    }
    
    // Getters and Setters
    // ...
}
```

### 在控制器中使用統一回應格式

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    /**
     * 獲取使用者列表
     */
    @GetMapping
    public ApiResponse<List<User>> getUsers() {
        List<User> users = userService.findAll();
        return ApiResponse.success("獲取使用者列表成功", users);
    }
    
    /**
     * 建立使用者
     */
    @PostMapping
    public ApiResponse<User> createUser(@RequestBody CreateUserRequest request) {
        User user = userService.createUser(request);
        return ApiResponse.success("使用者建立成功", user);
    }
    
    /**
     * 刪除使用者
     */
    @DeleteMapping("/{id}")
    public ApiResponse<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ApiResponse.success("使用者刪除成功", null);
    }
}
```

---

## 2.3.3 HTTP 狀態碼最佳實踐

### 常用狀態碼及其應用場景

| 狀態碼 | 名稱 | 使用場景 | 範例 |
|--------|------|----------|------|
| **200** | OK | 成功獲取資源 | GET /api/users |
| **201** | Created | 成功建立資源 | POST /api/users |
| **204** | No Content | 成功但無回應內容 | DELETE /api/users/1 |
| **400** | Bad Request | 請求參數錯誤 | 缺少必要參數 |
| **401** | Unauthorized | 未認證 | 缺少認證資訊 |
| **403** | Forbidden | 無權限 | 權限不足 |
| **404** | Not Found | 資源不存在 | 使用者不存在 |
| **500** | Internal Server Error | 伺服器內部錯誤 | 系統異常 |

### ResponseEntity 的使用

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    /**
     * 獲取商品詳情
     */
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<Product>> getProduct(@PathVariable Long id) {
        try {
            Product product = productService.findById(id);
            ApiResponse<Product> response = ApiResponse.success(product);
            return ResponseEntity.ok(response);
        } catch (ProductNotFoundException e) {
            ApiResponse<Product> response = ApiResponse.error(404, "商品不存在");
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * 建立商品
     */
    @PostMapping
    public ResponseEntity<ApiResponse<Product>> createProduct(
            @RequestBody CreateProductRequest request) {
        Product product = productService.createProduct(request);
        ApiResponse<Product> response = ApiResponse.success("商品建立成功", product);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
}
```

---

## 2.3.4 全域異常處理

### 建立全域異常處理器

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    /**
     * 處理參數驗證異常
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Void>> handleValidationException(
            MethodArgumentNotValidException e) {
        
        StringBuilder message = new StringBuilder("參數驗證失敗：");
        e.getBindingResult().getFieldErrors().forEach(error -> 
            message.append(error.getField()).append(" ").append(error.getDefaultMessage()).append("; ")
        );
        
        ApiResponse<Void> response = ApiResponse.error(400, message.toString());
        return ResponseEntity.badRequest().body(response);
    }
    
    /**
     * 處理資源不存在異常
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse<Void>> handleResourceNotFoundException(
            ResourceNotFoundException e) {
        ApiResponse<Void> response = ApiResponse.error(404, e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }
    
    /**
     * 處理一般異常
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleGeneralException(Exception e) {
        ApiResponse<Void> response = ApiResponse.error(500, "系統內部錯誤");
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
    }
}
```

---

## 2.3.5 為 Spring AI 做準備

### AI 服務的特殊需求

在設計 API 請求回應格式時，我們需要考慮 Spring AI 的特殊需求：

**流式回應支援**：
```java
@RestController
@RequestMapping("/api/ai")
public class AIController {
    
    /**
     * 流式對話 API（為 Spring AI 預留）
     */
    @PostMapping(value = "/chat/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter chatStream(@RequestBody ChatRequest request) {
        SseEmitter emitter = new SseEmitter();
        // 預留給 Spring AI 流式處理
        return emitter;
    }
}
```

**多媒體內容處理**：
```java
/**
 * 多媒體請求格式（為 AI 視覺服務預留）
 */
public class MultimodalRequest {
    private String text;
    private String imageBase64;
    private String audioBase64;
    
    // Getters and Setters
}

@PostMapping("/analyze/multimodal")
public ResponseEntity<ApiResponse<AnalysisResult>> analyzeMultimodal(
        @RequestBody MultimodalRequest request) {
    // 預留給 Spring AI 多模態分析
    return ResponseEntity.ok(ApiResponse.success("分析完成", new AnalysisResult()));
}
```

**批量處理支援**：
```java
/**
 * 批量處理請求（適合 AI 批量推理）
 */
@PostMapping("/batch/process")
public ResponseEntity<ApiResponse<List<ProcessResult>>> batchProcess(
        @RequestBody List<ProcessRequest> requests) {
    // 預留給 Spring AI 批量處理
    List<ProcessResult> results = new ArrayList<>();
    return ResponseEntity.ok(ApiResponse.success("批量處理完成", results));
}
```

---

## 📝 本章重點回顧

1. **參數處理**：掌握了 @PathVariable、@RequestParam、@RequestBody 的使用
2. **統一回應格式**：建立了標準化的 API 回應結構
3. **HTTP 狀態碼**：學會了正確使用各種狀態碼
4. **異常處理**：實現了全域異常處理機制
5. **AI 整合準備**：為 Spring AI 的特殊需求做好了架構準備

### 下一步學習方向

在下一章中，我們將進入第三章的企業級功能開發，學習資料驗證、檔案處理等進階技術，進一步完善我們的 API 開發技能。

---

**參考資料：**
- [Spring MVC Request Mapping](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping)
- [HTTP Status Codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
- [Spring Boot Error Handling](https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc.error-handling)
# 5.4 做一個字幕產生器

> **本章重點**：學習使用 Spring AI 的語音轉文字功能，建立完整的字幕產生系統，掌握音訊處理和多格式字幕輸出技術，為多媒體內容處理提供專業解決方案。

## 🎯 學習目標

完成本章學習後，您將能夠：

- 🎯 **理解語音轉文字技術**：掌握 Whisper 模型的工作原理和應用場景
- 🎯 **實現音訊檔案處理**：建立完整的音訊上傳和轉譯功能
- 🎯 **生成多格式字幕**：支援 SRT、VTT、JSON 等多種字幕格式
- 🎯 **優化轉譯品質**：掌握語言設定、溫度調整等優化技巧
- 🎯 **企業級應用設計**：建立可商用的字幕生成服務系統

---

## 5.4.1 語音轉文字技術革命

### 上字幕不再痛苦

![字幕產生器](https://ithelp.ithome.com.tw/upload/images/20240810/20161290jCx3iLQjtI.jpg)

相信很多人知道 OpenAI 開源了 Whisper 模型，網路上也很多人製作本機端的字幕產生程式，凱文大叔試過，只能說慘不忍睹，由於電腦沒有獨立顯卡，不到 30 分鐘的影片竟然一個小時還沒完成。

這時就很適合用平台的算力來協助了！

### 雲端 vs 本地處理對比

| 處理方式 | 優勢 | 劣勢 | 適用場景 |
|----------|------|------|----------|
| **雲端處理** | 速度快、品質高、無硬體要求 | 需要網路、有使用成本 | 商業應用、大量處理 |
| **本地處理** | 隱私保護、無網路依賴 | 速度慢、硬體要求高 | 敏感內容、離線環境 |

**成本效益分析**：
- 🕐 **時間成本**：雲端處理 30 分鐘影片約 2-3 分鐘，本地可能需要 1-2 小時
- 💰 **金錢成本**：OpenAI Whisper 約 $0.006/分鐘，22MB 四分多鐘影片約 $0.03
- 🔧 **硬體成本**：雲端無需投資 GPU，本地需要高階顯卡

### Spring AI 音訊轉譯支援

![Spring AI 音訊支援](https://ithelp.ithome.com.tw/upload/images/20240807/201612904zZn4fPMwh.png)

音頻轉譯在 Spring AI 的文件中主要支援：
- **OpenAI Whisper**：功能完整，支援時間戳記
- **Azure OpenAI**：企業級部署，合規性佳
- **Groq**：速度快但功能受限（無時間戳記）

**重要提醒**：原本想說可以用 Groq 省錢，不過凱文大叔實際測試發現 Groq 閹割了很多功能，只能產生純文字，字幕最重要的時間戳記卻無法產生，若單純產生文字稿還是能用，需要時間戳記就只能花點小錢了。

---

## 5.4.2 專案建立與配置

### Maven 依賴配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>subtitle-generator</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>subtitle-generator</name>
    <description>AI-powered subtitle generator using Spring AI</description>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <!-- 使用 Spring AI BOM 管理版本 -->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.ai</groupId>
                <artifactId>spring-ai-bom</artifactId>
                <version>1.0.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <dependencies>
        <!-- Spring AI OpenAI Starter -->
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-starter-model-openai</artifactId>
        </dependency>
        
        <!-- Spring Boot Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Spring Boot Validation -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <!-- File Processing -->
        <dependency>
            <groupId>org.apache.tika</groupId>
            <artifactId>tika-core</artifactId>
            <version>2.9.1</version>
        </dependency>
        
        <!-- JSON Processing -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

### 應用程式配置

```yaml
# application.yml
spring:
  application:
    name: subtitle-generator
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      base-url: https://api.openai.com
      audio:
        transcription:
          options:
            model: whisper-1
            response-format: verbose_json  # 包含時間戳記的詳細格式
            temperature: 0.0  # 最確定的結果
            language: zh  # 指定中文可提升準確度
            # timestamp-granularities 參數需在程式碼中設定
  
  # 檔案上傳配置
  servlet:
    multipart:
      max-file-size: 25MB  # Whisper 的檔案大小限制
      max-request-size: 25MB
      enabled: true

# 應用程式配置
app:
  subtitle:
    output-directory: ./subtitles
    supported-formats: ["srt", "vtt", "json", "txt"]
    max-duration: 3600  # 最大處理時長（秒）
    default-language: zh

# 伺服器配置
server:
  port: 8080
  servlet:
    context-path: /api

# 日誌配置
logging:
  level:
    org.springframework.ai: DEBUG
    com.example: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

---

## 5.4.3 基礎字幕生成功能

### 音訊轉譯控制器

```java
package com.example.controller;

import com.example.dto.SubtitleRequest;
import com.example.dto.SubtitleResponse;
import com.example.service.SubtitleGenerationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.Arrays;
import java.util.List;

@RestController
@RequestMapping("/subtitle")
@RequiredArgsConstructor
@Slf4j
public class SubtitleController {
    
    private final SubtitleGenerationService subtitleService;
    
    /**
     * 基礎字幕生成
     * @param file 音訊或影片檔案
     * @param format 輸出格式（srt, vtt, json, txt）
     * @param language 語言代碼（可選）
     * @return 字幕內容
     */
    @PostMapping(value = "/generate", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<SubtitleResponse> generateSubtitle(
            @RequestParam("file") MultipartFile file,
            @RequestParam(value = "format", defaultValue = "srt") String format,
            @RequestParam(value = "language", required = false) String language) {
        
        try {
            // 驗證檔案
            validateAudioFile(file);
            
            log.info("開始處理字幕生成：檔案={}, 格式={}, 語言={}", 
                    file.getOriginalFilename(), format, language);
            
            // 生成字幕
            SubtitleResponse response = subtitleService.generateSubtitle(
                    file, format, language
            );
            
            log.info("字幕生成完成：{}", file.getOriginalFilename());
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("字幕生成失敗：{}", file.getOriginalFilename(), e);
            
            SubtitleResponse errorResponse = SubtitleResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .fileName(file.getOriginalFilename())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 進階字幕生成（支援更多選項）
     * @param file 音訊檔案
     * @param request 生成選項
     * @return 字幕回應
     */
    @PostMapping(value = "/generate-advanced", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<SubtitleResponse> generateAdvancedSubtitle(
            @RequestParam("file") MultipartFile file,
            @ModelAttribute SubtitleRequest request) {
        
        try {
            validateAudioFile(file);
            
            log.info("開始進階字幕生成：{}", request);
            
            SubtitleResponse response = subtitleService.generateAdvancedSubtitle(
                    file, request
            );
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("進階字幕生成失敗", e);
            
            SubtitleResponse errorResponse = SubtitleResponse.builder()
                    .success(false)
                    .error(e.getMessage())
                    .fileName(file.getOriginalFilename())
                    .build();
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }
    
    /**
     * 批次字幕生成
     * @param files 多個音訊檔案
     * @param format 輸出格式
     * @return 批次處理結果
     */
    @PostMapping(value = "/batch-generate", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<List<SubtitleResponse>> batchGenerateSubtitles(
            @RequestParam("files") MultipartFile[] files,
            @RequestParam(value = "format", defaultValue = "srt") String format) {
        
        try {
            log.info("開始批次字幕生成：{} 個檔案", files.length);
            
            List<SubtitleResponse> responses = subtitleService.batchGenerateSubtitles(
                    Arrays.asList(files), format
            );
            
            return ResponseEntity.ok(responses);
            
        } catch (Exception e) {
            log.error("批次字幕生成失敗", e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 驗證音訊檔案
     */
    private void validateAudioFile(MultipartFile file) {
        if (file.isEmpty()) {
            throw new IllegalArgumentException("檔案不能為空");
        }
        
        // 檢查檔案大小（25MB 限制）
        if (file.getSize() > 25 * 1024 * 1024) {
            throw new IllegalArgumentException("檔案大小不能超過 25MB");
        }
        
        // 檢查檔案格式
        String contentType = file.getContentType();
        if (contentType == null || !isValidAudioFormat(contentType)) {
            throw new IllegalArgumentException(
                "不支援的檔案格式，請上傳 MP3、WAV、M4A、MP4 或 WEBM 格式"
            );
        }
    }
    
    private boolean isValidAudioFormat(String contentType) {
        return contentType.startsWith("audio/") || 
               contentType.equals("video/mp4") ||
               contentType.equals("video/webm");
    }
}
```

### 字幕生成服務

```java
package com.example.service;

import com.example.dto.SubtitleRequest;
import com.example.dto.SubtitleResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.audio.transcription.AudioTranscriptionModel;
import org.springframework.ai.audio.transcription.AudioTranscriptionPrompt;
import org.springframework.ai.audio.transcription.AudioTranscriptionResponse;
import org.springframework.ai.openai.OpenAiAudioTranscriptionOptions;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class SubtitleGenerationService {
    
    private final AudioTranscriptionModel transcriptionModel;
    private final SubtitleFormatterService formatterService;
    
    /**
     * 基礎字幕生成
     * @param file 音訊檔案
     * @param format 輸出格式
     * @param language 語言（可選）
     * @return 字幕回應
     */
    public SubtitleResponse generateSubtitle(
            MultipartFile file, 
            String format, 
            String language) {
        
        try {
            // 建立轉譯選項
            OpenAiAudioTranscriptionOptions options = OpenAiAudioTranscriptionOptions.builder()
                    .withModel("whisper-1")
                    .withResponseFormat("verbose_json")  // 包含時間戳記
                    .withTemperature(0.0f)
                    .withLanguage(language != null ? language : "zh")
                    .withTimestampGranularities(List.of("word", "segment"))
                    .build();
            
            // 建立音訊資源
            Resource audioResource = createAudioResource(file);
            
            // 建立轉譯請求
            AudioTranscriptionPrompt prompt = new AudioTranscriptionPrompt(
                    audioResource, options
            );
            
            // 執行轉譯
            AudioTranscriptionResponse response = transcriptionModel.call(prompt);
            String transcriptionResult = response.getResult().getOutput();
            
            // 格式化字幕
            String formattedSubtitle = formatterService.formatSubtitle(
                    transcriptionResult, format
            );
            
            return SubtitleResponse.builder()
                    .success(true)
                    .fileName(file.getOriginalFilename())
                    .format(format)
                    .language(language != null ? language : "zh")
                    .content(formattedSubtitle)
                    .fileSize(file.getSize())
                    .processingTime(calculateProcessingTime())
                    .timestamp(LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("字幕生成失敗：{}", file.getOriginalFilename(), e);
            throw new RuntimeException("字幕生成失敗：" + e.getMessage(), e);
        }
    }
    
    /**
     * 進階字幕生成
     * @param file 音訊檔案
     * @param request 生成選項
     * @return 字幕回應
     */
    public SubtitleResponse generateAdvancedSubtitle(
            MultipartFile file, 
            SubtitleRequest request) {
        
        try {
            // 建立進階轉譯選項
            OpenAiAudioTranscriptionOptions options = OpenAiAudioTranscriptionOptions.builder()
                    .withModel("whisper-1")
                    .withResponseFormat("verbose_json")
                    .withTemperature(request.getTemperature())
                    .withLanguage(request.getLanguage())
                    .withTimestampGranularities(request.getTimestampGranularities())
                    .build();
            
            // 如果有提示詞，加入提示
            if (request.getPrompt() != null && !request.getPrompt().isEmpty()) {
                options = options.toBuilder()
                        .withPrompt(request.getPrompt())
                        .build();
            }
            
            // 建立音訊資源
            Resource audioResource = createAudioResource(file);
            
            AudioTranscriptionPrompt prompt = new AudioTranscriptionPrompt(
                    audioResource, options
            );
            
            AudioTranscriptionResponse response = transcriptionModel.call(prompt);
            String transcriptionResult = response.getResult().getOutput();
            
            // 格式化字幕
            String formattedSubtitle = formatterService.formatSubtitle(
                    transcriptionResult, request.getFormat()
            );
            
            return SubtitleResponse.builder()
                    .success(true)
                    .fileName(file.getOriginalFilename())
                    .format(request.getFormat())
                    .language(request.getLanguage())
                    .content(formattedSubtitle)
                    .fileSize(file.getSize())
                    .temperature(request.getTemperature())
                    .prompt(request.getPrompt())
                    .processingTime(calculateProcessingTime())
                    .timestamp(LocalDateTime.now())
                    .build();
            
        } catch (Exception e) {
            log.error("進階字幕生成失敗：{}", file.getOriginalFilename(), e);
            throw new RuntimeException("進階字幕生成失敗：" + e.getMessage(), e);
        }
    }
    
    /**
     * 批次字幕生成
     * @param files 檔案列表
     * @param format 輸出格式
     * @return 批次處理結果
     */
    public List<SubtitleResponse> batchGenerateSubtitles(
            List<MultipartFile> files, 
            String format) {
        
        log.info("開始批次處理 {} 個檔案", files.size());
        
        List<CompletableFuture<SubtitleResponse>> futures = files.stream()
                .map(file -> CompletableFuture.supplyAsync(() -> {
                    try {
                        return generateSubtitle(file, format, null);
                    } catch (Exception e) {
                        log.error("批次處理失敗：{}", file.getOriginalFilename(), e);
                        return SubtitleResponse.builder()
                                .success(false)
                                .fileName(file.getOriginalFilename())
                                .error(e.getMessage())
                                .build();
                    }
                }))
                .collect(Collectors.toList());
        
        // 等待所有任務完成
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(
                futures.toArray(new CompletableFuture[0])
        );
        
        return allFutures.thenApply(v -> 
                futures.stream()
                        .map(CompletableFuture::join)
                        .collect(Collectors.toList())
        ).join();
    }
    
    private long calculateProcessingTime() {
        // 實際實現中應該記錄開始時間並計算差值
        return System.currentTimeMillis();
    }
    
    /**
     * 建立音訊資源
     * @param file MultipartFile 檔案
     * @return Resource 音訊資源
     */
    private Resource createAudioResource(MultipartFile file) {
        try {
            return new ByteArrayResource(file.getBytes()) {
                @Override
                public String getFilename() {
                    return file.getOriginalFilename();
                }
            };
        } catch (IOException e) {
            throw new RuntimeException("建立音訊資源失敗：" + e.getMessage(), e);
        }
    }
}
```

---

## 5.4.4 多格式字幕輸出

### 字幕格式化服務

```java
package com.example.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class SubtitleFormatterService {
    
    private final ObjectMapper objectMapper;
    
    /**
     * 格式化字幕為指定格式
     * @param transcriptionJson Whisper 回傳的 JSON 結果
     * @param format 目標格式
     * @return 格式化後的字幕內容
     */
    public String formatSubtitle(String transcriptionJson, String format) {
        try {
            JsonNode jsonNode = objectMapper.readTree(transcriptionJson);
            
            return switch (format.toLowerCase()) {
                case "srt" -> formatToSRT(jsonNode);
                case "vtt" -> formatToVTT(jsonNode);
                case "json" -> formatToJSON(jsonNode);
                case "txt" -> formatToTXT(jsonNode);
                default -> throw new IllegalArgumentException("不支援的格式：" + format);
            };
            
        } catch (Exception e) {
            log.error("字幕格式化失敗", e);
            throw new RuntimeException("字幕格式化失敗：" + e.getMessage(), e);
        }
    }
    
    /**
     * 格式化為 SRT 格式
     */
    private String formatToSRT(JsonNode jsonNode) {
        StringBuilder srt = new StringBuilder();
        JsonNode segments = jsonNode.get("segments");
        
        if (segments != null && segments.isArray()) {
            int index = 1;
            for (JsonNode segment : segments) {
                double start = segment.get("start").asDouble();
                double end = segment.get("end").asDouble();
                String text = segment.get("text").asText().trim();
                
                if (!text.isEmpty()) {
                    srt.append(index++).append("\n");
                    srt.append(formatTime(start)).append(" --> ").append(formatTime(end)).append("\n");
                    srt.append(text).append("\n\n");
                }
            }
        }
        
        return srt.toString();
    }
    
    /**
     * 格式化為 VTT 格式
     */
    private String formatToVTT(JsonNode jsonNode) {
        StringBuilder vtt = new StringBuilder();
        vtt.append("WEBVTT\n\n");
        
        JsonNode segments = jsonNode.get("segments");
        
        if (segments != null && segments.isArray()) {
            for (JsonNode segment : segments) {
                double start = segment.get("start").asDouble();
                double end = segment.get("end").asDouble();
                String text = segment.get("text").asText().trim();
                
                if (!text.isEmpty()) {
                    vtt.append(formatTimeVTT(start)).append(" --> ").append(formatTimeVTT(end)).append("\n");
                    vtt.append(text).append("\n\n");
                }
            }
        }
        
        return vtt.toString();
    }
    
    /**
     * 格式化為 JSON 格式（結構化）
     */
    private String formatToJSON(JsonNode jsonNode) {
        try {
            // 建立結構化的字幕 JSON
            SubtitleData subtitleData = new SubtitleData();
            subtitleData.setLanguage(jsonNode.get("language").asText());
            subtitleData.setDuration(jsonNode.get("duration").asDouble());
            
            JsonNode segments = jsonNode.get("segments");
            if (segments != null && segments.isArray()) {
                for (JsonNode segment : segments) {
                    SubtitleSegment subtitleSegment = new SubtitleSegment();
                    subtitleSegment.setStart(segment.get("start").asDouble());
                    subtitleSegment.setEnd(segment.get("end").asDouble());
                    subtitleSegment.setText(segment.get("text").asText().trim());
                    
                    // 如果有詞級時間戳記
                    JsonNode words = segment.get("words");
                    if (words != null && words.isArray()) {
                        for (JsonNode word : words) {
                            SubtitleWord subtitleWord = new SubtitleWord();
                            subtitleWord.setWord(word.get("word").asText());
                            subtitleWord.setStart(word.get("start").asDouble());
                            subtitleWord.setEnd(word.get("end").asDouble());
                            subtitleSegment.getWords().add(subtitleWord);
                        }
                    }
                    
                    subtitleData.getSegments().add(subtitleSegment);
                }
            }
            
            return objectMapper.writerWithDefaultPrettyPrinter()
                    .writeValueAsString(subtitleData);
            
        } catch (Exception e) {
            log.error("JSON 格式化失敗", e);
            return jsonNode.toPrettyString();
        }
    }
    
    /**
     * 格式化為純文字格式
     */
    private String formatToTXT(JsonNode jsonNode) {
        StringBuilder txt = new StringBuilder();
        JsonNode segments = jsonNode.get("segments");
        
        if (segments != null && segments.isArray()) {
            for (JsonNode segment : segments) {
                String text = segment.get("text").asText().trim();
                if (!text.isEmpty()) {
                    txt.append(text).append(" ");
                }
            }
        }
        
        return txt.toString().trim();
    }
    
    /**
     * 格式化時間為 SRT 格式 (HH:MM:SS,mmm)
     */
    private String formatTime(double seconds) {
        Duration duration = Duration.ofMillis((long) (seconds * 1000));
        long hours = duration.toHours();
        long minutes = duration.toMinutesPart();
        long secs = duration.toSecondsPart();
        long millis = duration.toMillisPart();
        
        return String.format("%02d:%02d:%02d,%03d", hours, minutes, secs, millis);
    }
    
    /**
     * 格式化時間為 VTT 格式 (HH:MM:SS.mmm)
     */
    private String formatTimeVTT(double seconds) {
        Duration duration = Duration.ofMillis((long) (seconds * 1000));
        long hours = duration.toHours();
        long minutes = duration.toMinutesPart();
        long secs = duration.toSecondsPart();
        long millis = duration.toMillisPart();
        
        return String.format("%02d:%02d:%02d.%03d", hours, minutes, secs, millis);
    }
}
```

### 字幕資料結構

```java
package com.example.dto;

import lombok.Data;
import java.util.ArrayList;
import java.util.List;

@Data
public class SubtitleData {
    private String language;
    private Double duration;
    private List<SubtitleSegment> segments = new ArrayList<>();
}

@Data
public class SubtitleSegment {
    private Double start;
    private Double end;
    private String text;
    private List<SubtitleWord> words = new ArrayList<>();
}

@Data
public class SubtitleWord {
    private String word;
    private Double start;
    private Double end;
}
```

---

## 5.4.5 請求和回應 DTO

### 字幕請求 DTO

```java
package com.example.dto;

import lombok.Data;
import javax.validation.constraints.*;
import java.util.List;

@Data
public class SubtitleRequest {
    
    @NotBlank(message = "輸出格式不能為空")
    @Pattern(regexp = "^(srt|vtt|json|txt)$", message = "格式必須是 srt、vtt、json 或 txt")
    private String format = "srt";
    
    @Pattern(regexp = "^[a-z]{2}$", message = "語言代碼必須是兩位字母")
    private String language = "zh";
    
    @DecimalMin(value = "0.0", message = "溫度值必須大於等於 0")
    @DecimalMax(value = "1.0", message = "溫度值必須小於等於 1")
    private Float temperature = 0.0f;
    
    @Size(max = 224, message = "提示詞不能超過 224 個字元")
    private String prompt;
    
    private List<String> timestampGranularities = List.of("segment");
    
    private Boolean includeWordTimestamps = false;
    
    private String model = "whisper-1";
}
```

### 字幕回應 DTO

```java
package com.example.dto;

import lombok.Builder;
import lombok.Data;
import java.time.LocalDateTime;

@Data
@Builder
public class SubtitleResponse {
    
    private boolean success;
    private String fileName;
    private String format;
    private String language;
    private String content;
    private Long fileSize;
    private Float temperature;
    private String prompt;
    private String model;
    private Long processingTime;
    private String error;
    private LocalDateTime timestamp;
    
    // 統計資訊
    private Integer segmentCount;
    private Integer wordCount;
    private Double audioDuration;
    
    /**
     * 建立成功回應
     */
    public static SubtitleResponse success(String fileName, String format, String content) {
        return SubtitleResponse.builder()
                .success(true)
                .fileName(fileName)
                .format(format)
                .content(content)
                .timestamp(LocalDateTime.now())
                .build();
    }
    
    /**
     * 建立錯誤回應
     */
    public static SubtitleResponse error(String fileName, String error) {
        return SubtitleResponse.builder()
                .success(false)
                .fileName(fileName)
                .error(error)
                .timestamp(LocalDateTime.now())
                .build();
    }
}
```

---

## 5.4.6 進階功能實現

### 字幕檔案下載服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Service
@RequiredArgsConstructor
@Slf4j
public class SubtitleDownloadService {
    
    @Value("${app.subtitle.output-directory:./subtitles}")
    private String outputDirectory;
    
    /**
     * 建立字幕檔案下載回應
     * @param content 字幕內容
     * @param fileName 原始檔案名稱
     * @param format 字幕格式
     * @return 下載回應
     */
    public ResponseEntity<Resource> createDownloadResponse(
            String content, 
            String fileName, 
            String format) {
        
        try {
            // 生成下載檔案名稱
            String downloadFileName = generateDownloadFileName(fileName, format);
            
            // 建立資源
            ByteArrayResource resource = new ByteArrayResource(
                    content.getBytes(StandardCharsets.UTF_8)
            );
            
            // 設定 Content-Type
            MediaType mediaType = getMediaTypeForFormat(format);
            
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, 
                           "attachment; filename=\"" + downloadFileName + "\"")
                    .contentType(mediaType)
                    .contentLength(resource.contentLength())
                    .body(resource);
            
        } catch (Exception e) {
            log.error("建立下載回應失敗", e);
            throw new RuntimeException("建立下載回應失敗：" + e.getMessage(), e);
        }
    }
    
    /**
     * 生成下載檔案名稱
     */
    private String generateDownloadFileName(String originalFileName, String format) {
        String baseName = originalFileName;
        
        // 移除原始副檔名
        int lastDotIndex = baseName.lastIndexOf('.');
        if (lastDotIndex > 0) {
            baseName = baseName.substring(0, lastDotIndex);
        }
        
        // 添加時間戳記
        String timestamp = LocalDateTime.now().format(
                DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")
        );
        
        return String.format("%s_字幕_%s.%s", baseName, timestamp, format);
    }
    
    /**
     * 根據格式獲取 MediaType
     */
    private MediaType getMediaTypeForFormat(String format) {
        return switch (format.toLowerCase()) {
            case "srt" -> MediaType.parseMediaType("application/x-subrip");
            case "vtt" -> MediaType.parseMediaType("text/vtt");
            case "json" -> MediaType.APPLICATION_JSON;
            case "txt" -> MediaType.TEXT_PLAIN;
            default -> MediaType.APPLICATION_OCTET_STREAM;
        };
    }
}
```

### 字幕品質優化服務

```java
package com.example.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.regex.Pattern;

@Service
@RequiredArgsConstructor
@Slf4j
public class SubtitleOptimizationService {
    
    /**
     * 優化字幕內容
     * @param content 原始字幕內容
     * @param language 語言
     * @return 優化後的字幕內容
     */
    public String optimizeSubtitleContent(String content, String language) {
        String optimized = content;
        
        // 移除多餘空白
        optimized = removeExtraWhitespace(optimized);
        
        // 修正標點符號
        optimized = fixPunctuation(optimized, language);
        
        // 合併短句
        optimized = mergeShortSentences(optimized);
        
        // 分割長句
        optimized = splitLongSentences(optimized);
        
        return optimized;
    }
    
    /**
     * 移除多餘空白
     */
    private String removeExtraWhitespace(String content) {
        return content.replaceAll("\\s+", " ").trim();
    }
    
    /**
     * 修正標點符號
     */
    private String fixPunctuation(String content, String language) {
        if ("zh".equals(language)) {
            // 中文標點符號修正
            content = content.replaceAll("\\s*,\\s*", "，");
            content = content.replaceAll("\\s*\\.\\s*", "。");
            content = content.replaceAll("\\s*\\?\\s*", "？");
            content = content.replaceAll("\\s*!\\s*", "！");
        }
        
        return content;
    }
    
    /**
     * 合併短句
     */
    private String mergeShortSentences(String content) {
        // 如果句子太短（少於10個字元），嘗試與下一句合併
        String[] sentences = content.split("[。！？.!?]");
        StringBuilder merged = new StringBuilder();
        
        for (int i = 0; i < sentences.length; i++) {
            String sentence = sentences[i].trim();
            if (sentence.length() < 10 && i < sentences.length - 1) {
                // 合併短句
                sentence += sentences[++i].trim();
            }
            if (!sentence.isEmpty()) {
                merged.append(sentence).append("。");
            }
        }
        
        return merged.toString();
    }
    
    /**
     * 分割長句
     */
    private String splitLongSentences(String content) {
        // 如果句子太長（超過50個字元），嘗試在適當位置分割
        return content.replaceAll("([，,])(?=.{20,})", "$1\n");
    }
    
    /**
     * 驗證字幕品質
     * @param content 字幕內容
     * @return 品質評分（0-100）
     */
    public int evaluateSubtitleQuality(String content) {
        int score = 100;
        
        // 檢查是否有明顯錯誤
        if (content.contains("[音樂]") || content.contains("[掌聲]")) {
            score -= 10;  // 包含音效標記
        }
        
        if (Pattern.compile("[a-zA-Z]{10,}").matcher(content).find()) {
            score -= 15;  // 包含長英文單詞（可能是錯誤識別）
        }
        
        if (content.length() < 10) {
            score -= 30;  // 內容太短
        }
        
        // 檢查標點符號比例
        long punctuationCount = content.chars()
                .filter(ch -> "，。！？,.!?".indexOf(ch) >= 0)
                .count();
        
        double punctuationRatio = (double) punctuationCount / content.length();
        if (punctuationRatio < 0.05) {
            score -= 20;  // 標點符號太少
        }
        
        return Math.max(0, score);
    }
}
```

---

## 5.4.7 Web 介面實現

### 字幕生成頁面

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 字幕產生器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 40px;
            max-width: 800px;
            width: 90%;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #333;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #666;
            font-size: 1.1rem;
        }
        
        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }
        
        .upload-area.dragover {
            border-color: #667eea;
            background: #f0f4ff;
        }
        
        .upload-icon {
            font-size: 3rem;
            color: #ddd;
            margin-bottom: 15px;
        }
        
        .upload-text {
            color: #666;
            font-size: 1.1rem;
            margin-bottom: 10px;
        }
        
        .upload-hint {
            color: #999;
            font-size: 0.9rem;
        }
        
        .options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .option-group {
            display: flex;
            flex-direction: column;
        }
        
        .option-group label {
            color: #333;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .option-group select,
        .option-group input {
            padding: 12px;
            border: 2px solid #eee;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }
        
        .option-group select:focus,
        .option-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .generate-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }
        
        .generate-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }
        
        .generate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .progress {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #eee;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .result {
            display: none;
            margin-top: 20px;
        }
        
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .result-title {
            color: #333;
            font-size: 1.3rem;
            font-weight: 600;
        }
        
        .download-btn {
            padding: 8px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }
        
        .download-btn:hover {
            background: #218838;
        }
        
        .result-content {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .options {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎬 AI 字幕產生器</h1>
            <p>上傳音訊或影片檔案，AI 自動生成高品質字幕</p>
        </div>
        
        <form id="subtitleForm" enctype="multipart/form-data">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">📁</div>
                <div class="upload-text">點擊選擇檔案或拖拽到此處</div>
                <div class="upload-hint">支援 MP3、WAV、M4A、MP4、WEBM 格式，最大 25MB</div>
                <input type="file" id="fileInput" name="file" accept="audio/*,video/*" style="display: none;">
            </div>
            
            <div class="options">
                <div class="option-group">
                    <label for="format">字幕格式</label>
                    <select id="format" name="format">
                        <option value="srt">SRT (最常用)</option>
                        <option value="vtt">VTT (網頁字幕)</option>
                        <option value="json">JSON (結構化)</option>
                        <option value="txt">TXT (純文字)</option>
                    </select>
                </div>
                
                <div class="option-group">
                    <label for="language">語言</label>
                    <select id="language" name="language">
                        <option value="zh">中文</option>
                        <option value="en">English</option>
                        <option value="ja">日本語</option>
                        <option value="ko">한국어</option>
                        <option value="auto">自動偵測</option>
                    </select>
                </div>
            </div>
            
            <button type="submit" class="generate-btn" id="generateBtn">
                🚀 開始生成字幕
            </button>
        </form>
        
        <div class="progress" id="progress">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="progressText">正在處理中，請稍候...</div>
        </div>
        
        <div class="result" id="result">
            <div class="result-header">
                <div class="result-title">✅ 字幕生成完成</div>
                <button class="download-btn" id="downloadBtn">📥 下載字幕</button>
            </div>
            <div class="result-content" id="resultContent"></div>
        </div>
    </div>
    
    <script>
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const form = document.getElementById('subtitleForm');
        const generateBtn = document.getElementById('generateBtn');
        const progress = document.getElementById('progress');
        const result = document.getElementById('result');
        const resultContent = document.getElementById('resultContent');
        const downloadBtn = document.getElementById('downloadBtn');
        
        let currentSubtitleData = null;
        
        // 檔案上傳區域事件
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', handleDragOver);
        uploadArea.addEventListener('dragleave', handleDragLeave);
        uploadArea.addEventListener('drop', handleDrop);
        
        fileInput.addEventListener('change', handleFileSelect);
        form.addEventListener('submit', handleSubmit);
        downloadBtn.addEventListener('click', handleDownload);
        
        function handleDragOver(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        }
        
        function handleDragLeave(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                fileInput.files = files;
                updateUploadArea(files[0]);
            }
        }
        
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                updateUploadArea(file);
            }
        }
        
        function updateUploadArea(file) {
            const uploadText = uploadArea.querySelector('.upload-text');
            const uploadHint = uploadArea.querySelector('.upload-hint');
            
            uploadText.textContent = `已選擇：${file.name}`;
            uploadHint.textContent = `檔案大小：${(file.size / 1024 / 1024).toFixed(2)} MB`;
        }
        
        async function handleSubmit(e) {
            e.preventDefault();
            
            const formData = new FormData(form);
            const file = fileInput.files[0];
            
            if (!file) {
                alert('請選擇要處理的檔案');
                return;
            }
            
            // 顯示進度
            showProgress();
            
            try {
                const response = await fetch('/api/subtitle/generate', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showResult(data);
                } else {
                    showError(data.error || '字幕生成失敗');
                }
                
            } catch (error) {
                console.error('Error:', error);
                showError('網路錯誤，請稍後再試');
            } finally {
                hideProgress();
            }
        }
        
        function showProgress() {
            generateBtn.disabled = true;
            generateBtn.textContent = '⏳ 處理中...';
            progress.style.display = 'block';
            result.style.display = 'none';
            
            // 模擬進度
            let progressValue = 0;
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            const interval = setInterval(() => {
                progressValue += Math.random() * 10;
                if (progressValue > 90) progressValue = 90;
                
                progressFill.style.width = progressValue + '%';
                
                if (progressValue < 30) {
                    progressText.textContent = '正在上傳檔案...';
                } else if (progressValue < 60) {
                    progressText.textContent = 'AI 正在分析音訊...';
                } else {
                    progressText.textContent = '正在生成字幕...';
                }
            }, 500);
            
            // 儲存 interval ID 以便後續清除
            progress.dataset.intervalId = interval;
        }
        
        function hideProgress() {
            generateBtn.disabled = false;
            generateBtn.textContent = '🚀 開始生成字幕';
            progress.style.display = 'none';
            
            // 清除進度模擬
            const intervalId = progress.dataset.intervalId;
            if (intervalId) {
                clearInterval(intervalId);
            }
        }
        
        function showResult(data) {
            currentSubtitleData = data;
            resultContent.textContent = data.content;
            result.style.display = 'block';
        }
        
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = '❌ ' + message;
            
            // 移除舊的錯誤訊息
            const oldError = document.querySelector('.error');
            if (oldError) {
                oldError.remove();
            }
            
            form.appendChild(errorDiv);
            
            // 3秒後自動移除錯誤訊息
            setTimeout(() => {
                errorDiv.remove();
            }, 3000);
        }
        
        function handleDownload() {
            if (!currentSubtitleData) return;
            
            const blob = new Blob([currentSubtitleData.content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            a.href = url;
            a.download = `${currentSubtitleData.fileName}_字幕.${currentSubtitleData.format}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
```

---

## 📝 本章重點回顧

1. **語音轉文字技術**：掌握了 Whisper 模型的工作原理和雲端處理優勢
2. **多格式字幕輸出**：實現了 SRT、VTT、JSON、TXT 等多種字幕格式
3. **企業級功能**：建立了完整的字幕生成、優化和管理系統
4. **Web 介面整合**：提供了友善的拖拽上傳和即時預覽功能
5. **品質優化技術**：掌握了字幕內容優化和品質評估方法

### 技術要點總結

| 技術點 | 重要性 | 實現難度 | 使用場景 |
|--------|--------|----------|----------|
| **基礎轉譯** | ⭐⭐⭐ | 低 | 所有字幕應用 |
| **多格式輸出** | ⭐⭐⭐ | 中 | 不同平台需求 |
| **批次處理** | ⭐⭐ | 中 | 大量內容處理 |
| **品質優化** | ⭐⭐ | 高 | 專業字幕製作 |
| **Web 介面** | ⭐⭐ | 中 | 使用者體驗 |
| **檔案管理** | ⭐ | 低 | 企業級部署 |

### 成本效益分析

**OpenAI Whisper 定價**：
- 💰 **成本**：$0.006 per minute
- ⏱️ **速度**：通常比音訊時長快 5-10 倍
- 🎯 **準確度**：中文識別準確率 > 95%
- 📊 **性價比**：相比人工字幕製作節省 80% 成本

### 最佳實踐建議

1. **檔案預處理**：確保音訊品質，移除背景噪音
2. **語言設定**：正確設定語言可提升 10-15% 準確度
3. **溫度調整**：使用 0.0 溫度獲得最穩定結果
4. **批次處理**：大量檔案使用非同步處理提升效率
5. **品質檢查**：實施自動品質評估和人工校對流程

### 下一步學習方向

在下一章中，我們將學習文字轉語音技術，探索如何讓 AI 幫你配音，建立完整的語音合成應用。

---

**參考資料：**
- [Spring AI Audio Transcription Documentation](https://docs.spring.io/spring-ai/reference/api/audio.html)
- [OpenAI Whisper API](https://platform.openai.com/docs/guides/speech-to-text)
- [SRT Subtitle Format Specification](https://en.wikipedia.org/wiki/SubRip)
- [WebVTT Specification](https://www.w3.org/TR/webvtt1/)